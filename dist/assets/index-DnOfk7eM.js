var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _a, _b, _c, _d, _focused, _cleanup, _setup, _e, _online, _cleanup2, _setup2, _f, _g, _gcTimeout, _h, _initialState2, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _dispatch, dispatch_fn, _i, _queries, _j, _observers, _mutationCache, _retryer2, _dispatch2, dispatch_fn2, _k, _mutations, _mutationId, _l, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _m;
function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
__name(_mergeNamespaces, "_mergeNamespaces");
(/* @__PURE__ */ __name(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  __name(getFetchOpts, "getFetchOpts");
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
  __name(processPreload, "processPreload");
}, "polyfill"))();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = /* @__PURE__ */ __name(function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    }, "a");
    a.prototype = f2.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
__name(getAugmentedNamespace, "getAugmentedNamespace");
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"), n$3 = Symbol.for("react.portal"), p$4 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = z$2 && a[z$2] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
__name(A$2, "A$2");
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
__name(E$1, "E$1");
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b2) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
__name(F, "F");
F.prototype = E$1.prototype;
function G$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
__name(G$1, "G$1");
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a && a.defaultProps)
    for (d2 in g2 = a.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$3, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
__name(M$1, "M$1");
function N$1(a, b2) {
  return { $$typeof: l$3, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
__name(N$1, "N$1");
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$3;
}
__name(O$1, "O$1");
function escape(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
__name(escape, "escape");
var P$1 = /\/+/g;
function Q$1(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
}
__name(Q$1, "Q$1");
function R$1(a, b2, e2, d2, c2) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2)
    a = null;
  var h2 = false;
  if (null === a)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$3:
          case n$3:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
      return a2;
    })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a))
    for (var g2 = 0; g2 < a.length; g2++) {
      k2 = a[g2];
      var f2 = d2 + Q$1(k2, g2);
      h2 += R$1(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$2(a), "function" === typeof f2)
    for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
      k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
__name(R$1, "R$1");
function S$1(a, b2, e2) {
  if (null == a)
    return a;
  var d2 = [], c2 = 0;
  R$1(a, d2, "", "", function(a2) {
    return b2.call(e2, a2, c2++);
  });
  return d2;
}
__name(S$1, "S$1");
function T$1(a) {
  if (-1 === a._status) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 1, a._result = b3;
    }, function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 2, a._result = b3;
    });
    -1 === a._status && (a._status = 0, a._result = b2);
  }
  if (1 === a._status)
    return a._result.default;
  throw a._result;
}
__name(T$1, "T$1");
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$1() {
  throw Error("act(...) is not supported in production builds of React.");
}
__name(X$1, "X$1");
react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
  S$1(a, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b2 = 0;
  S$1(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$4;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(a, b2, e2) {
  if (null === a || void 0 === a)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a.type && a.type.defaultProps)
      var g2 = a.type.defaultProps;
    for (f2 in b2)
      J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$3, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u$1, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$2, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b2 = M$1.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$3, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(a, b2) {
  return U$1.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$1.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e2) {
  return U$1.current.useImperativeHandle(a, b2, e2);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$1.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$1.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$1.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e2) {
  return U$1.current.useReducer(a, b2, e2);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e2) {
  return U$1.current.useSyncExternalStore(a, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React$1
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$2 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$2 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$3 = { key: true, ref: true, __self: true, __source: true };
function q$2(c2, a, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b2 in a)
    m$3.call(a, b2) && !p$3.hasOwnProperty(b2) && (d2[b2] = a[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a = c2.defaultProps, a)
      void 0 === d2[b2] && (d2[b2] = a[b2]);
  return { $$typeof: k$2, type: c2, key: e2, ref: h2, props: d2, _owner: n$2.current };
}
__name(q$2, "q$2");
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b2) {
    var c2 = a.length;
    a.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a[d2];
        if (0 < g2(e2, b2))
          a[d2] = b2, a[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  __name(f2, "f");
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  __name(h2, "h");
  function k2(a) {
    if (0 === a.length)
      return null;
    var b2 = a[0], c2 = a.pop();
    if (c2 !== b2) {
      a[0] = c2;
      a:
        for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a[d2] = x2, a[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  __name(k2, "k");
  function g2(a, b2) {
    var c2 = a.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a.id - b2.id;
  }
  __name(g2, "g");
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  __name(G2, "G");
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a);
      }
  }
  __name(H2, "H");
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  __name(J2, "J");
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  __name(M2, "M");
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  __name(R2, "R");
  var S2;
  if ("function" === typeof F2)
    S2 = /* @__PURE__ */ __name(function() {
      F2(R2);
    }, "S");
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = /* @__PURE__ */ __name(function() {
      U2.postMessage(null);
    }, "S");
  } else
    S2 = /* @__PURE__ */ __name(function() {
      D2(R2, 0);
    }, "S");
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  __name(I2, "I");
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b2);
  }
  __name(K2, "K");
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c2 = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$2(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
__name(p$2, "p$2");
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
__name(fa, "fa");
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++)
    da.add(b2[a]);
}
__name(ha, "ha");
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a))
    return true;
  if (ja.call(la, a))
    return false;
  if (ka.test(a))
    return ma[a] = true;
  la[a] = true;
  return false;
}
__name(oa, "oa");
function pa(a, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
__name(pa, "pa");
function qa(a, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
__name(qa, "qa");
function v$2(a, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
__name(v$2, "v$2");
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$1[a] = new v$2(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z$1[b2] = new v$2(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$1[a] = new v$2(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$1[a] = new v$2(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$1[a] = new v$2(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$1[a] = new v$2(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$1[a] = new v$2(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$1[a] = new v$2(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$1[a] = new v$2(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
__name(sa, "sa");
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(
    ra,
    sa
  );
  z$1[b2] = new v$2(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$2(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$2(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$1[a] = new v$2(a, 1, false, a.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$1[a] = new v$2(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b2, c2, d2) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
}
__name(ta, "ta");
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
__name(Ka, "Ka");
var A$1 = Object.assign, La;
function Ma(a) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a;
}
__name(Ma, "Ma");
var Na = false;
function Oa(a, b2) {
  if (!a || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = /* @__PURE__ */ __name(function() {
        throw Error();
      }, "b"), Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
__name(Oa, "Oa");
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
__name(Pa, "Pa");
function Qa(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a.render;
        a = a.displayName;
        a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
      case Ha:
        b2 = a._payload;
        a = a._init;
        try {
          return Qa(a(b2));
        } catch (c2) {
        }
    }
  return null;
}
__name(Qa, "Qa");
function Ra(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
__name(Ra, "Ra");
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
__name(Sa, "Sa");
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
__name(Ta, "Ta");
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
__name(Ua, "Ua");
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
__name(Va, "Va");
function Wa(a) {
  if (!a)
    return false;
  var b2 = a._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c2 ? (b2.setValue(a), true) : false;
}
__name(Wa, "Wa");
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
__name(Xa, "Xa");
function Ya(a, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
}
__name(Ya, "Ya");
function Za(a, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
__name(Za, "Za");
function ab(a, b2) {
  b2 = b2.checked;
  null != b2 && ta(a, "checked", b2, false);
}
__name(ab, "ab");
function bb(a, b2) {
  ab(a, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a.value || a.value != c2)
        a.value = "" + c2;
    } else
      a.value !== "" + c2 && (a.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
__name(bb, "bb");
function db(a, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a._wrapperState.initialValue;
    c2 || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c2 = a.name;
  "" !== c2 && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c2 && (a.name = c2);
}
__name(db, "db");
function cb(a, b2, c2) {
  if ("number" !== b2 || Xa(a.ownerDocument) !== a)
    null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
}
__name(cb, "cb");
var eb = Array.isArray;
function fb(a, b2, c2, d2) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a.length; c2++)
      e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c2) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
__name(fb, "fb");
function gb(a, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$2(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
__name(gb, "gb");
function hb(a, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$2(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$2(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a._wrapperState = { initialValue: Sa(c2) };
}
__name(hb, "hb");
function ib(a, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
  null != d2 && (a.defaultValue = "" + d2);
}
__name(ib, "ib");
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
}
__name(jb, "jb");
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
__name(kb, "kb");
function lb(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
__name(lb, "lb");
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c2, d2, e2);
    });
  } : a;
}(function(a, b2) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
    a.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b2.firstChild; )
      a.appendChild(b2.firstChild);
  }
});
function ob(a, b2) {
  if (b2) {
    var c2 = a.firstChild;
    if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
__name(ob, "ob");
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b2] = pb[a];
  });
});
function rb(a, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
}
__name(rb, "rb");
function sb(a, b2) {
  a = a.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a.setProperty(c2, e2) : a[c2] = e2;
    }
}
__name(sb, "sb");
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b2) {
  if (b2) {
    if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$2(137, a));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$2(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$2(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$2(62));
  }
}
__name(ub, "ub");
function vb(a, b2) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
__name(vb, "vb");
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
__name(xb, "xb");
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(p$2(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
__name(Bb, "Bb");
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
__name(Eb, "Eb");
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2)
      for (a = 0; a < b2.length; a++)
        Bb(b2[a]);
  }
}
__name(Fb, "Fb");
function Gb(a, b2) {
  return a(b2);
}
__name(Gb, "Gb");
function Hb() {
}
__name(Hb, "Hb");
var Ib = false;
function Jb(a, b2, c2) {
  if (Ib)
    return a(b2, c2);
  Ib = true;
  try {
    return Gb(a, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
__name(Jb, "Jb");
function Kb(a, b2) {
  var c2 = a.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d2;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$2(231, b2, typeof c2));
  return c2;
}
__name(Kb, "Kb");
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
__name(Nb, "Nb");
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
__name(Tb, "Tb");
function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$2(198));
    Qb || (Qb = true, Rb = l2);
  }
}
__name(Ub, "Ub");
function Vb(a) {
  var b2 = a, c2 = a;
  if (a.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
    while (a);
  }
  return 3 === b2.tag ? c2 : null;
}
__name(Vb, "Vb");
function Wb(a) {
  if (13 === a.tag) {
    var b2 = a.memoizedState;
    null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
__name(Wb, "Wb");
function Xb(a) {
  if (Vb(a) !== a)
    throw Error(p$2(188));
}
__name(Xb, "Xb");
function Yb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Vb(a);
    if (null === b2)
      throw Error(p$2(188));
    return b2 !== a ? null : a;
  }
  for (var c2 = a, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$2(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$2(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$2(190));
  }
  if (3 !== c2.tag)
    throw Error(p$2(188));
  return c2.stateNode.current === c2 ? a : b2;
}
__name(Yb, "Yb");
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
__name(Zb, "Zb");
function $b(a) {
  if (5 === a.tag || 6 === a.tag)
    return a;
  for (a = a.child; null !== a; ) {
    var b2 = $b(a);
    if (null !== b2)
      return b2;
    a = a.sibling;
  }
  return null;
}
__name($b, "$b");
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b2) {
    }
}
__name(mc, "mc");
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
__name(nc, "nc");
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
__name(tc, "tc");
function uc(a, b2) {
  var c2 = a.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a.entangledLanes;
  if (0 !== b2)
    for (a = a.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
  return d2;
}
__name(uc, "uc");
function vc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
__name(vc, "vc");
function wc(a, b2) {
  for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
__name(wc, "wc");
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
__name(xc, "xc");
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
__name(yc, "yc");
function zc(a) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a);
  return b2;
}
__name(zc, "zc");
function Ac(a, b2, c2) {
  a.pendingLanes |= b2;
  536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - oc(b2);
  a[b2] = c2;
}
__name(Ac, "Ac");
function Bc(a, b2) {
  var c2 = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d2 = a.eventTimes;
  for (a = a.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a[e2] = -1;
    c2 &= ~f2;
  }
}
__name(Bc, "Bc");
function Cc(a, b2) {
  var c2 = a.entangledLanes |= b2;
  for (a = a.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
    c2 &= ~e2;
  }
}
__name(Cc, "Cc");
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
__name(Dc, "Dc");
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
__name(Sc, "Sc");
function Tc(a, b2, c2, d2, e2, f2) {
  if (null === a || a.nativeEvent !== f2)
    return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
  a.eventSystemFlags |= d2;
  b2 = a.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a;
}
__name(Tc, "Tc");
function Uc(a, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
  }
  return false;
}
__name(Uc, "Uc");
function Vc(a) {
  var b2 = Wc(a.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a.blockedOn = b2;
          Ic(a.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
__name(Vc, "Vc");
function Xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (null === c2) {
      c2 = a.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
__name(Xc, "Xc");
function Zc(a, b2, c2) {
  Xc(a) && c2.delete(b2);
}
__name(Zc, "Zc");
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
__name($c, "$c");
function ad(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
__name(ad, "ad");
function bd(a) {
  function b2(b3) {
    return ad(b3, a);
  }
  __name(b2, "b");
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
__name(bd, "bd");
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
__name(ed, "ed");
function gd(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
__name(gd, "gd");
function fd(a, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a, b2, c2, d2);
    if (null === e2)
      hd(a, b2, d2, id$3, c2), Sc(a, d2);
    else if (Uc(e2, a, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b2, c2, d2);
        null === f2 && hd(a, b2, d2, id$3, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a, b2, d2, null, c2);
  }
}
__name(fd, "fd");
var id$3 = null;
function Yc(a, b2, c2, d2) {
  id$3 = null;
  a = xb(d2);
  a = Wc(a);
  if (null !== a)
    if (b2 = Vb(a), null === b2)
      a = null;
    else if (c2 = b2.tag, 13 === c2) {
      a = Wb(b2);
      if (null !== a)
        return a;
      a = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a = null;
    } else
      b2 !== a && (a = null);
  id$3 = a;
  return null;
}
__name(Yc, "Yc");
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
__name(jd, "jd");
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c2 && b2[a] === e2[a]; a++)
    ;
  var g2 = c2 - a;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
__name(nd, "nd");
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
__name(od, "od");
function pd() {
  return true;
}
__name(pd, "pd");
function qd() {
  return false;
}
__name(qd, "qd");
function rd(a) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a)
      a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  __name(b2, "b");
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
__name(rd, "rd");
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
__name(Pd, "Pd");
function zd() {
  return Pd;
}
__name(zd, "zd");
var Qd = A$1({}, ud, { key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
__name(ge, "ge");
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
__name(he, "he");
var ie = false;
function je(a, b2) {
  switch (a) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b2.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
__name(je, "je");
function ke(a, b2) {
  if (ie)
    return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
__name(ke, "ke");
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
}
__name(me, "me");
function ne(a, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
}
__name(ne, "ne");
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
__name(re, "re");
function te(a) {
  var b2 = ue(a);
  if (Wa(b2))
    return a;
}
__name(te, "te");
function ve(a, b2) {
  if ("change" === a)
    return b2;
}
__name(ve, "ve");
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
__name(Ae, "Ae");
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a, xb(a));
    Jb(re, b2);
  }
}
__name(Be, "Be");
function Ce(a, b2, c2) {
  "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
__name(Ce, "Ce");
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te(qe);
}
__name(De, "De");
function Ee(a, b2) {
  if ("click" === a)
    return te(b2);
}
__name(Ee, "Ee");
function Fe(a, b2) {
  if ("input" === a || "change" === a)
    return te(b2);
}
__name(Fe, "Fe");
function Ge(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
__name(Ge, "Ge");
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b2) {
  if (He(a, b2))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a[e2], b2[e2]))
      return false;
  }
  return true;
}
__name(Ie, "Ie");
function Je(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
__name(Je, "Je");
function Ke(a, b2) {
  var c2 = Je(a);
  a = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a + c2.textContent.length;
      if (a <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a };
      a = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
__name(Ke, "Ke");
function Le(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
__name(Le, "Le");
function Me() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a = b2.contentWindow;
    else
      break;
    b2 = Xa(a.document);
  }
  return b2;
}
__name(Me, "Me");
function Ne(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
__name(Ne, "Ne");
function Oe(a) {
  var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
      else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c2; a = a.parentNode; )
      1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
__name(Oe, "Oe");
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
__name(Ue, "Ue");
function Ve(a, b2) {
  var c2 = {};
  c2[a.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a] = "webkit" + b2;
  c2["Moz" + a] = "moz" + b2;
  return c2;
}
__name(Ve, "Ve");
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a])
    return Xe[a];
  if (!We[a])
    return a;
  var b2 = We[a], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye)
      return Xe[a] = b2[c2];
  return a;
}
__name(Ze, "Ze");
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b2) {
  df.set(a, b2);
  fa(b2, [a]);
}
__name(ff, "ff");
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b2, c2) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = c2;
  Ub(d2, b2, void 0, a);
  a.currentTarget = null;
}
__name(nf, "nf");
function se(a, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a.length; c2++) {
    var d2 = a[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a = Rb, Qb = false, Rb = null, a;
}
__name(se, "se");
function D(a, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a + "__bubble";
  c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
}
__name(D, "D");
function qf(a, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a, d2, b2);
}
__name(qf, "qf");
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
    });
    var b2 = 9 === a.nodeType ? a : a.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
__name(sf, "sf");
function pf(a, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
}
__name(pf, "pf");
function hd(a, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a, h3, d3);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c2) : ke(a, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
__name(hd, "hd");
function tf(a, b2, c2) {
  return { instance: a, listener: b2, currentTarget: c2 };
}
__name(tf, "tf");
function oe(a, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d2;
}
__name(oe, "oe");
function vf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
__name(vf, "vf");
function wf(a, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a.push({ event: b2, listeners: g2 });
}
__name(wf, "wf");
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
__name(zf, "zf");
function Af(a, b2, c2) {
  b2 = zf(b2);
  if (zf(a) !== b2 && c2)
    throw Error(p$2(425));
}
__name(Af, "Af");
function Bf() {
}
__name(Bf, "Bf");
var Cf = null, Df = null;
function Ef(a, b2) {
  return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
__name(Ef, "Ef");
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
__name(If, "If");
function Kf(a, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
__name(Kf, "Kf");
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a;
}
__name(Lf, "Lf");
function Mf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (8 === a.nodeType) {
      var c2 = a.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
__name(Mf, "Mf");
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b2 = a[Of];
  if (b2)
    return b2;
  for (var c2 = a.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a = Mf(a); null !== a; ) {
          if (c2 = a[Of])
            return c2;
          a = Mf(a);
        }
      return b2;
    }
    a = c2;
    c2 = a.parentNode;
  }
  return null;
}
__name(Wc, "Wc");
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
__name(Cb, "Cb");
function ue(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(p$2(33));
}
__name(ue, "ue");
function Db(a) {
  return a[Pf] || null;
}
__name(Db, "Db");
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
__name(Uf, "Uf");
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
__name(E, "E");
function G(a, b2) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b2;
}
__name(G, "G");
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b2) {
  var c2 = a.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
__name(Yf, "Yf");
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
__name(Zf, "Zf");
function $f() {
  E(Wf);
  E(H);
}
__name($f, "$f");
function ag(a, b2, c2) {
  if (H.current !== Vf)
    throw Error(p$2(168));
  G(H, b2);
  G(Wf, c2);
}
__name(ag, "ag");
function bg(a, b2, c2) {
  var d2 = a.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$2(108, Ra(a) || "Unknown", e2));
  return A$1({}, c2, d2);
}
__name(bg, "bg");
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
__name(cg, "cg");
function dg(a, b2, c2) {
  var d2 = a.stateNode;
  if (!d2)
    throw Error(p$2(169));
  c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c2);
}
__name(dg, "dg");
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
__name(hg, "hg");
function ig(a) {
  fg = true;
  hg(a);
}
__name(ig, "ig");
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a < c2.length; a++) {
        var d2 = c2[a];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
__name(jg, "jg");
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b2;
}
__name(tg, "tg");
function ug(a, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d2 = rg;
  a = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a;
}
__name(ug, "ug");
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
__name(vg, "vg");
function wg(a) {
  for (; a === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
__name(wg, "wg");
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a;
  b2 = a.deletions;
  null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
}
__name(Ag, "Ag");
function Cg(a, b2) {
  switch (a.tag) {
    case 5:
      var c2 = a.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
__name(Cg, "Cg");
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
__name(Dg, "Dg");
function Eg(a) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a, b2)) {
        if (Dg(a))
          throw Error(p$2(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a))
        throw Error(p$2(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
__name(Eg, "Eg");
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  xg = a;
}
__name(Fg, "Fg");
function Gg(a) {
  if (a !== xg)
    return false;
  if (!I)
    return Fg(a), I = true, false;
  var b2;
  (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a))
      throw Hg(), Error(p$2(418));
    for (; b2; )
      Ag(a, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(p$2(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
__name(Gg, "Gg");
function Hg() {
  for (var a = yg; a; )
    a = Lf(a.nextSibling);
}
__name(Hg, "Hg");
function Ig() {
  yg = xg = null;
  I = false;
}
__name(Ig, "Ig");
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
__name(Jg, "Jg");
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b2, c2) {
  a = c2.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$2(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$2(147, a));
      var e2 = d2, f2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = /* @__PURE__ */ __name(function(a2) {
        var b3 = e2.refs;
        null === a2 ? delete b3[f2] : b3[f2] = a2;
      }, "b");
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a)
      throw Error(p$2(284));
    if (!c2._owner)
      throw Error(p$2(290, a));
  }
  return a;
}
__name(Lg, "Lg");
function Mg(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$2(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
__name(Mg, "Mg");
function Ng(a) {
  var b2 = a._init;
  return b2(a._payload);
}
__name(Ng, "Ng");
function Og(a) {
  function b2(b3, c3) {
    if (a) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  __name(b2, "b");
  function c2(c3, d3) {
    if (!a)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  __name(c2, "c");
  function d2(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  __name(d2, "d");
  function e2(a2, b3) {
    a2 = Pg(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  __name(e2, "e");
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  __name(f2, "f");
  function g2(b3) {
    a && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  __name(g2, "g");
  function h2(a2, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = Qg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  __name(h2, "h");
  function k2(a2, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a2, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = Lg(a2, b3, c3), d3.return = a2, d3;
    d3 = Rg(c3.type, c3.key, c3.props, null, a2.mode, d3);
    d3.ref = Lg(a2, b3, c3);
    d3.return = a2;
    return d3;
  }
  __name(k2, "k");
  function l2(a2, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = Sg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a2;
    return b3;
  }
  __name(l2, "l");
  function m2(a2, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Tg(c3, a2.mode, d3, f3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  __name(m2, "m");
  function q2(a2, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = Qg("" + b3, a2.mode, c3), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = Rg(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = Lg(a2, null, b3), c3.return = a2, c3;
        case wa:
          return b3 = Sg(b3, a2.mode, c3), b3.return = a2, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a2, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Tg(b3, a2.mode, c3, null), b3.return = a2, b3;
      Mg(a2, b3);
    }
    return null;
  }
  __name(q2, "q");
  function r2(a2, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a2,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a2, b3, c3, d3, null);
      Mg(a2, c3);
    }
    return null;
  }
  __name(r2, "r");
  function y2(a2, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
        case wa:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a2, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
      Mg(b3, d3);
    }
    return null;
  }
  __name(y2, "y");
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  __name(n2, "n");
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$2(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$2(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  __name(t2, "t");
  function J2(a2, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a2, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c2(a2, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = Lg(a2, l3, f3);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                }
                c2(a2, l3);
                break;
              } else
                b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Tg(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Lg(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a2, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                } else {
                  c2(a2, d3);
                  break;
                }
              else
                b2(a2, d3);
              d3 = d3.sibling;
            }
            d3 = Sg(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g2(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a2, d3, f3, h3);
      if (Ka(f3))
        return t2(a2, d3, f3, h3);
      Mg(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = Qg(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
  }
  __name(J2, "J");
  return J2;
}
__name(Og, "Og");
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
__name($g, "$g");
function ah(a) {
  var b2 = Wg.current;
  E(Wg);
  a._currentValue = b2;
}
__name(ah, "ah");
function bh(a, b2, c2) {
  for (; null !== a; ) {
    var d2 = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a === c2)
      break;
    a = a.return;
  }
}
__name(bh, "bh");
function ch(a, b2) {
  Xg = a;
  Zg = Yg = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (dh = true), a.firstContext = null);
}
__name(ch, "ch");
function eh(a) {
  var b2 = a._currentValue;
  if (Zg !== a)
    if (a = { context: a, memoizedValue: b2, next: null }, null === Yg) {
      if (null === Xg)
        throw Error(p$2(308));
      Yg = a;
      Xg.dependencies = { lanes: 0, firstContext: a };
    } else
      Yg = Yg.next = a;
  return b2;
}
__name(eh, "eh");
var fh = null;
function gh(a) {
  null === fh ? fh = [a] : fh.push(a);
}
__name(gh, "gh");
function hh(a, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a, d2);
}
__name(hh, "hh");
function ih(a, b2) {
  a.lanes |= b2;
  var c2 = a.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
__name(ih, "ih");
var jh = false;
function kh(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
__name(kh, "kh");
function lh(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
__name(lh, "lh");
function mh(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
__name(mh, "mh");
function nh(a, b2, c2) {
  var d2 = a.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return ih(a, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return ih(a, c2);
}
__name(nh, "nh");
function oh(a, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
__name(oh, "oh");
function ph(a, b2) {
  var c2 = a.updateQueue, d2 = a.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a.updateQueue = c2;
    return;
  }
  a = c2.lastBaseUpdate;
  null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
  c2.lastBaseUpdate = b2;
}
__name(ph, "ph");
function qh(a, b2, c2, d2) {
  var e2 = a.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    rh |= g2;
    a.lanes = g2;
    a.memoizedState = q2;
  }
}
__name(qh, "qh");
function sh(a, b2, c2) {
  a = b2.effects;
  b2.effects = null;
  if (null !== a)
    for (b2 = 0; b2 < a.length; b2++) {
      var d2 = a[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$2(191, e2));
        e2.call(d2);
      }
    }
}
__name(sh, "sh");
var th = {}, uh = Uf(th), vh$1 = Uf(th), wh = Uf(th);
function xh(a) {
  if (a === th)
    throw Error(p$2(174));
  return a;
}
__name(xh, "xh");
function yh(a, b2) {
  G(wh, b2);
  G(vh$1, a);
  G(uh, th);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
  }
  E(uh);
  G(uh, b2);
}
__name(yh, "yh");
function zh() {
  E(uh);
  E(vh$1);
  E(wh);
}
__name(zh, "zh");
function Ah(a) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a.type);
  b2 !== c2 && (G(vh$1, a), G(uh, c2));
}
__name(Ah, "Ah");
function Bh(a) {
  vh$1.current === a && (E(uh), E(vh$1));
}
__name(Bh, "Bh");
var L = Uf(0);
function Ch(a) {
  for (var b2 = a; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
__name(Ch, "Ch");
var Dh = [];
function Eh() {
  for (var a = 0; a < Dh.length; a++)
    Dh[a]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
__name(Eh, "Eh");
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P() {
  throw Error(p$2(321));
}
__name(P, "P");
function Mh(a, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
    if (!He(a[c2], b2[c2]))
      return false;
  return true;
}
__name(Mh, "Mh");
function Nh(a, b2, c2, d2, e2, f2) {
  Hh = f2;
  M = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
  a = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2)
        throw Error(p$2(301));
      f2 += 1;
      O = N = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N && null !== N.next;
  Hh = 0;
  O = N = M = null;
  Ih = false;
  if (b2)
    throw Error(p$2(300));
  return a;
}
__name(Nh, "Nh");
function Sh() {
  var a = 0 !== Kh;
  Kh = 0;
  return a;
}
__name(Sh, "Sh");
function Th() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M.memoizedState = O = a : O = O.next = a;
  return O;
}
__name(Th, "Th");
function Uh() {
  if (null === N) {
    var a = M.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = N.next;
  var b2 = null === O ? M.memoizedState : O.next;
  if (null !== b2)
    O = b2, N = a;
  else {
    if (null === a)
      throw Error(p$2(310));
    N = a;
    a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
  }
  return O;
}
__name(Uh, "Uh");
function Vh(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
__name(Vh, "Vh");
function Wh(a) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$2(311));
  c2.lastRenderedReducer = a;
  var d2 = N, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        M.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (dh = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a = c2.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, M.lanes |= f2, rh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
__name(Wh, "Wh");
function Xh(a) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$2(311));
  c2.lastRenderedReducer = a;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
__name(Xh, "Xh");
function Yh() {
}
__name(Yh, "Yh");
function Zh(a, b2) {
  var c2 = M, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, dh = true);
  d2 = d2.queue;
  $h(ai.bind(null, c2, d2, a), [a]);
  if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === Q)
      throw Error(p$2(349));
    0 !== (Hh & 30) || di(c2, b2, e2);
  }
  return e2;
}
__name(Zh, "Zh");
function di(a, b2, c2) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c2 };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
}
__name(di, "di");
function ci(a, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei(b2) && fi(a);
}
__name(ci, "ci");
function ai(a, b2, c2) {
  return c2(function() {
    ei(b2) && fi(a);
  });
}
__name(ai, "ai");
function ei(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c2 = b2();
    return !He(a, c2);
  } catch (d2) {
    return true;
  }
}
__name(ei, "ei");
function fi(a) {
  var b2 = ih(a, 1);
  null !== b2 && gi(b2, a, 1, -1);
}
__name(fi, "fi");
function hi(a) {
  var b2 = Th();
  "function" === typeof a && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ii.bind(null, M, a);
  return [b2.memoizedState, a];
}
__name(hi, "hi");
function bi(a, b2, c2, d2) {
  a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
  return a;
}
__name(bi, "bi");
function ji() {
  return Uh().memoizedState;
}
__name(ji, "ji");
function ki(a, b2, c2, d2) {
  var e2 = Th();
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
__name(ki, "ki");
function li(a, b2, c2, d2) {
  var e2 = Uh();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== N) {
    var g2 = N.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Mh(d2, g2.deps)) {
      e2.memoizedState = bi(b2, c2, f2, d2);
      return;
    }
  }
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c2, f2, d2);
}
__name(li, "li");
function mi(a, b2) {
  return ki(8390656, 8, a, b2);
}
__name(mi, "mi");
function $h(a, b2) {
  return li(2048, 8, a, b2);
}
__name($h, "$h");
function ni(a, b2) {
  return li(4, 2, a, b2);
}
__name(ni, "ni");
function oi(a, b2) {
  return li(4, 4, a, b2);
}
__name(oi, "oi");
function pi(a, b2) {
  if ("function" === typeof b2)
    return a = a(), b2(a), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a = a(), b2.current = a, function() {
      b2.current = null;
    };
}
__name(pi, "pi");
function qi(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return li(4, 4, pi.bind(null, b2, a), c2);
}
__name(qi, "qi");
function ri() {
}
__name(ri, "ri");
function si(a, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a, b2];
  return a;
}
__name(si, "si");
function ti(a, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1]))
    return d2[0];
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}
__name(ti, "ti");
function ui(a, b2, c2) {
  if (0 === (Hh & 21))
    return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), M.lanes |= c2, rh |= c2, a.baseState = true);
  return b2;
}
__name(ui, "ui");
function vi(a, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a(false), b2();
  } finally {
    C = c2, Gh.transition = d2;
  }
}
__name(vi, "vi");
function wi() {
  return Uh().memoizedState;
}
__name(wi, "wi");
function xi(a, b2, c2) {
  var d2 = yi(a);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a))
    Ai(b2, c2);
  else if (c2 = hh(a, b2, c2, d2), null !== c2) {
    var e2 = R();
    gi(c2, a, d2, e2);
    Bi(c2, b2, d2);
  }
}
__name(xi, "xi");
function ii(a, b2, c2) {
  var d2 = yi(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a))
    Ai(b2, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = hh(a, b2, e2, d2);
    null !== c2 && (e2 = R(), gi(c2, a, d2, e2), Bi(c2, b2, d2));
  }
}
__name(ii, "ii");
function zi(a) {
  var b2 = a.alternate;
  return a === M || null !== b2 && b2 === M;
}
__name(zi, "zi");
function Ai(a, b2) {
  Jh = Ih = true;
  var c2 = a.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a.pending = b2;
}
__name(Ai, "Ai");
function Bi(a, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
__name(Bi, "Bi");
var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b2) {
  Th().memoizedState = [a, void 0 === b2 ? null : b2];
  return a;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a),
    c2
  );
}, useLayoutEffect: function(a, b2) {
  return ki(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return ki(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c2) {
  var d2 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d2.queue = a;
  a = a.dispatch = xi.bind(null, M, a);
  return [d2.memoizedState, a];
}, useRef: function(a) {
  var b2 = Th();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
  return Th().memoizedState = a;
}, useTransition: function() {
  var a = hi(false), b2 = a[0];
  a = vi.bind(null, a[1]);
  Th().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c2) {
  var d2 = M, e2 = Th();
  if (I) {
    if (void 0 === c2)
      throw Error(p$2(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q)
      throw Error(p$2(349));
    0 !== (Hh & 30) || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d2,
    f2,
    a
  ), [a]);
  d2.flags |= 2048;
  bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a = Th(), b2 = Q.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a) {
    var b2 = Uh();
    return ui(b2, N.memoizedState, a);
  },
  useTransition: function() {
    var a = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a) {
  var b2 = Uh();
  return null === N ? b2.memoizedState = a : ui(b2, N.memoizedState, a);
}, useTransition: function() {
  var a = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a, b2) {
  if (a && a.defaultProps) {
    b2 = A$1({}, b2);
    a = a.defaultProps;
    for (var c2 in a)
      void 0 === b2[c2] && (b2[c2] = a[c2]);
    return b2;
  }
  return b2;
}
__name(Ci, "Ci");
function Di(a, b2, c2, d2) {
  b2 = a.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a.memoizedState = c2;
  0 === a.lanes && (a.updateQueue.baseState = c2);
}
__name(Di, "Di");
var Ei = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
}, enqueueReplaceState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c2 = R(), d2 = yi(a), e2 = mh(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a, e2, d2);
  null !== b2 && (gi(b2, a, d2, c2), oh(b2, a, d2));
} };
function Fi(a, b2, c2, d2, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
__name(Fi, "Fi");
function Gi(a, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
  b2 = new b2(c2, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a.stateNode = b2;
  b2._reactInternals = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
__name(Gi, "Gi");
function Hi(a, b2, c2, d2) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a && Ei.enqueueReplaceState(b2, b2.state, null);
}
__name(Hi, "Hi");
function Ii(a, b2, c2, d2) {
  var e2 = a.stateNode;
  e2.props = c2;
  e2.state = a.memoizedState;
  e2.refs = {};
  kh(a);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a, b2, f2, c2), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a, c2, e2, d2), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
__name(Ii, "Ii");
function Ji(a, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e2, digest: null };
}
__name(Ji, "Ji");
function Ki(a, b2, c2) {
  return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
__name(Ki, "Ki");
function Li(a, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
__name(Li, "Li");
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Oi || (Oi = true, Pi = d2);
    Li(a, b2);
  };
  return c2;
}
__name(Ni, "Ni");
function Qi(a, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d2 = a.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Li(a, b2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Li(a, b2);
    "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
__name(Qi, "Qi");
function Si(a, b2, c2) {
  var d2 = a.pingCache;
  if (null === d2) {
    d2 = a.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a = Ti.bind(null, a, b2, c2), b2.then(a, a));
}
__name(Si, "Si");
function Ui(a) {
  do {
    var b2;
    if (b2 = 13 === a.tag)
      b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a;
    a = a.return;
  } while (null !== a);
  return null;
}
__name(Ui, "Ui");
function Vi(a, b2, c2, d2, e2) {
  if (0 === (a.mode & 1))
    return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
__name(Vi, "Vi");
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a, b2, c2, d2) {
  b2.child = null === a ? Vg(b2, null, c2, d2) : Ug(b2, a.child, c2, d2);
}
__name(Xi, "Xi");
function Yi(a, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d2 = Nh(a, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (null !== a && !dh)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, d2, e2);
  return b2.child;
}
__name(Yi, "Yi");
function $i(a, b2, c2, d2, e2) {
  if (null === a) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, bj(a, b2, f2, d2, e2);
    a = Rg(c2.type, null, d2, b2, b2.mode, e2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a.ref === b2.ref)
      return Zi(a, b2, e2);
  }
  b2.flags |= 1;
  a = Pg(f2, d2);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
__name($i, "$i");
function bj(a, b2, c2, d2, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d2) && a.ref === b2.ref)
      if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
        0 !== (a.flags & 131072) && (dh = true);
      else
        return b2.lanes = a.lanes, Zi(a, b2, e2);
  }
  return cj(a, b2, c2, d2, e2);
}
__name(bj, "bj");
function dj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G(ej, fj);
      fj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
  Xi(a, b2, e2, c2);
  return b2.child;
}
__name(dj, "dj");
function gj(a, b2) {
  var c2 = b2.ref;
  if (null === a && null !== c2 || null !== a && a.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
__name(gj, "gj");
function cj(a, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c2 = Nh(a, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (null !== a && !dh)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, c2, e2);
  return b2.child;
}
__name(cj, "cj");
function hj(a, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode)
    ij(a, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
  else if (null === a) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    lh(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return jj(a, b2, c2, d2, f2, e2);
}
__name(hj, "hj");
function jj(a, b2, c2, d2, e2, f2) {
  gj(a, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), Zi(a, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a && g2 ? (b2.child = Ug(b2, a.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
__name(jj, "jj");
function kj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
  yh(a, b2.containerInfo);
}
__name(kj, "kj");
function lj(a, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a, b2, c2, d2);
  return b2.child;
}
__name(lj, "lj");
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
__name(nj, "nj");
function oj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a || null !== a.memoizedState)
    e2 |= 1;
  G(L, e2 & 1);
  if (null === a) {
    Eg(b2);
    a = b2.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a = Tg(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a) : qj(b2, g2);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return rj(a, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a.childLanes & ~c2;
    b2.memoizedState = mj;
    return d2;
  }
  f2 = a.child;
  a = f2.sibling;
  d2 = Pg(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
__name(oj, "oj");
function qj(a, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
__name(qj, "qj");
function sj(a, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Ug(b2, a.child, null, c2);
  a = qj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
__name(sj, "sj");
function rj(a, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Ki(Error(p$2(422))), sj(a, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Ug(b2, a.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return sj(a, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$2(419));
    d2 = Ki(f2, d2, void 0);
    return sj(a, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a.childLanes);
  if (dh || h2) {
    d2 = Q;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a, e2), gi(d2, a, e2, -1));
    }
    tj();
    d2 = Ki(Error(p$2(421)));
    return sj(a, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a.child, b2 = uj.bind(null, a), e2._reactRetry = b2, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
  b2 = qj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
__name(rj, "rj");
function vj(a, b2, c2) {
  a.lanes |= b2;
  var d2 = a.alternate;
  null !== d2 && (d2.lanes |= b2);
  bh(a.return, b2, c2);
}
__name(vj, "vj");
function wj(a, b2, c2, d2, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
__name(wj, "wj");
function xj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a, b2, d2.children, c2);
  d2 = L.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128))
      a:
        for (a = b2.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && vj(a, c2, b2);
          else if (19 === a.tag)
            vj(a, c2, b2);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b2)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b2)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d2 &= 1;
  }
  G(L, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a = c2.alternate, null !== a && null === Ch(a) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        wj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a = e2.alternate;
          if (null !== a && null === Ch(a)) {
            b2.child = e2;
            break;
          }
          a = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a;
        }
        wj(b2, true, c2, null, f2);
        break;
      case "together":
        wj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
__name(xj, "xj");
function ij(a, b2) {
  0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
}
__name(ij, "ij");
function Zi(a, b2, c2) {
  null !== a && (b2.dependencies = a.dependencies);
  rh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a && b2.child !== a.child)
    throw Error(p$2(153));
  if (null !== b2.child) {
    a = b2.child;
    c2 = Pg(a, a.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a.sibling; )
      a = a.sibling, c2 = c2.sibling = Pg(a, a.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
__name(Zi, "Zi");
function yj(a, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Wg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return oj(a, b2, c2);
        G(L, L.current & 1);
        a = Zi(a, b2, c2);
        return null !== a ? a.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d2)
          return xj(a, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(L, L.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a, b2, c2);
  }
  return Zi(a, b2, c2);
}
__name(yj, "yj");
var zj, Aj, Bj, Cj;
zj = /* @__PURE__ */ __name(function(a, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
}, "zj");
Aj = /* @__PURE__ */ __name(function() {
}, "Aj");
Bj = /* @__PURE__ */ __name(function(a, b2, c2, d2) {
  var e2 = a.memoizedProps;
  if (e2 !== d2) {
    a = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a, e2);
        d2 = Ya(a, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d2 = gb(a, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
}, "Bj");
Cj = /* @__PURE__ */ __name(function(a, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
}, "Cj");
function Dj(a, b2) {
  if (!I)
    switch (a.tailMode) {
      case "hidden":
        b2 = a.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
    }
}
__name(Dj, "Dj");
function S(a) {
  var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else
    for (e2 = a.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d2;
  a.childLanes = c2;
  return b2;
}
__name(S, "S");
function Ej(a, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      E(Wf);
      E(H);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a || null === a.child)
        Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a, b2);
      S(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a && null != b2.stateNode)
        Bj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$2(166));
          S(b2);
          return null;
        }
        a = xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
          a[Of] = b2;
          a[Pf] = d2;
          zj(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D(lf[e2], a);
                e2 = d2;
                break;
              case "source":
                D("error", a);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e2 = d2;
                break;
              case "details":
                D("toggle", a);
                e2 = d2;
                break;
              case "input":
                Za(a, d2);
                e2 = Ya(a, d2);
                D("invalid", a);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$1({}, d2, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d2);
                e2 = gb(a, d2);
                D("invalid", a);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a);
                db(a, d2, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a && null != b2.stateNode)
        Cj(a, b2, a.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$2(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a = xg, null !== a)
              switch (a.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E(L);
      d2 = b2.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a) {
            if (!f2)
              throw Error(p$2(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$2(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else
          null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return zh(), Aj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return ah(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E(L);
      f2 = b2.memoizedState;
      if (null === f2)
        return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Dj(f2, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128))
            for (a = b2.child; null !== a; ) {
              g2 = Ch(a);
              if (null !== g2) {
                b2.flags |= 128;
                Dj(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                G(L, L.current & 1 | 2);
                return b2.child;
              }
              a = a.sibling;
            }
          null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a = Ch(g2), null !== a) {
            if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
              return S(b2), null;
          } else
            2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$2(156, b2.tag));
}
__name(Ej, "Ej");
function Ij(a, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return zh(), E(Wf), E(H), Eh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E(L);
      a = b2.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$2(340));
        Ig();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
__name(Ij, "Ij");
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a, b2) {
  var c2 = a.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W(a, b2, d2);
      }
    else
      c2.current = null;
}
__name(Lj, "Lj");
function Mj(a, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a, b2, d2);
  }
}
__name(Mj, "Mj");
var Nj = false;
function Oj(a, b2) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a)
      var c2 = { start: a.selectionStart, end: a.selectionEnd };
    else
      a: {
        c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; )
    if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
      a.return = b2, V = a;
    else
      for (; null !== V; ) {
        b2 = V;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$2(163));
            }
        } catch (F2) {
          W(b2, b2.return, F2);
        }
        a = b2.sibling;
        if (null !== a) {
          a.return = b2.return;
          V = a;
          break;
        }
        V = b2.return;
      }
  n2 = Nj;
  Nj = false;
  return n2;
}
__name(Oj, "Oj");
function Pj(a, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
__name(Pj, "Pj");
function Qj(a, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a) === a) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
__name(Qj, "Qj");
function Rj(a) {
  var b2 = a.ref;
  if (null !== b2) {
    var c2 = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c2;
        break;
      default:
        a = c2;
    }
    "function" === typeof b2 ? b2(a) : b2.current = a;
  }
}
__name(Rj, "Rj");
function Sj(a) {
  var b2 = a.alternate;
  null !== b2 && (a.alternate = null, Sj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
__name(Sj, "Sj");
function Tj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
__name(Tj, "Tj");
function Uj(a) {
  a:
    for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return))
          return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2)
          continue a;
        if (null === a.child || 4 === a.tag)
          continue a;
        else
          a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2))
        return a.stateNode;
    }
}
__name(Uj, "Uj");
function Vj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2)
    a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a = a.child, null !== a))
    for (Vj(a, b2, c2), a = a.sibling; null !== a; )
      Vj(a, b2, c2), a = a.sibling;
}
__name(Vj, "Vj");
function Wj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2)
    a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
  else if (4 !== d2 && (a = a.child, null !== a))
    for (Wj(a, b2, c2), a = a.sibling; null !== a; )
      Wj(a, b2, c2), a = a.sibling;
}
__name(Wj, "Wj");
var X = null, Xj = false;
function Yj(a, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    Zj(a, b2, c2), c2 = c2.sibling;
}
__name(Yj, "Yj");
function Zj(a, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U || Lj(c2, b2);
    case 6:
      var d2 = X, e2 = Xj;
      X = null;
      Yj(a, b2, c2);
      X = d2;
      Xj = e2;
      null !== X && (Xj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Xj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Xj;
      X = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a, b2, c2);
      X = d2;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Yj(a, b2, c2);
      break;
    case 1:
      if (!U && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W(c2, b2, h2);
        }
      Yj(a, b2, c2);
      break;
    case 21:
      Yj(a, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Yj(a, b2, c2), U = d2) : Yj(a, b2, c2);
      break;
    default:
      Yj(a, b2, c2);
  }
}
__name(Zj, "Zj");
function ak(a) {
  var b2 = a.updateQueue;
  if (null !== b2) {
    a.updateQueue = null;
    var c2 = a.stateNode;
    null === c2 && (c2 = a.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d2 = bk.bind(null, a, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
__name(ak, "ak");
function ck(a, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X = h2.stateNode;
                Xj = false;
                break a;
              case 3:
                X = h2.stateNode.containerInfo;
                Xj = true;
                break a;
              case 4:
                X = h2.stateNode.containerInfo;
                Xj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X)
          throw Error(p$2(160));
        Zj(f2, g2, e2);
        X = null;
        Xj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      dk(b2, a), b2 = b2.sibling;
}
__name(ck, "ck");
function dk(a, b2) {
  var c2 = a.alternate, d2 = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a);
      ek(a);
      if (d2 & 4) {
        try {
          Pj(3, a, a.return), Qj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Pj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a);
      ek(a);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a);
      ek(a);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
      }
      break;
    case 6:
      ck(b2, a);
      ek(a);
      if (d2 & 4) {
        if (null === a.stateNode)
          throw Error(p$2(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a);
      ek(a);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a, a.return, t2);
        }
      break;
    case 4:
      ck(b2, a);
      ek(a);
      break;
    case 13:
      ck(b2, a);
      ek(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
      d2 & 4 && ak(a);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a), U = l2) : ck(b2, a);
      ek(a);
      if (d2 & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
          for (V = a, m2 = a.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W(a, a.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a, a.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      ck(b2, a);
      ek(a);
      d2 & 4 && ak(a);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a
      ), ek(a);
  }
}
__name(dk, "dk");
function ek(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a.return; null !== c2; ) {
          if (Tj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$2(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Uj(a);
          Wj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Uj(a);
          Vj(a, h2, g2);
          break;
        default:
          throw Error(p$2(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
__name(ek, "ek");
function hk(a, b2, c2) {
  V = a;
  ik(a);
}
__name(hk, "hk");
function ik(a, b2, c2) {
  for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Jj;
        var l2 = U;
        Jj = g2;
        if ((U = k2) && !l2)
          for (V = e2; null !== V; )
            g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
        for (; null !== f2; )
          V = f2, ik(f2), f2 = f2.sibling;
        V = e2;
        Jj = h2;
        U = l2;
      }
      kk(a);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a);
  }
}
__name(ik, "ik");
function kk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && sh(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                sh(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$2(163));
          }
        U || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
__name(kk, "kk");
function gk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
__name(gk, "gk");
function jk(a) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
__name(jk, "jk");
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
__name(R, "R");
function yi(a) {
  if (0 === (a.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Bk && (Bk = yc()), Bk;
  a = C;
  if (0 !== a)
    return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
__name(yi, "yi");
function gi(a, b2, c2, d2) {
  if (50 < yk)
    throw yk = 0, zk = null, Error(p$2(185));
  Ac(a, c2, d2);
  if (0 === (K & 2) || a !== Q)
    a === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a, Z)), Dk(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
__name(gi, "gi");
function Dk(a, b2) {
  var c2 = a.callbackNode;
  wc(a, b2);
  var d2 = uc(a, a === Q ? Z : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c2;
  }
}
__name(Dk, "Dk");
function Gk(a, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6))
    throw Error(p$2(327));
  var c2 = a.callbackNode;
  if (Hk() && a.callbackNode !== c2)
    return null;
  var d2 = uc(a, a === Q ? Z : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2)
    b2 = Ik(a, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a || Z !== b2)
      uk = null, Gj = B() + 500, Kk(a, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Nk(a, e2)));
    if (1 === b2)
      throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
    if (6 === b2)
      Ck(a, d2);
    else {
      e2 = a.current.alternate;
      if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Nk(a, f2))), 1 === b2))
        throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
      a.finishedWork = e2;
      a.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$2(345));
        case 2:
          Pk(a, tk, uk);
          break;
        case 3:
          Ck(a, d2);
          if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a, 0))
              break;
            e2 = a.suspendedLanes;
            if ((e2 & d2) !== d2) {
              R();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 4:
          Ck(a, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
          if (10 < d2) {
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 5:
          Pk(a, tk, uk);
          break;
        default:
          throw Error(p$2(329));
      }
    }
  }
  Dk(a, B());
  return a.callbackNode === c2 ? Gk.bind(null, a) : null;
}
__name(Gk, "Gk");
function Nk(a, b2) {
  var c2 = sk;
  a.current.memoizedState.isDehydrated && (Kk(a, b2).flags |= 256);
  a = Ik(a, b2);
  2 !== a && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a;
}
__name(Nk, "Nk");
function Fj(a) {
  null === tk ? tk = a : tk.push.apply(tk, a);
}
__name(Fj, "Fj");
function Ok(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
__name(Ok, "Ok");
function Ck(a, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a[c2] = -1;
    b2 &= ~d2;
  }
}
__name(Ck, "Ck");
function Ek(a) {
  if (0 !== (K & 6))
    throw Error(p$2(327));
  Hk();
  var b2 = uc(a, 0);
  if (0 === (b2 & 1))
    return Dk(a, B()), null;
  var c2 = Ik(a, b2);
  if (0 !== a.tag && 2 === c2) {
    var d2 = xc(a);
    0 !== d2 && (b2 = d2, c2 = Nk(a, d2));
  }
  if (1 === c2)
    throw c2 = pk, Kk(a, 0), Ck(a, b2), Dk(a, B()), c2;
  if (6 === c2)
    throw Error(p$2(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Pk(a, tk, uk);
  Dk(a, B());
  return null;
}
__name(Ek, "Ek");
function Qk(a, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a(b2);
  } finally {
    K = c2, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
__name(Qk, "Qk");
function Rk(a) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b2 = K;
  K |= 1;
  var c2 = ok.transition, d2 = C;
  try {
    if (ok.transition = null, C = 1, a)
      return a();
  } finally {
    C = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
__name(Rk, "Rk");
function Hj() {
  fj = ej.current;
  E(ej);
}
__name(Hj, "Hj");
function Kk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c2 = a.timeoutHandle;
  -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d2);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d2.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c2 = c2.return;
    }
  Q = a;
  Y = a = Pg(a.current, null);
  Z = fj = b2;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++)
      if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    fh = null;
  }
  return a;
}
__name(Kk, "Kk");
function Mk(a, b2) {
  do {
    var c2 = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = M.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N = M = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        pk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Si(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$2(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Ni(f2, k2, b2);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h2, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
__name(Mk, "Mk");
function Jk() {
  var a = mk.current;
  mk.current = Rh;
  return null === a ? Rh : a;
}
__name(Jk, "Jk");
function tj() {
  if (0 === T || 3 === T || 2 === T)
    T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
__name(tj, "tj");
function Ik(a, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Jk();
  if (Q !== a || Z !== b2)
    uk = null, Kk(a, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a, e2);
    }
  while (1);
  $g();
  K = c2;
  mk.current = d2;
  if (null !== Y)
    throw Error(p$2(261));
  Q = null;
  Z = 0;
  return T;
}
__name(Ik, "Ik");
function Tk() {
  for (; null !== Y; )
    Uk(Y);
}
__name(Tk, "Tk");
function Lk() {
  for (; null !== Y && !cc(); )
    Uk(Y);
}
__name(Lk, "Lk");
function Uk(a) {
  var b2 = Vk(a.alternate, a, fj);
  a.memoizedProps = a.pendingProps;
  null === b2 ? Sk(a) : Y = b2;
  nk.current = null;
}
__name(Uk, "Uk");
function Sk(a) {
  var b2 = a;
  do {
    var c2 = b2.alternate;
    a = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a)
        a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a;
  } while (null !== b2);
  0 === T && (T = 5);
}
__name(Sk, "Sk");
function Pk(a, b2, c2) {
  var d2 = C, e2 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a, b2, c2, d2);
  } finally {
    ok.transition = e2, C = d2;
  }
  return null;
}
__name(Pk, "Pk");
function Wk(a, b2, c2, d2) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6))
    throw Error(p$2(327));
  c2 = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c2)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c2 === a.current)
    throw Error(p$2(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a, f2);
  a === Q && (Y = Q = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    nk.current = null;
    Oj(a, c2);
    dk(c2, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c2;
    hk(c2);
    dc();
    K = h2;
    C = g2;
    ok.transition = f2;
  } else
    a.current = c2;
  vk && (vk = false, wk = a, xk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c2.stateNode);
  Dk(a, B());
  if (null !== b2)
    for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi)
    throw Oi = false, a = Pi, Pi = null, a;
  0 !== (xk & 1) && 0 !== a.tag && Hk();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
  jg();
  return null;
}
__name(Wk, "Wk");
function Hk() {
  if (null !== wk) {
    var a = Dc(xk), b2 = ok.transition, c2 = C;
    try {
      ok.transition = null;
      C = 16 > a ? 16 : a;
      if (null === wk)
        var d2 = false;
      else {
        a = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6))
          throw Error(p$2(331));
        var e2 = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Sj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V = g2;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V = x2;
                  break b;
                }
                V = f2.return;
              }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V = u2;
          else
            b:
              for (g2 = w2; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h2);
                    }
                  } catch (na) {
                    W(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V = F2;
                  break b;
                }
                V = h2.return;
              }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, ok.transition = b2;
    }
  }
  return false;
}
__name(Hk, "Hk");
function Xk(a, b2, c2) {
  b2 = Ji(c2, b2);
  b2 = Ni(a, b2, 1);
  a = nh(a, b2, 1);
  b2 = R();
  null !== a && (Ac(a, 1, b2), Dk(a, b2));
}
__name(Xk, "Xk");
function W(a, b2, c2) {
  if (3 === a.tag)
    Xk(a, a, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Xk(b2, a, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
          a = Ji(c2, a);
          a = Qi(b2, a, 1);
          b2 = nh(b2, a, 1);
          a = R();
          null !== b2 && (Ac(b2, 1, a), Dk(b2, a));
          break;
        }
      }
      b2 = b2.return;
    }
}
__name(W, "W");
function Ti(a, b2, c2) {
  var d2 = a.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = R();
  a.pingedLanes |= a.suspendedLanes & c2;
  Q === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c2);
  Dk(a, b2);
}
__name(Ti, "Ti");
function Yk(a, b2) {
  0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R();
  a = ih(a, b2);
  null !== a && (Ac(a, b2, c2), Dk(a, c2));
}
__name(Yk, "Yk");
function uj(a) {
  var b2 = a.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a, c2);
}
__name(uj, "uj");
function bk(a, b2) {
  var c2 = 0;
  switch (a.tag) {
    case 13:
      var d2 = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a.stateNode;
      break;
    default:
      throw Error(p$2(314));
  }
  null !== d2 && d2.delete(b2);
  Yk(a, c2);
}
__name(bk, "bk");
var Vk;
Vk = /* @__PURE__ */ __name(function(a, b2, c2) {
  if (null !== a)
    if (a.memoizedProps !== b2.pendingProps || Wf.current)
      dh = true;
    else {
      if (0 === (a.lanes & c2) && 0 === (b2.flags & 128))
        return dh = false, yj(a, b2, c2);
      dh = 0 !== (a.flags & 131072) ? true : false;
    }
  else
    dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      ij(a, b2);
      a = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d2, a, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        ij(a, b2);
        a = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Zk(d2);
        a = Ci(d2, a);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d2, a, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, Ci(d2.type, a), c2);
            break a;
        }
        throw Error(p$2(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a, b2, d2, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a)
          throw Error(p$2(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a, b2);
        qh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ji(Error(p$2(423)), b2);
            b2 = lj(a, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ji(Error(p$2(424)), b2);
            b2 = lj(a, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = Zi(a, b2, c2);
            break a;
          }
          Xi(a, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a, b2), Xi(a, b2, g2, c2), b2.child;
    case 6:
      return null === a && Eg(b2), null;
    case 13:
      return oj(a, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Ug(b2, null, d2, c2) : Xi(a, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a, b2, d2, e2, c2);
    case 7:
      return Xi(a, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Wg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = Zi(a, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = mh(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    bh(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$2(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                bh(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Xi(a, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a, b2, d2, e2, c2);
    case 15:
      return bj(a, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a, c2);
    case 19:
      return xj(a, b2, c2);
    case 22:
      return dj(a, b2, c2);
  }
  throw Error(p$2(156, b2.tag));
}, "Vk");
function Fk(a, b2) {
  return ac(a, b2);
}
__name(Fk, "Fk");
function $k(a, b2, c2, d2) {
  this.tag = a;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
__name($k, "$k");
function Bg(a, b2, c2, d2) {
  return new $k(a, b2, c2, d2);
}
__name(Bg, "Bg");
function aj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
__name(aj, "aj");
function Zk(a) {
  if ("function" === typeof a)
    return aj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da)
      return 11;
    if (a === Ga)
      return 14;
  }
  return 2;
}
__name(Zk, "Zk");
function Pg(a, b2) {
  var c2 = a.alternate;
  null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a.flags & 14680064;
  c2.childLanes = a.childLanes;
  c2.lanes = a.lanes;
  c2.child = a.child;
  c2.memoizedProps = a.memoizedProps;
  c2.memoizedState = a.memoizedState;
  c2.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a.sibling;
  c2.index = a.index;
  c2.ref = a.ref;
  return c2;
}
__name(Pg, "Pg");
function Rg(a, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a;
  if ("function" === typeof a)
    aj(a) && (g2 = 1);
  else if ("string" === typeof a)
    g2 = 5;
  else
    a:
      switch (a) {
        case ya:
          return Tg(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
        case Ea:
          return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
        case Fa:
          return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
        case Ia:
          return pj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$2(130, null == a ? a : typeof a, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
__name(Rg, "Rg");
function Tg(a, b2, c2, d2) {
  a = Bg(7, a, d2, b2);
  a.lanes = c2;
  return a;
}
__name(Tg, "Tg");
function pj(a, b2, c2, d2) {
  a = Bg(22, a, d2, b2);
  a.elementType = Ia;
  a.lanes = c2;
  a.stateNode = { isHidden: false };
  return a;
}
__name(pj, "pj");
function Qg(a, b2, c2) {
  a = Bg(6, a, null, b2);
  a.lanes = c2;
  return a;
}
__name(Qg, "Qg");
function Sg(a, b2, c2) {
  b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
__name(Sg, "Sg");
function al(a, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
__name(al, "al");
function bl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = new al(a, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a;
}
__name(bl, "bl");
function cl(a, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
}
__name(cl, "cl");
function dl(a) {
  if (!a)
    return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag)
      throw Error(p$2(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$2(171));
  }
  if (1 === a.tag) {
    var c2 = a.type;
    if (Zf(c2))
      return bg(a, c2, b2);
  }
  return b2;
}
__name(dl, "dl");
function el(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = bl(c2, d2, true, a, e2, f2, g2, h2, k2);
  a.context = dl(null);
  c2 = a.current;
  d2 = R();
  e2 = yi(c2);
  f2 = mh(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d2);
  Dk(a, d2);
  return a;
}
__name(el, "el");
function fl(a, b2, c2, d2) {
  var e2 = b2.current, f2 = R(), g2 = yi(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f2, g2);
  b2.payload = { element: a };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a = nh(e2, b2, g2);
  null !== a && (gi(a, e2, g2, f2), oh(a, e2, g2));
  return g2;
}
__name(fl, "fl");
function gl(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
__name(gl, "gl");
function hl(a, b2) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c2 = a.retryLane;
    a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
__name(hl, "hl");
function il(a, b2) {
  hl(a, b2);
  (a = a.alternate) && hl(a, b2);
}
__name(il, "il");
function jl() {
  return null;
}
__name(jl, "jl");
var kl = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ll(a) {
  this._internalRoot = a;
}
__name(ll, "ll");
ml.prototype.render = ll.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$2(409));
  fl(a, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Rk(function() {
      fl(null, a, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a) {
  this._internalRoot = a;
}
__name(ml, "ml");
ml.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Hc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a);
    0 === c2 && Vc(a);
  }
};
function nl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
__name(nl, "nl");
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
__name(ol, "ol");
function pl() {
}
__name(pl, "pl");
function ql(a, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = /* @__PURE__ */ __name(function() {
        var a2 = gl(g2);
        f2.call(a2);
      }, "d");
    }
    var g2 = el(b2, d2, a, 0, null, false, false, "", pl);
    a._reactRootContainer = g2;
    a[uf] = g2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk();
    return g2;
  }
  for (; e2 = a.lastChild; )
    a.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = /* @__PURE__ */ __name(function() {
      var a2 = gl(k2);
      h2.call(a2);
    }, "d");
  }
  var k2 = bl(a, 0, false, null, null, false, false, "", pl);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Rk(function() {
    fl(b2, k2, c2, d2);
  });
  return k2;
}
__name(ql, "ql");
function rl(a, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = /* @__PURE__ */ __name(function() {
        var a2 = gl(g2);
        h2.call(a2);
      }, "e");
    }
    fl(b2, g2, a, e2);
  } else
    g2 = ql(c2, b2, a, e2, d2);
  return gl(g2);
}
__name(rl, "rl");
Ec = /* @__PURE__ */ __name(function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a, 1);
        if (null !== b3) {
          var c3 = R();
          gi(b3, a, 1, c3);
        }
      }), il(a, 1);
  }
}, "Ec");
Fc = /* @__PURE__ */ __name(function(a) {
  if (13 === a.tag) {
    var b2 = ih(a, 134217728);
    if (null !== b2) {
      var c2 = R();
      gi(b2, a, 134217728, c2);
    }
    il(a, 134217728);
  }
}, "Fc");
Gc = /* @__PURE__ */ __name(function(a) {
  if (13 === a.tag) {
    var b2 = yi(a), c2 = ih(a, b2);
    if (null !== c2) {
      var d2 = R();
      gi(c2, a, b2, d2);
    }
    il(a, b2);
  }
}, "Gc");
Hc = /* @__PURE__ */ __name(function() {
  return C;
}, "Hc");
Ic = /* @__PURE__ */ __name(function(a, b2) {
  var c2 = C;
  try {
    return C = a, b2();
  } finally {
    C = c2;
  }
}, "Ic");
yb = /* @__PURE__ */ __name(function(a, b2, c2) {
  switch (b2) {
    case "input":
      bb(a, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$2(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
  }
}, "yb");
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber)
    try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2))
    throw Error(p$2(200));
  return cl(a, b2, null, c2);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!nl(a))
    throw Error(p$2(299));
  var c2 = false, d2 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a, 1, false, null, null, c2, false, d2, e2);
  a[uf] = b2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b2 = a._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a.render)
      throw Error(p$2(188));
    a = Object.keys(a).join(",");
    throw Error(p$2(268, a));
  }
  a = Zb(b2);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Rk(a);
};
reactDom_production_min.hydrate = function(a, b2, c2) {
  if (!ol(b2))
    throw Error(p$2(200));
  return rl(null, a, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a, b2, c2) {
  if (!nl(a))
    throw Error(p$2(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a[uf] = b2.current;
  sf(a);
  if (d2)
    for (a = 0; a < d2.length; a++)
      c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new ml(b2);
};
reactDom_production_min.render = function(a, b2, c2) {
  if (!ol(b2))
    throw Error(p$2(200));
  return rl(null, a, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!ol(a))
    throw Error(p$2(40));
  return a._reactRootContainer ? (Rk(function() {
    rl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
  if (!ol(c2))
    throw Error(p$2(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(p$2(38));
  return rl(a, b2, c2, false, d2);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
__name(checkDCE, "checkDCE");
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
const ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ReactDOM
}, [reactDomExports]);
/**
 * @remix-run/router v1.16.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
__name(_extends$7, "_extends$7");
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  __name(createBrowserLocation, "createBrowserLocation");
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  __name(createBrowserHref, "createBrowserHref");
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
__name(createBrowserHistory, "createBrowserHistory");
function invariant$1(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
__name(invariant$1, "invariant$1");
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
__name(warning, "warning");
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
__name(createKey, "createKey");
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
__name(getHistoryState, "getHistoryState");
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$7({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
__name(createLocation, "createLocation");
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
__name(createPath, "createPath");
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
__name(parsePath, "parsePath");
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$7({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  __name(getIndex, "getIndex");
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  __name(handlePop, "handlePop");
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  __name(push, "push");
  function replace2(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  __name(replace2, "replace");
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    href = href.replace(/ $/, "%20");
    invariant$1(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  __name(createURL, "createURL");
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
__name(getUrlBasedHistory, "getUrlBasedHistory");
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
const immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(route) {
  return route.index === true;
}
__name(isIndexRoute, "isIndexRoute");
function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index2) => {
    let treePath = [...parentPath, index2];
    let id2 = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant$1(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant$1(!manifest[id2], 'Found a route id collision on id "' + id2 + `".  Route id's must be globally unique within Data Router usages`);
    if (isIndexRoute(route)) {
      let indexRoute = _extends$7({}, route, mapRouteProperties2(route), {
        id: id2
      });
      manifest[id2] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends$7({}, route, mapRouteProperties2(route), {
        id: id2,
        children: void 0
      });
      manifest[id2] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
__name(convertRoutesToDataRoutes, "convertRoutesToDataRoutes");
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i], decoded);
  }
  return matches;
}
__name(matchRoutes, "matchRoutes");
function convertRouteMatchToUiMatch(match2, loaderData) {
  let {
    route,
    pathname,
    params
  } = match2;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
__name(convertRouteMatchToUiMatch, "convertRouteMatchToUiMatch");
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = /* @__PURE__ */ __name((route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant$1(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant$1(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  }, "flattenRoute");
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
__name(flattenRoutes, "flattenRoutes");
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
__name(explodeOptionalSegments, "explodeOptionalSegments");
function rankRouteBranches(branches) {
  branches.sort((a, b2) => a.score !== b2.score ? b2.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
__name(rankRouteBranches, "rankRouteBranches");
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = /* @__PURE__ */ __name((s) => s === "*", "isSplat");
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
__name(computeScore, "computeScore");
function compareIndexes(a, b2) {
  let siblings = a.length === b2.length && a.slice(0, -1).every((n2, i) => n2 === b2[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
__name(compareIndexes, "compareIndexes");
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end2 = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
__name(matchRouteBranch, "matchRouteBranch");
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = compiledParams.reduce((memo2, _ref, index2) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index2];
    if (isOptional && !value) {
      memo2[paramName] = void 0;
    } else {
      memo2[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
__name(matchPath, "matchPath");
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
__name(compilePath, "compilePath");
function decodePath(value) {
  try {
    return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
__name(decodePath, "decodePath");
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
__name(stripBasename, "stripBasename");
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
__name(resolvePath, "resolvePath");
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
__name(resolvePathname, "resolvePathname");
function getInvalidPathError(char2, field, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
__name(getInvalidPathError, "getInvalidPathError");
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
}
__name(getPathContributingMatches, "getPathContributingMatches");
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match2, idx) => idx === matches.length - 1 ? match2.pathname : match2.pathnameBase);
  }
  return pathMatches.map((match2) => match2.pathnameBase);
}
__name(getResolveToMatches, "getResolveToMatches");
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$7({}, toArg);
    invariant$1(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant$1(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant$1(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
__name(resolveTo, "resolveTo");
const joinPaths = /* @__PURE__ */ __name((paths) => paths.join("/").replace(/\/\/+/g, "/"), "joinPaths");
const normalizePathname = /* @__PURE__ */ __name((pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/"), "normalizePathname");
const normalizeSearch = /* @__PURE__ */ __name((search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search, "normalizeSearch");
const normalizeHash = /* @__PURE__ */ __name((hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2, "normalizeHash");
const _ErrorResponseImpl = class _ErrorResponseImpl {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
};
__name(_ErrorResponseImpl, "ErrorResponseImpl");
let ErrorResponseImpl = _ErrorResponseImpl;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
__name(isRouteErrorResponse, "isRouteErrorResponse");
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
const IDLE_FETCHER = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
};
const ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const defaultMapRouteProperties = /* @__PURE__ */ __name((route) => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
}), "defaultMapRouteProperties");
const TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
function createRouter(init2) {
  const routerWindow = init2.window ? init2.window : typeof window !== "undefined" ? window : void 0;
  const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  const isServer2 = !isBrowser2;
  invariant$1(init2.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties2;
  if (init2.mapRouteProperties) {
    mapRouteProperties2 = init2.mapRouteProperties;
  } else if (init2.detectErrorBoundary) {
    let detectErrorBoundary = init2.detectErrorBoundary;
    mapRouteProperties2 = /* @__PURE__ */ __name((route) => ({
      hasErrorBoundary: detectErrorBoundary(route)
    }), "mapRouteProperties");
  } else {
    mapRouteProperties2 = defaultMapRouteProperties;
  }
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(init2.routes, mapRouteProperties2, void 0, manifest);
  let inFlightDataRoutes;
  let basename = init2.basename || "/";
  let dataStrategyImpl = init2.unstable_dataStrategy || defaultDataStrategy;
  let future = _extends$7({
    v7_fetcherPersist: false,
    v7_normalizeFormMethod: false,
    v7_partialHydration: false,
    v7_prependBasename: false,
    v7_relativeSplatPath: false,
    unstable_skipActionErrorRevalidation: false
  }, init2.future);
  let unlistenHistory = null;
  let subscribers = /* @__PURE__ */ new Set();
  let savedScrollPositions = null;
  let getScrollRestorationKey = null;
  let getScrollPosition = null;
  let initialScrollRestored = init2.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init2.history.location, basename);
  let initialErrors = null;
  if (initialMatches == null) {
    let error = getInternalRouterError(404, {
      pathname: init2.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized;
  let hasLazyRoutes = initialMatches.some((m2) => m2.route.lazy);
  let hasLoaders = initialMatches.some((m2) => m2.route.loader);
  if (hasLazyRoutes) {
    initialized = false;
  } else if (!hasLoaders) {
    initialized = true;
  } else if (future.v7_partialHydration) {
    let loaderData = init2.hydrationData ? init2.hydrationData.loaderData : null;
    let errors = init2.hydrationData ? init2.hydrationData.errors : null;
    let isRouteInitialized = /* @__PURE__ */ __name((m2) => {
      if (!m2.route.loader) {
        return true;
      }
      if (typeof m2.route.loader === "function" && m2.route.loader.hydrate === true) {
        return false;
      }
      return loaderData && loaderData[m2.route.id] !== void 0 || errors && errors[m2.route.id] !== void 0;
    }, "isRouteInitialized");
    if (errors) {
      let idx = initialMatches.findIndex((m2) => errors[m2.route.id] !== void 0);
      initialized = initialMatches.slice(0, idx + 1).every(isRouteInitialized);
    } else {
      initialized = initialMatches.every(isRouteInitialized);
    }
  } else {
    initialized = init2.hydrationData != null;
  }
  let router2;
  let state = {
    historyAction: init2.history.action,
    location: init2.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init2.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init2.hydrationData && init2.hydrationData.loaderData || {},
    actionData: init2.hydrationData && init2.hydrationData.actionData || null,
    errors: init2.hydrationData && init2.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  };
  let pendingAction = Action.Pop;
  let pendingPreventScrollReset = false;
  let pendingNavigationController;
  let pendingViewTransitionEnabled = false;
  let appliedViewTransitions = /* @__PURE__ */ new Map();
  let removePageHideEventListener = null;
  let isUninterruptedRevalidation = false;
  let isRevalidationRequired = false;
  let cancelledDeferredRoutes = [];
  let cancelledFetcherLoads = [];
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let pendingNavigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let fetchRedirectIds = /* @__PURE__ */ new Set();
  let fetchLoadMatches = /* @__PURE__ */ new Map();
  let activeFetchers = /* @__PURE__ */ new Map();
  let deletedFetchers = /* @__PURE__ */ new Set();
  let activeDeferreds = /* @__PURE__ */ new Map();
  let blockerFunctions = /* @__PURE__ */ new Map();
  let ignoreNextHistoryUpdate = false;
  function initialize() {
    unlistenHistory = init2.history.listen((_ref) => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        ignoreNextHistoryUpdate = true;
        init2.history.go(delta * -1);
        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location
            });
            init2.history.go(delta);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    });
    if (isBrowser2) {
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = /* @__PURE__ */ __name(() => persistAppliedTransitions(routerWindow, appliedViewTransitions), "_saveAppliedTransitions");
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
      removePageHideEventListener = /* @__PURE__ */ __name(() => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions), "removePageHideEventListener");
    }
    if (!state.initialized) {
      startNavigation(Action.Pop, state.location, {
        initialHydration: true
      });
    }
    return router2;
  }
  __name(initialize, "initialize");
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    if (removePageHideEventListener) {
      removePageHideEventListener();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_2, key) => deleteFetcher(key));
    state.blockers.forEach((_2, key) => deleteBlocker(key));
  }
  __name(dispose, "dispose");
  function subscribe2(fn2) {
    subscribers.add(fn2);
    return () => subscribers.delete(fn2);
  }
  __name(subscribe2, "subscribe");
  function updateState(newState, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state = _extends$7({}, state, newState);
    let completedFetchers = [];
    let deletedFetchersKeys = [];
    if (future.v7_fetcherPersist) {
      state.fetchers.forEach((fetcher, key) => {
        if (fetcher.state === "idle") {
          if (deletedFetchers.has(key)) {
            deletedFetchersKeys.push(key);
          } else {
            completedFetchers.push(key);
          }
        }
      });
    }
    [...subscribers].forEach((subscriber) => subscriber(state, {
      deletedFetchers: deletedFetchersKeys,
      unstable_viewTransitionOpts: opts.viewTransitionOpts,
      unstable_flushSync: opts.flushSync === true
    }));
    if (future.v7_fetcherPersist) {
      completedFetchers.forEach((key) => state.fetchers.delete(key));
      deletedFetchersKeys.forEach((key) => deleteFetcher(key));
    }
  }
  __name(updateState, "updateState");
  function completeNavigation(location, newState, _temp) {
    var _location$state, _location$state2;
    let {
      flushSync
    } = _temp === void 0 ? {} : _temp;
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        actionData = null;
      }
    } else if (isActionReload) {
      actionData = state.actionData;
    } else {
      actionData = null;
    }
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_2, k2) => blockers.set(k2, IDLE_BLOCKER));
    }
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = void 0;
    }
    if (isUninterruptedRevalidation)
      ;
    else if (pendingAction === Action.Pop)
      ;
    else if (pendingAction === Action.Push) {
      init2.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init2.history.replace(location, location.state);
    }
    let viewTransitionOpts;
    if (pendingAction === Action.Pop) {
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      if (priorPaths && priorPaths.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      } else if (appliedViewTransitions.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: location,
          nextLocation: state.location
        };
      }
    } else if (pendingViewTransitionEnabled) {
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      if (toPaths) {
        toPaths.add(location.pathname);
      } else {
        toPaths = /* @__PURE__ */ new Set([location.pathname]);
        appliedViewTransitions.set(state.location.pathname, toPaths);
      }
      viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      };
    }
    updateState(_extends$7({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }), {
      viewTransitionOpts,
      flushSync: flushSync === true
    });
    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    pendingViewTransitionEnabled = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  }
  __name(completeNavigation, "completeNavigation");
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init2.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    nextLocation = _extends$7({}, nextLocation, init2.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : void 0;
    let historyAction = Action.Push;
    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false)
      ;
    else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      historyAction = Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
    let flushSync = (opts && opts.unstable_flushSync) === true;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: nextLocation
          });
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({
            blockers
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.unstable_viewTransition,
      flushSync
    });
  }
  __name(navigate, "navigate");
  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });
    if (state.navigation.state === "submitting") {
      return;
    }
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    }
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  }
  __name(revalidate, "revalidate");
  async function startNavigation(historyAction, location, opts) {
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(routesToUse, location, basename);
    let flushSync = (opts && opts.flushSync) === true;
    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(routesToUse);
      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      }, {
        flushSync
      });
      return;
    }
    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      }, {
        flushSync
      });
      return;
    }
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init2.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionResult;
    if (opts && opts.pendingError) {
      pendingActionResult = [findNearestBoundary(matches).route.id, {
        type: ResultType.error,
        error: opts.pendingError
      }];
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionResult = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace,
        flushSync
      });
      if (actionResult.shortCircuited) {
        return;
      }
      pendingActionResult = actionResult.pendingActionResult;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      flushSync = false;
      request = createClientSideRequest(init2.history, request.url, request.signal);
    }
    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);
    if (shortCircuited) {
      return;
    }
    pendingNavigationController = null;
    completeNavigation(location, _extends$7({
      matches
    }, getActionDataForCommit(pendingActionResult), {
      loaderData,
      errors
    }));
  }
  __name(startNavigation, "startNavigation");
  async function handleAction(request, location, submission, matches, opts) {
    if (opts === void 0) {
      opts = {};
    }
    interruptActiveLoads();
    let navigation = getSubmittingNavigation(location, submission);
    updateState({
      navigation
    }, {
      flushSync: opts.flushSync === true
    });
    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      let results = await callDataStrategy("action", request, [actionMatch], matches);
      result = results[0];
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace2;
      if (opts && opts.replace != null) {
        replace2 = opts.replace;
      } else {
        let location2 = normalizeRedirectLocation(result.response.headers.get("Location"), new URL(request.url), basename);
        replace2 = location2 === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(request, result, {
        submission,
        replace: replace2
      });
      return {
        shortCircuited: true
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        pendingActionResult: [boundaryMatch.route.id, result]
      };
    }
    return {
      pendingActionResult: [actionMatch.route.id, result]
    };
  }
  __name(handleAction, "handleAction");
  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init2.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, future.unstable_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);
    cancelActiveDeferreds((routeId) => !(matches && matches.some((m2) => m2.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m2) => m2.route.id === routeId));
    pendingNavigationLoadId = ++incrementingLoadId;
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers2 = markFetchRedirectsDone();
      completeNavigation(location, _extends$7({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null
      }, getActionDataForCommit(pendingActionResult), updatedFetchers2 ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      });
      return {
        shortCircuited: true
      };
    }
    if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {
      revalidatingFetchers.forEach((rf2) => {
        let fetcher = state.fetchers.get(rf2.key);
        let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
        state.fetchers.set(rf2.key, revalidatingFetcher);
      });
      let actionData;
      if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
        actionData = {
          [pendingActionResult[0]]: pendingActionResult[1].data
        };
      } else if (state.actionData) {
        if (Object.keys(state.actionData).length === 0) {
          actionData = null;
        } else {
          actionData = state.actionData;
        }
      }
      updateState(_extends$7({
        navigation: loadingNavigation
      }, actionData !== void 0 ? {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      });
    }
    revalidatingFetchers.forEach((rf2) => {
      if (fetchControllers.has(rf2.key)) {
        abortFetcher(rf2.key);
      }
      if (rf2.controller) {
        fetchControllers.set(rf2.key, rf2.controller);
      }
    });
    let abortPendingFetchRevalidations = /* @__PURE__ */ __name(() => revalidatingFetchers.forEach((f2) => abortFetcher(f2.key)), "abortPendingFetchRevalidations");
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    }
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    }
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    }
    revalidatingFetchers.forEach((rf2) => fetchControllers.delete(rf2.key));
    let redirect = findRedirect([...loaderResults, ...fetcherResults]);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      await startRedirectNavigation(request, redirect.result, {
        replace: replace2
      });
      return {
        shortCircuited: true
      };
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe((aborted) => {
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    if (future.v7_partialHydration && initialHydration && state.errors) {
      Object.entries(state.errors).filter((_ref2) => {
        let [id2] = _ref2;
        return !matchesToLoad.some((m2) => m2.route.id === id2);
      }).forEach((_ref3) => {
        let [routeId, error] = _ref3;
        errors = Object.assign(errors || {}, {
          [routeId]: error
        });
      });
    }
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return _extends$7({
      loaderData,
      errors
    }, shouldUpdateFetchers ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  __name(handleLoaders, "handleLoaders");
  function fetch2(key, routeId, href, opts) {
    if (isServer2) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key))
      abortFetcher(key);
    let flushSync = (opts && opts.unstable_flushSync) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }), {
        flushSync
      });
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
    if (error) {
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    let match2 = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match2, matches, flushSync, submission);
      return;
    }
    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match2, matches, flushSync, submission);
  }
  __name(fetch2, "fetch");
  async function handleFetcherAction(key, routeId, path, match2, requestMatches, flushSync, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match2.route.action && !match2.route.lazy) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId
      });
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init2.history, path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResults = await callDataStrategy("action", fetchRequest, [match2], requestMatches);
    let actionResult = actionResults[0];
    if (fetchRequest.signal.aborted) {
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
    } else {
      if (isRedirectResult(actionResult)) {
        fetchControllers.delete(key);
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key);
          updateFetcherState(key, getLoadingFetcher(submission));
          return startRedirectNavigation(fetchRequest, actionResult, {
            fetcherSubmission: submission
          });
        }
      }
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init2.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant$1(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init2.history, state, matches, submission, nextLocation, false, future.unstable_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match2.route.id, actionResult]);
    revalidatingFetchers.filter((rf2) => rf2.key !== key).forEach((rf2) => {
      let staleKey = rf2.key;
      let existingFetcher2 = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
      state.fetchers.set(staleKey, revalidatingFetcher);
      if (fetchControllers.has(staleKey)) {
        abortFetcher(staleKey);
      }
      if (rf2.controller) {
        fetchControllers.set(staleKey, rf2.controller);
      }
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = /* @__PURE__ */ __name(() => revalidatingFetchers.forEach((rf2) => abortFetcher(rf2.key)), "abortPendingFetchRevalidations");
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
    let redirect = findRedirect([...loaderResults, ...fetcherResults]);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      return startRedirectNavigation(revalidationRequest, redirect.result);
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId);
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant$1(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      updateState({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),
        fetchers: new Map(state.fetchers)
      });
      isRevalidationRequired = false;
    }
  }
  __name(handleFetcherAction, "handleFetcherAction");
  async function handleFetcherLoader(key, routeId, path, match2, matches, flushSync, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {
      flushSync
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init2.history, path, abortController.signal);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let results = await callDataStrategy("loader", fetchRequest, [match2], matches);
    let result = results[0];
    if (isDeferredResult(result)) {
      result = await resolveDeferredData(result, fetchRequest.signal, true) || result;
    }
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    if (deletedFetchers.has(key)) {
      updateFetcherState(key, getDoneFetcher(void 0));
      return;
    }
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(fetchRequest, result);
        return;
      }
    }
    if (isErrorResult(result)) {
      setFetcherError(key, routeId, result.error);
      return;
    }
    invariant$1(!isDeferredResult(result), "Unhandled fetcher deferred data");
    updateFetcherState(key, getDoneFetcher(result.data));
  }
  __name(handleFetcherLoader, "handleFetcherLoader");
  async function startRedirectNavigation(request, redirect, _temp2) {
    let {
      submission,
      fetcherSubmission,
      replace: replace2
    } = _temp2 === void 0 ? {} : _temp2;
    if (redirect.response.headers.has("X-Remix-Revalidate")) {
      isRevalidationRequired = true;
    }
    let location = redirect.response.headers.get("Location");
    invariant$1(location, "Expected a Location header on the redirect Response");
    location = normalizeRedirectLocation(location, new URL(request.url), basename);
    let redirectLocation = createLocation(state.location, location, {
      _isRedirect: true
    });
    if (isBrowser2) {
      let isDocumentReload = false;
      if (redirect.response.headers.has("X-Remix-Reload-Document")) {
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX$1.test(location)) {
        const url = init2.history.createURL(location);
        isDocumentReload = // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace2) {
          routerWindow.location.replace(location);
        } else {
          routerWindow.location.assign(location);
        }
        return;
      }
    }
    pendingNavigationController = null;
    let redirectHistoryAction = replace2 === true ? Action.Replace : Action.Push;
    let {
      formMethod,
      formAction,
      formEncType
    } = state.navigation;
    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
      submission = getSubmissionFromNavigation(state.navigation);
    }
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends$7({}, activeSubmission, {
          formAction: location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }
  __name(startRedirectNavigation, "startRedirectNavigation");
  async function callDataStrategy(type, request, matchesToLoad, matches) {
    try {
      let results = await callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches, manifest, mapRouteProperties2);
      return await Promise.all(results.map((result, i) => {
        if (isRedirectHandlerResult(result)) {
          let response = result.result;
          return {
            type: ResultType.redirect,
            response: normalizeRelativeRoutingRedirectResponse(response, request, matchesToLoad[i].route.id, matches, basename, future.v7_relativeSplatPath)
          };
        }
        return convertHandlerResultToDataResult(result);
      }));
    } catch (e2) {
      return matchesToLoad.map(() => ({
        type: ResultType.error,
        error: e2
      }));
    }
  }
  __name(callDataStrategy, "callDataStrategy");
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    let [loaderResults, ...fetcherResults] = await Promise.all([matchesToLoad.length ? callDataStrategy("loader", request, matchesToLoad, matches) : [], ...fetchersToLoad.map((f2) => {
      if (f2.matches && f2.match && f2.controller) {
        let fetcherRequest = createClientSideRequest(init2.history, f2.path, f2.controller.signal);
        return callDataStrategy("loader", fetcherRequest, [f2.match], f2.matches).then((r2) => r2[0]);
      } else {
        return Promise.resolve({
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f2.path
          })
        });
      }
    })]);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f2) => f2.match), fetcherResults, fetchersToLoad.map((f2) => f2.controller ? f2.controller.signal : null), true)]);
    return {
      loaderResults,
      fetcherResults
    };
  }
  __name(callLoadersAndMaybeResolveData, "callLoadersAndMaybeResolveData");
  function interruptActiveLoads() {
    isRevalidationRequired = true;
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());
    fetchLoadMatches.forEach((_2, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  __name(interruptActiveLoads, "interruptActiveLoads");
  function updateFetcherState(key, fetcher, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  __name(updateFetcherState, "updateFetcherState");
  function setFetcherError(key, routeId, error, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  __name(setFetcherError, "setFetcherError");
  function getFetcher(key) {
    if (future.v7_fetcherPersist) {
      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
      if (deletedFetchers.has(key)) {
        deletedFetchers.delete(key);
      }
    }
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  __name(getFetcher, "getFetcher");
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    deletedFetchers.delete(key);
    state.fetchers.delete(key);
  }
  __name(deleteFetcher, "deleteFetcher");
  function deleteFetcherAndUpdateState(key) {
    if (future.v7_fetcherPersist) {
      let count = (activeFetchers.get(key) || 0) - 1;
      if (count <= 0) {
        activeFetchers.delete(key);
        deletedFetchers.add(key);
      } else {
        activeFetchers.set(key, count);
      }
    } else {
      deleteFetcher(key);
    }
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  __name(deleteFetcherAndUpdateState, "deleteFetcherAndUpdateState");
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant$1(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  __name(abortFetcher, "abortFetcher");
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  __name(markFetchersDone, "markFetchersDone");
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant$1(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  __name(markFetchRedirectsDone, "markFetchRedirectsDone");
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id2] of fetchReloadIds) {
      if (id2 < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant$1(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  __name(abortStaleFetchLoads, "abortStaleFetchLoads");
  function getBlocker(key, fn2) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn2) {
      blockerFunctions.set(key, fn2);
    }
    return blocker;
  }
  __name(getBlocker, "getBlocker");
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  __name(deleteBlocker, "deleteBlocker");
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    invariant$1(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({
      blockers
    });
  }
  __name(updateBlocker, "updateBlocker");
  function shouldBlockNavigation(_ref4) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref4;
    if (blockerFunctions.size === 0) {
      return;
    }
    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      return;
    }
    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  __name(shouldBlockNavigation, "shouldBlockNavigation");
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  }
  __name(cancelActiveDeferreds, "cancelActiveDeferreds");
  function enableScrollRestoration(positions, getPosition, getKey3) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey3 || null;
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y2 = getSavedScrollPosition(state.location, state.matches);
      if (y2 != null) {
        updateState({
          restoreScrollPosition: y2
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  __name(enableScrollRestoration, "enableScrollRestoration");
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey) {
      let key = getScrollRestorationKey(location, matches.map((m2) => convertRouteMatchToUiMatch(m2, state.loaderData)));
      return key || location.key;
    }
    return location.key;
  }
  __name(getScrollKey, "getScrollKey");
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollPosition) {
      let key = getScrollKey(location, matches);
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  __name(saveScrollPosition, "saveScrollPosition");
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions) {
      let key = getScrollKey(location, matches);
      let y2 = savedScrollPositions[key];
      if (typeof y2 === "number") {
        return y2;
      }
    }
    return null;
  }
  __name(getSavedScrollPosition, "getSavedScrollPosition");
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
  }
  __name(_internalSetRoutes, "_internalSetRoutes");
  router2 = {
    get basename() {
      return basename;
    },
    get future() {
      return future;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe: subscribe2,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (to) => init2.history.createHref(to),
    encodeLocation: (to) => init2.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: deleteFetcherAndUpdateState,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router2;
}
__name(createRouter, "createRouter");
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
}
__name(isSubmissionNavigation, "isSubmissionNavigation");
function normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId) {
    contextualMatches = [];
    for (let match2 of matches) {
      contextualMatches.push(match2);
      if (match2.route.id === fromRouteId) {
        activeRouteMatch = match2;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }
  let path = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
  if (to == null) {
    path.search = location.search;
    path.hash = location.hash;
  }
  if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (prependBasename && basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
__name(normalizeTo, "normalizeTo");
function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  }
  let getInvalidBodyError = /* @__PURE__ */ __name(() => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  }), "getInvalidBodyError");
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== void 0) {
    if (opts.formEncType === "text/plain") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(opts.body.entries()).reduce((acc, _ref5) => {
          let [name, value] = _ref5;
          return "" + acc + name + "=" + value + "\n";
        }, "")
      ) : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: void 0,
          json: void 0,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json,
            text: void 0
          }
        };
      } catch (e2) {
        return getInvalidBodyError();
      }
    }
  }
  invariant$1(typeof FormData === "function", "FormData is not available in this environment");
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e2) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: void 0,
    text: void 0
  };
  if (isMutationMethod(submission.formMethod)) {
    return {
      path,
      submission
    };
  }
  let parsedPath = parsePath(path);
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
}
__name(normalizeNavigateOptions, "normalizeNavigateOptions");
function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index2 = matches.findIndex((m2) => m2.route.id === boundaryId);
    if (index2 >= 0) {
      boundaryMatches = matches.slice(0, index2);
    }
  }
  return boundaryMatches;
}
__name(getLoaderMatchesUntilBoundary, "getLoaderMatchesUntilBoundary");
function getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  let boundaryId = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[0] : void 0;
  let boundaryMatches = boundaryId ? getLoaderMatchesUntilBoundary(matches, boundaryId) : matches;
  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
  let shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400;
  let navigationMatches = boundaryMatches.filter((match2, index2) => {
    let {
      route
    } = match2;
    if (route.lazy) {
      return true;
    }
    if (route.loader == null) {
      return false;
    }
    if (isInitialLoad) {
      if (typeof route.loader !== "function" || route.loader.hydrate) {
        return true;
      }
      return state.loaderData[route.id] === void 0 && // Don't re-run if the loader ran and threw an error
      (!state.errors || state.errors[route.id] === void 0);
    }
    if (isNewLoader(state.loaderData, state.matches[index2], match2) || cancelledDeferredRoutes.some((id2) => id2 === match2.route.id)) {
      return true;
    }
    let currentRouteMatch = state.matches[index2];
    let nextRouteMatch = match2;
    return shouldRevalidateLoader(match2, _extends$7({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      unstable_actionStatus: actionStatus,
      defaultShouldRevalidate: shouldSkipRevalidation ? false : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
      )
    }));
  });
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f2, key) => {
    if (isInitialLoad || !matches.some((m2) => m2.route.id === f2.routeId) || deletedFetchers.has(key)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f2.path, basename);
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f2.routeId,
        path: f2.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f2.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.includes(key)) {
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
      shouldRevalidate = isRevalidationRequired;
    } else {
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends$7({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params
      }, submission, {
        actionResult,
        unstable_actionStatus: actionStatus,
        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
      }));
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f2.routeId,
        path: f2.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
__name(getMatchesToLoad, "getMatchesToLoad");
function isNewLoader(currentLoaderData, currentMatch, match2) {
  let isNew = (
    // [a] -> [a, b]
    !currentMatch || // [a, b] -> [a, c]
    match2.route.id !== currentMatch.route.id
  );
  let isMissingData = currentLoaderData[match2.route.id] === void 0;
  return isNew || isMissingData;
}
__name(isNewLoader, "isNewLoader");
function isNewRouteInstance(currentMatch, match2) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match2.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match2.params["*"]
  );
}
__name(isNewRouteInstance, "isNewRouteInstance");
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
__name(shouldRevalidateLoader, "shouldRevalidateLoader");
async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant$1(routeToUpdate, "No route found in manifest");
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.'));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  Object.assign(routeToUpdate, routeUpdates);
  Object.assign(routeToUpdate, _extends$7({}, mapRouteProperties2(routeToUpdate), {
    lazy: void 0
  }));
}
__name(loadLazyRouteModule, "loadLazyRouteModule");
function defaultDataStrategy(opts) {
  return Promise.all(opts.matches.map((m2) => m2.resolve()));
}
__name(defaultDataStrategy, "defaultDataStrategy");
async function callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches, manifest, mapRouteProperties2, requestContext) {
  let routeIdsToLoad = matchesToLoad.reduce((acc, m2) => acc.add(m2.route.id), /* @__PURE__ */ new Set());
  let loadedMatches = /* @__PURE__ */ new Set();
  let results = await dataStrategyImpl({
    matches: matches.map((match2) => {
      let shouldLoad = routeIdsToLoad.has(match2.route.id);
      let resolve = /* @__PURE__ */ __name((handlerOverride) => {
        loadedMatches.add(match2.route.id);
        return shouldLoad ? callLoaderOrAction(type, request, match2, manifest, mapRouteProperties2, handlerOverride, requestContext) : Promise.resolve({
          type: ResultType.data,
          result: void 0
        });
      }, "resolve");
      return _extends$7({}, match2, {
        shouldLoad,
        resolve
      });
    }),
    request,
    params: matches[0].params,
    context: requestContext
  });
  matches.forEach((m2) => invariant$1(loadedMatches.has(m2.route.id), '`match.resolve()` was not called for route id "' + m2.route.id + '". You must call `match.resolve()` on every match passed to `dataStrategy` to ensure all routes are properly loaded.'));
  return results.filter((_2, i) => routeIdsToLoad.has(matches[i].route.id));
}
__name(callDataStrategyImpl, "callDataStrategyImpl");
async function callLoaderOrAction(type, request, match2, manifest, mapRouteProperties2, handlerOverride, staticContext) {
  let result;
  let onReject;
  let runHandler = /* @__PURE__ */ __name((handler) => {
    let reject;
    let abortPromise = new Promise((_2, r2) => reject = r2);
    onReject = /* @__PURE__ */ __name(() => reject(), "onReject");
    request.signal.addEventListener("abort", onReject);
    let actualHandler = /* @__PURE__ */ __name((ctx) => {
      if (typeof handler !== "function") {
        return Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + type + '" [routeId: ' + match2.route.id + "]")));
      }
      return handler({
        request,
        params: match2.params,
        context: staticContext
      }, ...ctx !== void 0 ? [ctx] : []);
    }, "actualHandler");
    let handlerPromise;
    if (handlerOverride) {
      handlerPromise = handlerOverride((ctx) => actualHandler(ctx));
    } else {
      handlerPromise = (async () => {
        try {
          let val = await actualHandler();
          return {
            type: "data",
            result: val
          };
        } catch (e2) {
          return {
            type: "error",
            result: e2
          };
        }
      })();
    }
    return Promise.race([handlerPromise, abortPromise]);
  }, "runHandler");
  try {
    let handler = match2.route[type];
    if (match2.route.lazy) {
      if (handler) {
        let handlerError;
        let [value] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          runHandler(handler).catch((e2) => {
            handlerError = e2;
          }),
          loadLazyRouteModule(match2.route, mapRouteProperties2, manifest)
        ]);
        if (handlerError !== void 0) {
          throw handlerError;
        }
        result = value;
      } else {
        await loadLazyRouteModule(match2.route, mapRouteProperties2, manifest);
        handler = match2.route[type];
        if (handler) {
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match2.route.id
          });
        } else {
          return {
            type: ResultType.data,
            result: void 0
          };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
    invariant$1(result.result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match2.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e2) {
    return {
      type: ResultType.error,
      result: e2
    };
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  return result;
}
__name(callLoaderOrAction, "callLoaderOrAction");
async function convertHandlerResultToDataResult(handlerResult) {
  let {
    result,
    type,
    status
  } = handlerResult;
  if (isResponse$1(result)) {
    let data;
    try {
      let contentType = result.headers.get("Content-Type");
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        if (result.body == null) {
          data = null;
        } else {
          data = await result.json();
        }
      } else {
        data = await result.text();
      }
    } catch (e2) {
      return {
        type: ResultType.error,
        error: e2
      };
    }
    if (type === ResultType.error) {
      return {
        type: ResultType.error,
        error: new ErrorResponseImpl(result.status, result.statusText, data),
        statusCode: result.status,
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (type === ResultType.error) {
    return {
      type: ResultType.error,
      error: result,
      statusCode: isRouteErrorResponse(result) ? result.status : status
    };
  }
  if (isDeferredData(result)) {
    var _result$init, _result$init2;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
    };
  }
  return {
    type: ResultType.data,
    data: result,
    statusCode: status
  };
}
__name(convertHandlerResultToDataResult, "convertHandlerResultToDataResult");
function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, v7_relativeSplatPath) {
  let location = response.headers.get("Location");
  invariant$1(location, "Redirects returned/thrown from loaders/actions must have a Location header");
  if (!ABSOLUTE_URL_REGEX$1.test(location)) {
    let trimmedMatches = matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1);
    location = normalizeTo(new URL(request.url), trimmedMatches, basename, true, location, v7_relativeSplatPath);
    response.headers.set("Location", location);
  }
  return response;
}
__name(normalizeRelativeRoutingRedirectResponse, "normalizeRelativeRoutingRedirectResponse");
function normalizeRedirectLocation(location, currentUrl, basename) {
  if (ABSOLUTE_URL_REGEX$1.test(location)) {
    let normalizedLocation = location;
    let url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
    let isSameBasename = stripBasename(url.pathname, basename) != null;
    if (url.origin === currentUrl.origin && isSameBasename) {
      return url.pathname + url.search + url.hash;
    }
  }
  return location;
}
__name(normalizeRedirectLocation, "normalizeRedirectLocation");
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init2 = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    init2.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init2.headers = new Headers({
        "Content-Type": formEncType
      });
      init2.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      init2.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      init2.body = convertFormDataToSearchParams(submission.formData);
    } else {
      init2.body = submission.formData;
    }
  }
  return new Request(url, init2);
}
__name(createClientSideRequest, "createClientSideRequest");
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
__name(convertFormDataToSearchParams, "convertFormDataToSearchParams");
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
__name(convertSearchParamsToFormData, "convertSearchParamsToFormData");
function processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
  results.forEach((result, index2) => {
    let id2 = matchesToLoad[index2].route.id;
    invariant$1(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      let error = result.error;
      if (pendingError !== void 0) {
        error = pendingError;
        pendingError = void 0;
      }
      errors = errors || {};
      {
        let boundaryMatch = findNearestBoundary(matches, id2);
        if (errors[boundaryMatch.route.id] == null) {
          errors[boundaryMatch.route.id] = error;
        }
      }
      loaderData[id2] = void 0;
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id2] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id2, result.deferredData);
        loaderData[id2] = result.deferredData.data;
        if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id2] = result.headers;
        }
      } else {
        loaderData[id2] = result.data;
        if (result.statusCode && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id2] = result.headers;
        }
      }
    }
  });
  if (pendingError !== void 0 && pendingActionResult) {
    errors = {
      [pendingActionResult[0]]: pendingError
    };
    loaderData[pendingActionResult[0]] = void 0;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
__name(processRouteLoaderData, "processRouteLoaderData");
function processLoaderData(state, matches, matchesToLoad, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds);
  for (let index2 = 0; index2 < revalidatingFetchers.length; index2++) {
    let {
      key,
      match: match2,
      controller
    } = revalidatingFetchers[index2];
    invariant$1(fetcherResults !== void 0 && fetcherResults[index2] !== void 0, "Did not find corresponding fetcher result");
    let result = fetcherResults[index2];
    if (controller && controller.signal.aborted) {
      continue;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match2 == null ? void 0 : match2.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends$7({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      invariant$1(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      invariant$1(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
__name(processLoaderData, "processLoaderData");
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends$7({}, newLoaderData);
  for (let match2 of matches) {
    let id2 = match2.route.id;
    if (newLoaderData.hasOwnProperty(id2)) {
      if (newLoaderData[id2] !== void 0) {
        mergedLoaderData[id2] = newLoaderData[id2];
      }
    } else if (loaderData[id2] !== void 0 && match2.route.loader) {
      mergedLoaderData[id2] = loaderData[id2];
    }
    if (errors && errors.hasOwnProperty(id2)) {
      break;
    }
  }
  return mergedLoaderData;
}
__name(mergeLoaderData, "mergeLoaderData");
function getActionDataForCommit(pendingActionResult) {
  if (!pendingActionResult) {
    return {};
  }
  return isErrorResult(pendingActionResult[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [pendingActionResult[0]]: pendingActionResult[1].data
    }
  };
}
__name(getActionDataForCommit, "getActionDataForCommit");
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find((m2) => m2.route.hasErrorBoundary === true) || matches[0];
}
__name(findNearestBoundary, "findNearestBoundary");
function getShortCircuitMatches(routes) {
  let route = routes.length === 1 ? routes[0] : routes.find((r2) => r2.index || !r2.path || r2.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
__name(getShortCircuitMatches, "getShortCircuitMatches");
function getInternalRouterError(status, _temp5) {
  let {
    pathname,
    routeId,
    method,
    type
  } = _temp5 === void 0 ? {} : _temp5;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"';
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = 'No route matches URL "' + pathname + '"';
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = 'Invalid request method "' + method.toUpperCase() + '"';
    }
  }
  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
}
__name(getInternalRouterError, "getInternalRouterError");
function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];
    if (isRedirectResult(result)) {
      return {
        result,
        idx: i
      };
    }
  }
}
__name(findRedirect, "findRedirect");
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends$7({}, parsedPath, {
    hash: ""
  }));
}
__name(stripHashFromPath, "stripHashFromPath");
function isHashChangeOnly(a, b2) {
  if (a.pathname !== b2.pathname || a.search !== b2.search) {
    return false;
  }
  if (a.hash === "") {
    return b2.hash !== "";
  } else if (a.hash === b2.hash) {
    return true;
  } else if (b2.hash !== "") {
    return true;
  }
  return false;
}
__name(isHashChangeOnly, "isHashChangeOnly");
function isRedirectHandlerResult(result) {
  return isResponse$1(result.result) && redirectStatusCodes.has(result.result.status);
}
__name(isRedirectHandlerResult, "isRedirectHandlerResult");
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
__name(isDeferredResult, "isDeferredResult");
function isErrorResult(result) {
  return result.type === ResultType.error;
}
__name(isErrorResult, "isErrorResult");
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
__name(isRedirectResult, "isRedirectResult");
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
}
__name(isDeferredData, "isDeferredData");
function isResponse$1(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
__name(isResponse$1, "isResponse$1");
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
__name(isValidMethod, "isValidMethod");
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
__name(isMutationMethod, "isMutationMethod");
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
  for (let index2 = 0; index2 < results.length; index2++) {
    let result = results[index2];
    let match2 = matchesToLoad[index2];
    if (!match2) {
      continue;
    }
    let currentMatch = currentMatches.find((m2) => m2.route.id === match2.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match2) && (currentLoaderData && currentLoaderData[match2.route.id]) !== void 0;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      let signal = signals[index2];
      invariant$1(signal, "Expected an AbortSignal for revalidating fetcher deferred result");
      await resolveDeferredData(result, signal, isFetcher).then((result2) => {
        if (result2) {
          results[index2] = result2 || results[index2];
        }
      });
    }
  }
}
__name(resolveDeferredResults, "resolveDeferredResults");
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e2) {
      return {
        type: ResultType.error,
        error: e2
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
__name(resolveDeferredData, "resolveDeferredData");
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some((v2) => v2 === "");
}
__name(hasNakedIndexQuery, "hasNakedIndexQuery");
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    return matches[matches.length - 1];
  }
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
__name(getTargetMatch, "getTargetMatch");
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text,
    formData,
    json
  } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json: void 0,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: void 0,
      text: void 0
    };
  } else if (json !== void 0) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json,
      text: void 0
    };
  }
}
__name(getSubmissionFromNavigation, "getSubmissionFromNavigation");
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    return navigation;
  }
}
__name(getLoadingNavigation, "getLoadingNavigation");
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
__name(getSubmittingNavigation, "getSubmittingNavigation");
function getLoadingFetcher(submission, data) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data
    };
    return fetcher;
  }
}
__name(getLoadingFetcher, "getLoadingFetcher");
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : void 0
  };
  return fetcher;
}
__name(getSubmittingFetcher, "getSubmittingFetcher");
function getDoneFetcher(data) {
  let fetcher = {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data
  };
  return fetcher;
}
__name(getDoneFetcher, "getDoneFetcher");
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
    if (sessionPositions) {
      let json = JSON.parse(sessionPositions);
      for (let [k2, v2] of Object.entries(json || {})) {
        if (v2 && Array.isArray(v2)) {
          transitions.set(k2, new Set(v2 || []));
        }
      }
    }
  } catch (e2) {
  }
}
__name(restoreAppliedTransitions, "restoreAppliedTransitions");
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json = {};
    for (let [k2, v2] of transitions) {
      json[k2] = [...v2];
    }
    try {
      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));
    } catch (error) {
      warning(false, "Failed to save applied view transitions in sessionStorage (" + error + ").");
    }
  }
}
__name(persistAppliedTransitions, "persistAppliedTransitions");
/**
 * React Router v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
__name(_extends$6, "_extends$6");
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant$1(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
__name(useHref, "useHref");
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
__name(useInRouterContext, "useInRouterContext");
function useLocation() {
  !useInRouterContext() ? invariant$1(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
__name(useLocation, "useLocation");
function useIsomorphicLayoutEffect$4(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
__name(useIsomorphicLayoutEffect$4, "useIsomorphicLayoutEffect$4");
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
__name(useNavigate, "useNavigate");
function useNavigateUnstable() {
  !useInRouterContext() ? invariant$1(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$4(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
__name(useNavigateUnstable, "useNavigateUnstable");
function useParams() {
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
__name(useParams, "useParams");
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
__name(useResolvedPath, "useResolvedPath");
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant$1(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  return renderedMatches;
}
__name(useRoutesImpl, "useRoutesImpl");
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
__name(DefaultErrorComponent, "DefaultErrorComponent");
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
const _RenderErrorBoundary = class _RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
};
__name(_RenderErrorBoundary, "RenderErrorBoundary");
let RenderErrorBoundary = _RenderErrorBoundary;
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
__name(RenderedRoute, "RenderedRoute");
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]) !== void 0);
    !(errorIndex >= 0) ? invariant$1(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match2 = renderedMatches[i];
      if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match2.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match2.route.loader && loaderData[match2.route.id] === void 0 && (!errors2 || errors2[match2.route.id] === void 0);
        if (match2.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match2.route.id ? errors[match2.route.id] : void 0;
      errorElement = match2.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index2 === 0) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index2) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = /* @__PURE__ */ __name(() => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    }, "getChildren");
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
__name(_renderMatches, "_renderMatches");
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext$1(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant$1(false) : void 0;
  return ctx;
}
__name(useDataRouterContext$1, "useDataRouterContext$1");
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant$1(false) : void 0;
  return state;
}
__name(useDataRouterState, "useDataRouterState");
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant$1(false) : void 0;
  return route;
}
__name(useRouteContext, "useRouteContext");
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant$1(false) : void 0;
  return thisRoute.route.id;
}
__name(useCurrentRouteId, "useCurrentRouteId");
function useRouteId() {
  return useCurrentRouteId(DataRouterStateHook$1.UseRouteId);
}
__name(useRouteId, "useRouteId");
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error !== void 0) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
__name(useRouteError, "useRouteError");
function useNavigateStable() {
  let {
    router: router2
  } = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$4(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      router2.navigate(to);
    } else {
      router2.navigate(to, _extends$6({
        fromRouteId: id2
      }, options));
    }
  }, [router2, id2]);
  return navigate;
}
__name(useNavigateStable, "useNavigateStable");
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant$1(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$6({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
__name(Router, "Router");
new Promise(() => {
});
function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
  };
  if (route.Component) {
    Object.assign(updates, {
      element: /* @__PURE__ */ reactExports.createElement(route.Component),
      Component: void 0
    });
  }
  if (route.HydrateFallback) {
    Object.assign(updates, {
      hydrateFallbackElement: /* @__PURE__ */ reactExports.createElement(route.HydrateFallback),
      HydrateFallback: void 0
    });
  }
  if (route.ErrorBoundary) {
    Object.assign(updates, {
      errorElement: /* @__PURE__ */ reactExports.createElement(route.ErrorBoundary),
      ErrorBoundary: void 0
    });
  }
  return updates;
}
__name(mapRouteProperties, "mapRouteProperties");
/**
 * React Router DOM v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
__name(_extends$5, "_extends$5");
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
__name(_objectWithoutPropertiesLoose$2, "_objectWithoutPropertiesLoose$2");
const defaultMethod = "get";
const defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
__name(isHtmlElement, "isHtmlElement");
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
__name(isButtonElement, "isButtonElement");
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
__name(isFormElement, "isFormElement");
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
__name(isInputElement, "isInputElement");
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
__name(isModifiedEvent, "isModifiedEvent");
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
__name(shouldProcessLinkClick, "shouldProcessLinkClick");
let _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e2) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
__name(isFormDataSubmitterSupported, "isFormDataSubmitterSupported");
const supportedFormEncTypes = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    return null;
  }
  return encType;
}
__name(getFormEncType, "getFormEncType");
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body2;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let {
        name,
        type,
        value
      } = target;
      if (type === "image") {
        let prefix2 = name ? name + "." : "";
        formData.append(prefix2 + "x", "0");
        formData.append(prefix2 + "y", "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body2 = target;
  }
  if (formData && encType === "text/plain") {
    body2 = formData;
    formData = void 0;
  }
  return {
    action,
    method: method.toLowerCase(),
    encType,
    formData,
    body: body2
  };
}
__name(getFormSubmissionInfo, "getFormSubmissionInfo");
const _excluded$2x = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], _excluded3$6 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"];
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e2) {
}
function createBrowserRouter(routes, opts) {
  return createRouter({
    basename: void 0,
    future: _extends$5({}, void 0, {
      v7_prependBasename: true
    }),
    history: createBrowserHistory({
      window: void 0
    }),
    hydrationData: parseHydrationData(),
    routes,
    mapRouteProperties,
    unstable_dataStrategy: void 0,
    window: void 0
  }).initialize();
}
__name(createBrowserRouter, "createBrowserRouter");
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  if (state && state.errors) {
    state = _extends$5({}, state, {
      errors: deserializeErrors(state.errors)
    });
  }
  return state;
}
__name(parseHydrationData, "parseHydrationData");
function deserializeErrors(errors) {
  if (!errors)
    return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = "";
            serialized[key] = error;
          } catch (e2) {
          }
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = "";
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
__name(deserializeErrors, "deserializeErrors");
const ViewTransitionContext = /* @__PURE__ */ reactExports.createContext({
  isTransitioning: false
});
const FetchersContext = /* @__PURE__ */ reactExports.createContext(/* @__PURE__ */ new Map());
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$2[START_TRANSITION];
const FLUSH_SYNC = "flushSync";
const flushSyncImpl = ReactDOM$1[FLUSH_SYNC];
function startTransitionSafe(cb2) {
  if (startTransitionImpl) {
    startTransitionImpl(cb2);
  } else {
    cb2();
  }
}
__name(startTransitionSafe, "startTransitionSafe");
function flushSyncSafe(cb2) {
  if (flushSyncImpl) {
    flushSyncImpl(cb2);
  } else {
    cb2();
  }
}
__name(flushSyncSafe, "flushSyncSafe");
const _Deferred = class _Deferred {
  constructor() {
    this.status = "pending";
    this.promise = new Promise((resolve, reject) => {
      this.resolve = (value) => {
        if (this.status === "pending") {
          this.status = "resolved";
          resolve(value);
        }
      };
      this.reject = (reason) => {
        if (this.status === "pending") {
          this.status = "rejected";
          reject(reason);
        }
      };
    });
  }
};
__name(_Deferred, "Deferred");
let Deferred = _Deferred;
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router: router2,
    future
  } = _ref;
  let [state, setStateImpl] = reactExports.useState(router2.state);
  let [pendingState, setPendingState] = reactExports.useState();
  let [vtContext, setVtContext] = reactExports.useState({
    isTransitioning: false
  });
  let [renderDfd, setRenderDfd] = reactExports.useState();
  let [transition, setTransition] = reactExports.useState();
  let [interruption, setInterruption] = reactExports.useState();
  let fetcherData = reactExports.useRef(/* @__PURE__ */ new Map());
  let {
    v7_startTransition
  } = future || {};
  let optInStartTransition = reactExports.useCallback((cb2) => {
    if (v7_startTransition) {
      startTransitionSafe(cb2);
    } else {
      cb2();
    }
  }, [v7_startTransition]);
  let setState = reactExports.useCallback((newState, _ref2) => {
    let {
      deletedFetchers,
      unstable_flushSync: flushSync,
      unstable_viewTransitionOpts: viewTransitionOpts
    } = _ref2;
    deletedFetchers.forEach((key) => fetcherData.current.delete(key));
    newState.fetchers.forEach((fetcher, key) => {
      if (fetcher.data !== void 0) {
        fetcherData.current.set(key, fetcher.data);
      }
    });
    let isViewTransitionUnavailable = router2.window == null || router2.window.document == null || typeof router2.window.document.startViewTransition !== "function";
    if (!viewTransitionOpts || isViewTransitionUnavailable) {
      if (flushSync) {
        flushSyncSafe(() => setStateImpl(newState));
      } else {
        optInStartTransition(() => setStateImpl(newState));
      }
      return;
    }
    if (flushSync) {
      flushSyncSafe(() => {
        if (transition) {
          renderDfd && renderDfd.resolve();
          transition.skipTransition();
        }
        setVtContext({
          isTransitioning: true,
          flushSync: true,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      });
      let t2 = router2.window.document.startViewTransition(() => {
        flushSyncSafe(() => setStateImpl(newState));
      });
      t2.finished.finally(() => {
        flushSyncSafe(() => {
          setRenderDfd(void 0);
          setTransition(void 0);
          setPendingState(void 0);
          setVtContext({
            isTransitioning: false
          });
        });
      });
      flushSyncSafe(() => setTransition(t2));
      return;
    }
    if (transition) {
      renderDfd && renderDfd.resolve();
      transition.skipTransition();
      setInterruption({
        state: newState,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    } else {
      setPendingState(newState);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    }
  }, [router2.window, transition, renderDfd, fetcherData, optInStartTransition]);
  reactExports.useLayoutEffect(() => router2.subscribe(setState), [router2, setState]);
  reactExports.useEffect(() => {
    if (vtContext.isTransitioning && !vtContext.flushSync) {
      setRenderDfd(new Deferred());
    }
  }, [vtContext]);
  reactExports.useEffect(() => {
    if (renderDfd && pendingState && router2.window) {
      let newState = pendingState;
      let renderPromise = renderDfd.promise;
      let transition2 = router2.window.document.startViewTransition(async () => {
        optInStartTransition(() => setStateImpl(newState));
        await renderPromise;
      });
      transition2.finished.finally(() => {
        setRenderDfd(void 0);
        setTransition(void 0);
        setPendingState(void 0);
        setVtContext({
          isTransitioning: false
        });
      });
      setTransition(transition2);
    }
  }, [optInStartTransition, pendingState, renderDfd, router2.window]);
  reactExports.useEffect(() => {
    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
      renderDfd.resolve();
    }
  }, [renderDfd, transition, state.location, pendingState]);
  reactExports.useEffect(() => {
    if (!vtContext.isTransitioning && interruption) {
      setPendingState(interruption.state);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: interruption.currentLocation,
        nextLocation: interruption.nextLocation
      });
      setInterruption(void 0);
    }
  }, [vtContext.isTransitioning, interruption]);
  reactExports.useEffect(() => {
  }, []);
  let navigator2 = reactExports.useMemo(() => {
    return {
      createHref: router2.createHref,
      encodeLocation: router2.encodeLocation,
      go: (n2) => router2.navigate(n2),
      push: (to, state2, opts) => router2.navigate(to, {
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state2, opts) => router2.navigate(to, {
        replace: true,
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router2]);
  let basename = router2.basename || "/";
  let dataRouterContext = reactExports.useMemo(() => ({
    router: router2,
    navigator: navigator2,
    static: false,
    basename
  }), [router2, navigator2, basename]);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /* @__PURE__ */ reactExports.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /* @__PURE__ */ reactExports.createElement(FetchersContext.Provider, {
    value: fetcherData.current
  }, /* @__PURE__ */ reactExports.createElement(ViewTransitionContext.Provider, {
    value: vtContext
  }, /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator2,
    future: {
      v7_relativeSplatPath: router2.future.v7_relativeSplatPath
    }
  }, state.initialized || router2.future.v7_partialHydration ? /* @__PURE__ */ reactExports.createElement(DataRoutes, {
    routes: router2.routes,
    future: router2.future,
    state
  }) : fallbackElement))))), null);
}
__name(RouterProvider, "RouterProvider");
function DataRoutes(_ref3) {
  let {
    routes,
    future,
    state
  } = _ref3;
  return useRoutesImpl(routes, void 0, state, future);
}
__name(DataRoutes, "DataRoutes");
const isBrowser$3 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function LinkWithRef(_ref7, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    unstable_viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose$2(_ref7, _excluded$2x);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
    absoluteHref = to;
    if (isBrowser$3) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
      }
    }
  }
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative,
    unstable_viewTransition
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  __name(handleClick, "handleClick");
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends$5({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
}, "LinkWithRef"));
const Form = /* @__PURE__ */ reactExports.forwardRef((_ref9, forwardedRef) => {
  let {
    fetcherKey,
    navigate,
    reloadDocument,
    replace: replace2,
    state,
    method = defaultMethod,
    action,
    onSubmit,
    relative,
    preventScrollReset,
    unstable_viewTransition
  } = _ref9, props = _objectWithoutPropertiesLoose$2(_ref9, _excluded3$6);
  let submit = useSubmit();
  let formAction = useFormAction(action, {
    relative
  });
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let submitHandler = /* @__PURE__ */ __name((event) => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented)
      return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
    submit(submitter || event.currentTarget, {
      fetcherKey,
      method: submitMethod,
      navigate,
      replace: replace2,
      state,
      relative,
      preventScrollReset,
      unstable_viewTransition
    });
  }, "submitHandler");
  return /* @__PURE__ */ reactExports.createElement("form", _extends$5({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant$1(false) : void 0;
  return ctx;
}
__name(useDataRouterContext, "useDataRouterContext");
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    unstable_viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative,
        unstable_viewTransition
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);
}
__name(useLinkClickHandler, "useLinkClickHandler");
function validateClientSideSubmission() {
  if (typeof document === "undefined") {
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
  }
}
__name(validateClientSideSubmission, "validateClientSideSubmission");
let fetcherId = 0;
let getUniqueFetcherId = /* @__PURE__ */ __name(() => "__" + String(++fetcherId) + "__", "getUniqueFetcherId");
function useSubmit() {
  let {
    router: router2
  } = useDataRouterContext(DataRouterHook.UseSubmit);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return reactExports.useCallback(function(target, options) {
    if (options === void 0) {
      options = {};
    }
    validateClientSideSubmission();
    let {
      action,
      method,
      encType,
      formData,
      body: body2
    } = getFormSubmissionInfo(target, basename);
    if (options.navigate === false) {
      let key = options.fetcherKey || getUniqueFetcherId();
      router2.fetch(key, currentRouteId, options.action || action, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body: body2,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        unstable_flushSync: options.unstable_flushSync
      });
    } else {
      router2.navigate(options.action || action, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body: body2,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        replace: options.replace,
        state: options.state,
        fromRouteId: currentRouteId,
        unstable_flushSync: options.unstable_flushSync,
        unstable_viewTransition: options.unstable_viewTransition
      });
    }
  }, [router2, basename, currentRouteId]);
}
__name(useSubmit, "useSubmit");
function useFormAction(action, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let routeContext = reactExports.useContext(RouteContext);
  !routeContext ? invariant$1(false) : void 0;
  let [match2] = routeContext.matches.slice(-1);
  let path = _extends$5({}, useResolvedPath(action ? action : ".", {
    relative
  }));
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    if (params.has("index") && params.get("index") === "") {
      params.delete("index");
      path.search = params.toString() ? "?" + params.toString() : "";
    }
  }
  if ((!action || action === ".") && match2.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
__name(useFormAction, "useFormAction");
function formatMuiErrorMessage$1(code) {
  let url = "https://mui.com/production-error/?code=" + code;
  for (let i = 1; i < arguments.length; i += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
}
__name(formatMuiErrorMessage$1, "formatMuiErrorMessage$1");
const formatMuiErrorMessage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: formatMuiErrorMessage$1
}, Symbol.toStringTag, { value: "Module" }));
const THEME_ID = "$$material";
function _extends$4() {
  return _extends$4 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2)
        ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$4.apply(null, arguments);
}
__name(_extends$4, "_extends$4");
function _objectWithoutPropertiesLoose$1(r2, e2) {
  if (null == r2)
    return {};
  var t2 = {};
  for (var n2 in r2)
    if ({}.hasOwnProperty.call(r2, n2)) {
      if (e2.includes(n2))
        continue;
      t2[n2] = r2[n2];
    }
  return t2;
}
__name(_objectWithoutPropertiesLoose$1, "_objectWithoutPropertiesLoose$1");
function memoize$1(fn2) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0)
      cache2[arg] = fn2(arg);
    return cache2[arg];
  };
}
__name(memoize$1, "memoize$1");
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var isDevelopment$2 = false;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
__name(sheetForTag, "sheetForTag");
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
__name(createStyleElement, "createStyleElement");
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment$2 : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  __name(StyleSheet2, "StyleSheet");
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = /* @__PURE__ */ __name(function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  }, "hydrate");
  _proto.insert = /* @__PURE__ */ __name(function insert2(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  }, "insert");
  _proto.flush = /* @__PURE__ */ __name(function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  }, "flush");
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$2(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
__name(hash$2, "hash$2");
function trim$1(value) {
  return value.trim();
}
__name(trim$1, "trim$1");
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
__name(match, "match");
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
__name(replace, "replace");
function indexof(value, search) {
  return value.indexOf(search);
}
__name(indexof, "indexof");
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
__name(charat, "charat");
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
__name(substr, "substr");
function strlen(value) {
  return value.length;
}
__name(strlen, "strlen");
function sizeof(value) {
  return value.length;
}
__name(sizeof, "sizeof");
function append(value, array) {
  return array.push(value), value;
}
__name(append, "append");
function combine(array, callback) {
  return array.map(callback).join("");
}
__name(combine, "combine");
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type, props, children, length2) {
  return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
}
__name(node, "node");
function copy(root2, props) {
  return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
__name(copy, "copy");
function char() {
  return character;
}
__name(char, "char");
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
__name(prev, "prev");
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
__name(next, "next");
function peek() {
  return charat(characters, position);
}
__name(peek, "peek");
function caret() {
  return position;
}
__name(caret, "caret");
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
__name(slice, "slice");
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
__name(token, "token");
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
__name(alloc, "alloc");
function dealloc(value) {
  return characters = "", value;
}
__name(dealloc, "dealloc");
function delimit(type) {
  return trim$1(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
__name(delimit, "delimit");
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
__name(whitespace, "whitespace");
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
__name(escaping, "escaping");
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
__name(delimiter, "delimiter");
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
__name(commenter, "commenter");
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}
__name(identifier, "identifier");
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
__name(compile, "compile");
function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference2 = ruleset(characters2, root2, parent, index2, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root2, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
__name(parse, "parse");
function ruleset(value, root2, parent, index2, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i = 0, j = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root2, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
__name(ruleset, "ruleset");
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
__name(comment, "comment");
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
__name(declaration, "declaration");
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
__name(serialize, "serialize");
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
__name(stringify, "stringify");
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index2, children, callback) || "";
    return output;
  };
}
__name(middleware, "middleware");
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
__name(rulesheet, "rulesheet");
var weakMemoize = /* @__PURE__ */ __name(function weakMemoize2(func) {
  var cache2 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache2.has(arg)) {
      return cache2.get(arg);
    }
    var ret = func(arg);
    cache2.set(arg, ret);
    return ret;
  };
}, "weakMemoize");
var identifierWithPointTracking = /* @__PURE__ */ __name(function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
}, "identifierWithPointTracking");
var toRules = /* @__PURE__ */ __name(function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
}, "toRules");
var getRules = /* @__PURE__ */ __name(function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
}, "getRules");
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = /* @__PURE__ */ __name(function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
}, "compat");
var removeLabel = /* @__PURE__ */ __name(function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
}, "removeLabel");
function prefix(value, length2) {
  switch (hash$2(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
__name(prefix, "prefix");
var prefixer = /* @__PURE__ */ __name(function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
}, "prefixer");
var defaultStylisPlugins = [prefixer];
var createCache = /* @__PURE__ */ __name(function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = /* @__PURE__ */ __name(function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    }, "stylis");
    _insert = /* @__PURE__ */ __name(function insert2(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    }, "insert");
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
}, "createCache");
var reactIs$2 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$2 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t$1 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w = b$1 ? Symbol.for("react.fundamental") : 60117, x = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
function z(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c$1:
        switch (a = a.type, a) {
          case l$1:
          case m$2:
          case e$1:
          case g$1:
          case f$1:
          case p$1:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k$1:
              case n$1:
              case t$1:
              case r$1:
              case h$1:
                return a;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
__name(z, "z");
function A(a) {
  return z(a) === m$2;
}
__name(A, "A");
reactIs_production_min$1.AsyncMode = l$1;
reactIs_production_min$1.ConcurrentMode = m$2;
reactIs_production_min$1.ContextConsumer = k$1;
reactIs_production_min$1.ContextProvider = h$1;
reactIs_production_min$1.Element = c$1;
reactIs_production_min$1.ForwardRef = n$1;
reactIs_production_min$1.Fragment = e$1;
reactIs_production_min$1.Lazy = t$1;
reactIs_production_min$1.Memo = r$1;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$1;
reactIs_production_min$1.StrictMode = f$1;
reactIs_production_min$1.Suspense = p$1;
reactIs_production_min$1.isAsyncMode = function(a) {
  return A(a) || z(a) === l$1;
};
reactIs_production_min$1.isConcurrentMode = A;
reactIs_production_min$1.isContextConsumer = function(a) {
  return z(a) === k$1;
};
reactIs_production_min$1.isContextProvider = function(a) {
  return z(a) === h$1;
};
reactIs_production_min$1.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c$1;
};
reactIs_production_min$1.isForwardRef = function(a) {
  return z(a) === n$1;
};
reactIs_production_min$1.isFragment = function(a) {
  return z(a) === e$1;
};
reactIs_production_min$1.isLazy = function(a) {
  return z(a) === t$1;
};
reactIs_production_min$1.isMemo = function(a) {
  return z(a) === r$1;
};
reactIs_production_min$1.isPortal = function(a) {
  return z(a) === d$1;
};
reactIs_production_min$1.isProfiler = function(a) {
  return z(a) === g$1;
};
reactIs_production_min$1.isStrictMode = function(a) {
  return z(a) === f$1;
};
reactIs_production_min$1.isSuspense = function(a) {
  return z(a) === p$1;
};
reactIs_production_min$1.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e$1 || a === m$2 || a === g$1 || a === f$1 || a === p$1 || a === q$1 || "object" === typeof a && null !== a && (a.$$typeof === t$1 || a.$$typeof === r$1 || a.$$typeof === h$1 || a.$$typeof === k$1 || a.$$typeof === n$1 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v$1);
};
reactIs_production_min$1.typeOf = z;
{
  reactIs$2.exports = reactIs_production_min$1;
}
var reactIsExports$1 = reactIs$2.exports;
var reactIs$1 = reactIsExports$1;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
var isBrowser$2 = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
__name(getRegisteredStyles, "getRegisteredStyles");
var registerStyles = /* @__PURE__ */ __name(function registerStyles2(cache2, serialized, isStringTag2) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$2 === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
}, "registerStyles");
var insertStyles = /* @__PURE__ */ __name(function insertStyles2(cache2, serialized, isStringTag2) {
  registerStyles(cache2, serialized, isStringTag2);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
}, "insertStyles");
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
__name(murmur2, "murmur2");
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var isDevelopment$1 = false;
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = /* @__PURE__ */ __name(function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
}, "isCustomProperty");
var isProcessableValue = /* @__PURE__ */ __name(function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
}, "isProcessableValue");
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = /* @__PURE__ */ __name(function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
}, "processStyleValue");
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes3 = interpolation;
      if (keyframes3.anim === 1) {
        cursor = {
          name: keyframes3.name,
          styles: keyframes3.styles,
          next: cursor
        };
        return keyframes3.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
__name(handleInterpolation, "handleInterpolation");
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment$1) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i2 = 0; _i2 < value.length; _i2++) {
            if (isProcessableValue(value[_i2])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
__name(createStringFromObject, "createStringFromObject");
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}
__name(serializeStyles, "serializeStyles");
var syncFallback = /* @__PURE__ */ __name(function syncFallback2(create) {
  return create();
}, "syncFallback");
var useInsertionEffect = React$2["useInsertionEffect"] ? React$2["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = /* @__PURE__ */ __name(function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache2 = reactExports.useContext(EmotionCacheContext);
    return func(props, cache2, ref);
  });
}, "withEmotionCache");
var ThemeContext$1 = /* @__PURE__ */ reactExports.createContext({});
var getTheme = /* @__PURE__ */ __name(function getTheme2(outerTheme, theme2) {
  if (typeof theme2 === "function") {
    var mergedTheme = theme2(outerTheme);
    return mergedTheme;
  }
  return _extends$4({}, outerTheme, theme2);
}, "getTheme");
var createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme2) {
    return getTheme(outerTheme, theme2);
  });
});
var ThemeProvider$3 = /* @__PURE__ */ __name(function ThemeProvider(props) {
  var theme2 = reactExports.useContext(ThemeContext$1);
  if (props.theme !== theme2) {
    theme2 = createCacheWithTheme(theme2)(props.theme);
  }
  return /* @__PURE__ */ reactExports.createElement(ThemeContext$1.Provider, {
    value: theme2
  }, props.children);
}, "ThemeProvider");
var _extends$3 = { exports: {} };
var hasRequired_extends;
function require_extends() {
  if (hasRequired_extends)
    return _extends$3.exports;
  hasRequired_extends = 1;
  (function(module) {
    function _extends3() {
      return module.exports = _extends3 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var t2 = arguments[e2];
          for (var r2 in t2)
            ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends3.apply(null, arguments);
    }
    __name(_extends3, "_extends");
    module.exports = _extends3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_extends$3);
  return _extends$3.exports;
}
__name(require_extends, "require_extends");
require_extends();
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext$1));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
__name(css, "css");
var keyframes$1 = /* @__PURE__ */ __name(function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: /* @__PURE__ */ __name(function toString3() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }, "toString")
  };
}, "keyframes");
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = /* @__PURE__ */ __name(function testOmitPropsOnComponent2(key) {
  return key !== "theme";
}, "testOmitPropsOnComponent");
var getDefaultShouldForwardProp = /* @__PURE__ */ __name(function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
}, "getDefaultShouldForwardProp");
var composeShouldForwardProps = /* @__PURE__ */ __name(function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
}, "composeShouldForwardProps");
var isDevelopment = false;
var Insertion = /* @__PURE__ */ __name(function Insertion2(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag2);
  });
  return null;
}, "Insertion");
var createStyled$3 = /* @__PURE__ */ __name(function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles2.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache2, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext$1);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache2.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
      className += cache2.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref) {
        newProps.ref = ref;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
        cache: cache2,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: /* @__PURE__ */ __name(function value() {
        if (targetClassName === void 0 && isDevelopment) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }, "value")
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled(nextTag, _extends$4({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
}, "createStyled");
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$3.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
__name(emptyFunction, "emptyFunction");
function emptyFunctionWithReset() {
}
__name(emptyFunctionWithReset, "emptyFunctionWithReset");
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = /* @__PURE__ */ __name(function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  __name(shim, "shim");
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  __name(getShim, "getShim");
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
}, "factoryWithThrowingShims");
{
  propTypes.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
let cache$1;
if (typeof document === "object") {
  cache$1 = createCache({
    key: "css",
    prepend: true
  });
}
function StyledEngineProvider(props) {
  const {
    injectFirst,
    children
  } = props;
  return injectFirst && cache$1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(CacheProvider, {
    value: cache$1,
    children
  }) : children;
}
__name(StyledEngineProvider, "StyledEngineProvider");
function isEmpty$4(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
__name(isEmpty$4, "isEmpty$4");
function GlobalStyles$2(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$4(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
__name(GlobalStyles$2, "GlobalStyles$2");
function styled$2(tag, options) {
  const stylesFactory = newStyled(tag, options);
  return stylesFactory;
}
__name(styled$2, "styled$2");
const internal_processStyles = /* @__PURE__ */ __name((tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
}, "internal_processStyles");
const styledEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GlobalStyles: GlobalStyles$2,
  StyledEngineProvider,
  ThemeContext: ThemeContext$1,
  css,
  default: styled$2,
  internal_processStyles,
  keyframes: keyframes$1
}, Symbol.toStringTag, { value: "Module" }));
function isPlainObject$2(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(item);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
__name(isPlainObject$2, "isPlainObject$2");
function deepClone$1(source) {
  if (!isPlainObject$2(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone$1(source[key]);
  });
  return output;
}
__name(deepClone$1, "deepClone$1");
function deepmerge$1(target, source, options = {
  clone: true
}) {
  const output = options.clone ? _extends$4({}, target) : target;
  if (isPlainObject$2(target) && isPlainObject$2(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject$2(source[key]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject$2(target[key])) {
        output[key] = deepmerge$1(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject$2(source[key]) ? deepClone$1(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
__name(deepmerge$1, "deepmerge$1");
const deepmerge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: deepmerge$1,
  isPlainObject: isPlainObject$2
}, Symbol.toStringTag, { value: "Module" }));
const _excluded$2w = ["values", "unit", "step"];
const sortBreakpointsValues = /* @__PURE__ */ __name((values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends$4({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
}, "sortBreakpointsValues");
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5
  } = breakpoints, other = _objectWithoutPropertiesLoose$1(breakpoints, _excluded$2w);
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  __name(up, "up");
  function down(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  __name(down, "down");
  function between(start2, end2) {
    const endIndex = keys.indexOf(end2);
    return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end2) - step / 100}${unit})`;
  }
  __name(between, "between");
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  __name(only, "only");
  function not(key) {
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  __name(not, "not");
  return _extends$4({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
__name(createBreakpoints, "createBreakpoints");
const shape = {
  borderRadius: 4
};
function merge$2(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge$1(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
__name(merge$2, "merge$2");
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$1[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme2 = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
__name(handleBreakpoints, "handleBreakpoints");
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
__name(createEmptyBreakpointObject, "createEmptyBreakpointObject");
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
__name(removeUnusedBreakpoints, "removeUnusedBreakpoints");
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge$1(prev2, next2), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
__name(mergeBreakpointsInOrder, "mergeBreakpointsInOrder");
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i) => {
      if (i < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
__name(computeBreakpointsBase, "computeBreakpointsBase");
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys = Object.keys(base);
  if (keys.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys.reduce((acc, breakpoint, i) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
      previous = i;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
__name(resolveBreakpointValues, "resolveBreakpointValues");
function capitalize$1(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage$1(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
__name(capitalize$1, "capitalize$1");
const capitalize = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: capitalize$1
}, Symbol.toStringTag, { value: "Module" }));
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
__name(getPath, "getPath");
function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
__name(getStyleValue$1, "getStyleValue$1");
function style$f(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn2 = /* @__PURE__ */ __name((props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme2 = props.theme;
    const themeMapping = getPath(theme2, themeKey) || {};
    const styleFromPropValue = /* @__PURE__ */ __name((propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    }, "styleFromPropValue");
    return handleBreakpoints(props, propValue, styleFromPropValue);
  }, "fn");
  fn2.propTypes = {};
  fn2.filterProps = [prop];
  return fn2;
}
__name(style$f, "style$f");
function memoize(fn2) {
  const cache2 = {};
  return (arg) => {
    if (cache2[arg] === void 0) {
      cache2[arg] = fn2(arg);
    }
    return cache2[arg];
  };
}
__name(memoize, "memoize");
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a, b2] = prop.split("");
  const property = properties[a];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme2, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme2, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === "number") {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing * abs2;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing[abs2];
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
__name(createUnaryUnit, "createUnaryUnit");
function createUnarySpacing(theme2) {
  return createUnaryUnit(theme2, "spacing", 8);
}
__name(createUnarySpacing, "createUnarySpacing");
function getValue$1(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  const abs2 = Math.abs(propValue);
  const transformed = transformer(abs2);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === "number") {
    return -transformed;
  }
  return `-${transformed}`;
}
__name(getValue$1, "getValue$1");
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue$1(transformer, propValue);
    return acc;
  }, {});
}
__name(getStyleFromPropValue, "getStyleFromPropValue");
function resolveCssProperty(props, keys, prop, transformer) {
  if (keys.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
__name(resolveCssProperty, "resolveCssProperty");
function style$e(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge$2, {});
}
__name(style$e, "style$e");
function margin(props) {
  return style$e(props, marginKeys);
}
__name(margin, "margin");
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style$e(props, paddingKeys);
}
__name(padding, "padding");
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const transform = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing = /* @__PURE__ */ __name((...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  }, "spacing");
  spacing.mui = true;
  return spacing;
}
__name(createSpacing, "createSpacing");
function compose$1(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn2 = /* @__PURE__ */ __name((props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge$2(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  }, "fn");
  fn2.propTypes = {};
  fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn2;
}
__name(compose$1, "compose$1");
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
__name(borderTransform, "borderTransform");
function createBorderStyle(prop, transform) {
  return style$f({
    prop,
    themeKey: "borders",
    transform
  });
}
__name(createBorderStyle, "createBorderStyle");
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = /* @__PURE__ */ __name((props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = /* @__PURE__ */ __name((propValue) => ({
      borderRadius: getValue$1(transformer, propValue)
    }), "styleFromPropValue");
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
}, "borderRadius");
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose$1(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = /* @__PURE__ */ __name((props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = /* @__PURE__ */ __name((propValue) => ({
      gap: getValue$1(transformer, propValue)
    }), "styleFromPropValue");
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
}, "gap");
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = /* @__PURE__ */ __name((props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = /* @__PURE__ */ __name((propValue) => ({
      columnGap: getValue$1(transformer, propValue)
    }), "styleFromPropValue");
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
}, "columnGap");
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = /* @__PURE__ */ __name((props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = /* @__PURE__ */ __name((propValue) => ({
      rowGap: getValue$1(transformer, propValue)
    }), "styleFromPropValue");
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
}, "rowGap");
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$f({
  prop: "gridColumn"
});
const gridRow = style$f({
  prop: "gridRow"
});
const gridAutoFlow = style$f({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$f({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$f({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$f({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$f({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$f({
  prop: "gridTemplateAreas"
});
const gridArea = style$f({
  prop: "gridArea"
});
compose$1(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
__name(paletteTransform, "paletteTransform");
const color$1 = style$f({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$f({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$f({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose$1(color$1, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
__name(sizingTransform, "sizingTransform");
const width = style$f({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = /* @__PURE__ */ __name((props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = /* @__PURE__ */ __name((propValue) => {
      var _props$theme, _props$theme2;
      const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    }, "styleFromPropValue");
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
}, "maxWidth");
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$f({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$f({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$f({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$f({
  prop: "minHeight",
  transform: sizingTransform
});
style$f({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$f({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$f({
  prop: "boxSizing"
});
compose$1(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
__name(objectsHaveSameKeys, "objectsHaveSameKeys");
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
__name(callIfFn, "callIfFn");
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme2, config2) {
    const props = {
      [prop]: val,
      theme: theme2
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme2, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = /* @__PURE__ */ __name((propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    }, "styleFromPropValue");
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  __name(getThemeValue, "getThemeValue");
  function styleFunctionSx2(props) {
    var _theme$unstable_sxCon;
    const {
      sx,
      theme: theme2 = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = (_theme$unstable_sxCon = theme2.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme2);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme2.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme2);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge$2(css2, getThemeValue(styleKey, value, theme2, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme: theme2
              }, value, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme: theme2
                });
              } else {
                css2 = merge$2(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge$2(css2, getThemeValue(styleKey, value, theme2, config2));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css2);
    }
    __name(traverse, "traverse");
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  __name(styleFunctionSx2, "styleFunctionSx");
  return styleFunctionSx2;
}
__name(unstable_createStyleFunctionSx, "unstable_createStyleFunctionSx");
const styleFunctionSx$1 = unstable_createStyleFunctionSx();
styleFunctionSx$1.filterProps = ["sx"];
function applyStyles$2(key, styles2) {
  const theme2 = this;
  if (theme2.vars && typeof theme2.getColorSchemeSelector === "function") {
    const selector = theme2.getColorSchemeSelector(key).replace(/(\[[^\]]+\])/, "*:where($1)");
    return {
      [selector]: styles2
    };
  }
  if (theme2.palette.mode === key) {
    return styles2;
  }
  return {};
}
__name(applyStyles$2, "applyStyles$2");
const _excluded$2v = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$2(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$2v);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge$1({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: _extends$4({
      mode: "light"
    }, paletteInput),
    spacing,
    shape: _extends$4({}, shape, shapeInput)
  }, other);
  muiTheme.applyStyles = applyStyles$2;
  muiTheme = args.reduce((acc, argument) => deepmerge$1(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$4({}, defaultSxConfig, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = /* @__PURE__ */ __name(function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  }, "sx");
  return muiTheme;
}
__name(createTheme$2, "createTheme$2");
const createTheme$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: createTheme$2,
  private_createBreakpoints: createBreakpoints,
  unstable_applyStyles: applyStyles$2
}, Symbol.toStringTag, { value: "Module" }));
function isObjectEmpty$1(obj) {
  return Object.keys(obj).length === 0;
}
__name(isObjectEmpty$1, "isObjectEmpty$1");
function useTheme$4(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext$1);
  return !contextTheme || isObjectEmpty$1(contextTheme) ? defaultTheme2 : contextTheme;
}
__name(useTheme$4, "useTheme$4");
const systemDefaultTheme$2 = createTheme$2();
function useTheme$3(defaultTheme2 = systemDefaultTheme$2) {
  return useTheme$4(defaultTheme2);
}
__name(useTheme$3, "useTheme$3");
function GlobalStyles$1({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$3(defaultTheme2);
  const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: globalStyles
  });
}
__name(GlobalStyles$1, "GlobalStyles$1");
const _excluded$2u = ["sx"];
const splitProps = /* @__PURE__ */ __name((props) => {
  var _props$theme$unstable, _props$theme;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
}, "splitProps");
function extendSxProp(props) {
  const {
    sx: inSx
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2u);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = /* @__PURE__ */ __name((...args) => {
      const result = inSx(...args);
      if (!isPlainObject$2(result)) {
        return systemProps;
      }
      return _extends$4({}, systemProps, result);
    }, "finalSx");
  } else {
    finalSx = _extends$4({}, systemProps, inSx);
  }
  return _extends$4({}, otherProps, {
    sx: finalSx
  });
}
__name(extendSxProp, "extendSxProp");
const styleFunctionSx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: styleFunctionSx$1,
  extendSxProp,
  unstable_createStyleFunctionSx,
  unstable_defaultSxConfig: defaultSxConfig
}, Symbol.toStringTag, { value: "Module" }));
const defaultGenerator = /* @__PURE__ */ __name((componentName) => componentName, "defaultGenerator");
const createClassNameGenerator = /* @__PURE__ */ __name(() => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
}, "createClassNameGenerator");
const ClassNameGenerator = createClassNameGenerator();
function r(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2)) {
      var o = e2.length;
      for (t2 = 0; t2 < o; t2++)
        e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else
      for (f2 in e2)
        e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
__name(r, "r");
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++)
    (e2 = arguments[f2]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
__name(clsx, "clsx");
const _excluded$2t = ["className", "component"];
function createBox$1(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled$2("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx$1);
  const Box2 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Box3(inProps, ref) {
    const theme2 = useTheme$3(defaultTheme2);
    const _extendSxProp = extendSxProp(inProps), {
      className,
      component = "div"
    } = _extendSxProp, other = _objectWithoutPropertiesLoose$1(_extendSxProp, _excluded$2t);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, _extends$4({
      as: component,
      ref,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme2[themeId] || theme2 : theme2
    }, other));
  }, "Box"));
  return Box2;
}
__name(createBox$1, "createBox$1");
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass$1(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
__name(generateUtilityClass$1, "generateUtilityClass$1");
function generateUtilityClasses$1(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass$1(componentName, slot, globalStatePrefix);
  });
  return result;
}
__name(generateUtilityClasses$1, "generateUtilityClasses$1");
var reactIs = { exports: {} };
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m$1 = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
u = Symbol.for("react.module.reference");
function v(a) {
  if ("object" === typeof a && null !== a) {
    var r2 = a.$$typeof;
    switch (r2) {
      case b:
        switch (a = a.type, a) {
          case d:
          case f:
          case e:
          case m$1:
          case n:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case h:
              case l:
              case q:
              case p:
              case g:
                return a;
              default:
                return r2;
            }
        }
      case c:
        return r2;
    }
  }
}
__name(v, "v");
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = g;
reactIs_production_min.Element = b;
reactIs_production_min.ForwardRef = l;
reactIs_production_min.Fragment = d;
reactIs_production_min.Lazy = q;
reactIs_production_min.Memo = p;
reactIs_production_min.Portal = c;
reactIs_production_min.Profiler = f;
reactIs_production_min.StrictMode = e;
reactIs_production_min.Suspense = m$1;
reactIs_production_min.SuspenseList = n;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a) {
  return v(a) === h;
};
reactIs_production_min.isContextProvider = function(a) {
  return v(a) === g;
};
reactIs_production_min.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === b;
};
reactIs_production_min.isForwardRef = function(a) {
  return v(a) === l;
};
reactIs_production_min.isFragment = function(a) {
  return v(a) === d;
};
reactIs_production_min.isLazy = function(a) {
  return v(a) === q;
};
reactIs_production_min.isMemo = function(a) {
  return v(a) === p;
};
reactIs_production_min.isPortal = function(a) {
  return v(a) === c;
};
reactIs_production_min.isProfiler = function(a) {
  return v(a) === f;
};
reactIs_production_min.isStrictMode = function(a) {
  return v(a) === e;
};
reactIs_production_min.isSuspense = function(a) {
  return v(a) === m$1;
};
reactIs_production_min.isSuspenseList = function(a) {
  return v(a) === n;
};
reactIs_production_min.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m$1 || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;
};
reactIs_production_min.typeOf = v;
{
  reactIs.exports = reactIs_production_min;
}
var reactIsExports = reactIs.exports;
const fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function getFunctionName(fn2) {
  const match2 = `${fn2}`.match(fnNameMatchRegex);
  const name = match2 && match2[1];
  return name || "";
}
__name(getFunctionName, "getFunctionName");
function getFunctionComponentName(Component, fallback = "") {
  return Component.displayName || Component.name || getFunctionName(Component) || fallback;
}
__name(getFunctionComponentName, "getFunctionComponentName");
function getWrappedName(outerType, innerType, wrapperName) {
  const functionName = getFunctionComponentName(innerType);
  return outerType.displayName || (functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName);
}
__name(getWrappedName, "getWrappedName");
function getDisplayName$1(Component) {
  if (Component == null) {
    return void 0;
  }
  if (typeof Component === "string") {
    return Component;
  }
  if (typeof Component === "function") {
    return getFunctionComponentName(Component, "Component");
  }
  if (typeof Component === "object") {
    switch (Component.$$typeof) {
      case reactIsExports.ForwardRef:
        return getWrappedName(Component, Component.render, "ForwardRef");
      case reactIsExports.Memo:
        return getWrappedName(Component, Component.type, "memo");
      default:
        return void 0;
    }
  }
  return void 0;
}
__name(getDisplayName$1, "getDisplayName$1");
const getDisplayName = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: getDisplayName$1,
  getFunctionName
}, Symbol.toStringTag, { value: "Module" }));
const _excluded$2s = ["ownerState"], _excluded2$i = ["variants"], _excluded3$5 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function isEmpty$3(obj) {
  return Object.keys(obj).length === 0;
}
__name(isEmpty$3, "isEmpty$3");
function isStringTag$1(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
__name(isStringTag$1, "isStringTag$1");
function shouldForwardProp$1(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
__name(shouldForwardProp$1, "shouldForwardProp$1");
const systemDefaultTheme$1 = createTheme$2();
const lowercaseFirstLetter$1 = /* @__PURE__ */ __name((string) => {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}, "lowercaseFirstLetter$1");
function resolveTheme$1({
  defaultTheme: defaultTheme2,
  theme: theme2,
  themeId
}) {
  return isEmpty$3(theme2) ? defaultTheme2 : theme2[themeId] || theme2;
}
__name(resolveTheme$1, "resolveTheme$1");
function defaultOverridesResolver$1(slot) {
  if (!slot) {
    return null;
  }
  return (props, styles2) => styles2[slot];
}
__name(defaultOverridesResolver$1, "defaultOverridesResolver$1");
function processStyleArg$1(callableStyle, _ref) {
  let {
    ownerState
  } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$2s);
  const resolvedStylesArg = typeof callableStyle === "function" ? callableStyle(_extends$4({
    ownerState
  }, props)) : callableStyle;
  if (Array.isArray(resolvedStylesArg)) {
    return resolvedStylesArg.flatMap((resolvedStyle) => processStyleArg$1(resolvedStyle, _extends$4({
      ownerState
    }, props)));
  }
  if (!!resolvedStylesArg && typeof resolvedStylesArg === "object" && Array.isArray(resolvedStylesArg.variants)) {
    const {
      variants = []
    } = resolvedStylesArg, otherStyles = _objectWithoutPropertiesLoose$1(resolvedStylesArg, _excluded2$i);
    let result = otherStyles;
    variants.forEach((variant) => {
      let isMatch = true;
      if (typeof variant.props === "function") {
        isMatch = variant.props(_extends$4({
          ownerState
        }, props, ownerState));
      } else {
        Object.keys(variant.props).forEach((key) => {
          if ((ownerState == null ? void 0 : ownerState[key]) !== variant.props[key] && props[key] !== variant.props[key]) {
            isMatch = false;
          }
        });
      }
      if (isMatch) {
        if (!Array.isArray(result)) {
          result = [result];
        }
        result.push(typeof variant.style === "function" ? variant.style(_extends$4({
          ownerState
        }, props, ownerState)) : variant.style);
      }
    });
    return result;
  }
  return resolvedStylesArg;
}
__name(processStyleArg$1, "processStyleArg$1");
function createStyled$2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme$1,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp$1,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp$1
  } = input;
  const systemSx = /* @__PURE__ */ __name((props) => {
    return styleFunctionSx$1(_extends$4({}, props, {
      theme: resolveTheme$1(_extends$4({}, props, {
        defaultTheme: defaultTheme2,
        themeId
      }))
    }));
  }, "systemSx");
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: overridesResolver2 = defaultOverridesResolver$1(lowercaseFirstLetter$1(componentSlot))
    } = inputOptions, options = _objectWithoutPropertiesLoose$1(inputOptions, _excluded3$5);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp$1;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag$1(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, _extends$4({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const transformStyleArg = /* @__PURE__ */ __name((stylesArg) => {
      if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg || isPlainObject$2(stylesArg)) {
        return (props) => processStyleArg$1(stylesArg, _extends$4({}, props, {
          theme: resolveTheme$1({
            theme: props.theme,
            defaultTheme: defaultTheme2,
            themeId
          })
        }));
      }
      return stylesArg;
    }, "transformStyleArg");
    const muiStyledResolver = /* @__PURE__ */ __name((styleArg, ...expressions) => {
      let transformedStyleArg = transformStyleArg(styleArg);
      const expressionsWithDefaultTheme = expressions ? expressions.map(transformStyleArg) : [];
      if (componentName && overridesResolver2) {
        expressionsWithDefaultTheme.push((props) => {
          const theme2 = resolveTheme$1(_extends$4({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          if (!theme2.components || !theme2.components[componentName] || !theme2.components[componentName].styleOverrides) {
            return null;
          }
          const styleOverrides = theme2.components[componentName].styleOverrides;
          const resolvedStyleOverrides = {};
          Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
            resolvedStyleOverrides[slotKey] = processStyleArg$1(slotStyle, _extends$4({}, props, {
              theme: theme2
            }));
          });
          return overridesResolver2(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          var _theme$components;
          const theme2 = resolveTheme$1(_extends$4({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          const themeVariants = theme2 == null || (_theme$components = theme2.components) == null || (_theme$components = _theme$components[componentName]) == null ? void 0 : _theme$components.variants;
          return processStyleArg$1({
            variants: themeVariants
          }, _extends$4({}, props, {
            theme: theme2
          }));
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      }
      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    }, "muiStyledResolver");
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
__name(createStyled$2, "createStyled$2");
const styled$1 = createStyled$2();
function resolveProps(defaultProps2, props) {
  const output = _extends$4({}, props);
  Object.keys(defaultProps2).forEach((propName) => {
    if (propName.toString().match(/^(components|slots)$/)) {
      output[propName] = _extends$4({}, defaultProps2[propName], output[propName]);
    } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
      const defaultSlotProps = defaultProps2[propName] || {};
      const slotProps = props[propName];
      output[propName] = {};
      if (!slotProps || !Object.keys(slotProps)) {
        output[propName] = defaultSlotProps;
      } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
        output[propName] = slotProps;
      } else {
        output[propName] = _extends$4({}, slotProps);
        Object.keys(defaultSlotProps).forEach((slotPropName) => {
          output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
        });
      }
    } else if (output[propName] === void 0) {
      output[propName] = defaultProps2[propName];
    }
  });
  return output;
}
__name(resolveProps, "resolveProps");
function getThemeProps$1(params) {
  const {
    theme: theme2,
    name,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name] || !theme2.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme2.components[name].defaultProps, props);
}
__name(getThemeProps$1, "getThemeProps$1");
function useThemeProps$1({
  props,
  name,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme2 = useTheme$3(defaultTheme2);
  if (themeId) {
    theme2 = theme2[themeId] || theme2;
  }
  const mergedProps = getThemeProps$1({
    theme: theme2,
    name,
    props
  });
  return mergedProps;
}
__name(useThemeProps$1, "useThemeProps$1");
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const [match2, setMatch] = reactExports.useState(() => {
    if (noSsr && matchMedia) {
      return matchMedia(query).matches;
    }
    if (ssrMatchMedia) {
      return ssrMatchMedia(query).matches;
    }
    return defaultMatches;
  });
  useEnhancedEffect(() => {
    let active = true;
    if (!matchMedia) {
      return void 0;
    }
    const queryList = matchMedia(query);
    const updateMatch = /* @__PURE__ */ __name(() => {
      if (active) {
        setMatch(queryList.matches);
      }
    }, "updateMatch");
    updateMatch();
    queryList.addListener(updateMatch);
    return () => {
      active = false;
      queryList.removeListener(updateMatch);
    };
  }, [query, matchMedia]);
  return match2;
}
__name(useMediaQueryOld, "useMediaQueryOld");
const maybeReactUseSyncExternalStore = reactExports.useSyncExternalStore;
function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
  const getServerSnapshot = reactExports.useMemo(() => {
    if (noSsr && matchMedia) {
      return () => matchMedia(query).matches;
    }
    if (ssrMatchMedia !== null) {
      const {
        matches
      } = ssrMatchMedia(query);
      return () => matches;
    }
    return getDefaultSnapshot;
  }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia]);
  const [getSnapshot, subscribe2] = reactExports.useMemo(() => {
    if (matchMedia === null) {
      return [getDefaultSnapshot, () => () => {
      }];
    }
    const mediaQueryList = matchMedia(query);
    return [() => mediaQueryList.matches, (notify) => {
      mediaQueryList.addListener(notify);
      return () => {
        mediaQueryList.removeListener(notify);
      };
    }];
  }, [getDefaultSnapshot, matchMedia, query]);
  const match2 = maybeReactUseSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot);
  return match2;
}
__name(useMediaQueryNew, "useMediaQueryNew");
function useMediaQuery(queryInput, options = {}) {
  const theme2 = useTheme$4();
  const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
  const {
    defaultMatches = false,
    matchMedia = supportMatchMedia ? window.matchMedia : null,
    ssrMatchMedia = null,
    noSsr = false
  } = getThemeProps$1({
    name: "MuiUseMediaQuery",
    props: options,
    theme: theme2
  });
  let query = typeof queryInput === "function" ? queryInput(theme2) : queryInput;
  query = query.replace(/^@media( ?)/m, "");
  const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
  const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
  return match2;
}
__name(useMediaQuery, "useMediaQuery");
function clamp$5(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min2, Math.min(val, max2));
}
__name(clamp$5, "clamp$5");
const clamp$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: clamp$5
}, Symbol.toStringTag, { value: "Module" }));
function clampWrapper$1(value, min2 = 0, max2 = 1) {
  return clamp$5(value, min2, max2);
}
__name(clampWrapper$1, "clampWrapper$1");
function hexToRgb$1(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re2);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n2) => n2 + n2);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index2) => {
    return index2 < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
__name(hexToRgb$1, "hexToRgb$1");
function decomposeColor$1(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor$1(hexToRgb$1(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
    throw new Error(formatMuiErrorMessage$1(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error(formatMuiErrorMessage$1(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
__name(decomposeColor$1, "decomposeColor$1");
function recomposeColor$1(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.indexOf("rgb") !== -1) {
    values2 = values2.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
  } else if (type.indexOf("hsl") !== -1) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.indexOf("color") !== -1) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
__name(recomposeColor$1, "recomposeColor$1");
function alpha$2(color2, value) {
  color2 = decomposeColor$1(color2);
  value = clampWrapper$1(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor$1(color2);
}
__name(alpha$2, "alpha$2");
function darken$1(color2, coefficient) {
  color2 = decomposeColor$1(color2);
  coefficient = clampWrapper$1(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor$1(color2);
}
__name(darken$1, "darken$1");
function lighten$1(color2, coefficient) {
  color2 = decomposeColor$1(color2);
  coefficient = clampWrapper$1(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.indexOf("rgb") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (255 - color2.values[i]) * coefficient;
    }
  } else if (color2.type.indexOf("color") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (1 - color2.values[i]) * coefficient;
    }
  }
  return recomposeColor$1(color2);
}
__name(lighten$1, "lighten$1");
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return /* @__PURE__ */ __name(function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    }, "chainedFunction");
  }, () => {
  });
}
__name(createChainedFunction, "createChainedFunction");
function debounce$2(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = /* @__PURE__ */ __name(() => {
      func.apply(this, args);
    }, "later");
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  __name(debounced, "debounced");
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
__name(debounce$2, "debounce$2");
function deprecatedPropType(validator2, reason) {
  {
    return () => null;
  }
}
__name(deprecatedPropType, "deprecatedPropType");
function isMuiElement(element, muiNames) {
  var _muiName, _element$type;
  return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(
    // For server components `muiName` is avaialble in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    (_muiName = element.type.muiName) != null ? _muiName : (_element$type = element.type) == null || (_element$type = _element$type._payload) == null || (_element$type = _element$type.value) == null ? void 0 : _element$type.muiName
  ) !== -1;
}
__name(isMuiElement, "isMuiElement");
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
__name(ownerDocument, "ownerDocument");
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
__name(ownerWindow, "ownerWindow");
function requirePropFactory(componentNameInError, Component) {
  {
    return () => null;
  }
}
__name(requirePropFactory, "requirePropFactory");
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
__name(setRef, "setRef");
let globalId$1 = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId$1 += 1;
      setDefaultId(`mui-${globalId$1}`);
    }
  }, [defaultId]);
  return id2;
}
__name(useGlobalId, "useGlobalId");
const maybeReactUseId = React$2["useId".toString()];
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
__name(useId, "useId");
function unsupportedProp(props, propName, componentName, location, propFullName) {
  {
    return null;
  }
}
__name(unsupportedProp, "unsupportedProp");
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
__name(useControlled, "useControlled");
function useEventCallback(fn2) {
  const ref = reactExports.useRef(fn2);
  useEnhancedEffect(() => {
    ref.current = fn2;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref.current)(...args)
  )).current;
}
__name(useEventCallback, "useEventCallback");
function useForkRef(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef(ref, instance);
      });
    };
  }, refs);
}
__name(useForkRef, "useForkRef");
const UNINITIALIZED = {};
function useLazyRef(init2, initArg) {
  const ref = reactExports.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init2(initArg);
  }
  return ref;
}
__name(useLazyRef, "useLazyRef");
const EMPTY = [];
function useOnMount(fn2) {
  reactExports.useEffect(fn2, EMPTY);
}
__name(useOnMount, "useOnMount");
const _Timeout = class _Timeout {
  constructor() {
    this.currentId = null;
    this.clear = () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    };
    this.disposeEffect = () => {
      return this.clear;
    };
  }
  static create() {
    return new _Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay2, fn2) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn2();
    }, delay2);
  }
};
__name(_Timeout, "Timeout");
let Timeout = _Timeout;
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
__name(useTimeout, "useTimeout");
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
const hadFocusVisibleRecentlyTimeout = new Timeout();
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node2) {
  const {
    type,
    tagName
  } = node2;
  if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node2.readOnly) {
    return true;
  }
  if (node2.isContentEditable) {
    return true;
  }
  return false;
}
__name(focusTriggersKeyboardModality, "focusTriggersKeyboardModality");
function handleKeyDown$1(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}
__name(handleKeyDown$1, "handleKeyDown$1");
function handlePointerDown() {
  hadKeyboardEvent = false;
}
__name(handlePointerDown, "handlePointerDown");
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
__name(handleVisibilityChange, "handleVisibilityChange");
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown$1, true);
  doc.addEventListener("mousedown", handlePointerDown, true);
  doc.addEventListener("pointerdown", handlePointerDown, true);
  doc.addEventListener("touchstart", handlePointerDown, true);
  doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
__name(prepare, "prepare");
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch (error) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
__name(isFocusVisible, "isFocusVisible");
function useIsFocusVisible() {
  const ref = reactExports.useCallback((node2) => {
    if (node2 != null) {
      prepare(node2.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = reactExports.useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      hadFocusVisibleRecentlyTimeout.start(100, () => {
        hadFocusVisibleRecently = false;
      });
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }
  __name(handleBlurVisible, "handleBlurVisible");
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  __name(handleFocusVisible, "handleFocusVisible");
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}
__name(useIsFocusVisible, "useIsFocusVisible");
function getScrollbarSize$1(doc) {
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
__name(getScrollbarSize$1, "getScrollbarSize$1");
const usePreviousProps = /* @__PURE__ */ __name((value) => {
  const ref = reactExports.useRef({});
  reactExports.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}, "usePreviousProps");
const visuallyHidden = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
function composeClasses(slots, getUtilityClass, classes2 = void 0) {
  const output = {};
  Object.keys(slots).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          const utilityClass = getUtilityClass(key);
          if (utilityClass !== "") {
            acc.push(utilityClass);
          }
          if (classes2 && classes2[key]) {
            acc.push(classes2[key]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output;
}
__name(composeClasses, "composeClasses");
function isHostComponent$1(element) {
  return typeof element === "string";
}
__name(isHostComponent$1, "isHostComponent$1");
function appendOwnerState$1(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent$1(elementType)) {
    return otherProps;
  }
  return _extends$4({}, otherProps, {
    ownerState: _extends$4({}, otherProps.ownerState, ownerState)
  });
}
__name(appendOwnerState$1, "appendOwnerState$1");
function extractEventHandlers$1(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
__name(extractEventHandlers$1, "extractEventHandlers$1");
function omitEventHandlers$1(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
__name(omitEventHandlers$1, "omitEventHandlers$1");
function mergeSlotProps$1(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = _extends$4({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends$4({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers$1(_extends$4({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers$1(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers$1(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends$4({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends$4({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
__name(mergeSlotProps$1, "mergeSlotProps$1");
function resolveComponentProps$1(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
__name(resolveComponentProps$1, "resolveComponentProps$1");
const _excluded$2r = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function useSlotProps$1(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false
  } = parameters, rest = _objectWithoutPropertiesLoose$1(parameters, _excluded$2r);
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps$1(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps$1(_extends$4({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = appendOwnerState$1(elementType, _extends$4({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}
__name(useSlotProps$1, "useSlotProps$1");
const ThemeContext = /* @__PURE__ */ reactExports.createContext(null);
function useTheme$2() {
  const theme2 = reactExports.useContext(ThemeContext);
  return theme2;
}
__name(useTheme$2, "useTheme$2");
const hasSymbol = typeof Symbol === "function" && Symbol.for;
const nested = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === "function") {
    const mergedTheme = localTheme(outerTheme);
    return mergedTheme;
  }
  return _extends$4({}, outerTheme, localTheme);
}
__name(mergeOuterLocalTheme, "mergeOuterLocalTheme");
function ThemeProvider$2(props) {
  const {
    children,
    theme: localTheme
  } = props;
  const outerTheme = useTheme$2();
  const theme2 = reactExports.useMemo(() => {
    const output = outerTheme === null ? localTheme : mergeOuterLocalTheme(outerTheme, localTheme);
    if (output != null) {
      output[nested] = outerTheme !== null;
    }
    return output;
  }, [localTheme, outerTheme]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, {
    value: theme2,
    children
  });
}
__name(ThemeProvider$2, "ThemeProvider$2");
const _excluded$2q = ["value"];
const RtlContext = /* @__PURE__ */ reactExports.createContext();
function RtlProvider(_ref) {
  let {
    value
  } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$2q);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RtlContext.Provider, _extends$4({
    value: value != null ? value : true
  }, props));
}
__name(RtlProvider, "RtlProvider");
const useRtl = /* @__PURE__ */ __name(() => {
  const value = reactExports.useContext(RtlContext);
  return value != null ? value : false;
}, "useRtl");
const PropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
function DefaultPropsProvider({
  value,
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PropsContext.Provider, {
    value,
    children
  });
}
__name(DefaultPropsProvider, "DefaultPropsProvider");
function getThemeProps(params) {
  const {
    theme: theme2,
    name,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name]) {
    return props;
  }
  const config2 = theme2.components[name];
  if (config2.defaultProps) {
    return resolveProps(config2.defaultProps, props);
  }
  if (!config2.styleOverrides && !config2.variants) {
    return resolveProps(config2, props);
  }
  return props;
}
__name(getThemeProps, "getThemeProps");
function useDefaultProps$1({
  props,
  name
}) {
  const ctx = reactExports.useContext(PropsContext);
  return getThemeProps({
    props,
    name,
    theme: {
      components: ctx
    }
  });
}
__name(useDefaultProps$1, "useDefaultProps$1");
const EMPTY_THEME = {};
function useThemeScoping(themeId, upperTheme, localTheme, isPrivate = false) {
  return reactExports.useMemo(() => {
    const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
    if (typeof localTheme === "function") {
      const mergedTheme = localTheme(resolvedTheme);
      const result = themeId ? _extends$4({}, upperTheme, {
        [themeId]: mergedTheme
      }) : mergedTheme;
      if (isPrivate) {
        return () => result;
      }
      return result;
    }
    return themeId ? _extends$4({}, upperTheme, {
      [themeId]: localTheme
    }) : _extends$4({}, upperTheme, localTheme);
  }, [themeId, upperTheme, localTheme, isPrivate]);
}
__name(useThemeScoping, "useThemeScoping");
function ThemeProvider$1(props) {
  const {
    children,
    theme: localTheme,
    themeId
  } = props;
  const upperTheme = useTheme$4(EMPTY_THEME);
  const upperPrivateTheme = useTheme$2() || EMPTY_THEME;
  const engineTheme = useThemeScoping(themeId, upperTheme, localTheme);
  const privateTheme = useThemeScoping(themeId, upperPrivateTheme, localTheme, true);
  const rtlValue = engineTheme.direction === "rtl";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$2, {
    theme: privateTheme,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
      value: engineTheme,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RtlProvider, {
        value: rtlValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultPropsProvider, {
          value: engineTheme == null ? void 0 : engineTheme.components,
          children
        })
      })
    })
  });
}
__name(ThemeProvider$1, "ThemeProvider$1");
function _typeof$5(o) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$5(o);
}
__name(_typeof$5, "_typeof$5");
function toPrimitive(t2, r2) {
  if ("object" != _typeof$5(t2) || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$5(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
__name(toPrimitive, "toPrimitive");
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof$5(i) ? i : i + "";
}
__name(toPropertyKey, "toPropertyKey");
const _excluded$2p = ["className", "component", "disableGutters", "fixed", "maxWidth", "classes"];
const defaultTheme$4 = createTheme$2();
const defaultCreateStyledComponent$1 = styled$1("div", {
  name: "MuiContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`maxWidth${capitalize$1(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
  }
});
const useThemePropsDefault$1 = /* @__PURE__ */ __name((inProps) => useThemeProps$1({
  props: inProps,
  name: "MuiContainer",
  defaultTheme: defaultTheme$4
}), "useThemePropsDefault$1");
const useUtilityClasses$1U = /* @__PURE__ */ __name((ownerState, componentName) => {
  const getContainerUtilityClass = /* @__PURE__ */ __name((slot) => {
    return generateUtilityClass$1(componentName, slot);
  }, "getContainerUtilityClass");
  const {
    classes: classes2,
    fixed,
    disableGutters,
    maxWidth: maxWidth2
  } = ownerState;
  const slots = {
    root: ["root", maxWidth2 && `maxWidth${capitalize$1(String(maxWidth2))}`, fixed && "fixed", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getContainerUtilityClass, classes2);
}, "useUtilityClasses$1U");
function createContainer(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent$1,
    useThemeProps: useThemeProps2 = useThemePropsDefault$1,
    componentName = "MuiContainer"
  } = options;
  const ContainerRoot = createStyledComponent(({
    theme: theme2,
    ownerState
  }) => _extends$4({
    width: "100%",
    marginLeft: "auto",
    boxSizing: "border-box",
    marginRight: "auto",
    display: "block"
  }, !ownerState.disableGutters && {
    paddingLeft: theme2.spacing(2),
    paddingRight: theme2.spacing(2),
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up("sm")]: {
      paddingLeft: theme2.spacing(3),
      paddingRight: theme2.spacing(3)
    }
  }), ({
    theme: theme2,
    ownerState
  }) => ownerState.fixed && Object.keys(theme2.breakpoints.values).reduce((acc, breakpointValueKey) => {
    const breakpoint = breakpointValueKey;
    const value = theme2.breakpoints.values[breakpoint];
    if (value !== 0) {
      acc[theme2.breakpoints.up(breakpoint)] = {
        maxWidth: `${value}${theme2.breakpoints.unit}`
      };
    }
    return acc;
  }, {}), ({
    theme: theme2,
    ownerState
  }) => _extends$4({}, ownerState.maxWidth === "xs" && {
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up("xs")]: {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      maxWidth: Math.max(theme2.breakpoints.values.xs, 444)
    }
  }, ownerState.maxWidth && // @ts-ignore module augmentation fails if custom breakpoints are used
  ownerState.maxWidth !== "xs" && {
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up(ownerState.maxWidth)]: {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      maxWidth: `${theme2.breakpoints.values[ownerState.maxWidth]}${theme2.breakpoints.unit}`
    }
  }));
  const Container2 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Container22(inProps, ref) {
    const props = useThemeProps2(inProps);
    const {
      className,
      component = "div",
      disableGutters = false,
      fixed = false,
      maxWidth: maxWidth2 = "lg"
    } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2p);
    const ownerState = _extends$4({}, props, {
      component,
      disableGutters,
      fixed,
      maxWidth: maxWidth2
    });
    const classes2 = useUtilityClasses$1U(ownerState, componentName);
    return (
      // @ts-ignore theme is injected by the styled util
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerRoot, _extends$4({
        as: component,
        ownerState,
        className: clsx(classes2.root, className),
        ref
      }, other))
    );
  }, "Container2"));
  return Container2;
}
__name(createContainer, "createContainer");
const _excluded$2o = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"];
const defaultTheme$3 = createTheme$2();
const defaultCreateStyledComponent = styled$1("div", {
  name: "MuiStack",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
});
function useThemePropsDefault(props) {
  return useThemeProps$1({
    props,
    name: "MuiStack",
    defaultTheme: defaultTheme$3
  });
}
__name(useThemePropsDefault, "useThemePropsDefault");
function joinChildren(children, separator) {
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  return childrenArray.reduce((output, child, index2) => {
    output.push(child);
    if (index2 < childrenArray.length - 1) {
      output.push(/* @__PURE__ */ reactExports.cloneElement(separator, {
        key: `separator-${index2}`
      }));
    }
    return output;
  }, []);
}
__name(joinChildren, "joinChildren");
const getSideFromDirection = /* @__PURE__ */ __name((direction) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction];
}, "getSideFromDirection");
const style$d = /* @__PURE__ */ __name(({
  ownerState,
  theme: theme2
}) => {
  let styles2 = _extends$4({
    display: "flex",
    flexDirection: "column"
  }, handleBreakpoints({
    theme: theme2
  }, resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme2.breakpoints.values
  }), (propValue) => ({
    flexDirection: propValue
  })));
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme2);
    const base = Object.keys(theme2.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index2, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index2 > 0 ? directionValues[breakpoints[index2 - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = /* @__PURE__ */ __name((propValue, breakpoint) => {
      if (ownerState.useFlexGap) {
        return {
          gap: getValue$1(transformer, propValue)
        };
      }
      return {
        // The useFlexGap={false} implement relies on each child to give up control of the margin.
        // We need to reset the margin to avoid double spacing.
        "& > :not(style):not(style)": {
          margin: 0
        },
        "& > :not(style) ~ :not(style)": {
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue$1(transformer, propValue)
        }
      };
    }, "styleFromPropValue");
    styles2 = deepmerge$1(styles2, handleBreakpoints({
      theme: theme2
    }, spacingValues, styleFromPropValue));
  }
  styles2 = mergeBreakpointsInOrder(theme2.breakpoints, styles2);
  return styles2;
}, "style$d");
function createStack(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    componentName = "MuiStack"
  } = options;
  const useUtilityClasses2 = /* @__PURE__ */ __name(() => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, (slot) => generateUtilityClass$1(componentName, slot), {});
  }, "useUtilityClasses");
  const StackRoot = createStyledComponent(style$d);
  const Stack2 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Grid2(inProps, ref) {
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp(themeProps);
    const {
      component = "div",
      direction = "column",
      spacing = 0,
      divider,
      children,
      className,
      useFlexGap = false
    } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2o);
    const ownerState = {
      direction,
      spacing,
      useFlexGap
    };
    const classes2 = useUtilityClasses2();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StackRoot, _extends$4({
      as: component,
      ownerState,
      ref,
      className: clsx(classes2.root, className)
    }, other, {
      children: divider ? joinChildren(children, divider) : children
    }));
  }, "Grid"));
  return Stack2;
}
__name(createStack, "createStack");
function createMixins(breakpoints, mixins) {
  return _extends$4({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
__name(createMixins, "createMixins");
var colorManipulator = {};
var interopRequireDefault = { exports: {} };
(function(module) {
  function _interopRequireDefault2(e2) {
    return e2 && e2.__esModule ? e2 : {
      "default": e2
    };
  }
  __name(_interopRequireDefault2, "_interopRequireDefault");
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(formatMuiErrorMessage);
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(clamp$4);
var _interopRequireDefault$B = interopRequireDefaultExports;
Object.defineProperty(colorManipulator, "__esModule", {
  value: true
});
var alpha_1 = colorManipulator.alpha = alpha$1;
colorManipulator.blend = blend$1;
colorManipulator.colorChannel = void 0;
var darken_1 = colorManipulator.darken = darken;
colorManipulator.decomposeColor = decomposeColor;
colorManipulator.emphasize = emphasize;
var getContrastRatio_1 = colorManipulator.getContrastRatio = getContrastRatio;
colorManipulator.getLuminance = getLuminance;
colorManipulator.hexToRgb = hexToRgb;
colorManipulator.hslToRgb = hslToRgb;
var lighten_1 = colorManipulator.lighten = lighten;
colorManipulator.private_safeAlpha = private_safeAlpha;
colorManipulator.private_safeColorChannel = void 0;
colorManipulator.private_safeDarken = private_safeDarken;
colorManipulator.private_safeEmphasize = private_safeEmphasize;
colorManipulator.private_safeLighten = private_safeLighten;
colorManipulator.recomposeColor = recomposeColor;
colorManipulator.rgbToHex = rgbToHex;
var _formatMuiErrorMessage2 = _interopRequireDefault$B(require$$1$1);
var _clamp = _interopRequireDefault$B(require$$2);
function clampWrapper(value, min2 = 0, max2 = 1) {
  return (0, _clamp.default)(value, min2, max2);
}
__name(clampWrapper, "clampWrapper");
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re2);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n2) => n2 + n2);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index2) => {
    return index2 < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
__name(hexToRgb, "hexToRgb");
function intToHex(int2) {
  const hex2 = int2.toString(16);
  return hex2.length === 1 ? `0${hex2}` : hex2;
}
__name(intToHex, "intToHex");
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
    throw new Error((0, _formatMuiErrorMessage2.default)(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error((0, _formatMuiErrorMessage2.default)(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
__name(decomposeColor, "decomposeColor");
const colorChannel = /* @__PURE__ */ __name((color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.indexOf("hsl") !== -1 && idx !== 0 ? `${val}%` : val).join(" ");
}, "colorChannel");
colorManipulator.colorChannel = colorChannel;
const private_safeColorChannel = /* @__PURE__ */ __name((color2, warning2) => {
  try {
    return colorChannel(color2);
  } catch (error) {
    if (warning2 && false) {
      console.warn(warning2);
    }
    return color2;
  }
}, "private_safeColorChannel");
colorManipulator.private_safeColorChannel = private_safeColorChannel;
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.indexOf("rgb") !== -1) {
    values2 = values2.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
  } else if (type.indexOf("hsl") !== -1) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.indexOf("color") !== -1) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
__name(recomposeColor, "recomposeColor");
function rgbToHex(color2) {
  if (color2.indexOf("#") === 0) {
    return color2;
  }
  const {
    values: values2
  } = decomposeColor(color2);
  return `#${values2.map((n2, i) => intToHex(i === 3 ? Math.round(255 * n2) : n2)).join("")}`;
}
__name(rgbToHex, "rgbToHex");
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h2 = values2[0];
  const s = values2[1] / 100;
  const l2 = values2[2] / 100;
  const a = s * Math.min(l2, 1 - l2);
  const f2 = /* @__PURE__ */ __name((n2, k2 = (n2 + h2 / 30) % 12) => l2 - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1), "f");
  let type = "rgb";
  const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
__name(hslToRgb, "hslToRgb");
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
__name(getLuminance, "getLuminance");
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
__name(getContrastRatio, "getContrastRatio");
function alpha$1(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
__name(alpha$1, "alpha$1");
function private_safeAlpha(color2, value, warning2) {
  try {
    return alpha$1(color2, value);
  } catch (error) {
    if (warning2 && false) {
      console.warn(warning2);
    }
    return color2;
  }
}
__name(private_safeAlpha, "private_safeAlpha");
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
__name(darken, "darken");
function private_safeDarken(color2, coefficient, warning2) {
  try {
    return darken(color2, coefficient);
  } catch (error) {
    if (warning2 && false) {
      console.warn(warning2);
    }
    return color2;
  }
}
__name(private_safeDarken, "private_safeDarken");
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.indexOf("rgb") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (255 - color2.values[i]) * coefficient;
    }
  } else if (color2.type.indexOf("color") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (1 - color2.values[i]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
__name(lighten, "lighten");
function private_safeLighten(color2, coefficient, warning2) {
  try {
    return lighten(color2, coefficient);
  } catch (error) {
    if (warning2 && false) {
      console.warn(warning2);
    }
    return color2;
  }
}
__name(private_safeLighten, "private_safeLighten");
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
__name(emphasize, "emphasize");
function private_safeEmphasize(color2, coefficient, warning2) {
  try {
    return emphasize(color2, coefficient);
  } catch (error) {
    if (warning2 && false) {
      console.warn(warning2);
    }
    return color2;
  }
}
__name(private_safeEmphasize, "private_safeEmphasize");
function blend$1(background, overlay, opacity, gamma = 1) {
  const blendChannel = /* @__PURE__ */ __name((b2, o) => Math.round((b2 ** (1 / gamma) * (1 - opacity) + o ** (1 / gamma) * opacity) ** gamma), "blendChannel");
  const backgroundColor2 = decomposeColor(background);
  const overlayColor = decomposeColor(overlay);
  const rgb = [blendChannel(backgroundColor2.values[0], overlayColor.values[0]), blendChannel(backgroundColor2.values[1], overlayColor.values[1]), blendChannel(backgroundColor2.values[2], overlayColor.values[2])];
  return recomposeColor({
    type: "rgb",
    values: rgb
  });
}
__name(blend$1, "blend$1");
const common = {
  black: "#000",
  white: "#fff"
};
const grey$1 = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
const _excluded$2n = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common.white,
    default: common.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten_1(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken_1(intent.main, tonalOffsetDark);
    }
  }
}
__name(addLightOrDark, "addLightOrDark");
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
__name(getDefaultPrimary, "getDefaultPrimary");
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
__name(getDefaultSecondary, "getDefaultSecondary");
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
__name(getDefaultError, "getDefaultError");
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
__name(getDefaultInfo, "getDefaultInfo");
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
__name(getDefaultSuccess, "getDefaultSuccess");
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
__name(getDefaultWarning, "getDefaultWarning");
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette, other = _objectWithoutPropertiesLoose$1(palette, _excluded$2n);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning2 = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio_1(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  __name(getContrastText, "getContrastText");
  const augmentColor = /* @__PURE__ */ __name(({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = _extends$4({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage$1(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage$1(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  }, "augmentColor");
  const modes = {
    dark,
    light
  };
  const paletteOutput = deepmerge$1(_extends$4({
    // A collection of common colors.
    common: _extends$4({}, common),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey: grey$1,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}
__name(createPalette, "createPalette");
const _excluded$2m = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round$5(value) {
  return Math.round(value * 1e5) / 1e5;
}
__name(round$5, "round$5");
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const _ref = typeof typography === "function" ? typography(palette) : typography, {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose$1(_ref, _excluded$2m);
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size2) => `${size2 / htmlFontSize * coef}rem`);
  const buildVariant = /* @__PURE__ */ __name((fontWeight, size2, lineHeight, letterSpacing, casing) => _extends$4({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size2),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round$5(letterSpacing / size2)}em`
  } : {}, casing, allVariants), "buildVariant");
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge$1(_extends$4({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
__name(createTypography, "createTypography");
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px2) {
  return [`${px2[0]}px ${px2[1]}px ${px2[2]}px ${px2[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px2[4]}px ${px2[5]}px ${px2[6]}px ${px2[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px2[8]}px ${px2[9]}px ${px2[10]}px ${px2[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
__name(createShadow, "createShadow");
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const _excluded$2l = ["duration", "easing", "delay"];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
__name(formatMs, "formatMs");
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
__name(getAutoHeightDuration, "getAutoHeightDuration");
function createTransitions(inputTransitions) {
  const mergedEasing = _extends$4({}, easing, inputTransitions.easing);
  const mergedDuration = _extends$4({}, duration, inputTransitions.duration);
  const create = /* @__PURE__ */ __name((props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay: delay2 = 0
    } = options;
    _objectWithoutPropertiesLoose$1(options, _excluded$2l);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay2 === "string" ? delay2 : formatMs(delay2)}`).join(",");
  }, "create");
  return _extends$4({
    getAutoHeightDuration,
    create
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
__name(createTransitions, "createTransitions");
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
const _excluded$2k = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$2k);
  if (options.vars) {
    throw new Error(formatMuiErrorMessage$1(18));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$2(options);
  let muiTheme = deepmerge$1(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends$4({}, zIndex)
  });
  muiTheme = deepmerge$1(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge$1(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$4({}, defaultSxConfig, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = /* @__PURE__ */ __name(function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  }, "sx");
  return muiTheme;
}
__name(createTheme, "createTheme");
function getUnit(input) {
  return String(input).match(/[\d.\-+]*\s*(.*)/)[1] || "";
}
__name(getUnit, "getUnit");
function toUnitless(length2) {
  return parseFloat(length2);
}
__name(toUnitless, "toUnitless");
const defaultTheme$2 = createTheme();
function useTheme$1() {
  const theme2 = useTheme$3(defaultTheme$2);
  return theme2[THEME_ID] || theme2;
}
__name(useTheme$1, "useTheme$1");
function useThemeProps({
  props,
  name
}) {
  return useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme$2,
    themeId: THEME_ID
  });
}
__name(useThemeProps, "useThemeProps");
var createStyled$1 = {};
var objectWithoutPropertiesLoose = { exports: {} };
var hasRequiredObjectWithoutPropertiesLoose;
function requireObjectWithoutPropertiesLoose() {
  if (hasRequiredObjectWithoutPropertiesLoose)
    return objectWithoutPropertiesLoose.exports;
  hasRequiredObjectWithoutPropertiesLoose = 1;
  (function(module) {
    function _objectWithoutPropertiesLoose3(r2, e2) {
      if (null == r2)
        return {};
      var t2 = {};
      for (var n2 in r2)
        if ({}.hasOwnProperty.call(r2, n2)) {
          if (e2.includes(n2))
            continue;
          t2[n2] = r2[n2];
        }
      return t2;
    }
    __name(_objectWithoutPropertiesLoose3, "_objectWithoutPropertiesLoose");
    module.exports = _objectWithoutPropertiesLoose3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(objectWithoutPropertiesLoose);
  return objectWithoutPropertiesLoose.exports;
}
__name(requireObjectWithoutPropertiesLoose, "requireObjectWithoutPropertiesLoose");
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(styledEngine);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(deepmerge);
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(capitalize);
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(getDisplayName);
const require$$7 = /* @__PURE__ */ getAugmentedNamespace(createTheme$1);
const require$$8$1 = /* @__PURE__ */ getAugmentedNamespace(styleFunctionSx);
var _interopRequireDefault$A = interopRequireDefaultExports;
Object.defineProperty(createStyled$1, "__esModule", {
  value: true
});
var _default = createStyled$1.default = createStyled2;
createStyled$1.shouldForwardProp = shouldForwardProp;
createStyled$1.systemDefaultTheme = void 0;
var _extends2 = _interopRequireDefault$A(require_extends());
var _objectWithoutPropertiesLoose2 = _interopRequireDefault$A(requireObjectWithoutPropertiesLoose());
var _styledEngine$1 = _interopRequireWildcard$1(require$$1);
var _deepmerge = require$$4;
_interopRequireDefault$A(require$$5);
_interopRequireDefault$A(require$$6);
var _createTheme = _interopRequireDefault$A(require$$7);
var _styleFunctionSx = _interopRequireDefault$A(require$$8$1);
const _excluded$2j = ["ownerState"], _excluded2$h = ["variants"], _excluded3$4 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function _getRequireWildcardCache$1(e2) {
  if ("function" != typeof WeakMap)
    return null;
  var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache$1 = /* @__PURE__ */ __name(function(e22) {
    return e22 ? t2 : r2;
  }, "_getRequireWildcardCache$1"))(e2);
}
__name(_getRequireWildcardCache$1, "_getRequireWildcardCache$1");
function _interopRequireWildcard$1(e2, r2) {
  if (e2 && e2.__esModule)
    return e2;
  if (null === e2 || "object" != typeof e2 && "function" != typeof e2)
    return { default: e2 };
  var t2 = _getRequireWildcardCache$1(r2);
  if (t2 && t2.has(e2))
    return t2.get(e2);
  var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u2 in e2)
    if ("default" !== u2 && Object.prototype.hasOwnProperty.call(e2, u2)) {
      var i = a ? Object.getOwnPropertyDescriptor(e2, u2) : null;
      i && (i.get || i.set) ? Object.defineProperty(n2, u2, i) : n2[u2] = e2[u2];
    }
  return n2.default = e2, t2 && t2.set(e2, n2), n2;
}
__name(_interopRequireWildcard$1, "_interopRequireWildcard$1");
function isEmpty$2(obj) {
  return Object.keys(obj).length === 0;
}
__name(isEmpty$2, "isEmpty$2");
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
__name(isStringTag, "isStringTag");
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
__name(shouldForwardProp, "shouldForwardProp");
const systemDefaultTheme = createStyled$1.systemDefaultTheme = (0, _createTheme.default)();
const lowercaseFirstLetter = /* @__PURE__ */ __name((string) => {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}, "lowercaseFirstLetter");
function resolveTheme({
  defaultTheme: defaultTheme2,
  theme: theme2,
  themeId
}) {
  return isEmpty$2(theme2) ? defaultTheme2 : theme2[themeId] || theme2;
}
__name(resolveTheme, "resolveTheme");
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (props, styles2) => styles2[slot];
}
__name(defaultOverridesResolver, "defaultOverridesResolver");
function processStyleArg(callableStyle, _ref) {
  let {
    ownerState
  } = _ref, props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded$2j);
  const resolvedStylesArg = typeof callableStyle === "function" ? callableStyle((0, _extends2.default)({
    ownerState
  }, props)) : callableStyle;
  if (Array.isArray(resolvedStylesArg)) {
    return resolvedStylesArg.flatMap((resolvedStyle) => processStyleArg(resolvedStyle, (0, _extends2.default)({
      ownerState
    }, props)));
  }
  if (!!resolvedStylesArg && typeof resolvedStylesArg === "object" && Array.isArray(resolvedStylesArg.variants)) {
    const {
      variants = []
    } = resolvedStylesArg, otherStyles = (0, _objectWithoutPropertiesLoose2.default)(resolvedStylesArg, _excluded2$h);
    let result = otherStyles;
    variants.forEach((variant) => {
      let isMatch = true;
      if (typeof variant.props === "function") {
        isMatch = variant.props((0, _extends2.default)({
          ownerState
        }, props, ownerState));
      } else {
        Object.keys(variant.props).forEach((key) => {
          if ((ownerState == null ? void 0 : ownerState[key]) !== variant.props[key] && props[key] !== variant.props[key]) {
            isMatch = false;
          }
        });
      }
      if (isMatch) {
        if (!Array.isArray(result)) {
          result = [result];
        }
        result.push(typeof variant.style === "function" ? variant.style((0, _extends2.default)({
          ownerState
        }, props, ownerState)) : variant.style);
      }
    });
    return result;
  }
  return resolvedStylesArg;
}
__name(processStyleArg, "processStyleArg");
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  const systemSx = /* @__PURE__ */ __name((props) => {
    return (0, _styleFunctionSx.default)((0, _extends2.default)({}, props, {
      theme: resolveTheme((0, _extends2.default)({}, props, {
        defaultTheme: defaultTheme2,
        themeId
      }))
    }));
  }, "systemSx");
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    (0, _styledEngine$1.internal_processStyles)(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
    } = inputOptions, options = (0, _objectWithoutPropertiesLoose2.default)(inputOptions, _excluded3$4);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = (0, _styledEngine$1.default)(tag, (0, _extends2.default)({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const transformStyleArg = /* @__PURE__ */ __name((stylesArg) => {
      if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg || (0, _deepmerge.isPlainObject)(stylesArg)) {
        return (props) => processStyleArg(stylesArg, (0, _extends2.default)({}, props, {
          theme: resolveTheme({
            theme: props.theme,
            defaultTheme: defaultTheme2,
            themeId
          })
        }));
      }
      return stylesArg;
    }, "transformStyleArg");
    const muiStyledResolver = /* @__PURE__ */ __name((styleArg, ...expressions) => {
      let transformedStyleArg = transformStyleArg(styleArg);
      const expressionsWithDefaultTheme = expressions ? expressions.map(transformStyleArg) : [];
      if (componentName && overridesResolver2) {
        expressionsWithDefaultTheme.push((props) => {
          const theme2 = resolveTheme((0, _extends2.default)({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          if (!theme2.components || !theme2.components[componentName] || !theme2.components[componentName].styleOverrides) {
            return null;
          }
          const styleOverrides = theme2.components[componentName].styleOverrides;
          const resolvedStyleOverrides = {};
          Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
            resolvedStyleOverrides[slotKey] = processStyleArg(slotStyle, (0, _extends2.default)({}, props, {
              theme: theme2
            }));
          });
          return overridesResolver2(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          var _theme$components;
          const theme2 = resolveTheme((0, _extends2.default)({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          const themeVariants = theme2 == null || (_theme$components = theme2.components) == null || (_theme$components = _theme$components[componentName]) == null ? void 0 : _theme$components.variants;
          return processStyleArg({
            variants: themeVariants
          }, (0, _extends2.default)({}, props, {
            theme: theme2
          }));
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      }
      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    }, "muiStyledResolver");
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
__name(createStyled2, "createStyled");
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
__name(slotShouldForwardProp, "slotShouldForwardProp");
const rootShouldForwardProp = /* @__PURE__ */ __name((prop) => slotShouldForwardProp(prop) && prop !== "classes", "rootShouldForwardProp");
const styled = _default({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$2,
  rootShouldForwardProp
});
const _excluded$2i = ["theme"];
function ThemeProvider2(_ref) {
  let {
    theme: themeInput
  } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$2i);
  const scopedTheme = themeInput[THEME_ID];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, _extends$4({}, props, {
    themeId: scopedTheme ? THEME_ID : void 0,
    theme: scopedTheme || themeInput
  }));
}
__name(ThemeProvider2, "ThemeProvider");
const getOverlayAlpha = /* @__PURE__ */ __name((elevation) => {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return (alphaValue / 100).toFixed(2);
}, "getOverlayAlpha");
const boxClasses = generateUtilityClasses$1("MuiBox", ["root"]);
const defaultTheme$1 = createTheme();
const Box = createBox$1({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  defaultClassName: boxClasses.root,
  generateClassName: ClassNameGenerator.generate
});
const TableContext = /* @__PURE__ */ reactExports.createContext();
function useDefaultProps(params) {
  return useDefaultProps$1(params);
}
__name(useDefaultProps, "useDefaultProps");
function getTableUtilityClass(slot) {
  return generateUtilityClass$1("MuiTable", slot);
}
__name(getTableUtilityClass, "getTableUtilityClass");
generateUtilityClasses$1("MuiTable", ["root", "stickyHeader"]);
const _excluded$2h = ["className", "component", "padding", "size", "stickyHeader"];
const useUtilityClasses$1T = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", stickyHeader && "stickyHeader"]
  };
  return composeClasses(slots, getTableUtilityClass, classes2);
}, "useUtilityClasses$1T");
const TableRoot$1 = styled("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": _extends$4({}, theme2.typography.body2, {
    padding: theme2.spacing(2),
    color: (theme2.vars || theme2).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  })
}, ownerState.stickyHeader && {
  borderCollapse: "separate"
}));
const defaultComponent$3 = "table";
const Table$1 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Table2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTable"
  });
  const {
    className,
    component = defaultComponent$3,
    padding: padding2 = "normal",
    size: size2 = "medium",
    stickyHeader = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2h);
  const ownerState = _extends$4({}, props, {
    component,
    padding: padding2,
    size: size2,
    stickyHeader
  });
  const classes2 = useUtilityClasses$1T(ownerState);
  const table = reactExports.useMemo(() => ({
    padding: padding2,
    size: size2,
    stickyHeader
  }), [padding2, size2, stickyHeader]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext.Provider, {
    value: table,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot$1, _extends$4({
      as: component,
      role: component === defaultComponent$3 ? null : "table",
      ref,
      className: clsx(classes2.root, className),
      ownerState
    }, other))
  });
}, "Table2"));
const Tablelvl2Context = /* @__PURE__ */ reactExports.createContext();
function getTableBodyUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableBody", slot);
}
__name(getTableBodyUtilityClass, "getTableBodyUtilityClass");
generateUtilityClasses$1("MuiTableBody", ["root"]);
const _excluded$2g = ["className", "component"];
const useUtilityClasses$1S = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableBodyUtilityClass, classes2);
}, "useUtilityClasses$1S");
const TableBodyRoot = styled("tbody", {
  name: "MuiTableBody",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "table-row-group"
});
const tablelvl2$1 = {
  variant: "body"
};
const defaultComponent$2 = "tbody";
const TableBody = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TableBody2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableBody"
  });
  const {
    className,
    component = defaultComponent$2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2g);
  const ownerState = _extends$4({}, props, {
    component
  });
  const classes2 = useUtilityClasses$1S(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2$1,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBodyRoot, _extends$4({
      className: clsx(classes2.root, className),
      as: component,
      ref,
      role: component === defaultComponent$2 ? null : "rowgroup",
      ownerState
    }, other))
  });
}, "TableBody2"));
function getTableCellUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableCell", slot);
}
__name(getTableCellUtilityClass, "getTableCellUtilityClass");
const tableCellClasses = generateUtilityClasses$1("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
const _excluded$2f = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"];
const useUtilityClasses$1R = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    variant,
    align,
    padding: padding2,
    size: size2,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize$1(align)}`, padding2 !== "normal" && `padding${capitalize$1(padding2)}`, `size${capitalize$1(size2)}`]
  };
  return composeClasses(slots, getTableCellUtilityClass, classes2);
}, "useUtilityClasses$1R");
const TableCellRoot = styled("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize$1(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize$1(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize$1(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({}, theme2.typography.body2, {
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: theme2.vars ? `1px solid ${theme2.vars.palette.TableCell.border}` : `1px solid
    ${theme2.palette.mode === "light" ? lighten_1(alpha_1(theme2.palette.divider, 1), 0.88) : darken_1(alpha_1(theme2.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16
}, ownerState.variant === "head" && {
  color: (theme2.vars || theme2).palette.text.primary,
  lineHeight: theme2.typography.pxToRem(24),
  fontWeight: theme2.typography.fontWeightMedium
}, ownerState.variant === "body" && {
  color: (theme2.vars || theme2).palette.text.primary
}, ownerState.variant === "footer" && {
  color: (theme2.vars || theme2).palette.text.secondary,
  lineHeight: theme2.typography.pxToRem(21),
  fontSize: theme2.typography.pxToRem(12)
}, ownerState.size === "small" && {
  padding: "6px 16px",
  [`&.${tableCellClasses.paddingCheckbox}`]: {
    width: 24,
    // prevent the checkbox column from growing
    padding: "0 12px 0 16px",
    "& > *": {
      padding: 0
    }
  }
}, ownerState.padding === "checkbox" && {
  width: 48,
  // prevent the checkbox column from growing
  padding: "0 0 0 4px"
}, ownerState.padding === "none" && {
  padding: 0
}, ownerState.align === "left" && {
  textAlign: "left"
}, ownerState.align === "center" && {
  textAlign: "center"
}, ownerState.align === "right" && {
  textAlign: "right",
  flexDirection: "row-reverse"
}, ownerState.align === "justify" && {
  textAlign: "justify"
}, ownerState.stickyHeader && {
  position: "sticky",
  top: 0,
  zIndex: 2,
  backgroundColor: (theme2.vars || theme2).palette.background.default
}));
const TableCell = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TableCell2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableCell"
  });
  const {
    align = "inherit",
    className,
    component: componentProp,
    padding: paddingProp,
    scope: scopeProp,
    size: sizeProp,
    sortDirection,
    variant: variantProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2f);
  const table = reactExports.useContext(TableContext);
  const tablelvl22 = reactExports.useContext(Tablelvl2Context);
  const isHeadCell = tablelvl22 && tablelvl22.variant === "head";
  let component;
  if (componentProp) {
    component = componentProp;
  } else {
    component = isHeadCell ? "th" : "td";
  }
  let scope = scopeProp;
  if (component === "td") {
    scope = void 0;
  } else if (!scope && isHeadCell) {
    scope = "col";
  }
  const variant = variantProp || tablelvl22 && tablelvl22.variant;
  const ownerState = _extends$4({}, props, {
    align,
    component,
    padding: paddingProp || (table && table.padding ? table.padding : "normal"),
    size: sizeProp || (table && table.size ? table.size : "medium"),
    sortDirection,
    stickyHeader: variant === "head" && table && table.stickyHeader,
    variant
  });
  const classes2 = useUtilityClasses$1R(ownerState);
  let ariaSort = null;
  if (sortDirection) {
    ariaSort = sortDirection === "asc" ? "ascending" : "descending";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableCellRoot, _extends$4({
    as: component,
    ref,
    className: clsx(classes2.root, className),
    "aria-sort": ariaSort,
    scope,
    ownerState
  }, other));
}, "TableCell2"));
function getTableContainerUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableContainer", slot);
}
__name(getTableContainerUtilityClass, "getTableContainerUtilityClass");
generateUtilityClasses$1("MuiTableContainer", ["root"]);
const _excluded$2e = ["className", "component"];
const useUtilityClasses$1Q = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableContainerUtilityClass, classes2);
}, "useUtilityClasses$1Q");
const TableContainerRoot = styled("div", {
  name: "MuiTableContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  width: "100%",
  overflowX: "auto"
});
const TableContainer = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TableContainer2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableContainer"
  });
  const {
    className,
    component = "div"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2e);
  const ownerState = _extends$4({}, props, {
    component
  });
  const classes2 = useUtilityClasses$1Q(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainerRoot, _extends$4({
    ref,
    as: component,
    className: clsx(classes2.root, className),
    ownerState
  }, other));
}, "TableContainer2"));
function getTableHeadUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableHead", slot);
}
__name(getTableHeadUtilityClass, "getTableHeadUtilityClass");
generateUtilityClasses$1("MuiTableHead", ["root"]);
const _excluded$2d = ["className", "component"];
const useUtilityClasses$1P = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableHeadUtilityClass, classes2);
}, "useUtilityClasses$1P");
const TableHeadRoot = styled("thead", {
  name: "MuiTableHead",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "table-header-group"
});
const tablelvl2 = {
  variant: "head"
};
const defaultComponent$1 = "thead";
const TableHead = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TableHead2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableHead"
  });
  const {
    className,
    component = defaultComponent$1
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2d);
  const ownerState = _extends$4({}, props, {
    component
  });
  const classes2 = useUtilityClasses$1P(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeadRoot, _extends$4({
      as: component,
      className: clsx(classes2.root, className),
      ref,
      role: component === defaultComponent$1 ? null : "rowgroup",
      ownerState
    }, other))
  });
}, "TableHead2"));
const _excluded$2c = ["onChange", "maxRows", "minRows", "style", "value"];
function getStyleValue(value) {
  return parseInt(value, 10) || 0;
}
__name(getStyleValue, "getStyleValue");
const styles$e = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isEmpty$1(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflowing;
}
__name(isEmpty$1, "isEmpty$1");
const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TextareaAutosize2(props, forwardedRef) {
  const {
    onChange,
    maxRows,
    minRows = 1,
    style: style2,
    value
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2c);
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef(null);
  const handleRef = useForkRef(forwardedRef, inputRef);
  const heightRef = reactExports.useRef(null);
  const shadowRef = reactExports.useRef(null);
  const calculateTextareaStyles = reactExports.useCallback(() => {
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    const computedStyle = containerWindow.getComputedStyle(input);
    if (computedStyle.width === "0px") {
      return {
        outerHeightStyle: 0,
        overflowing: false
      };
    }
    const inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || "x";
    if (inputShallow.value.slice(-1) === "\n") {
      inputShallow.value += " ";
    }
    const boxSizing2 = computedStyle.boxSizing;
    const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
    const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
    const innerHeight = inputShallow.scrollHeight;
    inputShallow.value = "x";
    const singleRowHeight = inputShallow.scrollHeight;
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
    const overflowing = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflowing
    };
  }, [maxRows, minRows, props.placeholder]);
  const syncHeight = reactExports.useCallback(() => {
    const textareaStyles = calculateTextareaStyles();
    if (isEmpty$1(textareaStyles)) {
      return;
    }
    const outerHeightStyle = textareaStyles.outerHeightStyle;
    const input = inputRef.current;
    if (heightRef.current !== outerHeightStyle) {
      heightRef.current = outerHeightStyle;
      input.style.height = `${outerHeightStyle}px`;
    }
    input.style.overflow = textareaStyles.overflowing ? "hidden" : "";
  }, [calculateTextareaStyles]);
  useEnhancedEffect(() => {
    const handleResize = /* @__PURE__ */ __name(() => {
      syncHeight();
    }, "handleResize");
    let rAF;
    const debounceHandleResize = debounce$2(handleResize);
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    containerWindow.addEventListener("resize", debounceHandleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(input);
    }
    return () => {
      debounceHandleResize.clear();
      cancelAnimationFrame(rAF);
      containerWindow.removeEventListener("resize", debounceHandleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [calculateTextareaStyles, syncHeight]);
  useEnhancedEffect(() => {
    syncHeight();
  });
  const handleChange = /* @__PURE__ */ __name((event) => {
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  }, "handleChange");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", _extends$4({
      value,
      onChange: handleChange,
      ref: handleRef,
      rows: minRows,
      style: style2
    }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: shadowRef,
      tabIndex: -1,
      style: _extends$4({}, styles$e.shadow, style2, {
        paddingTop: 0,
        paddingBottom: 0
      })
    })]
  });
}, "TextareaAutosize2"));
function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state) => {
    acc[state] = props[state];
    if (muiFormControl) {
      if (typeof props[state] === "undefined") {
        acc[state] = muiFormControl[state];
      }
    }
    return acc;
  }, {});
}
__name(formControlState, "formControlState");
const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useFormControl() {
  return reactExports.useContext(FormControlContext);
}
__name(useFormControl, "useFormControl");
function GlobalStyles(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, _extends$4({}, props, {
    defaultTheme: defaultTheme$2,
    themeId: THEME_ID
  }));
}
__name(GlobalStyles, "GlobalStyles");
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
__name(hasValue, "hasValue");
function isFilled(obj, SSR = false) {
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
__name(isFilled, "isFilled");
function isAdornedStart(obj) {
  return obj.startAdornment;
}
__name(isAdornedStart, "isAdornedStart");
function getInputBaseUtilityClass(slot) {
  return generateUtilityClass$1("MuiInputBase", slot);
}
__name(getInputBaseUtilityClass, "getInputBaseUtilityClass");
const inputBaseClasses = generateUtilityClasses$1("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
const _excluded$2b = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
const rootOverridesResolver = /* @__PURE__ */ __name((props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
}, "rootOverridesResolver");
const inputOverridesResolver = /* @__PURE__ */ __name((props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
}, "inputOverridesResolver");
const useUtilityClasses$1O = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    color: color2,
    disabled,
    error,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size: size2,
    startAdornment,
    type
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size2 && size2 !== "medium" && `size${capitalize$1(size2)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
    input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size2 === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
  };
  return composeClasses(slots, getInputBaseUtilityClass, classes2);
}, "useUtilityClasses$1O");
const InputBaseRoot = styled("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$4({}, theme2.typography.body1, {
  color: (theme2.vars || theme2).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled,
    cursor: "default"
  }
}, ownerState.multiline && _extends$4({
  padding: "4px 0 5px"
}, ownerState.size === "small" && {
  paddingTop: 1
}), ownerState.fullWidth && {
  width: "100%"
}));
const InputBaseComponent = styled("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => {
  const light2 = theme2.palette.mode === "light";
  const placeholder = _extends$4({
    color: "currentColor"
  }, theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  }, {
    transition: theme2.transitions.create("opacity", {
      duration: theme2.transitions.duration.shorter
    })
  });
  const placeholderHidden = {
    opacity: "0 !important"
  };
  const placeholderVisible = theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  };
  return _extends$4({
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    // Fix IE11 width issue
    animationName: "mui-auto-fill-cancel",
    animationDuration: "10ms",
    "&::-webkit-input-placeholder": placeholder,
    "&::-moz-placeholder": placeholder,
    // Firefox 19+
    "&:-ms-input-placeholder": placeholder,
    // IE11
    "&::-ms-input-placeholder": placeholder,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
      "&::-webkit-input-placeholder": placeholderHidden,
      "&::-moz-placeholder": placeholderHidden,
      // Firefox 19+
      "&:-ms-input-placeholder": placeholderHidden,
      // IE11
      "&::-ms-input-placeholder": placeholderHidden,
      // Edge
      "&:focus::-webkit-input-placeholder": placeholderVisible,
      "&:focus::-moz-placeholder": placeholderVisible,
      // Firefox 19+
      "&:focus:-ms-input-placeholder": placeholderVisible,
      // IE11
      "&:focus::-ms-input-placeholder": placeholderVisible
      // Edge
    },
    [`&.${inputBaseClasses.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (theme2.vars || theme2).palette.text.disabled
      // Fix opacity Safari bug
    },
    "&:-webkit-autofill": {
      animationDuration: "5000s",
      animationName: "mui-auto-fill"
    }
  }, ownerState.size === "small" && {
    paddingTop: 1
  }, ownerState.multiline && {
    height: "auto",
    resize: "none",
    padding: 0,
    paddingTop: 0
  }, ownerState.type === "search" && {
    // Improve type search style.
    MozAppearance: "textfield"
  });
});
const inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
  styles: {
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }
});
const InputBase = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function InputBase2(inProps, ref) {
  var _slotProps$input;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInputBase"
  });
  const {
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    disableInjectingGlobalStyles,
    endAdornment,
    fullWidth = false,
    id: id2,
    inputComponent = "input",
    inputProps: inputPropsProp = {},
    inputRef: inputRefProp,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onClick,
    onFocus,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    renderSuffix,
    rows,
    slotProps = {},
    slots = {},
    startAdornment,
    type = "text",
    value: valueProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2b);
  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef();
  const handleInputRefWarning = reactExports.useCallback((instance) => {
  }, []);
  const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
  const [focused, setFocused] = reactExports.useState(false);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  reactExports.useEffect(() => {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  const onFilled = muiFormControl && muiFormControl.onFilled;
  const onEmpty = muiFormControl && muiFormControl.onEmpty;
  const checkDirty = reactExports.useCallback((obj) => {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect(() => {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  const handleFocus = /* @__PURE__ */ __name((event) => {
    if (fcs.disabled) {
      event.stopPropagation();
      return;
    }
    if (onFocus) {
      onFocus(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  }, "handleFocus");
  const handleBlur2 = /* @__PURE__ */ __name((event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  }, "handleBlur");
  const handleChange = /* @__PURE__ */ __name((event, ...args) => {
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(formatMuiErrorMessage$1(1));
      }
      checkDirty({
        value: element.value
      });
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange(event, ...args);
    }
    if (onChange) {
      onChange(event, ...args);
    }
  }, "handleChange");
  reactExports.useEffect(() => {
    checkDirty(inputRef.current);
  }, []);
  const handleClick = /* @__PURE__ */ __name((event) => {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  }, "handleClick");
  let InputComponent = inputComponent;
  let inputProps = inputPropsProp;
  if (multiline && InputComponent === "input") {
    if (rows) {
      inputProps = _extends$4({
        type: void 0,
        minRows: rows,
        maxRows: rows
      }, inputProps);
    } else {
      inputProps = _extends$4({
        type: void 0,
        maxRows,
        minRows
      }, inputProps);
    }
    InputComponent = TextareaAutosize;
  }
  const handleAutoFill = /* @__PURE__ */ __name((event) => {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  }, "handleAutoFill");
  reactExports.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  const ownerState = _extends$4({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type
  });
  const classes2 = useUtilityClasses$1O(ownerState);
  const Root = slots.root || components.Root || InputBaseRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const Input3 = slots.input || components.Input || InputBaseComponent;
  inputProps = _extends$4({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$4({}, rootProps, !isHostComponent$1(Root) && {
      ownerState: _extends$4({}, ownerState, rootProps.ownerState)
    }, {
      ref,
      onClick: handleClick
    }, other, {
      className: clsx(classes2.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
      children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input3, _extends$4({
          ownerState,
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete,
          autoFocus,
          defaultValue,
          disabled: fcs.disabled,
          id: id2,
          onAnimationStart: handleAutoFill,
          name,
          placeholder,
          readOnly,
          required: fcs.required,
          rows,
          value,
          onKeyDown,
          onKeyUp,
          type
        }, inputProps, !isHostComponent$1(Input3) && {
          as: InputComponent,
          ownerState: _extends$4({}, ownerState, inputProps.ownerState)
        }, {
          ref: handleInputRef,
          className: clsx(classes2.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
          onBlur: handleBlur2,
          onChange: handleChange,
          onFocus: handleFocus
        }))
      }), endAdornment, renderSuffix ? renderSuffix(_extends$4({}, fcs, {
        startAdornment
      })) : null]
    }))]
  });
}, "InputBase2"));
const ListContext$1 = /* @__PURE__ */ reactExports.createContext({});
function _setPrototypeOf$4(t2, e2) {
  return _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf$4(t2, e2);
}
__name(_setPrototypeOf$4, "_setPrototypeOf$4");
function _inheritsLoose(t2, o) {
  t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, _setPrototypeOf$4(t2, o);
}
__name(_inheritsLoose, "_inheritsLoose");
const config = {
  disabled: false
};
const TransitionGroupContext = React$1.createContext(null);
var forceReflow = /* @__PURE__ */ __name(function forceReflow2(node2) {
  return node2.scrollTop;
}, "forceReflow");
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  __name(Transition2, "Transition2");
  Transition2.getDerivedStateFromProps = /* @__PURE__ */ __name(function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  }, "getDerivedStateFromProps");
  var _proto = Transition2.prototype;
  _proto.componentDidMount = /* @__PURE__ */ __name(function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  }, "componentDidMount");
  _proto.componentDidUpdate = /* @__PURE__ */ __name(function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  }, "componentDidUpdate");
  _proto.componentWillUnmount = /* @__PURE__ */ __name(function componentWillUnmount() {
    this.cancelNextCallback();
  }, "componentWillUnmount");
  _proto.getTimeouts = /* @__PURE__ */ __name(function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  }, "getTimeouts");
  _proto.updateStatus = /* @__PURE__ */ __name(function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2)
            forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  }, "updateStatus");
  _proto.performEnter = /* @__PURE__ */ __name(function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  }, "performEnter");
  _proto.performExit = /* @__PURE__ */ __name(function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  }, "performExit");
  _proto.cancelNextCallback = /* @__PURE__ */ __name(function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  }, "cancelNextCallback");
  _proto.safeSetState = /* @__PURE__ */ __name(function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  }, "safeSetState");
  _proto.setNextCallback = /* @__PURE__ */ __name(function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  }, "setNextCallback");
  _proto.onTransitionEnd = /* @__PURE__ */ __name(function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  }, "onTransitionEnd");
  _proto.render = /* @__PURE__ */ __name(function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React$1.cloneElement(React$1.Children.only(children), childProps))
    );
  }, "render");
  return Transition2;
}(React$1.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$7() {
}
__name(noop$7, "noop$7");
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$7,
  onEntering: noop$7,
  onEntered: noop$7,
  onExit: noop$7,
  onExiting: noop$7,
  onExited: noop$7
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
function _assertThisInitialized$4(e2) {
  if (void 0 === e2)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
__name(_assertThisInitialized$4, "_assertThisInitialized$4");
function getChildMapping(children, mapFn) {
  var mapper = /* @__PURE__ */ __name(function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  }, "mapper");
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    reactExports.Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
__name(getChildMapping, "getChildMapping");
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  __name(getValueForKey, "getValueForKey");
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
__name(mergeChildMappings, "mergeChildMappings");
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
__name(getProp, "getProp");
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
__name(getInitialChildMapping, "getInitialChildMapping");
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!reactExports.isValidElement(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
__name(getNextChildMapping, "getNextChildMapping");
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps$1 = {
  component: "div",
  childFactory: /* @__PURE__ */ __name(function childFactory(child) {
    return child;
  }, "childFactory")
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized$4(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  __name(TransitionGroup2, "TransitionGroup2");
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = /* @__PURE__ */ __name(function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  }, "componentDidMount");
  _proto.componentWillUnmount = /* @__PURE__ */ __name(function componentWillUnmount() {
    this.mounted = false;
  }, "componentWillUnmount");
  TransitionGroup2.getDerivedStateFromProps = /* @__PURE__ */ __name(function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  }, "getDerivedStateFromProps");
  _proto.handleExited = /* @__PURE__ */ __name(function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends$4({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  }, "handleExited");
  _proto.render = /* @__PURE__ */ __name(function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React$1.createElement(Component, props, children));
  }, "render");
  return TransitionGroup2;
}(React$1.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps$1;
function Ripple(props) {
  const {
    className,
    classes: classes2,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes2.ripple, classes2.rippleVisible, pulsate && classes2.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes2.child, leaving && classes2.childLeaving, pulsate && classes2.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
__name(Ripple, "Ripple");
const touchRippleClasses = generateUtilityClasses$1("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const _excluded$2a = ["center", "classes", "className"];
let _$3 = /* @__PURE__ */ __name((t2) => t2, "_$3"), _t$3, _t2$3, _t3$3, _t4$3;
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes$1(_t$3 || (_t$3 = _$3`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
const exitKeyframe = keyframes$1(_t2$3 || (_t2$3 = _$3`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
const pulsateKeyframe = keyframes$1(_t3$3 || (_t3$3 = _$3`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
const TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4$3 || (_t4$3 = _$3`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({
  theme: theme2
}) => theme2.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut);
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TouchRipple2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes: classes2 = {},
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2a);
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes2.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes2.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes2.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes2.child, touchRippleClasses.child),
        childLeaving: clsx(classes2.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes2.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes2]);
  const start2 = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event != null && event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = reactExports.useCallback(() => {
    start2({}, {
      pulsate: true
    });
  }, [start2]);
  const stop = reactExports.useCallback((event, cb2) => {
    startTimer.clear();
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, [startTimer]);
  reactExports.useImperativeHandle(ref, () => ({
    pulsate,
    start: start2,
    stop
  }), [pulsate, start2, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends$4({
    className: clsx(touchRippleClasses.root, classes2.root, className),
    ref: container
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
}, "TouchRipple2"));
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass$1("MuiButtonBase", slot);
}
__name(getButtonBaseUtilityClass, "getButtonBaseUtilityClass");
const buttonBaseClasses = generateUtilityClasses$1("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const _excluded$29 = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
const useUtilityClasses$1N = /* @__PURE__ */ __name((ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes2);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
}, "useUtilityClasses$1N");
const ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function ButtonBase2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$29);
  const buttonRef = reactExports.useRef(null);
  const rippleRef = reactExports.useRef(null);
  const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const [mountedState, setMountedState] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setMountedState(true);
  }, []);
  const enableTouchRipple = mountedState && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple && mountedState) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore = skipRippleAction;
      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  __name(useRippleHandler, "useRippleHandler");
  const handleMouseDown = useRippleHandler("start", onMouseDown);
  const handleContextMenu = useRippleHandler("stop", onContextMenu);
  const handleDragLeave = useRippleHandler("stop", onDragLeave);
  const handleMouseUp = useRippleHandler("stop", onMouseUp);
  const handleMouseLeave = useRippleHandler("stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler("start", onTouchStart);
  const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
  const handleTouchMove = useRippleHandler("stop", onTouchMove);
  const handleBlur2 = useRippleHandler("stop", (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = /* @__PURE__ */ __name(() => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  }, "isNonNativeButton");
  const keydownRef = reactExports.useRef(false);
  const handleKeyDown2 = useEventCallback((event) => {
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
      keydownRef.current = true;
      rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
  const ownerState = _extends$4({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes2 = useUtilityClasses$1N(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$4({
    as: ComponentProp,
    className: clsx(classes2.root, className),
    ownerState,
    onBlur: handleBlur2,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type
  }, buttonProps, other, {
    children: [children, enableTouchRipple ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, _extends$4({
        ref: handleRippleRef,
        center: centerRipple
      }, TouchRippleProps))
    ) : null]
  }));
}, "ButtonBase2"));
function getDividerUtilityClass(slot) {
  return generateUtilityClass$1("MuiDivider", slot);
}
__name(getDividerUtilityClass, "getDividerUtilityClass");
const dividerClasses = generateUtilityClasses$1("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const _excluded$28 = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"];
const useUtilityClasses$1M = /* @__PURE__ */ __name((ownerState) => {
  const {
    absolute,
    children,
    classes: classes2,
    flexItem,
    light: light2,
    orientation,
    textAlign,
    variant
  } = ownerState;
  const slots = {
    root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign === "right" && orientation !== "vertical" && "textAlignRight", textAlign === "left" && orientation !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
  };
  return composeClasses(slots, getDividerUtilityClass, classes2);
}, "useUtilityClasses$1M");
const DividerRoot = styled("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (theme2.vars || theme2).palette.divider,
  borderBottomWidth: "thin"
}, ownerState.absolute && {
  position: "absolute",
  bottom: 0,
  left: 0,
  width: "100%"
}, ownerState.light && {
  borderColor: theme2.vars ? `rgba(${theme2.vars.palette.dividerChannel} / 0.08)` : alpha_1(theme2.palette.divider, 0.08)
}, ownerState.variant === "inset" && {
  marginLeft: 72
}, ownerState.variant === "middle" && ownerState.orientation === "horizontal" && {
  marginLeft: theme2.spacing(2),
  marginRight: theme2.spacing(2)
}, ownerState.variant === "middle" && ownerState.orientation === "vertical" && {
  marginTop: theme2.spacing(1),
  marginBottom: theme2.spacing(1)
}, ownerState.orientation === "vertical" && {
  height: "100%",
  borderBottomWidth: 0,
  borderRightWidth: "thin"
}, ownerState.flexItem && {
  alignSelf: "stretch",
  height: "auto"
}), ({
  ownerState
}) => _extends$4({}, ownerState.children && {
  display: "flex",
  whiteSpace: "nowrap",
  textAlign: "center",
  border: 0,
  borderTopStyle: "solid",
  borderLeftStyle: "solid",
  "&::before, &::after": {
    content: '""',
    alignSelf: "center"
  }
}), ({
  theme: theme2,
  ownerState
}) => _extends$4({}, ownerState.children && ownerState.orientation !== "vertical" && {
  "&::before, &::after": {
    width: "100%",
    borderTop: `thin solid ${(theme2.vars || theme2).palette.divider}`,
    borderTopStyle: "inherit"
  }
}), ({
  theme: theme2,
  ownerState
}) => _extends$4({}, ownerState.children && ownerState.orientation === "vertical" && {
  flexDirection: "column",
  "&::before, &::after": {
    height: "100%",
    borderLeft: `thin solid ${(theme2.vars || theme2).palette.divider}`,
    borderLeftStyle: "inherit"
  }
}), ({
  ownerState
}) => _extends$4({}, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && {
  "&::before": {
    width: "90%"
  },
  "&::after": {
    width: "10%"
  }
}, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && {
  "&::before": {
    width: "10%"
  },
  "&::after": {
    width: "90%"
  }
}));
const DividerWrapper = styled("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  display: "inline-block",
  paddingLeft: `calc(${theme2.spacing(1)} * 1.2)`,
  paddingRight: `calc(${theme2.spacing(1)} * 1.2)`
}, ownerState.orientation === "vertical" && {
  paddingTop: `calc(${theme2.spacing(1)} * 1.2)`,
  paddingBottom: `calc(${theme2.spacing(1)} * 1.2)`
}));
const Divider = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Divider2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDivider"
  });
  const {
    absolute = false,
    children,
    className,
    component = children ? "div" : "hr",
    flexItem = false,
    light: light2 = false,
    orientation = "horizontal",
    role = component !== "hr" ? "separator" : void 0,
    textAlign = "center",
    variant = "fullWidth"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$28);
  const ownerState = _extends$4({}, props, {
    absolute,
    component,
    flexItem,
    light: light2,
    orientation,
    role,
    textAlign,
    variant
  });
  const classes2 = useUtilityClasses$1M(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, _extends$4({
    as: component,
    className: clsx(classes2.root, className),
    role,
    ref,
    ownerState
  }, other, {
    children: children ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
      className: classes2.wrapper,
      ownerState,
      children
    }) : null
  }));
}, "Divider2"));
Divider.muiSkipListHighlight = true;
function getListItemIconUtilityClass(slot) {
  return generateUtilityClass$1("MuiListItemIcon", slot);
}
__name(getListItemIconUtilityClass, "getListItemIconUtilityClass");
const listItemIconClasses = generateUtilityClasses$1("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const _excluded$27 = ["className"];
const useUtilityClasses$1L = /* @__PURE__ */ __name((ownerState) => {
  const {
    alignItems,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", alignItems === "flex-start" && "alignItemsFlexStart"]
  };
  return composeClasses(slots, getListItemIconUtilityClass, classes2);
}, "useUtilityClasses$1L");
const ListItemIconRoot = styled("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  minWidth: 56,
  color: (theme2.vars || theme2).palette.action.active,
  flexShrink: 0,
  display: "inline-flex"
}, ownerState.alignItems === "flex-start" && {
  marginTop: 8
}));
const ListItemIcon = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function ListItemIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemIcon"
  });
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$27);
  const context = reactExports.useContext(ListContext$1);
  const ownerState = _extends$4({}, props, {
    alignItems: context.alignItems
  });
  const classes2 = useUtilityClasses$1L(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIconRoot, _extends$4({
    className: clsx(classes2.root, className),
    ownerState,
    ref
  }, other));
}, "ListItemIcon2"));
function getTypographyUtilityClass(slot) {
  return generateUtilityClass$1("MuiTypography", slot);
}
__name(getTypographyUtilityClass, "getTypographyUtilityClass");
generateUtilityClasses$1("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const _excluded$26 = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
const useUtilityClasses$1K = /* @__PURE__ */ __name((ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize$1(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes2);
}, "useUtilityClasses$1K");
const TypographyRoot = styled("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize$1(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  margin: 0
}, ownerState.variant === "inherit" && {
  // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
  font: "inherit"
}, ownerState.variant !== "inherit" && theme2.typography[ownerState.variant], ownerState.align !== "inherit" && {
  textAlign: ownerState.align
}, ownerState.noWrap && {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, ownerState.gutterBottom && {
  marginBottom: "0.35em"
}, ownerState.paragraph && {
  marginBottom: 16
}));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const colorTransformations = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
};
const transformDeprecatedColors = /* @__PURE__ */ __name((color2) => {
  return colorTransformations[color2] || color2;
}, "transformDeprecatedColors");
const Typography = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Typography2(inProps, ref) {
  const themeProps = useDefaultProps({
    props: inProps,
    name: "MuiTypography"
  });
  const color2 = transformDeprecatedColors(themeProps.color);
  const props = extendSxProp(_extends$4({}, themeProps, {
    color: color2
  }));
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$26);
  const ownerState = _extends$4({}, props, {
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  });
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes2 = useUtilityClasses$1K(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, _extends$4({
    as: Component,
    ref,
    ownerState,
    className: clsx(classes2.root, className)
  }, other));
}, "Typography2"));
function getListItemTextUtilityClass(slot) {
  return generateUtilityClass$1("MuiListItemText", slot);
}
__name(getListItemTextUtilityClass, "getListItemTextUtilityClass");
const listItemTextClasses = generateUtilityClasses$1("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
const _excluded$25 = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"];
const useUtilityClasses$1J = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    inset,
    primary,
    secondary,
    dense
  } = ownerState;
  const slots = {
    root: ["root", inset && "inset", dense && "dense", primary && secondary && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  };
  return composeClasses(slots, getListItemTextUtilityClass, classes2);
}, "useUtilityClasses$1J");
const ListItemTextRoot = styled("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${listItemTextClasses.primary}`]: styles2.primary
    }, {
      [`& .${listItemTextClasses.secondary}`]: styles2.secondary
    }, styles2.root, ownerState.inset && styles2.inset, ownerState.primary && ownerState.secondary && styles2.multiline, ownerState.dense && styles2.dense];
  }
})(({
  ownerState
}) => _extends$4({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4
}, ownerState.primary && ownerState.secondary && {
  marginTop: 6,
  marginBottom: 6
}, ownerState.inset && {
  paddingLeft: 56
}));
const ListItemText = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function ListItemText2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemText"
  });
  const {
    children,
    className,
    disableTypography = false,
    inset = false,
    primary: primaryProp,
    primaryTypographyProps,
    secondary: secondaryProp,
    secondaryTypographyProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$25);
  const {
    dense
  } = reactExports.useContext(ListContext$1);
  let primary = primaryProp != null ? primaryProp : children;
  let secondary = secondaryProp;
  const ownerState = _extends$4({}, props, {
    disableTypography,
    inset,
    primary: !!primary,
    secondary: !!secondary,
    dense
  });
  const classes2 = useUtilityClasses$1J(ownerState);
  if (primary != null && primary.type !== Typography && !disableTypography) {
    primary = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, _extends$4({
      variant: dense ? "body2" : "body1",
      className: classes2.primary,
      component: primaryTypographyProps != null && primaryTypographyProps.variant ? void 0 : "span",
      display: "block"
    }, primaryTypographyProps, {
      children: primary
    }));
  }
  if (secondary != null && secondary.type !== Typography && !disableTypography) {
    secondary = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, _extends$4({
      variant: "body2",
      className: classes2.secondary,
      color: "text.secondary",
      display: "block"
    }, secondaryTypographyProps, {
      children: secondary
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemTextRoot, _extends$4({
    className: clsx(classes2.root, className),
    ownerState,
    ref
  }, other, {
    children: [primary, secondary]
  }));
}, "ListItemText2"));
function getMenuItemUtilityClass$1(slot) {
  return generateUtilityClass$1("MuiMenuItem", slot);
}
__name(getMenuItemUtilityClass$1, "getMenuItemUtilityClass$1");
const menuItemClasses$1 = generateUtilityClasses$1("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const _excluded$24 = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
const overridesResolver$3 = /* @__PURE__ */ __name((props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
}, "overridesResolver$3");
const useUtilityClasses$1I = /* @__PURE__ */ __name((ownerState) => {
  const {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getMenuItemUtilityClass$1, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$1I");
const MenuItemRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: overridesResolver$3
})(({
  theme: theme2,
  ownerState
}) => _extends$4({}, theme2.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses$1.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    [`&.${menuItemClasses$1.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  },
  [`&.${menuItemClasses$1.selected}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${menuItemClasses$1.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses.root}`]: {
    marginTop: theme2.spacing(1),
    marginBottom: theme2.spacing(1)
  },
  [`& + .${dividerClasses.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses.root}`]: {
    minWidth: 36
  }
}, !ownerState.dense && {
  [theme2.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, ownerState.dense && _extends$4({
  minHeight: 32,
  // https://m2.material.io/components/menus#specs > Dense
  paddingTop: 4,
  paddingBottom: 4
}, theme2.typography.body2, {
  [`& .${listItemIconClasses.root} svg`]: {
    fontSize: "1.25rem"
  }
})));
const MenuItem = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function MenuItem2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenuItem"
  });
  const {
    autoFocus = false,
    component = "li",
    dense = false,
    divider = false,
    disableGutters = false,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$24);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    disableGutters
  }), [context.dense, dense, disableGutters]);
  const menuItemRef = reactExports.useRef(null);
  useEnhancedEffect(() => {
    if (autoFocus) {
      if (menuItemRef.current) {
        menuItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = _extends$4({}, props, {
    dense: childContext.dense,
    divider,
    disableGutters
  });
  const classes2 = useUtilityClasses$1I(props);
  const handleRef = useForkRef(menuItemRef, ref);
  let tabIndex;
  if (!props.disabled) {
    tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends$4({
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx(classes2.focusVisible, focusVisibleClassName),
      className: clsx(classes2.root, className)
    }, other, {
      ownerState,
      classes: classes2
    }))
  });
}, "MenuItem2"));
function getListUtilityClass(slot) {
  return generateUtilityClass$1("MuiList", slot);
}
__name(getListUtilityClass, "getListUtilityClass");
generateUtilityClasses$1("MuiList", ["root", "padding", "dense", "subheader"]);
const _excluded$23 = ["children", "className", "component", "dense", "disablePadding", "subheader"];
const useUtilityClasses$1H = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses(slots, getListUtilityClass, classes2);
}, "useUtilityClasses$1H");
const ListRoot = styled("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})(({
  ownerState
}) => _extends$4({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !ownerState.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.subheader && {
  paddingTop: 0
}));
const List = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function List2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiList"
  });
  const {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$23);
  const context = reactExports.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = _extends$4({}, props, {
    component,
    dense,
    disablePadding
  });
  const classes2 = useUtilityClasses$1H(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends$4({
      as: component,
      className: clsx(classes2.root, className),
      ref,
      ownerState
    }, other, {
      children: [subheader, children]
    }))
  });
}, "List2"));
const _excluded$22 = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function nextItem(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
__name(nextItem, "nextItem");
function previousItem(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
__name(previousItem, "previousItem");
function textCriteriaMatches$1(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.indexOf(textCriteria.keys.join("")) === 0;
}
__name(textCriteriaMatches$1, "textCriteriaMatches$1");
function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches$1(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
__name(moveFocus, "moveFocus");
const MenuList = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function MenuList2(props, ref) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$22);
  const listRef = reactExports.useRef(null);
  const textCriteriaRef = reactExports.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, {
      direction
    }) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize$1(ownerDocument(containerElement))}px`;
        listRef.current.style[direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown2 = /* @__PURE__ */ __name((event) => {
    const list = listRef.current;
    const key = event.key;
    const currentFocus = ownerDocument(list).activeElement;
    if (key === "ArrowDown") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key === "Home") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === "End") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches$1(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, "handleKeyDown");
  const handleRef = useForkRef(listRef, ref);
  let activeItemIndex = -1;
  reactExports.Children.forEach(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      if (activeItemIndex === index2) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
    if (activeItemIndex === index2 && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
      activeItemIndex += 1;
      if (activeItemIndex >= children.length) {
        activeItemIndex = -1;
      }
    }
  });
  const items = reactExports.Children.map(children, (child, index2) => {
    if (index2 === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List, _extends$4({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown2,
    tabIndex: autoFocus ? 0 : -1
  }, other, {
    children: items
  }));
}, "MenuList2"));
const reflow = /* @__PURE__ */ __name((node2) => node2.scrollTop, "reflow");
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
    easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
    delay: style2.transitionDelay
  };
}
__name(getTransitionProps, "getTransitionProps");
const _excluded$21 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale$1(value) {
  return `scale(${value}, ${value ** 2})`;
}
__name(getScale$1, "getScale$1");
const styles$d = {
  entering: {
    opacity: 1,
    transform: getScale$1(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Grow2(props, ref) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$21);
  const timer = useTimeout();
  const autoTimeout = reactExports.useRef();
  const theme2 = useTheme$1();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = /* @__PURE__ */ __name((callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  }, "normalizedTransitionCallback");
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay: delay2,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay: delay2
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: delay2,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay: delay2,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay: delay2
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay2 : delay2 || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale$1(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = /* @__PURE__ */ __name((next2) => {
    if (timeout === "auto") {
      timer.start(autoTimeout.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  }, "handleAddEndListener");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$4({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$4({
        style: _extends$4({
          opacity: 0,
          transform: getScale$1(0.75),
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$d[state], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
}, "Grow2"));
Grow.muiSupportAuto = true;
function isOverflowing$1(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
__name(isOverflowing$1, "isOverflowing$1");
function ariaHidden$1(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
__name(ariaHidden$1, "ariaHidden$1");
function getPaddingRight$1(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
__name(getPaddingRight$1, "getPaddingRight$1");
function isAriaHiddenForbiddenOnElement$1(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
__name(isAriaHiddenForbiddenOnElement$1, "isAriaHiddenForbiddenOnElement$1");
function ariaHiddenSiblings$1(container, mountElement, currentElement, elementsToExclude, show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement$1(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden$1(element, show);
    }
  });
}
__name(ariaHiddenSiblings$1, "ariaHiddenSiblings$1");
function findIndexOf$1(items, callback) {
  let idx = -1;
  items.some((item, index2) => {
    if (callback(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
__name(findIndexOf$1, "findIndexOf$1");
function handleContainer$1(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing$1(container)) {
      const scrollbarSize = getScrollbarSize$1(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight$1(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight$1(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = /* @__PURE__ */ __name(() => {
    restoreStyle.forEach(({
      value,
      el: el2,
      property
    }) => {
      if (value) {
        el2.style.setProperty(property, value);
      } else {
        el2.style.removeProperty(property);
      }
    });
  }, "restore");
  return restore;
}
__name(handleContainer$1, "handleContainer$1");
function getHiddenSiblings$1(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
__name(getHiddenSiblings$1, "getHiddenSiblings$1");
let ModalManager$1 = (_a = class {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden$1(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings$1(container);
    ariaHiddenSiblings$1(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf$1(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf$1(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer$1(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf$1(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden$1(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings$1(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden$1(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}, __name(_a, "ModalManager"), _a);
const candidatesSelector$1 = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex$1(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
__name(getTabIndex$1, "getTabIndex$1");
function isNonTabbableRadio$1(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = /* @__PURE__ */ __name((selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`), "getRadio");
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
__name(isNonTabbableRadio$1, "isNonTabbableRadio$1");
function isNodeMatchingSelectorFocusable$1(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio$1(node2)) {
    return false;
  }
  return true;
}
__name(isNodeMatchingSelectorFocusable$1, "isNodeMatchingSelectorFocusable$1");
function defaultGetTabbable$1(root2) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root2.querySelectorAll(candidatesSelector$1)).forEach((node2, i) => {
    const nodeTabIndex = getTabIndex$1(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable$1(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a, b2) => a.tabIndex === b2.tabIndex ? a.documentOrder - b2.documentOrder : a.tabIndex - b2.tabIndex).map((a) => a.node).concat(regularTabNodes);
}
__name(defaultGetTabbable$1, "defaultGetTabbable$1");
function defaultIsEnabled$1() {
  return true;
}
__name(defaultIsEnabled$1, "defaultIsEnabled$1");
function FocusTrap$1(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable$1,
    isEnabled: isEnabled2 = defaultIsEnabled$1,
    open: open2
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open2]);
  reactExports.useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open2]);
  reactExports.useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = /* @__PURE__ */ __name((nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled2() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    }, "loopFocus");
    const contain = /* @__PURE__ */ __name(() => {
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled2() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        var _lastKeydown$current, _lastKeydown$current2;
        const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    }, "contain");
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled2, open2, getTabbable]);
  const onFocus = /* @__PURE__ */ __name((event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  }, "onFocus");
  const handleFocusSentinel = /* @__PURE__ */ __name((event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  }, "handleFocusSentinel");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open2 ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open2 ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
__name(FocusTrap$1, "FocusTrap$1");
function getContainer$3(container) {
  return typeof container === "function" ? container() : container;
}
__name(getContainer$3, "getContainer$3");
const Portal$1 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$3(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
  });
}, "Portal2"));
const _excluded$20 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
const styles$c = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Fade2(props, ref) {
  const theme2 = useTheme$1();
  const defaultTimeout = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$20);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = /* @__PURE__ */ __name((callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  }, "normalizedTransitionCallback");
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = /* @__PURE__ */ __name((next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  }, "handleAddEndListener");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$4({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$4({
        style: _extends$4({
          opacity: 0,
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$c[state], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
}, "Fade2"));
function getBackdropUtilityClass(slot) {
  return generateUtilityClass$1("MuiBackdrop", slot);
}
__name(getBackdropUtilityClass, "getBackdropUtilityClass");
generateUtilityClasses$1("MuiBackdrop", ["root", "invisible"]);
const _excluded$1$ = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
const useUtilityClasses$1G = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes2);
}, "useUtilityClasses$1G");
const BackdropRoot = styled("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})(({
  ownerState
}) => _extends$4({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, ownerState.invisible && {
  backgroundColor: "transparent"
}));
const Backdrop$2 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Backdrop2(inProps, ref) {
  var _slotProps$root, _ref, _slots$root;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    className,
    component = "div",
    components = {},
    componentsProps = {},
    invisible = false,
    open: open2,
    slotProps = {},
    slots = {},
    TransitionComponent = Fade,
    transitionDuration
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1$);
  const ownerState = _extends$4({}, props, {
    component,
    invisible
  });
  const classes2 = useUtilityClasses$1G(ownerState);
  const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$4({
    in: open2,
    timeout: transitionDuration
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends$4({
      "aria-hidden": true
    }, rootSlotProps, {
      as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
      className: clsx(classes2.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
      ownerState: _extends$4({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
      classes: classes2,
      ref,
      children
    }))
  }));
}, "Backdrop2"));
function getContainer$2(container) {
  return typeof container === "function" ? container() : container;
}
__name(getContainer$2, "getContainer$2");
function getHasTransition$1(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
__name(getHasTransition$1, "getHasTransition$1");
const defaultManager$1 = new ModalManager$1();
function useModal$1(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    // @ts-ignore internal logic - Base UI supports the manager as a prop too
    manager = defaultManager$1,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open: open2,
    rootRef
  } = parameters;
  const modal = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open2);
  const hasTransition = getHasTransition$1(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = /* @__PURE__ */ __name(() => ownerDocument(mountNodeRef.current), "getDoc");
  const getModal = /* @__PURE__ */ __name(() => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  }, "getModal");
  const handleMounted = /* @__PURE__ */ __name(() => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  }, "handleMounted");
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer$2(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open2 && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden$1(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp, manager]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open2) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open2, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  }, "createHandleKeyDown");
  const createHandleBackdropClick = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  }, "createHandleBackdropClick");
  const getRootProps = /* @__PURE__ */ __name((otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers$1(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = _extends$4({}, propsEventHandlers, otherHandlers);
    return _extends$4({
      role: "presentation"
    }, externalEventHandlers, {
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    });
  }, "getRootProps");
  const getBackdropProps = /* @__PURE__ */ __name((otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return _extends$4({
      "aria-hidden": true
    }, externalEventHandlers, {
      onClick: createHandleBackdropClick(externalEventHandlers),
      open: open2
    });
  }, "getBackdropProps");
  const getTransitionProps2 = /* @__PURE__ */ __name(() => {
    const handleEnter = /* @__PURE__ */ __name(() => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    }, "handleEnter");
    const handleExited = /* @__PURE__ */ __name(() => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    }, "handleExited");
    return {
      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
    };
  }, "getTransitionProps");
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
__name(useModal$1, "useModal$1");
function getModalUtilityClass$1(slot) {
  return generateUtilityClass$1("MuiModal", slot);
}
__name(getModalUtilityClass$1, "getModalUtilityClass$1");
generateUtilityClasses$1("MuiModal", ["root", "hidden", "backdrop"]);
const _excluded$1_ = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"];
const useUtilityClasses$1F = /* @__PURE__ */ __name((ownerState) => {
  const {
    open: open2,
    exited,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", !open2 && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, getModalUtilityClass$1, classes2);
}, "useUtilityClasses$1F");
const ModalRoot = styled("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  position: "fixed",
  zIndex: (theme2.vars || theme2).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !ownerState.open && ownerState.exited && {
  visibility: "hidden"
}));
const ModalBackdrop = styled(Backdrop$2, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles2) => {
    return styles2.backdrop;
  }
})({
  zIndex: -1
});
const Modal$3 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Modal2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
  const props = useDefaultProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onBackdropClick,
    open: open2,
    slotProps,
    slots
    // eslint-disable-next-line react/prop-types
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1_);
  const propsWithDefaults = _extends$4({}, props, {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  });
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal$1(_extends$4({}, propsWithDefaults, {
    rootRef: ref
  }));
  const ownerState = _extends$4({}, propsWithDefaults, {
    exited
  });
  const classes2 = useUtilityClasses$1F(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
  const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
  const rootProps = useSlotProps$1({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    getSlotProps: getRootProps,
    additionalProps: {
      ref,
      as: component
    },
    ownerState,
    className: clsx(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes2 == null ? void 0 : classes2.root, !ownerState.open && ownerState.exited && (classes2 == null ? void 0 : classes2.hidden))
  });
  const backdropProps = useSlotProps$1({
    elementType: BackdropSlot,
    externalSlotProps: backdropSlotProps,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps(_extends$4({}, otherHandlers, {
        onClick: (e2) => {
          if (onBackdropClick) {
            onBackdropClick(e2);
          }
          if (otherHandlers != null && otherHandlers.onClick) {
            otherHandlers.onClick(e2);
          }
        }
      }));
    },
    className: clsx(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes2 == null ? void 0 : classes2.backdrop),
    ownerState
  });
  if (!keepMounted && !open2 && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$4({}, rootProps, {
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, _extends$4({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap$1, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open: open2,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    }))
  });
}, "Modal2"));
function getPaperUtilityClass(slot) {
  return generateUtilityClass$1("MuiPaper", slot);
}
__name(getPaperUtilityClass, "getPaperUtilityClass");
generateUtilityClasses$1("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$1Z = ["className", "component", "elevation", "square", "variant"];
const useUtilityClasses$1E = /* @__PURE__ */ __name((ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes2);
}, "useUtilityClasses$1E");
const PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$vars$overlays;
  return _extends$4({
    backgroundColor: (theme2.vars || theme2).palette.background.paper,
    color: (theme2.vars || theme2).palette.text.primary,
    transition: theme2.transitions.create("box-shadow")
  }, !ownerState.square && {
    borderRadius: theme2.shape.borderRadius
  }, ownerState.variant === "outlined" && {
    border: `1px solid ${(theme2.vars || theme2).palette.divider}`
  }, ownerState.variant === "elevation" && _extends$4({
    boxShadow: (theme2.vars || theme2).shadows[ownerState.elevation]
  }, !theme2.vars && theme2.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha_1("#fff", getOverlayAlpha(ownerState.elevation))}, ${alpha_1("#fff", getOverlayAlpha(ownerState.elevation))})`
  }, theme2.vars && {
    backgroundImage: (_theme$vars$overlays = theme2.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
});
const Paper = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Paper2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPaper"
  });
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1Z);
  const ownerState = _extends$4({}, props, {
    component,
    elevation,
    square,
    variant
  });
  const classes2 = useUtilityClasses$1E(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends$4({
    as: component,
    ownerState,
    className: clsx(classes2.root, className),
    ref
  }, other));
}, "Paper2"));
function getPopoverUtilityClass(slot) {
  return generateUtilityClass$1("MuiPopover", slot);
}
__name(getPopoverUtilityClass, "getPopoverUtilityClass");
generateUtilityClasses$1("MuiPopover", ["root", "paper"]);
const _excluded$1Y = ["onEntering"], _excluded2$g = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"], _excluded3$3 = ["slotProps"];
function getOffsetTop(rect, vertical) {
  let offset2 = 0;
  if (typeof vertical === "number") {
    offset2 = vertical;
  } else if (vertical === "center") {
    offset2 = rect.height / 2;
  } else if (vertical === "bottom") {
    offset2 = rect.height;
  }
  return offset2;
}
__name(getOffsetTop, "getOffsetTop");
function getOffsetLeft(rect, horizontal) {
  let offset2 = 0;
  if (typeof horizontal === "number") {
    offset2 = horizontal;
  } else if (horizontal === "center") {
    offset2 = rect.width / 2;
  } else if (horizontal === "right") {
    offset2 = rect.width;
  }
  return offset2;
}
__name(getOffsetLeft, "getOffsetLeft");
function getTransformOriginValue(transformOrigin2) {
  return [transformOrigin2.horizontal, transformOrigin2.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
}
__name(getTransformOriginValue, "getTransformOriginValue");
function resolveAnchorEl$1(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
__name(resolveAnchorEl$1, "resolveAnchorEl$1");
const useUtilityClasses$1D = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPopoverUtilityClass, classes2);
}, "useUtilityClasses$1D");
const PopoverRoot = styled(Modal$3, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const PopoverPaper = styled(Paper, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Popover2(inProps, ref) {
  var _slotProps$paper, _slots$root, _slots$paper;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopover"
  });
  const {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open: open2,
    PaperProps: PaperPropsProp = {},
    slots,
    slotProps,
    transformOrigin: transformOrigin2 = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent = Grow,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps: {
      onEntering
    } = {},
    disableScrollLock = false
  } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$1Y), other = _objectWithoutPropertiesLoose$1(props, _excluded2$g);
  const externalPaperSlotProps = (_slotProps$paper = slotProps == null ? void 0 : slotProps.paper) != null ? _slotProps$paper : PaperPropsProp;
  const paperRef = reactExports.useRef();
  const handlePaperRef = useForkRef(paperRef, externalPaperSlotProps.ref);
  const ownerState = _extends$4({}, props, {
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    externalPaperSlotProps,
    transformOrigin: transformOrigin2,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  });
  const classes2 = useUtilityClasses$1D(ownerState);
  const getAnchorOffset = reactExports.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = reactExports.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin2.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin2.horizontal)
    };
  }, [transformOrigin2.horizontal, transformOrigin2.vertical]);
  const getPositioningStyle = reactExports.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top2 = anchorOffset.top - elemTransformOrigin.vertical;
    let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom2 = top2 + elemRect.height;
    const right2 = left2 + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl$1(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (marginThreshold !== null && top2 < marginThreshold) {
      const diff = top2 - marginThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (marginThreshold !== null && bottom2 > heightThreshold) {
      const diff = bottom2 - heightThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (marginThreshold !== null && left2 < marginThreshold) {
      const diff = left2 - marginThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right2 > widthThreshold) {
      const diff = right2 - widthThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top2)}px`,
      left: `${Math.round(left2)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = reactExports.useState(open2);
  const setPositioningStyles = reactExports.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.top = positioning.top;
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  reactExports.useEffect(() => {
    if (disableScrollLock) {
      window.addEventListener("scroll", setPositioningStyles);
    }
    return () => window.removeEventListener("scroll", setPositioningStyles);
  }, [anchorEl, disableScrollLock, setPositioningStyles]);
  const handleEntering = /* @__PURE__ */ __name((element, isAppearing) => {
    if (onEntering) {
      onEntering(element, isAppearing);
    }
    setPositioningStyles();
  }, "handleEntering");
  const handleExited = /* @__PURE__ */ __name(() => {
    setIsPositioned(false);
  }, "handleExited");
  reactExports.useEffect(() => {
    if (open2) {
      setPositioningStyles();
    }
  });
  reactExports.useImperativeHandle(action, () => open2 ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open2, setPositioningStyles]);
  reactExports.useEffect(() => {
    if (!open2) {
      return void 0;
    }
    const handleResize = debounce$2(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(anchorEl);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open2, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl$1(anchorEl)).body : void 0);
  const RootSlot = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : PopoverRoot;
  const PaperSlot = (_slots$paper = slots == null ? void 0 : slots.paper) != null ? _slots$paper : PopoverPaper;
  const paperProps = useSlotProps$1({
    elementType: PaperSlot,
    externalSlotProps: _extends$4({}, externalPaperSlotProps, {
      style: isPositioned ? externalPaperSlotProps.style : _extends$4({}, externalPaperSlotProps.style, {
        opacity: 0
      })
    }),
    additionalProps: {
      elevation,
      ref: handlePaperRef
    },
    ownerState,
    className: clsx(classes2.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className)
  });
  const _useSlotProps = useSlotProps$1({
    elementType: RootSlot,
    externalSlotProps: (slotProps == null ? void 0 : slotProps.root) || {},
    externalForwardedProps: other,
    additionalProps: {
      ref,
      slotProps: {
        backdrop: {
          invisible: true
        }
      },
      container,
      open: open2
    },
    ownerState,
    className: clsx(classes2.root, className)
  }), {
    slotProps: rootSlotPropsProp
  } = _useSlotProps, rootProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded3$3);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, _extends$4({}, rootProps, !isHostComponent$1(RootSlot) && {
    slotProps: rootSlotPropsProp,
    disableScrollLock
  }, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$4({
      appear: true,
      in: open2,
      onEntering: handleEntering,
      onExited: handleExited,
      timeout: transitionDuration
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, _extends$4({}, paperProps, {
        children
      }))
    }))
  }));
}, "Popover2"));
function getMenuUtilityClass$1(slot) {
  return generateUtilityClass$1("MuiMenu", slot);
}
__name(getMenuUtilityClass$1, "getMenuUtilityClass$1");
generateUtilityClasses$1("MuiMenu", ["root", "paper", "list"]);
const _excluded$1X = ["onEntering"], _excluded2$f = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"];
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$1C = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses(slots, getMenuUtilityClass$1, classes2);
}, "useUtilityClasses$1C");
const MenuRoot = styled(Popover, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const MenuPaper = styled(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled(MenuList, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (props, styles2) => styles2.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu$1 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Menu2(inProps, ref) {
  var _slots$paper, _slotProps$paper;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenu"
  });
  const {
    autoFocus = true,
    children,
    className,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open: open2,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: {
      onEntering
    } = {},
    variant = "selectedMenu",
    slots = {},
    slotProps = {}
  } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$1X), other = _objectWithoutPropertiesLoose$1(props, _excluded2$f);
  const isRtl = useRtl();
  const ownerState = _extends$4({}, props, {
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  });
  const classes2 = useUtilityClasses$1C(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open2;
  const menuListActionsRef = reactExports.useRef(null);
  const handleEntering = /* @__PURE__ */ __name((element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, {
        direction: isRtl ? "rtl" : "ltr"
      });
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  }, "handleEntering");
  const handleListKeyDown = /* @__PURE__ */ __name((event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  }, "handleListKeyDown");
  let activeItemIndex = -1;
  reactExports.Children.map(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
  });
  const PaperSlot = (_slots$paper = slots.paper) != null ? _slots$paper : MenuPaper;
  const paperExternalSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : PaperProps;
  const rootSlotProps = useSlotProps$1({
    elementType: slots.root,
    externalSlotProps: slotProps.root,
    ownerState,
    className: [classes2.root, className]
  });
  const paperSlotProps = useSlotProps$1({
    elementType: PaperSlot,
    externalSlotProps: paperExternalSlotProps,
    ownerState,
    className: classes2.paper
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends$4({
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    slots: {
      paper: PaperSlot,
      root: slots.root
    },
    slotProps: {
      root: rootSlotProps,
      paper: paperSlotProps
    },
    open: open2,
    ref,
    transitionDuration,
    TransitionProps: _extends$4({
      onEntering: handleEntering
    }, TransitionProps),
    ownerState
  }, other, {
    classes: PopoverClasses,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends$4({
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant
    }, MenuListProps, {
      className: clsx(classes2.list, MenuListProps.className),
      children
    }))
  }));
}, "Menu2"));
function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass$1("MuiNativeSelect", slot);
}
__name(getNativeSelectUtilityClasses, "getNativeSelectUtilityClasses");
const nativeSelectClasses = generateUtilityClasses$1("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
const _excluded$1W = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"];
const useUtilityClasses$1B = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    variant,
    disabled,
    multiple,
    open: open2,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize$1(variant)}`, open2 && "iconOpen", disabled && "disabled"]
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes2);
}, "useUtilityClasses$1B");
const nativeSelectSelectStyles = /* @__PURE__ */ __name(({
  ownerState,
  theme: theme2
}) => _extends$4({
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  borderRadius: 0,
  // Reset
  cursor: "pointer",
  "&:focus": _extends$4({}, theme2.vars ? {
    backgroundColor: `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.05)`
  } : {
    backgroundColor: theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
  }, {
    borderRadius: 0
    // Reset Chrome style
  }),
  // Remove IE11 arrow
  "&::-ms-expand": {
    display: "none"
  },
  [`&.${nativeSelectClasses.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (theme2.vars || theme2).palette.background.paper
  },
  // Bump specificity to allow extending custom inputs
  "&&&": {
    paddingRight: 24,
    minWidth: 16
    // So it doesn't collapse.
  }
}, ownerState.variant === "filled" && {
  "&&&": {
    paddingRight: 32
  }
}, ownerState.variant === "outlined" && {
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  "&:focus": {
    borderRadius: (theme2.vars || theme2).shape.borderRadius
    // Reset the reset for Chrome style
  },
  "&&&": {
    paddingRight: 32
  }
}), "nativeSelectSelectStyles");
const NativeSelectSelect = styled("select", {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
      [`&.${nativeSelectClasses.multiple}`]: styles2.multiple
    }];
  }
})(nativeSelectSelectStyles);
const nativeSelectIconStyles = /* @__PURE__ */ __name(({
  ownerState,
  theme: theme2
}) => _extends$4({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  top: "calc(50% - .5em)",
  // Center vertically, height is 1em
  pointerEvents: "none",
  // Don't block pointer events on the select under the icon.
  color: (theme2.vars || theme2).palette.action.active,
  [`&.${nativeSelectClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  }
}, ownerState.open && {
  transform: "rotate(180deg)"
}, ownerState.variant === "filled" && {
  right: 7
}, ownerState.variant === "outlined" && {
  right: 7
}), "nativeSelectIconStyles");
const NativeSelectIcon = styled("svg", {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize$1(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})(nativeSelectIconStyles);
const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function NativeSelectInput2(props, ref) {
  const {
    className,
    disabled,
    error,
    IconComponent,
    inputRef,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1W);
  const ownerState = _extends$4({}, props, {
    disabled,
    variant,
    error
  });
  const classes2 = useUtilityClasses$1B(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, _extends$4({
      ownerState,
      className: clsx(classes2.select, className),
      disabled,
      ref: inputRef || ref
    }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState,
      className: classes2.icon
    })]
  });
}, "NativeSelectInput2"));
function getSelectUtilityClasses(slot) {
  return generateUtilityClass$1("MuiSelect", slot);
}
__name(getSelectUtilityClasses, "getSelectUtilityClasses");
const selectClasses = generateUtilityClasses$1("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var _span$3;
const _excluded$1V = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
const SelectSelect = styled("div", {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [
      // Win specificity over the input base
      {
        [`&.${selectClasses.select}`]: styles2.select
      },
      {
        [`&.${selectClasses.select}`]: styles2[ownerState.variant]
      },
      {
        [`&.${selectClasses.error}`]: styles2.error
      },
      {
        [`&.${selectClasses.multiple}`]: styles2.multiple
      }
    ];
  }
})(nativeSelectSelectStyles, {
  // Win specificity over the input base
  [`&.${selectClasses.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
});
const SelectIcon = styled("svg", {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize$1(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})(nativeSelectIconStyles);
const SelectNativeInput = styled("input", {
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (props, styles2) => styles2.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function areEqualValues(a, b2) {
  if (typeof b2 === "object" && b2 !== null) {
    return a === b2;
  }
  return String(a) === String(b2);
}
__name(areEqualValues, "areEqualValues");
function isEmpty(display) {
  return display == null || typeof display === "string" && !display.trim();
}
__name(isEmpty, "isEmpty");
const useUtilityClasses$1A = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    variant,
    disabled,
    multiple,
    open: open2,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize$1(variant)}`, open2 && "iconOpen", disabled && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return composeClasses(slots, getSelectUtilityClasses, classes2);
}, "useUtilityClasses$1A");
const SelectInput = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function SelectInput2(props, ref) {
  var _MenuProps$slotProps;
  const {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultOpen,
    defaultValue,
    disabled,
    displayEmpty,
    error = false,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name,
    onBlur,
    onChange,
    onClose,
    onFocus,
    onOpen,
    open: openProp,
    readOnly,
    renderValue: renderValue2,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    value: valueProp,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1V);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Select"
  });
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Select"
  });
  const inputRef = reactExports.useRef(null);
  const displayRef = reactExports.useRef(null);
  const [displayNode, setDisplayNode] = reactExports.useState(null);
  const {
    current: isOpenControlled
  } = reactExports.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
  const handleRef = useForkRef(ref, inputRefProp);
  const handleDisplayRef = reactExports.useCallback((node2) => {
    displayRef.current = node2;
    if (node2) {
      setDisplayNode(node2);
    }
  }, []);
  const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
  reactExports.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);
  reactExports.useEffect(() => {
    if (defaultOpen && openState && displayNode && !isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      displayRef.current.focus();
    }
  }, [displayNode, autoWidth]);
  reactExports.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useEffect(() => {
    if (!labelId) {
      return void 0;
    }
    const label = ownerDocument(displayRef.current).getElementById(labelId);
    if (label) {
      const handler = /* @__PURE__ */ __name(() => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      }, "handler");
      label.addEventListener("click", handler);
      return () => {
        label.removeEventListener("click", handler);
      };
    }
    return void 0;
  }, [labelId]);
  const update = /* @__PURE__ */ __name((open22, event) => {
    if (open22) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      setOpenState(open22);
    }
  }, "update");
  const handleMouseDown = /* @__PURE__ */ __name((event) => {
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    displayRef.current.focus();
    update(true, event);
  }, "handleMouseDown");
  const handleClose = /* @__PURE__ */ __name((event) => {
    update(false, event);
  }, "handleClose");
  const childrenArray = reactExports.Children.toArray(children);
  const handleChange = /* @__PURE__ */ __name((event) => {
    const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
    if (child === void 0) {
      return;
    }
    setValueState(child.props.value);
    if (onChange) {
      onChange(event, child);
    }
  }, "handleChange");
  const handleItemClick = /* @__PURE__ */ __name((child) => (event) => {
    let newValue;
    if (!event.currentTarget.hasAttribute("tabindex")) {
      return;
    }
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);
      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }
    if (child.props.onClick) {
      child.props.onClick(event);
    }
    if (value !== newValue) {
      setValueState(newValue);
      if (onChange) {
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: true,
          value: {
            value: newValue,
            name
          }
        });
        onChange(clonedEvent, child);
      }
    }
    if (!multiple) {
      update(false, event);
    }
  }, "handleItemClick");
  const handleKeyDown2 = /* @__PURE__ */ __name((event) => {
    if (!readOnly) {
      const validKeys = [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ];
      if (validKeys.indexOf(event.key) !== -1) {
        event.preventDefault();
        update(true, event);
      }
    }
  }, "handleKeyDown");
  const open2 = displayNode !== null && openState;
  const handleBlur2 = /* @__PURE__ */ __name((event) => {
    if (!open2 && onBlur) {
      Object.defineProperty(event, "target", {
        writable: true,
        value: {
          value,
          name
        }
      });
      onBlur(event);
    }
  }, "handleBlur");
  delete other["aria-invalid"];
  let display;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;
  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue2) {
      display = renderValue2(value);
    } else {
      computeDisplay = true;
    }
  }
  const items = childrenArray.map((child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    let selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(formatMuiErrorMessage$1(2));
      }
      selected = value.some((v2) => areEqualValues(v2, child.props.value));
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      "aria-selected": selected ? "true" : "false",
      onClick: handleItemClick(child),
      onKeyUp: (event) => {
        if (event.key === " ") {
          event.preventDefault();
        }
        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: "option",
      selected,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": child.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  if (computeDisplay) {
    if (multiple) {
      if (displayMultiple.length === 0) {
        display = null;
      } else {
        display = displayMultiple.reduce((output, child, index2) => {
          output.push(child);
          if (index2 < displayMultiple.length - 1) {
            output.push(", ");
          }
          return output;
        }, []);
      }
    } else {
      display = displaySingle;
    }
  }
  let menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = anchorElement.clientWidth;
  }
  let tabIndex;
  if (typeof tabIndexProp !== "undefined") {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
  const ownerState = _extends$4({}, props, {
    variant,
    value,
    open: open2,
    error
  });
  const classes2 = useUtilityClasses$1A(ownerState);
  const paperProps = _extends$4({}, MenuProps.PaperProps, (_MenuProps$slotProps = MenuProps.slotProps) == null ? void 0 : _MenuProps$slotProps.paper);
  const listboxId = useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, _extends$4({
      ref: handleDisplayRef,
      tabIndex,
      role: "combobox",
      "aria-controls": listboxId,
      "aria-disabled": disabled ? "true" : void 0,
      "aria-expanded": open2 ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
      "aria-describedby": ariaDescribedby,
      onKeyDown: handleKeyDown2,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur2,
      onFocus
    }, SelectDisplayProps, {
      ownerState,
      className: clsx(SelectDisplayProps.className, classes2.select, className),
      id: buttonId,
      children: isEmpty(display) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$3 || (_span$3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: ""
        }))
      ) : display
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, _extends$4({
      "aria-invalid": error,
      value: Array.isArray(value) ? value.join(",") : value,
      name,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled,
      className: classes2.nativeInput,
      autoFocus,
      ownerState
    }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
      as: IconComponent,
      className: classes2.icon,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, _extends$4({
      id: `menu-${name || ""}`,
      anchorEl: anchorElement,
      open: open2,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, MenuProps, {
      MenuListProps: _extends$4({
        "aria-labelledby": labelId,
        role: "listbox",
        "aria-multiselectable": multiple ? "true" : void 0,
        disableListWrap: true,
        id: listboxId
      }, MenuProps.MenuListProps),
      slotProps: _extends$4({}, MenuProps.slotProps, {
        paper: _extends$4({}, paperProps, {
          style: _extends$4({
            minWidth: menuMinWidth
          }, paperProps != null ? paperProps.style : null)
        })
      }),
      children: items
    }))]
  });
}, "SelectInput2"));
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass$1("MuiSvgIcon", slot);
}
__name(getSvgIconUtilityClass, "getSvgIconUtilityClass");
generateUtilityClasses$1("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$1U = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
const useUtilityClasses$1z = /* @__PURE__ */ __name((ownerState) => {
  const {
    color: color2,
    fontSize,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize$1(color2)}`, `fontSize${capitalize$1(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes2);
}, "useUtilityClasses$1z");
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize$1(ownerState.color)}`], styles2[`fontSize${capitalize$1(ownerState.fontSize)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    // the <svg> will define the property that has `currentColor`
    // for example heroicons uses fill="none" and stroke="currentColor"
    fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
    flexShrink: 0,
    transition: (_theme$transitions = theme2.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
      duration: (_theme$transitions2 = theme2.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((_theme$typography = theme2.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
      medium: ((_theme$typography2 = theme2.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
      large: ((_theme$typography3 = theme2.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
    }[ownerState.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (_palette$ownerState$c = (_palette = (theme2.vars || theme2).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
      action: (_palette2 = (theme2.vars || theme2).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
      disabled: (_palette3 = (theme2.vars || theme2).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
      inherit: void 0
    }[ownerState.color]
  };
});
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function SvgIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1U);
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
  const ownerState = _extends$4({}, props, {
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes2 = useUtilityClasses$1z(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$4({
    as: component,
    className: clsx(classes2.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref
  }, more, other, hasSvgAsChild && children.props, {
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  }));
}, "SvgIcon2"));
SvgIcon.muiName = "SvgIcon";
function createSvgIcon$1(path, displayName) {
  function Component(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, _extends$4({
      "data-testid": `${displayName}Icon`,
      ref
    }, props, {
      children: path
    }));
  }
  __name(Component, "Component");
  Component.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
__name(createSvgIcon$1, "createSvgIcon$1");
const ArrowDropDownIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
function getInputUtilityClass(slot) {
  return generateUtilityClass$1("MuiInput", slot);
}
__name(getInputUtilityClass, "getInputUtilityClass");
const inputClasses = _extends$4({}, inputBaseClasses, generateUtilityClasses$1("MuiInput", ["root", "underline", "input"]));
const _excluded$1T = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$1y = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getInputUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$1y");
const InputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const light2 = theme2.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme2.vars) {
    bottomLineColor = `rgba(${theme2.vars.palette.common.onBackgroundChannel} / ${theme2.vars.opacity.inputUnderline})`;
  }
  return _extends$4({
    position: "relative"
  }, ownerState.formControl && {
    "label + &": {
      marginTop: 16
    }
  }, !ownerState.disableUnderline && {
    "&::after": {
      borderBottom: `2px solid ${(theme2.vars || theme2).palette[ownerState.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme2.transitions.create("transform", {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${inputClasses.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${inputClasses.error}`]: {
      "&::before, &::after": {
        borderBottomColor: (theme2.vars || theme2).palette.error.main
      }
    },
    "&::before": {
      borderBottom: `1px solid ${bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme2.transitions.create("border-bottom-color", {
        duration: theme2.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${inputClasses.disabled}, .${inputClasses.error}):before`]: {
      borderBottom: `2px solid ${(theme2.vars || theme2).palette.text.primary}`,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        borderBottom: `1px solid ${bottomLineColor}`
      }
    },
    [`&.${inputClasses.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  });
});
const InputInput = styled(InputBaseComponent, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})({});
const Input = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Input2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInput"
  });
  const {
    disableUnderline,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1T);
  const classes2 = useUtilityClasses$1y(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge$1(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, _extends$4({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other, {
    classes: classes2
  }));
}, "Input2"));
Input.muiName = "Input";
function getFilledInputUtilityClass(slot) {
  return generateUtilityClass$1("MuiFilledInput", slot);
}
__name(getFilledInputUtilityClass, "getFilledInputUtilityClass");
const filledInputClasses = _extends$4({}, inputBaseClasses, generateUtilityClasses$1("MuiFilledInput", ["root", "underline", "input"]));
const _excluded$1S = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$1x = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$1x");
const FilledInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _palette;
  const light2 = theme2.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return _extends$4({
    position: "relative",
    backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme2.vars || theme2).shape.borderRadius,
    borderTopRightRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create("background-color", {
      duration: theme2.transitions.duration.shorter,
      easing: theme2.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${filledInputClasses.focused}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${filledInputClasses.disabled}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.disabledBg : disabledBackground
    }
  }, !ownerState.disableUnderline && {
    "&::after": {
      borderBottom: `2px solid ${(_palette = (theme2.vars || theme2).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme2.transitions.create("transform", {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${filledInputClasses.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${filledInputClasses.error}`]: {
      "&::before, &::after": {
        borderBottomColor: (theme2.vars || theme2).palette.error.main
      }
    },
    "&::before": {
      borderBottom: `1px solid ${theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / ${theme2.vars.opacity.inputUnderline})` : bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme2.transitions.create("border-bottom-color", {
        duration: theme2.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${filledInputClasses.disabled}, .${filledInputClasses.error}):before`]: {
      borderBottom: `1px solid ${(theme2.vars || theme2).palette.text.primary}`
    },
    [`&.${filledInputClasses.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  }, ownerState.startAdornment && {
    paddingLeft: 12
  }, ownerState.endAdornment && {
    paddingRight: 12
  }, ownerState.multiline && _extends$4({
    padding: "25px 12px 8px"
  }, ownerState.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, ownerState.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }, ownerState.hiddenLabel && ownerState.size === "small" && {
    paddingTop: 8,
    paddingBottom: 9
  }));
});
const FilledInputInput = styled(InputBaseComponent, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}, theme2.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  paddingTop: 21,
  paddingBottom: 4
}, ownerState.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}, ownerState.hiddenLabel && ownerState.size === "small" && {
  paddingTop: 8,
  paddingBottom: 9
}, ownerState.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}));
const FilledInput = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function FilledInput2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFilledInput"
  });
  const {
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    // declare here to prevent spreading to DOM
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1S);
  const ownerState = _extends$4({}, props, {
    fullWidth,
    inputComponent,
    multiline,
    type
  });
  const classes2 = useUtilityClasses$1x(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge$1(filledInputComponentsProps, slotProps != null ? slotProps : componentsPropsProp) : filledInputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, _extends$4({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other, {
    classes: classes2
  }));
}, "FilledInput2"));
FilledInput.muiName = "Input";
var _span$2;
const _excluded$1R = ["children", "classes", "className", "label", "notched"];
const NotchedOutlineRoot$1 = styled("fieldset", {
  shouldForwardProp: rootShouldForwardProp
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
});
const NotchedOutlineLegend = styled("legend", {
  shouldForwardProp: rootShouldForwardProp
})(({
  ownerState,
  theme: theme2
}) => _extends$4({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden"
}, !ownerState.withLabel && {
  padding: 0,
  lineHeight: "11px",
  // sync with `height` in `legend` styles
  transition: theme2.transitions.create("width", {
    duration: 150,
    easing: theme2.transitions.easing.easeOut
  })
}, ownerState.withLabel && _extends$4({
  display: "block",
  // Fix conflict with normalize.css and sanitize.css
  padding: 0,
  height: 11,
  // sync with `lineHeight` in `legend` styles
  fontSize: "0.75em",
  visibility: "hidden",
  maxWidth: 0.01,
  transition: theme2.transitions.create("max-width", {
    duration: 50,
    easing: theme2.transitions.easing.easeOut
  }),
  whiteSpace: "nowrap",
  "& > span": {
    paddingLeft: 5,
    paddingRight: 5,
    display: "inline-block",
    opacity: 0,
    visibility: "visible"
  }
}, ownerState.notched && {
  maxWidth: "100%",
  transition: theme2.transitions.create("max-width", {
    duration: 100,
    easing: theme2.transitions.easing.easeOut,
    delay: 50
  })
})));
function NotchedOutline(props) {
  const {
    className,
    label,
    notched
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1R);
  const withLabel = label != null && label !== "";
  const ownerState = _extends$4({}, props, {
    notched,
    withLabel
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, _extends$4({
    "aria-hidden": true,
    className,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: ""
        }))
      )
    })
  }));
}
__name(NotchedOutline, "NotchedOutline");
function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass$1("MuiOutlinedInput", slot);
}
__name(getOutlinedInputUtilityClass, "getOutlinedInputUtilityClass");
const outlinedInputClasses = _extends$4({}, inputBaseClasses, generateUtilityClasses$1("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
const _excluded$1Q = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
const useUtilityClasses$1w = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$1w");
const OutlinedInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return _extends$4({
    position: "relative",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
        borderColor: theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      }
    },
    [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette[ownerState.color].main,
      borderWidth: 2
    },
    [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.error.main
    },
    [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.action.disabled
    }
  }, ownerState.startAdornment && {
    paddingLeft: 14
  }, ownerState.endAdornment && {
    paddingRight: 14
  }, ownerState.multiline && _extends$4({
    padding: "16.5px 14px"
  }, ownerState.size === "small" && {
    padding: "8.5px 14px"
  }));
});
const NotchedOutlineRoot = styled(NotchedOutline, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (props, styles2) => styles2.notchedOutline
})(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
  };
});
const OutlinedInputInput = styled(InputBaseComponent, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  padding: "16.5px 14px"
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}, theme2.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  padding: "8.5px 14px"
}, ownerState.multiline && {
  padding: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}));
const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function OutlinedInput2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiOutlinedInput"
  });
  const {
    components = {},
    fullWidth = false,
    inputComponent = "input",
    label,
    multiline = false,
    notched,
    slots = {},
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1Q);
  const classes2 = useUtilityClasses$1w(props);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  });
  const ownerState = _extends$4({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type
  });
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, _extends$4({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
      ownerState,
      className: classes2.notchedOutline,
      label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, "", "*"]
      })) : label,
      notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other, {
    classes: _extends$4({}, classes2, {
      notchedOutline: null
    })
  }));
}, "OutlinedInput2"));
OutlinedInput.muiName = "Input";
const _excluded$1P = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], _excluded2$e = ["root"];
const useUtilityClasses$1v = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  return classes2;
}, "useUtilityClasses$1v");
const styledRootConfig = {
  name: "MuiSelect",
  overridesResolver: (props, styles2) => styles2.root,
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
  slot: "Root"
};
const StyledInput = styled(Input, styledRootConfig)("");
const StyledOutlinedInput = styled(OutlinedInput, styledRootConfig)("");
const StyledFilledInput = styled(FilledInput, styledRootConfig)("");
const Select = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Select2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiSelect",
    props: inProps
  });
  const {
    autoWidth = false,
    children,
    classes: classesProp = {},
    className,
    defaultOpen = false,
    displayEmpty = false,
    IconComponent = ArrowDropDownIcon,
    id: id2,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = false,
    native = false,
    onClose,
    onOpen,
    open: open2,
    renderValue: renderValue2,
    SelectDisplayProps,
    variant: variantProp = "outlined"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1P);
  const inputComponent = native ? NativeSelectInput : SelectInput;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "error"]
  });
  const variant = fcs.variant || variantProp;
  const ownerState = _extends$4({}, props, {
    variant,
    classes: classesProp
  });
  const classes2 = useUtilityClasses$1v(ownerState);
  const restOfClasses = _objectWithoutPropertiesLoose$1(classes2, _excluded2$e);
  const InputComponent = input || {
    standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
      ownerState
    }),
    outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
      label,
      ownerState
    }),
    filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
      ownerState
    })
  }[variant];
  const inputComponentRef = useForkRef(ref, InputComponent.ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, _extends$4({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent,
      inputProps: _extends$4({
        children,
        error: fcs.error,
        IconComponent,
        variant,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple
      }, native ? {
        id: id2
      } : {
        autoWidth,
        defaultOpen,
        displayEmpty,
        labelId,
        MenuProps,
        onClose,
        onOpen,
        open: open2,
        renderValue: renderValue2,
        SelectDisplayProps: _extends$4({
          id: id2
        }, SelectDisplayProps)
      }, inputProps, {
        classes: inputProps ? deepmerge$1(restOfClasses, inputProps.classes) : restOfClasses
      }, input ? input.props.inputProps : {})
    }, (multiple && native || displayEmpty) && variant === "outlined" ? {
      notched: true
    } : {}, {
      ref: inputComponentRef,
      className: clsx(InputComponent.props.className, className, classes2.root)
    }, !input && {
      variant
    }, other))
  });
}, "Select2"));
Select.muiName = "Select";
function getToolbarUtilityClass(slot) {
  return generateUtilityClass$1("MuiToolbar", slot);
}
__name(getToolbarUtilityClass, "getToolbarUtilityClass");
generateUtilityClasses$1("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const _excluded$1O = ["className", "component", "disableGutters", "variant"];
const useUtilityClasses$1u = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disableGutters,
    variant
  } = ownerState;
  const slots = {
    root: ["root", !disableGutters && "gutters", variant]
  };
  return composeClasses(slots, getToolbarUtilityClass, classes2);
}, "useUtilityClasses$1u");
const ToolbarRoot = styled("div", {
  name: "MuiToolbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableGutters && styles2.gutters, styles2[ownerState.variant]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  position: "relative",
  display: "flex",
  alignItems: "center"
}, !ownerState.disableGutters && {
  paddingLeft: theme2.spacing(2),
  paddingRight: theme2.spacing(2),
  [theme2.breakpoints.up("sm")]: {
    paddingLeft: theme2.spacing(3),
    paddingRight: theme2.spacing(3)
  }
}, ownerState.variant === "dense" && {
  minHeight: 48
}), ({
  theme: theme2,
  ownerState
}) => ownerState.variant === "regular" && theme2.mixins.toolbar);
const Toolbar = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Toolbar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiToolbar"
  });
  const {
    className,
    component = "div",
    disableGutters = false,
    variant = "regular"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1O);
  const ownerState = _extends$4({}, props, {
    component,
    disableGutters,
    variant
  });
  const classes2 = useUtilityClasses$1u(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarRoot, _extends$4({
    as: component,
    className: clsx(classes2.root, className),
    ref,
    ownerState
  }, other));
}, "Toolbar2"));
const KeyboardArrowLeft = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), "KeyboardArrowLeft");
const KeyboardArrowRight = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), "KeyboardArrowRight");
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass$1("MuiIconButton", slot);
}
__name(getIconButtonUtilityClass, "getIconButtonUtilityClass");
const iconButtonClasses = generateUtilityClasses$1("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
const _excluded$1N = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
const useUtilityClasses$1t = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disabled,
    color: color2,
    edge,
    size: size2
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize$1(color2)}`, edge && `edge${capitalize$1(edge)}`, `size${capitalize$1(size2)}`]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes2);
}, "useUtilityClasses$1t");
const IconButtonRoot = styled(ButtonBase, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize$1(ownerState.edge)}`], styles2[`size${capitalize$1(ownerState.size)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme2.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  overflow: "visible",
  // Explicitly set the default value to solve a bug on IE11.
  color: (theme2.vars || theme2).palette.action.active,
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  })
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.activeChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha_1(theme2.palette.action.active, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}), ({
  theme: theme2,
  ownerState
}) => {
  var _palette;
  const palette = (_palette = (theme2.vars || theme2).palette) == null ? void 0 : _palette[ownerState.color];
  return _extends$4({}, ownerState.color === "inherit" && {
    color: "inherit"
  }, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends$4({
    color: palette == null ? void 0 : palette.main
  }, !ownerState.disableRipple && {
    "&:hover": _extends$4({}, palette && {
      backgroundColor: theme2.vars ? `rgba(${palette.mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha_1(palette.main, theme2.palette.action.hoverOpacity)
    }, {
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    })
  }), ownerState.size === "small" && {
    padding: 5,
    fontSize: theme2.typography.pxToRem(18)
  }, ownerState.size === "large" && {
    padding: 12,
    fontSize: theme2.typography.pxToRem(28)
  }, {
    [`&.${iconButtonClasses.disabled}`]: {
      backgroundColor: "transparent",
      color: (theme2.vars || theme2).palette.action.disabled
    }
  });
});
const IconButton = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function IconButton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size: size2 = "medium"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1N);
  const ownerState = _extends$4({}, props, {
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    size: size2
  });
  const classes2 = useUtilityClasses$1t(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonRoot, _extends$4({
    className: clsx(classes2.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    ref
  }, other, {
    ownerState,
    children
  }));
}, "IconButton2"));
const LastPageIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}), "LastPage");
const FirstPageIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}), "FirstPage");
const _excluded$1M = ["backIconButtonProps", "count", "disabled", "getItemAriaLabel", "nextIconButtonProps", "onPageChange", "page", "rowsPerPage", "showFirstButton", "showLastButton", "slots", "slotProps"];
const TablePaginationActions = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TablePaginationActions2(props, ref) {
  var _slots$firstButton, _slots$lastButton, _slots$nextButton, _slots$previousButton, _slots$firstButtonIco, _slots$lastButtonIcon, _slots$nextButtonIcon, _slots$previousButton2;
  const {
    backIconButtonProps,
    count,
    disabled = false,
    getItemAriaLabel,
    nextIconButtonProps,
    onPageChange,
    page,
    rowsPerPage,
    showFirstButton,
    showLastButton,
    slots = {},
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1M);
  const isRtl = useRtl();
  const handleFirstPageButtonClick = /* @__PURE__ */ __name((event) => {
    onPageChange(event, 0);
  }, "handleFirstPageButtonClick");
  const handleBackButtonClick = /* @__PURE__ */ __name((event) => {
    onPageChange(event, page - 1);
  }, "handleBackButtonClick");
  const handleNextButtonClick = /* @__PURE__ */ __name((event) => {
    onPageChange(event, page + 1);
  }, "handleNextButtonClick");
  const handleLastPageButtonClick = /* @__PURE__ */ __name((event) => {
    onPageChange(event, Math.max(0, Math.ceil(count / rowsPerPage) - 1));
  }, "handleLastPageButtonClick");
  const FirstButton = (_slots$firstButton = slots.firstButton) != null ? _slots$firstButton : IconButton;
  const LastButton = (_slots$lastButton = slots.lastButton) != null ? _slots$lastButton : IconButton;
  const NextButton = (_slots$nextButton = slots.nextButton) != null ? _slots$nextButton : IconButton;
  const PreviousButton = (_slots$previousButton = slots.previousButton) != null ? _slots$previousButton : IconButton;
  const FirstButtonIcon = (_slots$firstButtonIco = slots.firstButtonIcon) != null ? _slots$firstButtonIco : FirstPageIcon;
  const LastButtonIcon = (_slots$lastButtonIcon = slots.lastButtonIcon) != null ? _slots$lastButtonIcon : LastPageIcon;
  const NextButtonIcon = (_slots$nextButtonIcon = slots.nextButtonIcon) != null ? _slots$nextButtonIcon : KeyboardArrowRight;
  const PreviousButtonIcon = (_slots$previousButton2 = slots.previousButtonIcon) != null ? _slots$previousButton2 : KeyboardArrowLeft;
  const FirstButtonSlot = isRtl ? LastButton : FirstButton;
  const PreviousButtonSlot = isRtl ? NextButton : PreviousButton;
  const NextButtonSlot = isRtl ? PreviousButton : NextButton;
  const LastButtonSlot = isRtl ? FirstButton : LastButton;
  const firstButtonSlotProps = isRtl ? slotProps.lastButton : slotProps.firstButton;
  const previousButtonSlotProps = isRtl ? slotProps.nextButton : slotProps.previousButton;
  const nextButtonSlotProps = isRtl ? slotProps.previousButton : slotProps.nextButton;
  const lastButtonSlotProps = isRtl ? slotProps.firstButton : slotProps.lastButton;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$4({
    ref
  }, other, {
    children: [showFirstButton && /* @__PURE__ */ jsxRuntimeExports.jsx(FirstButtonSlot, _extends$4({
      onClick: handleFirstPageButtonClick,
      disabled: disabled || page === 0,
      "aria-label": getItemAriaLabel("first", page),
      title: getItemAriaLabel("first", page)
    }, firstButtonSlotProps, {
      children: isRtl ? /* @__PURE__ */ jsxRuntimeExports.jsx(LastButtonIcon, _extends$4({}, slotProps.lastButtonIcon)) : /* @__PURE__ */ jsxRuntimeExports.jsx(FirstButtonIcon, _extends$4({}, slotProps.firstButtonIcon))
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(PreviousButtonSlot, _extends$4({
      onClick: handleBackButtonClick,
      disabled: disabled || page === 0,
      color: "inherit",
      "aria-label": getItemAriaLabel("previous", page),
      title: getItemAriaLabel("previous", page)
    }, previousButtonSlotProps != null ? previousButtonSlotProps : backIconButtonProps, {
      children: isRtl ? /* @__PURE__ */ jsxRuntimeExports.jsx(NextButtonIcon, _extends$4({}, slotProps.nextButtonIcon)) : /* @__PURE__ */ jsxRuntimeExports.jsx(PreviousButtonIcon, _extends$4({}, slotProps.previousButtonIcon))
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(NextButtonSlot, _extends$4({
      onClick: handleNextButtonClick,
      disabled: disabled || (count !== -1 ? page >= Math.ceil(count / rowsPerPage) - 1 : false),
      color: "inherit",
      "aria-label": getItemAriaLabel("next", page),
      title: getItemAriaLabel("next", page)
    }, nextButtonSlotProps != null ? nextButtonSlotProps : nextIconButtonProps, {
      children: isRtl ? /* @__PURE__ */ jsxRuntimeExports.jsx(PreviousButtonIcon, _extends$4({}, slotProps.previousButtonIcon)) : /* @__PURE__ */ jsxRuntimeExports.jsx(NextButtonIcon, _extends$4({}, slotProps.nextButtonIcon))
    })), showLastButton && /* @__PURE__ */ jsxRuntimeExports.jsx(LastButtonSlot, _extends$4({
      onClick: handleLastPageButtonClick,
      disabled: disabled || page >= Math.ceil(count / rowsPerPage) - 1,
      "aria-label": getItemAriaLabel("last", page),
      title: getItemAriaLabel("last", page)
    }, lastButtonSlotProps, {
      children: isRtl ? /* @__PURE__ */ jsxRuntimeExports.jsx(FirstButtonIcon, _extends$4({}, slotProps.firstButtonIcon)) : /* @__PURE__ */ jsxRuntimeExports.jsx(LastButtonIcon, _extends$4({}, slotProps.lastButtonIcon))
    }))]
  }));
}, "TablePaginationActions2"));
function getTablePaginationUtilityClass(slot) {
  return generateUtilityClass$1("MuiTablePagination", slot);
}
__name(getTablePaginationUtilityClass, "getTablePaginationUtilityClass");
const tablePaginationClasses = generateUtilityClasses$1("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]);
var _InputBase;
const _excluded$1L = ["ActionsComponent", "backIconButtonProps", "className", "colSpan", "component", "count", "disabled", "getItemAriaLabel", "labelDisplayedRows", "labelRowsPerPage", "nextIconButtonProps", "onPageChange", "onRowsPerPageChange", "page", "rowsPerPage", "rowsPerPageOptions", "SelectProps", "showFirstButton", "showLastButton", "slotProps", "slots"];
const TablePaginationRoot = styled(TableCell, {
  name: "MuiTablePagination",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => ({
  overflow: "auto",
  color: (theme2.vars || theme2).palette.text.primary,
  fontSize: theme2.typography.pxToRem(14),
  // Increase the specificity to override TableCell.
  "&:last-child": {
    padding: 0
  }
}));
const TablePaginationToolbar = styled(Toolbar, {
  name: "MuiTablePagination",
  slot: "Toolbar",
  overridesResolver: (props, styles2) => _extends$4({
    [`& .${tablePaginationClasses.actions}`]: styles2.actions
  }, styles2.toolbar)
})(({
  theme: theme2
}) => ({
  minHeight: 52,
  paddingRight: 2,
  [`${theme2.breakpoints.up("xs")} and (orientation: landscape)`]: {
    minHeight: 52
  },
  [theme2.breakpoints.up("sm")]: {
    minHeight: 52,
    paddingRight: 2
  },
  [`& .${tablePaginationClasses.actions}`]: {
    flexShrink: 0,
    marginLeft: 20
  }
}));
const TablePaginationSpacer = styled("div", {
  name: "MuiTablePagination",
  slot: "Spacer",
  overridesResolver: (props, styles2) => styles2.spacer
})({
  flex: "1 1 100%"
});
const TablePaginationSelectLabel = styled("p", {
  name: "MuiTablePagination",
  slot: "SelectLabel",
  overridesResolver: (props, styles2) => styles2.selectLabel
})(({
  theme: theme2
}) => _extends$4({}, theme2.typography.body2, {
  flexShrink: 0
}));
const TablePaginationSelect = styled(Select, {
  name: "MuiTablePagination",
  slot: "Select",
  overridesResolver: (props, styles2) => _extends$4({
    [`& .${tablePaginationClasses.selectIcon}`]: styles2.selectIcon,
    [`& .${tablePaginationClasses.select}`]: styles2.select
  }, styles2.input, styles2.selectRoot)
})({
  color: "inherit",
  fontSize: "inherit",
  flexShrink: 0,
  marginRight: 32,
  marginLeft: 8,
  [`& .${tablePaginationClasses.select}`]: {
    paddingLeft: 8,
    paddingRight: 24,
    textAlign: "right",
    textAlignLast: "right"
    // Align <select> on Chrome.
  }
});
const TablePaginationMenuItem = styled(MenuItem, {
  name: "MuiTablePagination",
  slot: "MenuItem",
  overridesResolver: (props, styles2) => styles2.menuItem
})({});
const TablePaginationDisplayedRows = styled("p", {
  name: "MuiTablePagination",
  slot: "DisplayedRows",
  overridesResolver: (props, styles2) => styles2.displayedRows
})(({
  theme: theme2
}) => _extends$4({}, theme2.typography.body2, {
  flexShrink: 0
}));
function defaultLabelDisplayedRows$1({
  from: from2,
  to,
  count
}) {
  return `${from2}${to} of ${count !== -1 ? count : `more than ${to}`}`;
}
__name(defaultLabelDisplayedRows$1, "defaultLabelDisplayedRows$1");
function defaultGetAriaLabel(type) {
  return `Go to ${type} page`;
}
__name(defaultGetAriaLabel, "defaultGetAriaLabel");
const useUtilityClasses$1s = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    toolbar: ["toolbar"],
    spacer: ["spacer"],
    selectLabel: ["selectLabel"],
    select: ["select"],
    input: ["input"],
    selectIcon: ["selectIcon"],
    menuItem: ["menuItem"],
    displayedRows: ["displayedRows"],
    actions: ["actions"]
  };
  return composeClasses(slots, getTablePaginationUtilityClass, classes2);
}, "useUtilityClasses$1s");
const TablePagination = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TablePagination2(inProps, ref) {
  var _slotProps$select;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTablePagination"
  });
  const {
    ActionsComponent = TablePaginationActions,
    backIconButtonProps,
    className,
    colSpan: colSpanProp,
    component = TableCell,
    count,
    disabled = false,
    getItemAriaLabel = defaultGetAriaLabel,
    labelDisplayedRows = defaultLabelDisplayedRows$1,
    labelRowsPerPage = "Rows per page:",
    nextIconButtonProps,
    onPageChange,
    onRowsPerPageChange,
    page,
    rowsPerPage,
    rowsPerPageOptions = [10, 25, 50, 100],
    SelectProps = {},
    showFirstButton = false,
    showLastButton = false,
    slotProps = {},
    slots = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1L);
  const ownerState = props;
  const classes2 = useUtilityClasses$1s(ownerState);
  const selectProps = (_slotProps$select = slotProps == null ? void 0 : slotProps.select) != null ? _slotProps$select : SelectProps;
  const MenuItemComponent = selectProps.native ? "option" : TablePaginationMenuItem;
  let colSpan;
  if (component === TableCell || component === "td") {
    colSpan = colSpanProp || 1e3;
  }
  const selectId = useId(selectProps.id);
  const labelId = useId(selectProps.labelId);
  const getLabelDisplayedRowsTo = /* @__PURE__ */ __name(() => {
    if (count === -1) {
      return (page + 1) * rowsPerPage;
    }
    return rowsPerPage === -1 ? count : Math.min(count, (page + 1) * rowsPerPage);
  }, "getLabelDisplayedRowsTo");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationRoot, _extends$4({
    colSpan,
    ref,
    as: component,
    ownerState,
    className: clsx(classes2.root, className)
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TablePaginationToolbar, {
      className: classes2.toolbar,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationSpacer, {
        className: classes2.spacer
      }), rowsPerPageOptions.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationSelectLabel, {
        className: classes2.selectLabel,
        id: labelId,
        children: labelRowsPerPage
      }), rowsPerPageOptions.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationSelect, _extends$4({
        variant: "standard"
      }, !selectProps.variant && {
        input: _InputBase || (_InputBase = /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, {}))
      }, {
        value: rowsPerPage,
        onChange: onRowsPerPageChange,
        id: selectId,
        labelId
      }, selectProps, {
        classes: _extends$4({}, selectProps.classes, {
          // TODO v5 remove `classes.input`
          root: clsx(classes2.input, classes2.selectRoot, (selectProps.classes || {}).root),
          select: clsx(classes2.select, (selectProps.classes || {}).select),
          // TODO v5 remove `selectIcon`
          icon: clsx(classes2.selectIcon, (selectProps.classes || {}).icon)
        }),
        disabled,
        children: rowsPerPageOptions.map((rowsPerPageOption) => /* @__PURE__ */ reactExports.createElement(MenuItemComponent, _extends$4({}, !isHostComponent$1(MenuItemComponent) && {
          ownerState
        }, {
          className: classes2.menuItem,
          key: rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption,
          value: rowsPerPageOption.value ? rowsPerPageOption.value : rowsPerPageOption
        }), rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption))
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationDisplayedRows, {
        className: classes2.displayedRows,
        children: labelDisplayedRows({
          from: count === 0 ? 0 : page * rowsPerPage + 1,
          to: getLabelDisplayedRowsTo(),
          count: count === -1 ? -1 : count,
          page
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsComponent, {
        className: classes2.actions,
        backIconButtonProps,
        count,
        nextIconButtonProps,
        onPageChange,
        page,
        rowsPerPage,
        showFirstButton,
        showLastButton,
        slotProps: slotProps.actions,
        slots: slots.actions,
        getItemAriaLabel,
        disabled
      })]
    })
  }));
}, "TablePagination2"));
function getTableRowUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableRow", slot);
}
__name(getTableRowUtilityClass, "getTableRowUtilityClass");
const tableRowClasses = generateUtilityClasses$1("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
const _excluded$1K = ["className", "component", "hover", "selected"];
const useUtilityClasses$1r = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    selected,
    hover,
    head,
    footer
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", hover && "hover", head && "head", footer && "footer"]
  };
  return composeClasses(slots, getTableRowUtilityClass, classes2);
}, "useUtilityClasses$1r");
const TableRowRoot = styled("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
  }
})(({
  theme: theme2
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${tableRowClasses.hover}:hover`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.hover
  },
  [`&.${tableRowClasses.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity)
    }
  }
}));
const defaultComponent = "tr";
const TableRow = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TableRow2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableRow"
  });
  const {
    className,
    component = defaultComponent,
    hover = false,
    selected = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1K);
  const tablelvl22 = reactExports.useContext(Tablelvl2Context);
  const ownerState = _extends$4({}, props, {
    component,
    hover,
    selected,
    head: tablelvl22 && tablelvl22.variant === "head",
    footer: tablelvl22 && tablelvl22.variant === "footer"
  });
  const classes2 = useUtilityClasses$1r(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRowRoot, _extends$4({
    as: component,
    ref,
    className: clsx(classes2.root, className),
    role: component === defaultComponent ? null : "row",
    ownerState
  }, other));
}, "TableRow2"));
const ArrowDownwardIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}), "ArrowDownward");
function getTableSortLabelUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableSortLabel", slot);
}
__name(getTableSortLabelUtilityClass, "getTableSortLabelUtilityClass");
const tableSortLabelClasses = generateUtilityClasses$1("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc"]);
const _excluded$1J = ["active", "children", "className", "direction", "hideSortIcon", "IconComponent"];
const useUtilityClasses$1q = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    direction,
    active
  } = ownerState;
  const slots = {
    root: ["root", active && "active"],
    icon: ["icon", `iconDirection${capitalize$1(direction)}`]
  };
  return composeClasses(slots, getTableSortLabelUtilityClass, classes2);
}, "useUtilityClasses$1q");
const TableSortLabelRoot = styled(ButtonBase, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.active && styles2.active];
  }
})(({
  theme: theme2
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (theme2.vars || theme2).palette.text.secondary
  },
  "&:hover": {
    color: (theme2.vars || theme2).palette.text.secondary,
    [`& .${tableSortLabelClasses.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${tableSortLabelClasses.active}`]: {
    color: (theme2.vars || theme2).palette.text.primary,
    [`& .${tableSortLabelClasses.icon}`]: {
      opacity: 1,
      color: (theme2.vars || theme2).palette.text.secondary
    }
  }
}));
const TableSortLabelIcon = styled("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, styles2[`iconDirection${capitalize$1(ownerState.direction)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: theme2.transitions.create(["opacity", "transform"], {
    duration: theme2.transitions.duration.shorter
  }),
  userSelect: "none"
}, ownerState.direction === "desc" && {
  transform: "rotate(0deg)"
}, ownerState.direction === "asc" && {
  transform: "rotate(180deg)"
}));
const TableSortLabel = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TableSortLabel2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableSortLabel"
  });
  const {
    active = false,
    children,
    className,
    direction = "asc",
    hideSortIcon = false,
    IconComponent = ArrowDownwardIcon
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1J);
  const ownerState = _extends$4({}, props, {
    active,
    direction,
    hideSortIcon,
    IconComponent
  });
  const classes2 = useUtilityClasses$1q(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableSortLabelRoot, _extends$4({
    className: clsx(classes2.root, className),
    component: "span",
    disableRipple: true,
    ownerState,
    ref
  }, other, {
    children: [children, hideSortIcon && !active ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(TableSortLabelIcon, {
      as: IconComponent,
      className: clsx(classes2.icon),
      ownerState
    })]
  }));
}, "TableSortLabel2"));
var useThemeWithoutDefault = {};
Object.defineProperty(useThemeWithoutDefault, "__esModule", {
  value: true
});
var default_1$v = useThemeWithoutDefault.default = void 0;
var React = _interopRequireWildcard(reactExports);
var _styledEngine = require$$1;
function _getRequireWildcardCache(e2) {
  if ("function" != typeof WeakMap)
    return null;
  var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(e3) {
    return e3 ? t2 : r2;
  }, "_getRequireWildcardCache"))(e2);
}
__name(_getRequireWildcardCache, "_getRequireWildcardCache");
function _interopRequireWildcard(e2, r2) {
  if (e2 && e2.__esModule)
    return e2;
  if (null === e2 || "object" != typeof e2 && "function" != typeof e2)
    return { default: e2 };
  var t2 = _getRequireWildcardCache(r2);
  if (t2 && t2.has(e2))
    return t2.get(e2);
  var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u2 in e2)
    if ("default" !== u2 && Object.prototype.hasOwnProperty.call(e2, u2)) {
      var i = a ? Object.getOwnPropertyDescriptor(e2, u2) : null;
      i && (i.get || i.set) ? Object.defineProperty(n2, u2, i) : n2[u2] = e2[u2];
    }
  return n2.default = e2, t2 && t2.set(e2, n2), n2;
}
__name(_interopRequireWildcard, "_interopRequireWildcard");
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
__name(isObjectEmpty, "isObjectEmpty");
function useTheme(defaultTheme2 = null) {
  const contextTheme = React.useContext(_styledEngine.ThemeContext);
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
__name(useTheme, "useTheme");
default_1$v = useThemeWithoutDefault.default = useTheme;
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto$1 = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto$1]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName$1(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
__name(getNodeName$1, "getNodeName$1");
function getWindow$1(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument2 = node2.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node2;
}
__name(getWindow$1, "getWindow$1");
function isElement$1(node2) {
  var OwnElement = getWindow$1(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
__name(isElement$1, "isElement$1");
function isHTMLElement$2(node2) {
  var OwnElement = getWindow$1(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
__name(isHTMLElement$2, "isHTMLElement$2");
function isShadowRoot$1(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow$1(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
__name(isShadowRoot$1, "isShadowRoot$1");
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement$2(element) || !getNodeName$1(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
__name(applyStyles, "applyStyles");
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement$2(element) || !getNodeName$1(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
__name(effect$2, "effect$2");
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
__name(getBasePlacement, "getBasePlacement");
var max$2 = Math.max;
var min$2 = Math.min;
var round$4 = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
__name(getUAString, "getUAString");
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
__name(isLayoutViewport, "isLayoutViewport");
function getBoundingClientRect$1(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$2(element)) {
    scaleX = element.offsetWidth > 0 ? round$4(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$4(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow$1(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y2,
    right: x2 + width2,
    bottom: y2 + height2,
    left: x2,
    x: x2,
    y: y2
  };
}
__name(getBoundingClientRect$1, "getBoundingClientRect$1");
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect$1(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
__name(getLayoutRect, "getLayoutRect");
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot$1(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
__name(contains, "contains");
function getComputedStyle$3(element) {
  return getWindow$1(element).getComputedStyle(element);
}
__name(getComputedStyle$3, "getComputedStyle$3");
function isTableElement$1(element) {
  return ["table", "td", "th"].indexOf(getNodeName$1(element)) >= 0;
}
__name(isTableElement$1, "isTableElement$1");
function getDocumentElement$1(element) {
  return ((isElement$1(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
__name(getDocumentElement$1, "getDocumentElement$1");
function getParentNode$1(element) {
  if (getNodeName$1(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot$1(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement$1(element)
  );
}
__name(getParentNode$1, "getParentNode$1");
function getTrueOffsetParent$1(element) {
  if (!isHTMLElement$2(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$3(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
__name(getTrueOffsetParent$1, "getTrueOffsetParent$1");
function getContainingBlock$1(element) {
  var isFirefox2 = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement$2(element)) {
    var elementCss = getComputedStyle$3(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode$1(element);
  if (isShadowRoot$1(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$2(currentNode) && ["html", "body"].indexOf(getNodeName$1(currentNode)) < 0) {
    var css2 = getComputedStyle$3(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox2 && css2.willChange === "filter" || isFirefox2 && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
__name(getContainingBlock$1, "getContainingBlock$1");
function getOffsetParent$1(element) {
  var window2 = getWindow$1(element);
  var offsetParent = getTrueOffsetParent$1(element);
  while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle$3(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent$1(offsetParent);
  }
  if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle$3(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock$1(element) || window2;
}
__name(getOffsetParent$1, "getOffsetParent$1");
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
__name(getMainAxisFromPlacement, "getMainAxisFromPlacement");
function within(min2, value, max2) {
  return max$2(min2, min$2(value, max2));
}
__name(within, "within");
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
__name(withinMaxClamp, "withinMaxClamp");
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
__name(getFreshSideObject, "getFreshSideObject");
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
__name(mergePaddingObject, "mergePaddingObject");
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
__name(expandToHashMap, "expandToHashMap");
var toPaddingObject = /* @__PURE__ */ __name(function toPaddingObject2(padding2, state) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
}, "toPaddingObject");
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent$1(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
__name(arrow, "arrow");
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
__name(effect$1, "effect$1");
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
__name(getVariation, "getVariation");
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y2 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$4(x2 * dpr) / dpr || 0,
    y: round$4(y2 * dpr) / dpr || 0
  };
}
__name(roundOffsetsByDPR, "roundOffsetsByDPR");
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent$1(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow$1(popper2)) {
      offsetParent = getDocumentElement$1(popper2);
      if (getComputedStyle$3(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }, getWindow$1(popper2)) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
__name(mapToStyles, "mapToStyles");
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
__name(computeStyles, "computeStyles");
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow$1(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
__name(effect, "effect");
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: /* @__PURE__ */ __name(function fn() {
  }, "fn"),
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement$1(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
__name(getOppositePlacement$1, "getOppositePlacement$1");
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
__name(getOppositeVariationPlacement, "getOppositeVariationPlacement");
function getWindowScroll(node2) {
  var win = getWindow$1(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
__name(getWindowScroll, "getWindowScroll");
function getWindowScrollBarX$1(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getWindowScroll(element).scrollLeft;
}
__name(getWindowScrollBarX$1, "getWindowScrollBarX$1");
function getViewportRect$1(element, strategy) {
  var win = getWindow$1(element);
  var html2 = getDocumentElement$1(element);
  var visualViewport = win.visualViewport;
  var width2 = html2.clientWidth;
  var height2 = html2.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x2 + getWindowScrollBarX$1(element),
    y: y2
  };
}
__name(getViewportRect$1, "getViewportRect$1");
function getDocumentRect$1(element) {
  var _element$ownerDocumen;
  var html2 = getDocumentElement$1(element);
  var winScroll = getWindowScroll(element);
  var body2 = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max$2(html2.scrollWidth, html2.clientWidth, body2 ? body2.scrollWidth : 0, body2 ? body2.clientWidth : 0);
  var height2 = max$2(html2.scrollHeight, html2.clientHeight, body2 ? body2.scrollHeight : 0, body2 ? body2.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX$1(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$3(body2 || html2).direction === "rtl") {
    x2 += max$2(html2.clientWidth, body2 ? body2.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x: x2,
    y: y2
  };
}
__name(getDocumentRect$1, "getDocumentRect$1");
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$3(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
__name(isScrollParent, "isScrollParent");
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName$1(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement$2(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode$1(node2));
}
__name(getScrollParent, "getScrollParent");
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow$1(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode$1(target)))
  );
}
__name(listScrollParents, "listScrollParents");
function rectToClientRect$1(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
__name(rectToClientRect$1, "rectToClientRect$1");
function getInnerBoundingClientRect$1(element, strategy) {
  var rect = getBoundingClientRect$1(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
__name(getInnerBoundingClientRect$1, "getInnerBoundingClientRect$1");
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect$1(getViewportRect$1(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect$1(clippingParent, strategy) : rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element)));
}
__name(getClientRectFromMixedType, "getClientRectFromMixedType");
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode$1(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$3(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$2(element) ? getOffsetParent$1(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body";
  });
}
__name(getClippingParents, "getClippingParents");
function getClippingRect$1(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max$2(rect.top, accRect.top);
    accRect.right = min$2(rect.right, accRect.right);
    accRect.bottom = min$2(rect.bottom, accRect.bottom);
    accRect.left = max$2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
__name(getClippingRect$1, "getClippingRect$1");
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
__name(computeOffsets, "computeOffsets");
function detectOverflow$1(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect$1(isElement$1(element) ? element : element.contextElement || getDocumentElement$1(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
__name(detectOverflow$1, "detectOverflow$1");
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow$1(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b2) {
    return overflows[a] - overflows[b2];
  });
}
__name(computeAutoPlacement, "computeAutoPlacement");
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto$1) {
    return [];
  }
  var oppositePlacement = getOppositePlacement$1(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
__name(getExpandedFallbackPlacements, "getExpandedFallbackPlacements");
function flip$3(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement$1(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto$1 ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow$1(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement$1(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement$1(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = /* @__PURE__ */ __name(function _loop2(_i3) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i3).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    }, "_loop");
    for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
      var _ret = _loop(_i2);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
__name(flip$3, "flip$3");
const flip$4 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip$3,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
__name(getSideOffsets, "getSideOffsets");
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
__name(isAnySideFullyClipped, "isAnySideFullyClipped");
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow$1(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow$1(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
__name(hide, "hide");
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance2 = _ref[1];
  skidding = skidding || 0;
  distance2 = (distance2 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance2,
    y: skidding
  } : {
    x: skidding,
    y: distance2
  };
}
__name(distanceAndSkiddingToXY, "distanceAndSkiddingToXY");
function offset$3(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data;
}
__name(offset$3, "offset$3");
const offset$4 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset$3
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
__name(popperOffsets, "popperOffsets");
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
__name(getAltAxis, "getAltAxis");
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow$1(state, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent$1(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min$2(min2, tetherMin) : min2, offset2, tether ? max$2(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
__name(preventOverflow, "preventOverflow");
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
__name(getHTMLElementScroll, "getHTMLElementScroll");
function getNodeScroll$1(node2) {
  if (node2 === getWindow$1(node2) || !isHTMLElement$2(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
__name(getNodeScroll$1, "getNodeScroll$1");
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$4(rect.width) / element.offsetWidth || 1;
  var scaleY = round$4(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
__name(isElementScaled, "isElementScaled");
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$2(offsetParent);
  var offsetParentIsScaled = isHTMLElement$2(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement$1(offsetParent);
  var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$2(offsetParent)) {
      offsets = getBoundingClientRect$1(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
__name(getCompositeRect, "getCompositeRect");
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  __name(sort, "sort");
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
__name(order, "order");
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
__name(orderModifiers, "orderModifiers");
function debounce$1(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
__name(debounce$1, "debounce$1");
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
__name(mergeByName, "mergeByName");
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
__name(areValidElements, "areValidElements");
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return /* @__PURE__ */ __name(function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: /* @__PURE__ */ __name(function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      }, "setOptions"),
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: /* @__PURE__ */ __name(function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent$1(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      }, "forceUpdate"),
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$1(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: /* @__PURE__ */ __name(function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }, "destroy")
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = /* @__PURE__ */ __name(function noopFn2() {
          }, "noopFn");
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    __name(runModifierEffects, "runModifierEffects");
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    __name(cleanupModifierEffects, "cleanupModifierEffects");
    return instance;
  }, "createPopper");
}
__name(popperGenerator, "popperGenerator");
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$4, flip$4, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function getPopperUtilityClass(slot) {
  return generateUtilityClass$1("MuiPopper", slot);
}
__name(getPopperUtilityClass, "getPopperUtilityClass");
generateUtilityClasses$1("MuiPopper", ["root"]);
const _excluded$1I = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"], _excluded2$d = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
function flipPlacement(placement, direction) {
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
__name(flipPlacement, "flipPlacement");
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
__name(resolveAnchorEl, "resolveAnchorEl");
function isHTMLElement$1(element) {
  return element.nodeType !== void 0;
}
__name(isHTMLElement$1, "isHTMLElement$1");
const useUtilityClasses$1p = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPopperUtilityClass, classes2);
}, "useUtilityClasses$1p");
const defaultPopperOptions = {};
const PopperTooltip = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function PopperTooltip2(props, forwardedRef) {
  var _slots$root;
  const {
    anchorEl,
    children,
    direction,
    disablePortal,
    modifiers,
    open: open2,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    slotProps = {},
    slots = {},
    TransitionProps
    // @ts-ignore internal logic
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1I);
  const tooltipRef = reactExports.useRef(null);
  const ownRef = useForkRef(tooltipRef, forwardedRef);
  const popperRef = reactExports.useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = reactExports.useRef(handlePopperRef);
  useEnhancedEffect(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  reactExports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  const [placement, setPlacement] = reactExports.useState(rtlPlacement);
  const [resolvedAnchorElement, setResolvedAnchorElement] = reactExports.useState(resolveAnchorEl(anchorEl));
  reactExports.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  reactExports.useEffect(() => {
    if (anchorEl) {
      setResolvedAnchorElement(resolveAnchorEl(anchorEl));
    }
  }, [anchorEl]);
  useEnhancedEffect(() => {
    if (!resolvedAnchorElement || !open2) {
      return void 0;
    }
    const handlePopperUpdate = /* @__PURE__ */ __name((data) => {
      setPlacement(data.placement);
    }, "handlePopperUpdate");
    let popperModifiers = [{
      name: "preventOverflow",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "flip",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "onUpdate",
      enabled: true,
      phase: "afterWrite",
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];
    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, _extends$4({
      placement: rtlPlacement
    }, popperOptions, {
      modifiers: popperModifiers
    }));
    handlePopperRefRef.current(popper2);
    return () => {
      popper2.destroy();
      handlePopperRefRef.current(null);
    };
  }, [resolvedAnchorElement, disablePortal, modifiers, open2, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes2 = useUtilityClasses$1p(props);
  const Root = (_slots$root = slots.root) != null ? _slots$root : "div";
  const rootProps = useSlotProps$1({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tooltip",
      ref: ownRef
    },
    ownerState: props,
    className: classes2.root
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$4({}, rootProps, {
    children: typeof children === "function" ? children(childProps) : children
  }));
}, "PopperTooltip2"));
const Popper$1 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Popper2(props, forwardedRef) {
  const {
    anchorEl,
    children,
    container: containerProp,
    direction = "ltr",
    disablePortal = false,
    keepMounted = false,
    modifiers,
    open: open2,
    placement = "bottom",
    popperOptions = defaultPopperOptions,
    popperRef,
    style: style2,
    transition = false,
    slotProps = {},
    slots = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded2$d);
  const [exited, setExited] = reactExports.useState(true);
  const handleEnter = /* @__PURE__ */ __name(() => {
    setExited(false);
  }, "handleEnter");
  const handleExited = /* @__PURE__ */ __name(() => {
    setExited(true);
  }, "handleExited");
  if (!keepMounted && !open2 && (!transition || exited)) {
    return null;
  }
  let container;
  if (containerProp) {
    container = containerProp;
  } else if (anchorEl) {
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    container = resolvedAnchorEl && isHTMLElement$1(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
  }
  const display = !open2 && keepMounted && (!transition || exited) ? "none" : void 0;
  const transitionProps = transition ? {
    in: open2,
    onEnter: handleEnter,
    onExited: handleExited
  } : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, {
    disablePortal,
    container,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperTooltip, _extends$4({
      anchorEl,
      direction,
      disablePortal,
      modifiers,
      ref: forwardedRef,
      open: transition ? !exited : open2,
      placement,
      popperOptions,
      popperRef,
      slotProps,
      slots
    }, other, {
      style: _extends$4({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display
      }, style2),
      TransitionProps: transitionProps,
      children
    }))
  });
}, "Popper2"));
const _excluded$1H = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"];
const PopperRoot = styled(Popper$1, {
  name: "MuiPopper",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const Popper = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Popper22(inProps, ref) {
  var _slots$root;
  const theme2 = default_1$v();
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopper"
  });
  const {
    anchorEl,
    component,
    components,
    componentsProps,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open: open2,
    placement,
    popperOptions,
    popperRef,
    transition,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1H);
  const RootComponent = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components == null ? void 0 : components.Root;
  const otherProps = _extends$4({
    anchorEl,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open: open2,
    placement,
    popperOptions,
    popperRef,
    transition
  }, other);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperRoot, _extends$4({
    as: component,
    direction: theme2 == null ? void 0 : theme2.direction,
    slots: {
      root: RootComponent
    },
    slotProps: slotProps != null ? slotProps : componentsProps
  }, otherProps, {
    ref
  }));
}, "Popper2"));
function getTooltipUtilityClass(slot) {
  return generateUtilityClass$1("MuiTooltip", slot);
}
__name(getTooltipUtilityClass, "getTooltipUtilityClass");
const tooltipClasses = generateUtilityClasses$1("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
const _excluded$1G = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
function round$3(value) {
  return Math.round(value * 1e5) / 1e5;
}
__name(round$3, "round$3");
const useUtilityClasses$1o = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disableInteractive,
    arrow: arrow2,
    touch,
    placement
  } = ownerState;
  const slots = {
    popper: ["popper", !disableInteractive && "popperInteractive", arrow2 && "popperArrow"],
    tooltip: ["tooltip", arrow2 && "tooltipArrow", touch && "touch", `tooltipPlacement${capitalize$1(placement.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return composeClasses(slots, getTooltipUtilityClass, classes2);
}, "useUtilityClasses$1o");
const TooltipPopper = styled(Popper, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.popper, !ownerState.disableInteractive && styles2.popperInteractive, ownerState.arrow && styles2.popperArrow, !ownerState.open && styles2.popperClose];
  }
})(({
  theme: theme2,
  ownerState,
  open: open2
}) => _extends$4({
  zIndex: (theme2.vars || theme2).zIndex.tooltip,
  pointerEvents: "none"
}, !ownerState.disableInteractive && {
  pointerEvents: "auto"
}, !open2 && {
  pointerEvents: "none"
}, ownerState.arrow && {
  [`&[data-popper-placement*="bottom"] .${tooltipClasses.arrow}`]: {
    top: 0,
    marginTop: "-0.71em",
    "&::before": {
      transformOrigin: "0 100%"
    }
  },
  [`&[data-popper-placement*="top"] .${tooltipClasses.arrow}`]: {
    bottom: 0,
    marginBottom: "-0.71em",
    "&::before": {
      transformOrigin: "100% 0"
    }
  },
  [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: _extends$4({}, !ownerState.isRtl ? {
    left: 0,
    marginLeft: "-0.71em"
  } : {
    right: 0,
    marginRight: "-0.71em"
  }, {
    height: "1em",
    width: "0.71em",
    "&::before": {
      transformOrigin: "100% 100%"
    }
  }),
  [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: _extends$4({}, !ownerState.isRtl ? {
    right: 0,
    marginRight: "-0.71em"
  } : {
    left: 0,
    marginLeft: "-0.71em"
  }, {
    height: "1em",
    width: "0.71em",
    "&::before": {
      transformOrigin: "0 0"
    }
  })
}));
const TooltipTooltip = styled("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.tooltip, ownerState.touch && styles2.touch, ownerState.arrow && styles2.tooltipArrow, styles2[`tooltipPlacement${capitalize$1(ownerState.placement.split("-")[0])}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  backgroundColor: theme2.vars ? theme2.vars.palette.Tooltip.bg : alpha_1(theme2.palette.grey[700], 0.92),
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  color: (theme2.vars || theme2).palette.common.white,
  fontFamily: theme2.typography.fontFamily,
  padding: "4px 8px",
  fontSize: theme2.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: theme2.typography.fontWeightMedium
}, ownerState.arrow && {
  position: "relative",
  margin: 0
}, ownerState.touch && {
  padding: "8px 16px",
  fontSize: theme2.typography.pxToRem(14),
  lineHeight: `${round$3(16 / 14)}em`,
  fontWeight: theme2.typography.fontWeightRegular
}, {
  [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: _extends$4({
    transformOrigin: "right center"
  }, !ownerState.isRtl ? _extends$4({
    marginRight: "14px"
  }, ownerState.touch && {
    marginRight: "24px"
  }) : _extends$4({
    marginLeft: "14px"
  }, ownerState.touch && {
    marginLeft: "24px"
  })),
  [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: _extends$4({
    transformOrigin: "left center"
  }, !ownerState.isRtl ? _extends$4({
    marginLeft: "14px"
  }, ownerState.touch && {
    marginLeft: "24px"
  }) : _extends$4({
    marginRight: "14px"
  }, ownerState.touch && {
    marginRight: "24px"
  })),
  [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: _extends$4({
    transformOrigin: "center bottom",
    marginBottom: "14px"
  }, ownerState.touch && {
    marginBottom: "24px"
  }),
  [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: _extends$4({
    transformOrigin: "center top",
    marginTop: "14px"
  }, ownerState.touch && {
    marginTop: "24px"
  })
}));
const TooltipArrow = styled("span", {
  name: "MuiTooltip",
  slot: "Arrow",
  overridesResolver: (props, styles2) => styles2.arrow
})(({
  theme: theme2
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: theme2.vars ? theme2.vars.palette.Tooltip.bg : alpha_1(theme2.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
}));
let hystersisOpen = false;
const hystersisTimer = new Timeout();
let cursorPosition = {
  x: 0,
  y: 0
};
function composeEventHandler(handler, eventHandler2) {
  return (event, ...params) => {
    if (eventHandler2) {
      eventHandler2(event, ...params);
    }
    handler(event, ...params);
  };
}
__name(composeEventHandler, "composeEventHandler");
const Tooltip = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Tooltip2(inProps, ref) {
  var _ref, _slots$popper, _ref2, _ref3, _slots$transition, _ref4, _slots$tooltip, _ref5, _slots$arrow, _slotProps$popper, _ref6, _slotProps$popper2, _slotProps$transition, _slotProps$tooltip, _ref7, _slotProps$tooltip2, _slotProps$arrow, _ref8, _slotProps$arrow2;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTooltip"
  });
  const {
    arrow: arrow2 = false,
    children: childrenProp,
    components = {},
    componentsProps = {},
    describeChild = false,
    disableFocusListener = false,
    disableHoverListener = false,
    disableInteractive: disableInteractiveProp = false,
    disableTouchListener = false,
    enterDelay = 100,
    enterNextDelay = 0,
    enterTouchDelay = 700,
    followCursor = false,
    id: idProp,
    leaveDelay = 0,
    leaveTouchDelay = 1500,
    onClose,
    onOpen,
    open: openProp,
    placement = "bottom",
    PopperComponent: PopperComponentProp,
    PopperProps = {},
    slotProps = {},
    slots = {},
    title,
    TransitionComponent: TransitionComponentProp = Grow,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1G);
  const children = /* @__PURE__ */ reactExports.isValidElement(childrenProp) ? childrenProp : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    children: childrenProp
  });
  const theme2 = useTheme$1();
  const isRtl = useRtl();
  const [childNode, setChildNode] = reactExports.useState();
  const [arrowRef, setArrowRef] = reactExports.useState(null);
  const ignoreNonTouchEvents = reactExports.useRef(false);
  const disableInteractive = disableInteractiveProp || followCursor;
  const closeTimer = useTimeout();
  const enterTimer = useTimeout();
  const leaveTimer = useTimeout();
  const touchTimer = useTimeout();
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: "Tooltip",
    state: "open"
  });
  let open2 = openState;
  const id2 = useId(idProp);
  const prevUserSelect = reactExports.useRef();
  const stopTouchInteraction = useEventCallback(() => {
    if (prevUserSelect.current !== void 0) {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      prevUserSelect.current = void 0;
    }
    touchTimer.clear();
  });
  reactExports.useEffect(() => stopTouchInteraction, [stopTouchInteraction]);
  const handleOpen = /* @__PURE__ */ __name((event) => {
    hystersisTimer.clear();
    hystersisOpen = true;
    setOpenState(true);
    if (onOpen && !open2) {
      onOpen(event);
    }
  }, "handleOpen");
  const handleClose = useEventCallback(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (event) => {
      hystersisTimer.start(800 + leaveDelay, () => {
        hystersisOpen = false;
      });
      setOpenState(false);
      if (onClose && open2) {
        onClose(event);
      }
      closeTimer.start(theme2.transitions.duration.shortest, () => {
        ignoreNonTouchEvents.current = false;
      });
    }
  );
  const handleMouseOver = /* @__PURE__ */ __name((event) => {
    if (ignoreNonTouchEvents.current && event.type !== "touchstart") {
      return;
    }
    if (childNode) {
      childNode.removeAttribute("title");
    }
    enterTimer.clear();
    leaveTimer.clear();
    if (enterDelay || hystersisOpen && enterNextDelay) {
      enterTimer.start(hystersisOpen ? enterNextDelay : enterDelay, () => {
        handleOpen(event);
      });
    } else {
      handleOpen(event);
    }
  }, "handleMouseOver");
  const handleMouseLeave = /* @__PURE__ */ __name((event) => {
    enterTimer.clear();
    leaveTimer.start(leaveDelay, () => {
      handleClose(event);
    });
  }, "handleMouseLeave");
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [, setChildIsFocusVisible] = reactExports.useState(false);
  const handleBlur2 = /* @__PURE__ */ __name((event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setChildIsFocusVisible(false);
      handleMouseLeave(event);
    }
  }, "handleBlur");
  const handleFocus = /* @__PURE__ */ __name((event) => {
    if (!childNode) {
      setChildNode(event.currentTarget);
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setChildIsFocusVisible(true);
      handleMouseOver(event);
    }
  }, "handleFocus");
  const detectTouchStart = /* @__PURE__ */ __name((event) => {
    ignoreNonTouchEvents.current = true;
    const childrenProps2 = children.props;
    if (childrenProps2.onTouchStart) {
      childrenProps2.onTouchStart(event);
    }
  }, "detectTouchStart");
  const handleTouchStart = /* @__PURE__ */ __name((event) => {
    detectTouchStart(event);
    leaveTimer.clear();
    closeTimer.clear();
    stopTouchInteraction();
    prevUserSelect.current = document.body.style.WebkitUserSelect;
    document.body.style.WebkitUserSelect = "none";
    touchTimer.start(enterTouchDelay, () => {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      handleMouseOver(event);
    });
  }, "handleTouchStart");
  const handleTouchEnd = /* @__PURE__ */ __name((event) => {
    if (children.props.onTouchEnd) {
      children.props.onTouchEnd(event);
    }
    stopTouchInteraction();
    leaveTimer.start(leaveTouchDelay, () => {
      handleClose(event);
    });
  }, "handleTouchEnd");
  reactExports.useEffect(() => {
    if (!open2) {
      return void 0;
    }
    function handleKeyDown2(nativeEvent) {
      if (nativeEvent.key === "Escape" || nativeEvent.key === "Esc") {
        handleClose(nativeEvent);
      }
    }
    __name(handleKeyDown2, "handleKeyDown");
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [handleClose, open2]);
  const handleRef = useForkRef(children.ref, focusVisibleRef, setChildNode, ref);
  if (!title && title !== 0) {
    open2 = false;
  }
  const popperRef = reactExports.useRef();
  const handleMouseMove = /* @__PURE__ */ __name((event) => {
    const childrenProps2 = children.props;
    if (childrenProps2.onMouseMove) {
      childrenProps2.onMouseMove(event);
    }
    cursorPosition = {
      x: event.clientX,
      y: event.clientY
    };
    if (popperRef.current) {
      popperRef.current.update();
    }
  }, "handleMouseMove");
  const nameOrDescProps = {};
  const titleIsString = typeof title === "string";
  if (describeChild) {
    nameOrDescProps.title = !open2 && titleIsString && !disableHoverListener ? title : null;
    nameOrDescProps["aria-describedby"] = open2 ? id2 : null;
  } else {
    nameOrDescProps["aria-label"] = titleIsString ? title : null;
    nameOrDescProps["aria-labelledby"] = open2 && !titleIsString ? id2 : null;
  }
  const childrenProps = _extends$4({}, nameOrDescProps, other, children.props, {
    className: clsx(other.className, children.props.className),
    onTouchStart: detectTouchStart,
    ref: handleRef
  }, followCursor ? {
    onMouseMove: handleMouseMove
  } : {});
  const interactiveWrapperListeners = {};
  if (!disableTouchListener) {
    childrenProps.onTouchStart = handleTouchStart;
    childrenProps.onTouchEnd = handleTouchEnd;
  }
  if (!disableHoverListener) {
    childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
    childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
    if (!disableInteractive) {
      interactiveWrapperListeners.onMouseOver = handleMouseOver;
      interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
    }
  }
  if (!disableFocusListener) {
    childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
    childrenProps.onBlur = composeEventHandler(handleBlur2, childrenProps.onBlur);
    if (!disableInteractive) {
      interactiveWrapperListeners.onFocus = handleFocus;
      interactiveWrapperListeners.onBlur = handleBlur2;
    }
  }
  const popperOptions = reactExports.useMemo(() => {
    var _PopperProps$popperOp;
    let tooltipModifiers = [{
      name: "arrow",
      enabled: Boolean(arrowRef),
      options: {
        element: arrowRef,
        padding: 4
      }
    }];
    if ((_PopperProps$popperOp = PopperProps.popperOptions) != null && _PopperProps$popperOp.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
    }
    return _extends$4({}, PopperProps.popperOptions, {
      modifiers: tooltipModifiers
    });
  }, [arrowRef, PopperProps]);
  const ownerState = _extends$4({}, props, {
    isRtl,
    arrow: arrow2,
    disableInteractive,
    placement,
    PopperComponentProp,
    touch: ignoreNonTouchEvents.current
  });
  const classes2 = useUtilityClasses$1o(ownerState);
  const PopperComponent = (_ref = (_slots$popper = slots.popper) != null ? _slots$popper : components.Popper) != null ? _ref : TooltipPopper;
  const TransitionComponent = (_ref2 = (_ref3 = (_slots$transition = slots.transition) != null ? _slots$transition : components.Transition) != null ? _ref3 : TransitionComponentProp) != null ? _ref2 : Grow;
  const TooltipComponent = (_ref4 = (_slots$tooltip = slots.tooltip) != null ? _slots$tooltip : components.Tooltip) != null ? _ref4 : TooltipTooltip;
  const ArrowComponent = (_ref5 = (_slots$arrow = slots.arrow) != null ? _slots$arrow : components.Arrow) != null ? _ref5 : TooltipArrow;
  const popperProps = appendOwnerState$1(PopperComponent, _extends$4({}, PopperProps, (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper, {
    className: clsx(classes2.popper, PopperProps == null ? void 0 : PopperProps.className, (_ref6 = (_slotProps$popper2 = slotProps.popper) != null ? _slotProps$popper2 : componentsProps.popper) == null ? void 0 : _ref6.className)
  }), ownerState);
  const transitionProps = appendOwnerState$1(TransitionComponent, _extends$4({}, TransitionProps, (_slotProps$transition = slotProps.transition) != null ? _slotProps$transition : componentsProps.transition), ownerState);
  const tooltipProps = appendOwnerState$1(TooltipComponent, _extends$4({}, (_slotProps$tooltip = slotProps.tooltip) != null ? _slotProps$tooltip : componentsProps.tooltip, {
    className: clsx(classes2.tooltip, (_ref7 = (_slotProps$tooltip2 = slotProps.tooltip) != null ? _slotProps$tooltip2 : componentsProps.tooltip) == null ? void 0 : _ref7.className)
  }), ownerState);
  const tooltipArrowProps = appendOwnerState$1(ArrowComponent, _extends$4({}, (_slotProps$arrow = slotProps.arrow) != null ? _slotProps$arrow : componentsProps.arrow, {
    className: clsx(classes2.arrow, (_ref8 = (_slotProps$arrow2 = slotProps.arrow) != null ? _slotProps$arrow2 : componentsProps.arrow) == null ? void 0 : _ref8.className)
  }), ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ reactExports.cloneElement(children, childrenProps), /* @__PURE__ */ jsxRuntimeExports.jsx(PopperComponent, _extends$4({
      as: PopperComponentProp != null ? PopperComponentProp : Popper,
      placement,
      anchorEl: followCursor ? {
        getBoundingClientRect: () => ({
          top: cursorPosition.y,
          left: cursorPosition.x,
          right: cursorPosition.x,
          bottom: cursorPosition.y,
          width: 0,
          height: 0
        })
      } : childNode,
      popperRef,
      open: childNode ? open2 : false,
      id: id2,
      transition: true
    }, interactiveWrapperListeners, popperProps, {
      popperOptions,
      children: ({
        TransitionProps: TransitionPropsInner
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$4({
        timeout: theme2.transitions.duration.shorter
      }, TransitionPropsInner, transitionProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipComponent, _extends$4({}, tooltipProps, {
          children: [title, arrow2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowComponent, _extends$4({}, tooltipArrowProps, {
            ref: setArrowRef
          })) : null]
        }))
      }))
    }))]
  });
}, "Tooltip2"));
function getFormControlUtilityClasses(slot) {
  return generateUtilityClass$1("MuiFormControl", slot);
}
__name(getFormControlUtilityClasses, "getFormControlUtilityClasses");
generateUtilityClasses$1("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const _excluded$1F = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
const useUtilityClasses$1n = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    margin: margin2,
    fullWidth
  } = ownerState;
  const slots = {
    root: ["root", margin2 !== "none" && `margin${capitalize$1(margin2)}`, fullWidth && "fullWidth"]
  };
  return composeClasses(slots, getFormControlUtilityClasses, classes2);
}, "useUtilityClasses$1n");
const FormControlRoot = styled("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles2) => {
    return _extends$4({}, styles2.root, styles2[`margin${capitalize$1(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth);
  }
})(({
  ownerState
}) => _extends$4({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top"
}, ownerState.margin === "normal" && {
  marginTop: 16,
  marginBottom: 8
}, ownerState.margin === "dense" && {
  marginTop: 8,
  marginBottom: 4
}, ownerState.fullWidth && {
  width: "100%"
}));
const FormControl = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function FormControl2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormControl"
  });
  const {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    error = false,
    focused: visuallyFocused,
    fullWidth = false,
    hiddenLabel = false,
    margin: margin2 = "none",
    required = false,
    size: size2 = "medium",
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1F);
  const ownerState = _extends$4({}, props, {
    color: color2,
    component,
    disabled,
    error,
    fullWidth,
    hiddenLabel,
    margin: margin2,
    required,
    size: size2,
    variant
  });
  const classes2 = useUtilityClasses$1n(ownerState);
  const [adornedStart, setAdornedStart] = reactExports.useState(() => {
    let initialAdornedStart = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }
    return initialAdornedStart;
  });
  const [filled, setFilled] = reactExports.useState(() => {
    let initialFilled = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
          initialFilled = true;
        }
      });
    }
    return initialFilled;
  });
  const [focusedState, setFocused] = reactExports.useState(false);
  if (disabled && focusedState) {
    setFocused(false);
  }
  const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
  let registerEffect;
  const childContext = reactExports.useMemo(() => {
    return {
      adornedStart,
      setAdornedStart,
      color: color2,
      disabled,
      error,
      filled,
      focused,
      fullWidth,
      hiddenLabel,
      size: size2,
      onBlur: () => {
        setFocused(false);
      },
      onEmpty: () => {
        setFilled(false);
      },
      onFilled: () => {
        setFilled(true);
      },
      onFocus: () => {
        setFocused(true);
      },
      registerEffect,
      required,
      variant
    };
  }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size2, variant]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, _extends$4({
      as: component,
      ownerState,
      className: clsx(classes2.root, className),
      ref
    }, other, {
      children
    }))
  });
}, "FormControl2"));
const Stack = createStack({
  createStyledComponent: styled("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  }),
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiStack"
  })
});
const stackClasses = generateUtilityClasses$1("MuiStack", ["root"]);
function getFormControlLabelUtilityClasses(slot) {
  return generateUtilityClass$1("MuiFormControlLabel", slot);
}
__name(getFormControlLabelUtilityClasses, "getFormControlLabelUtilityClasses");
const formControlLabelClasses = generateUtilityClasses$1("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]);
const _excluded$1E = ["checked", "className", "componentsProps", "control", "disabled", "disableTypography", "inputRef", "label", "labelPlacement", "name", "onChange", "required", "slotProps", "value"];
const useUtilityClasses$1m = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disabled,
    labelPlacement,
    error,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", `labelPlacement${capitalize$1(labelPlacement)}`, error && "error", required && "required"],
    label: ["label", disabled && "disabled"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses(slots, getFormControlLabelUtilityClasses, classes2);
}, "useUtilityClasses$1m");
const FormControlLabelRoot = styled("label", {
  name: "MuiFormControlLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formControlLabelClasses.label}`]: styles2.label
    }, styles2.root, styles2[`labelPlacement${capitalize$1(ownerState.labelPlacement)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  display: "inline-flex",
  alignItems: "center",
  cursor: "pointer",
  // For correct alignment with the text.
  verticalAlign: "middle",
  WebkitTapHighlightColor: "transparent",
  marginLeft: -11,
  marginRight: 16,
  // used for row presentation of radio/checkbox
  [`&.${formControlLabelClasses.disabled}`]: {
    cursor: "default"
  }
}, ownerState.labelPlacement === "start" && {
  flexDirection: "row-reverse",
  marginLeft: 16,
  // used for row presentation of radio/checkbox
  marginRight: -11
}, ownerState.labelPlacement === "top" && {
  flexDirection: "column-reverse",
  marginLeft: 16
}, ownerState.labelPlacement === "bottom" && {
  flexDirection: "column",
  marginLeft: 16
}, {
  [`& .${formControlLabelClasses.label}`]: {
    [`&.${formControlLabelClasses.disabled}`]: {
      color: (theme2.vars || theme2).palette.text.disabled
    }
  }
}));
const AsteriskComponent$1 = styled("span", {
  name: "MuiFormControlLabel",
  slot: "Asterisk",
  overridesResolver: (props, styles2) => styles2.asterisk
})(({
  theme: theme2
}) => ({
  [`&.${formControlLabelClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const FormControlLabel = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function FormControlLabel2(inProps, ref) {
  var _ref, _slotProps$typography;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormControlLabel"
  });
  const {
    className,
    componentsProps = {},
    control,
    disabled: disabledProp,
    disableTypography,
    label: labelProp,
    labelPlacement = "end",
    required: requiredProp,
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1E);
  const muiFormControl = useFormControl();
  const disabled = (_ref = disabledProp != null ? disabledProp : control.props.disabled) != null ? _ref : muiFormControl == null ? void 0 : muiFormControl.disabled;
  const required = requiredProp != null ? requiredProp : control.props.required;
  const controlProps = {
    disabled,
    required
  };
  ["checked", "name", "onChange", "value", "inputRef"].forEach((key) => {
    if (typeof control.props[key] === "undefined" && typeof props[key] !== "undefined") {
      controlProps[key] = props[key];
    }
  });
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["error"]
  });
  const ownerState = _extends$4({}, props, {
    disabled,
    labelPlacement,
    required,
    error: fcs.error
  });
  const classes2 = useUtilityClasses$1m(ownerState);
  const typographySlotProps = (_slotProps$typography = slotProps.typography) != null ? _slotProps$typography : componentsProps.typography;
  let label = labelProp;
  if (label != null && label.type !== Typography && !disableTypography) {
    label = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, _extends$4({
      component: "span"
    }, typographySlotProps, {
      className: clsx(classes2.label, typographySlotProps == null ? void 0 : typographySlotProps.className),
      children: label
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControlLabelRoot, _extends$4({
    className: clsx(classes2.root, className),
    ownerState,
    ref
  }, other, {
    children: [/* @__PURE__ */ reactExports.cloneElement(control, controlProps), required ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, {
      display: "block",
      children: [label, /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent$1, {
        ownerState,
        "aria-hidden": true,
        className: classes2.asterisk,
        children: ["", "*"]
      })]
    }) : label]
  }));
}, "FormControlLabel2"));
function getSwitchBaseUtilityClass(slot) {
  return generateUtilityClass$1("PrivateSwitchBase", slot);
}
__name(getSwitchBaseUtilityClass, "getSwitchBaseUtilityClass");
generateUtilityClasses$1("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const _excluded$1D = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"];
const useUtilityClasses$1l = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    checked,
    disabled,
    edge
  } = ownerState;
  const slots = {
    root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize$1(edge)}`],
    input: ["input"]
  };
  return composeClasses(slots, getSwitchBaseUtilityClass, classes2);
}, "useUtilityClasses$1l");
const SwitchBaseRoot = styled(ButtonBase)(({
  ownerState
}) => _extends$4({
  padding: 9,
  borderRadius: "50%"
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}));
const SwitchBaseInput = styled("input", {
  shouldForwardProp: rootShouldForwardProp
})({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
});
const SwitchBase = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function SwitchBase2(props, ref) {
  const {
    autoFocus,
    checked: checkedProp,
    checkedIcon,
    className,
    defaultChecked,
    disabled: disabledProp,
    disableFocusRipple = false,
    edge = false,
    icon,
    id: id2,
    inputProps,
    inputRef,
    name,
    onBlur,
    onChange,
    onFocus,
    readOnly,
    required = false,
    tabIndex,
    type,
    value
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1D);
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "SwitchBase",
    state: "checked"
  });
  const muiFormControl = useFormControl();
  const handleFocus = /* @__PURE__ */ __name((event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    }
  }, "handleFocus");
  const handleBlur2 = /* @__PURE__ */ __name((event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    }
  }, "handleBlur");
  const handleInputChange = /* @__PURE__ */ __name((event) => {
    if (event.nativeEvent.defaultPrevented) {
      return;
    }
    const newChecked = event.target.checked;
    setCheckedState(newChecked);
    if (onChange) {
      onChange(event, newChecked);
    }
  }, "handleInputChange");
  let disabled = disabledProp;
  if (muiFormControl) {
    if (typeof disabled === "undefined") {
      disabled = muiFormControl.disabled;
    }
  }
  const hasLabelFor = type === "checkbox" || type === "radio";
  const ownerState = _extends$4({}, props, {
    checked,
    disabled,
    disableFocusRipple,
    edge
  });
  const classes2 = useUtilityClasses$1l(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchBaseRoot, _extends$4({
    component: "span",
    className: clsx(classes2.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    tabIndex: null,
    role: void 0,
    onFocus: handleFocus,
    onBlur: handleBlur2,
    ownerState,
    ref
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchBaseInput, _extends$4({
      autoFocus,
      checked: checkedProp,
      defaultChecked,
      className: classes2.input,
      disabled,
      id: hasLabelFor ? id2 : void 0,
      name,
      onChange: handleInputChange,
      readOnly,
      ref: inputRef,
      required,
      ownerState,
      tabIndex,
      type
    }, type === "checkbox" && value === void 0 ? {} : {
      value
    }, inputProps)), checked ? checkedIcon : icon]
  }));
}, "SwitchBase2"));
function getSwitchUtilityClass(slot) {
  return generateUtilityClass$1("MuiSwitch", slot);
}
__name(getSwitchUtilityClass, "getSwitchUtilityClass");
const switchClasses = generateUtilityClasses$1("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]);
const _excluded$1C = ["className", "color", "edge", "size", "sx"];
const useUtilityClasses$1k = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    edge,
    size: size2,
    color: color2,
    checked,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", edge && `edge${capitalize$1(edge)}`, `size${capitalize$1(size2)}`],
    switchBase: ["switchBase", `color${capitalize$1(color2)}`, checked && "checked", disabled && "disabled"],
    thumb: ["thumb"],
    track: ["track"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getSwitchUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$1k");
const SwitchRoot = styled("span", {
  name: "MuiSwitch",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.edge && styles2[`edge${capitalize$1(ownerState.edge)}`], styles2[`size${capitalize$1(ownerState.size)}`]];
  }
})({
  display: "inline-flex",
  width: 34 + 12 * 2,
  height: 14 + 12 * 2,
  overflow: "hidden",
  padding: 12,
  boxSizing: "border-box",
  position: "relative",
  flexShrink: 0,
  zIndex: 0,
  // Reset the stacking context.
  verticalAlign: "middle",
  // For correct alignment with the text.
  "@media print": {
    colorAdjust: "exact"
  },
  variants: [{
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -8
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -8
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      width: 40,
      height: 24,
      padding: 7,
      [`& .${switchClasses.thumb}`]: {
        width: 16,
        height: 16
      },
      [`& .${switchClasses.switchBase}`]: {
        padding: 4,
        [`&.${switchClasses.checked}`]: {
          transform: "translateX(16px)"
        }
      }
    }
  }]
});
const SwitchSwitchBase = styled(SwitchBase, {
  name: "MuiSwitch",
  slot: "SwitchBase",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.switchBase, {
      [`& .${switchClasses.input}`]: styles2.input
    }, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(({
  theme: theme2
}) => ({
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  // Render above the focus ripple.
  color: theme2.vars ? theme2.vars.palette.Switch.defaultColor : `${theme2.palette.mode === "light" ? theme2.palette.common.white : theme2.palette.grey[300]}`,
  transition: theme2.transitions.create(["left", "transform"], {
    duration: theme2.transitions.duration.shortest
  }),
  [`&.${switchClasses.checked}`]: {
    transform: "translateX(20px)"
  },
  [`&.${switchClasses.disabled}`]: {
    color: theme2.vars ? theme2.vars.palette.Switch.defaultDisabledColor : `${theme2.palette.mode === "light" ? theme2.palette.grey[100] : theme2.palette.grey[600]}`
  },
  [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
    opacity: 0.5
  },
  [`&.${switchClasses.disabled} + .${switchClasses.track}`]: {
    opacity: theme2.vars ? theme2.vars.opacity.switchTrackDisabled : `${theme2.palette.mode === "light" ? 0.12 : 0.2}`
  },
  [`& .${switchClasses.input}`]: {
    left: "-100%",
    width: "300%"
  }
}), ({
  theme: theme2
}) => ({
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.activeChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha_1(theme2.palette.action.active, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  variants: [...Object.entries(theme2.palette).filter(([, value]) => value.main && value.light).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${switchClasses.checked}`]: {
        color: (theme2.vars || theme2).palette[color2].main,
        "&:hover": {
          backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[color2].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha_1(theme2.palette[color2].main, theme2.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        },
        [`&.${switchClasses.disabled}`]: {
          color: theme2.vars ? theme2.vars.palette.Switch[`${color2}DisabledColor`] : `${theme2.palette.mode === "light" ? lighten_1(theme2.palette[color2].main, 0.62) : darken_1(theme2.palette[color2].main, 0.55)}`
        }
      },
      [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
        backgroundColor: (theme2.vars || theme2).palette[color2].main
      }
    }
  }))]
}));
const SwitchTrack = styled("span", {
  name: "MuiSwitch",
  slot: "Track",
  overridesResolver: (props, styles2) => styles2.track
})(({
  theme: theme2
}) => ({
  height: "100%",
  width: "100%",
  borderRadius: 14 / 2,
  zIndex: -1,
  transition: theme2.transitions.create(["opacity", "background-color"], {
    duration: theme2.transitions.duration.shortest
  }),
  backgroundColor: theme2.vars ? theme2.vars.palette.common.onBackground : `${theme2.palette.mode === "light" ? theme2.palette.common.black : theme2.palette.common.white}`,
  opacity: theme2.vars ? theme2.vars.opacity.switchTrack : `${theme2.palette.mode === "light" ? 0.38 : 0.3}`
}));
const SwitchThumb = styled("span", {
  name: "MuiSwitch",
  slot: "Thumb",
  overridesResolver: (props, styles2) => styles2.thumb
})(({
  theme: theme2
}) => ({
  boxShadow: (theme2.vars || theme2).shadows[1],
  backgroundColor: "currentColor",
  width: 20,
  height: 20,
  borderRadius: "50%"
}));
const Switch = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Switch2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSwitch"
  });
  const {
    className,
    color: color2 = "primary",
    edge = false,
    size: size2 = "medium",
    sx
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1C);
  const ownerState = _extends$4({}, props, {
    color: color2,
    edge,
    size: size2
  });
  const classes2 = useUtilityClasses$1k(ownerState);
  const icon = /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumb, {
    className: classes2.thumb,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchRoot, {
    className: clsx(classes2.root, className),
    sx,
    ownerState,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchSwitchBase, _extends$4({
      type: "checkbox",
      icon,
      checkedIcon: icon,
      ref,
      ownerState
    }, other, {
      classes: _extends$4({}, classes2, {
        root: classes2.switchBase
      })
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchTrack, {
      className: classes2.track,
      ownerState
    })]
  });
}, "Switch2"));
var FilterList = {};
var createSvgIcon = {};
const unstable_ClassNameGenerator = {
  configure: (generator) => {
    ClassNameGenerator.configure(generator);
  }
};
const utils$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  capitalize: capitalize$1,
  createChainedFunction,
  createSvgIcon: createSvgIcon$1,
  debounce: debounce$2,
  deprecatedPropType,
  isMuiElement,
  ownerDocument,
  ownerWindow,
  requirePropFactory,
  setRef,
  unstable_ClassNameGenerator,
  unstable_useEnhancedEffect: useEnhancedEffect,
  unstable_useId: useId,
  unsupportedProp,
  useControlled,
  useEventCallback,
  useForkRef,
  useIsFocusVisible
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(utils$2);
var hasRequiredCreateSvgIcon;
function requireCreateSvgIcon() {
  if (hasRequiredCreateSvgIcon)
    return createSvgIcon;
  hasRequiredCreateSvgIcon = 1;
  (function(exports) {
    "use client";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _utils.createSvgIcon;
      }
    });
    var _utils = require$$0;
  })(createSvgIcon);
  return createSvgIcon;
}
__name(requireCreateSvgIcon, "requireCreateSvgIcon");
var _interopRequireDefault$z = interopRequireDefaultExports;
Object.defineProperty(FilterList, "__esModule", {
  value: true
});
var default_1$u = FilterList.default = void 0;
var _createSvgIcon$u = _interopRequireDefault$z(requireCreateSvgIcon());
var _jsxRuntime$u = jsxRuntimeExports;
default_1$u = FilterList.default = (0, _createSvgIcon$u.default)(/* @__PURE__ */ (0, _jsxRuntime$u.jsx)("path", {
  d: "M10 18h4v-2h-4zM3 6v2h18V6zm3 7h12v-2H6z"
}), "FilterList");
const _excluded$1B = ["className", "elementType", "ownerState", "externalForwardedProps", "getSlotOwnerState", "internalForwardedProps"], _excluded2$c = ["component", "slots", "slotProps"], _excluded3$2 = ["component"];
function useSlot(name, parameters) {
  const {
    className,
    elementType: initialElementType,
    ownerState,
    externalForwardedProps,
    getSlotOwnerState,
    internalForwardedProps
  } = parameters, useSlotPropsParams = _objectWithoutPropertiesLoose$1(parameters, _excluded$1B);
  const {
    component: rootComponent,
    slots = {
      [name]: void 0
    },
    slotProps = {
      [name]: void 0
    }
  } = externalForwardedProps, other = _objectWithoutPropertiesLoose$1(externalForwardedProps, _excluded2$c);
  const elementType = slots[name] || initialElementType;
  const resolvedComponentsProps = resolveComponentProps$1(slotProps[name], ownerState);
  const _mergeSlotProps = mergeSlotProps$1(_extends$4({
    className
  }, useSlotPropsParams, {
    externalForwardedProps: name === "root" ? other : void 0,
    externalSlotProps: resolvedComponentsProps
  })), {
    props: {
      component: slotComponent
    },
    internalRef
  } = _mergeSlotProps, mergedProps = _objectWithoutPropertiesLoose$1(_mergeSlotProps.props, _excluded3$2);
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, parameters.ref);
  const slotOwnerState = getSlotOwnerState ? getSlotOwnerState(mergedProps) : {};
  const finalOwnerState = _extends$4({}, ownerState, slotOwnerState);
  const LeafComponent = name === "root" ? slotComponent || rootComponent : slotComponent;
  const props = appendOwnerState$1(elementType, _extends$4({}, name === "root" && !rootComponent && !slots[name] && internalForwardedProps, name !== "root" && !slots[name] && internalForwardedProps, mergedProps, LeafComponent && {
    as: LeafComponent
  }, {
    ref
  }), finalOwnerState);
  Object.keys(slotOwnerState).forEach((propName) => {
    delete props[propName];
  });
  return [elementType, props];
}
__name(useSlot, "useSlot");
function getAlertUtilityClass(slot) {
  return generateUtilityClass$1("MuiAlert", slot);
}
__name(getAlertUtilityClass, "getAlertUtilityClass");
const alertClasses = generateUtilityClasses$1("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
const SuccessOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}), "SuccessOutlined");
const ReportProblemOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}), "ReportProblemOutlined");
const ErrorOutlineIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "ErrorOutline");
const InfoOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}), "InfoOutlined");
const ClearIcon$1 = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
const _excluded$1A = ["action", "children", "className", "closeText", "color", "components", "componentsProps", "icon", "iconMapping", "onClose", "role", "severity", "slotProps", "slots", "variant"];
const useUtilityClasses$1j = /* @__PURE__ */ __name((ownerState) => {
  const {
    variant,
    color: color2,
    severity,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2 || severity)}`, `${variant}${capitalize$1(color2 || severity)}`, `${variant}`],
    icon: ["icon"],
    message: ["message"],
    action: ["action"]
  };
  return composeClasses(slots, getAlertUtilityClass, classes2);
}, "useUtilityClasses$1j");
const AlertRoot = styled(Paper, {
  name: "MuiAlert",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize$1(ownerState.color || ownerState.severity)}`]];
  }
})(({
  theme: theme2
}) => {
  const getColor = theme2.palette.mode === "light" ? darken_1 : lighten_1;
  const getBackgroundColor = theme2.palette.mode === "light" ? lighten_1 : darken_1;
  return _extends$4({}, theme2.typography.body2, {
    backgroundColor: "transparent",
    display: "flex",
    padding: "6px 16px",
    variants: [...Object.entries(theme2.palette).filter(([, value]) => value.main && value.light).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "standard"
      },
      style: {
        color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
        backgroundColor: theme2.vars ? theme2.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme2.palette[color2].light, 0.9),
        [`& .${alertClasses.icon}`]: theme2.vars ? {
          color: theme2.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme2.palette[color2].main
        }
      }
    })), ...Object.entries(theme2.palette).filter(([, value]) => value.main && value.light).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "outlined"
      },
      style: {
        color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
        border: `1px solid ${(theme2.vars || theme2).palette[color2].light}`,
        [`& .${alertClasses.icon}`]: theme2.vars ? {
          color: theme2.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme2.palette[color2].main
        }
      }
    })), ...Object.entries(theme2.palette).filter(([, value]) => value.main && value.dark).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "filled"
      },
      style: _extends$4({
        fontWeight: theme2.typography.fontWeightMedium
      }, theme2.vars ? {
        color: theme2.vars.palette.Alert[`${color2}FilledColor`],
        backgroundColor: theme2.vars.palette.Alert[`${color2}FilledBg`]
      } : {
        backgroundColor: theme2.palette.mode === "dark" ? theme2.palette[color2].dark : theme2.palette[color2].main,
        color: theme2.palette.getContrastText(theme2.palette[color2].main)
      })
    }))]
  });
});
const AlertIcon = styled("div", {
  name: "MuiAlert",
  slot: "Icon",
  overridesResolver: (props, styles2) => styles2.icon
})({
  marginRight: 12,
  padding: "7px 0",
  display: "flex",
  fontSize: 22,
  opacity: 0.9
});
const AlertMessage = styled("div", {
  name: "MuiAlert",
  slot: "Message",
  overridesResolver: (props, styles2) => styles2.message
})({
  padding: "8px 0",
  minWidth: 0,
  overflow: "auto"
});
const AlertAction = styled("div", {
  name: "MuiAlert",
  slot: "Action",
  overridesResolver: (props, styles2) => styles2.action
})({
  display: "flex",
  alignItems: "flex-start",
  padding: "4px 0 0 16px",
  marginLeft: "auto",
  marginRight: -8
});
const defaultIconMapping = {
  success: /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
    fontSize: "inherit"
  }),
  warning: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
    fontSize: "inherit"
  }),
  error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineIcon, {
    fontSize: "inherit"
  }),
  info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlinedIcon, {
    fontSize: "inherit"
  })
};
const Alert = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Alert2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAlert"
  });
  const {
    action,
    children,
    className,
    closeText = "Close",
    color: color2,
    components = {},
    componentsProps = {},
    icon,
    iconMapping = defaultIconMapping,
    onClose,
    role = "alert",
    severity = "success",
    slotProps = {},
    slots = {},
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1A);
  const ownerState = _extends$4({}, props, {
    color: color2,
    severity,
    variant,
    colorSeverity: color2 || severity
  });
  const classes2 = useUtilityClasses$1j(ownerState);
  const externalForwardedProps = {
    slots: _extends$4({
      closeButton: components.CloseButton,
      closeIcon: components.CloseIcon
    }, slots),
    slotProps: _extends$4({}, componentsProps, slotProps)
  };
  const [CloseButtonSlot, closeButtonProps] = useSlot("closeButton", {
    elementType: IconButton,
    externalForwardedProps,
    ownerState
  });
  const [CloseIconSlot, closeIconProps] = useSlot("closeIcon", {
    elementType: ClearIcon$1,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(AlertRoot, _extends$4({
    role,
    elevation: 0,
    ownerState,
    className: clsx(classes2.root, className),
    ref
  }, other, {
    children: [icon !== false ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertIcon, {
      ownerState,
      className: classes2.icon,
      children: icon || iconMapping[severity] || defaultIconMapping[severity]
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(AlertMessage, {
      ownerState,
      className: classes2.message,
      children
    }), action != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertAction, {
      ownerState,
      className: classes2.action,
      children: action
    }) : null, action == null && onClose ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertAction, {
      ownerState,
      className: classes2.action,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButtonSlot, _extends$4({
        size: "small",
        "aria-label": closeText,
        title: closeText,
        color: "inherit",
        onClick: onClose
      }, closeButtonProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIconSlot, _extends$4({
          fontSize: "small"
        }, closeIconProps))
      }))
    }) : null]
  }));
}, "Alert2"));
function getAppBarUtilityClass(slot) {
  return generateUtilityClass$1("MuiAppBar", slot);
}
__name(getAppBarUtilityClass, "getAppBarUtilityClass");
generateUtilityClasses$1("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent", "colorError", "colorInfo", "colorSuccess", "colorWarning"]);
const _excluded$1z = ["className", "color", "enableColorOnDark", "position"];
const useUtilityClasses$1i = /* @__PURE__ */ __name((ownerState) => {
  const {
    color: color2,
    position: position2,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, `position${capitalize$1(position2)}`]
  };
  return composeClasses(slots, getAppBarUtilityClass, classes2);
}, "useUtilityClasses$1i");
const joinVars = /* @__PURE__ */ __name((var1, var2) => var1 ? `${var1 == null ? void 0 : var1.replace(")", "")}, ${var2})` : var2, "joinVars");
const AppBarRoot = styled(Paper, {
  name: "MuiAppBar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`position${capitalize$1(ownerState.position)}`], styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const backgroundColorDefault = theme2.palette.mode === "light" ? theme2.palette.grey[100] : theme2.palette.grey[900];
  return _extends$4({
    display: "flex",
    flexDirection: "column",
    width: "100%",
    boxSizing: "border-box",
    // Prevent padding issue with the Modal and fixed positioned AppBar.
    flexShrink: 0
  }, ownerState.position === "fixed" && {
    position: "fixed",
    zIndex: (theme2.vars || theme2).zIndex.appBar,
    top: 0,
    left: "auto",
    right: 0,
    "@media print": {
      // Prevent the app bar to be visible on each printed page.
      position: "absolute"
    }
  }, ownerState.position === "absolute" && {
    position: "absolute",
    zIndex: (theme2.vars || theme2).zIndex.appBar,
    top: 0,
    left: "auto",
    right: 0
  }, ownerState.position === "sticky" && {
    //  sticky is not supported by IE11.
    position: "sticky",
    zIndex: (theme2.vars || theme2).zIndex.appBar,
    top: 0,
    left: "auto",
    right: 0
  }, ownerState.position === "static" && {
    position: "static"
  }, ownerState.position === "relative" && {
    position: "relative"
  }, !theme2.vars && _extends$4({}, ownerState.color === "default" && {
    backgroundColor: backgroundColorDefault,
    color: theme2.palette.getContrastText(backgroundColorDefault)
  }, ownerState.color && ownerState.color !== "default" && ownerState.color !== "inherit" && ownerState.color !== "transparent" && {
    backgroundColor: theme2.palette[ownerState.color].main,
    color: theme2.palette[ownerState.color].contrastText
  }, ownerState.color === "inherit" && {
    color: "inherit"
  }, theme2.palette.mode === "dark" && !ownerState.enableColorOnDark && {
    backgroundColor: null,
    color: null
  }, ownerState.color === "transparent" && _extends$4({
    backgroundColor: "transparent",
    color: "inherit"
  }, theme2.palette.mode === "dark" && {
    backgroundImage: "none"
  })), theme2.vars && _extends$4({}, ownerState.color === "default" && {
    "--AppBar-background": ownerState.enableColorOnDark ? theme2.vars.palette.AppBar.defaultBg : joinVars(theme2.vars.palette.AppBar.darkBg, theme2.vars.palette.AppBar.defaultBg),
    "--AppBar-color": ownerState.enableColorOnDark ? theme2.vars.palette.text.primary : joinVars(theme2.vars.palette.AppBar.darkColor, theme2.vars.palette.text.primary)
  }, ownerState.color && !ownerState.color.match(/^(default|inherit|transparent)$/) && {
    "--AppBar-background": ownerState.enableColorOnDark ? theme2.vars.palette[ownerState.color].main : joinVars(theme2.vars.palette.AppBar.darkBg, theme2.vars.palette[ownerState.color].main),
    "--AppBar-color": ownerState.enableColorOnDark ? theme2.vars.palette[ownerState.color].contrastText : joinVars(theme2.vars.palette.AppBar.darkColor, theme2.vars.palette[ownerState.color].contrastText)
  }, !["inherit", "transparent"].includes(ownerState.color) && {
    backgroundColor: "var(--AppBar-background)"
  }, {
    color: ownerState.color === "inherit" ? "inherit" : "var(--AppBar-color)"
  }, ownerState.color === "transparent" && {
    backgroundImage: "none",
    backgroundColor: "transparent",
    color: "inherit"
  }));
});
const AppBar = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function AppBar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAppBar"
  });
  const {
    className,
    color: color2 = "primary",
    enableColorOnDark = false,
    position: position2 = "fixed"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1z);
  const ownerState = _extends$4({}, props, {
    color: color2,
    position: position2,
    enableColorOnDark
  });
  const classes2 = useUtilityClasses$1i(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AppBarRoot, _extends$4({
    square: true,
    component: "header",
    ownerState,
    elevation: 4,
    className: clsx(classes2.root, className, position2 === "fixed" && "mui-fixed"),
    ref
  }, other));
}, "AppBar2"));
function stripDiacritics(string) {
  return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
}
__name(stripDiacritics, "stripDiacritics");
function createFilterOptions(config2 = {}) {
  const {
    ignoreAccents = true,
    ignoreCase = true,
    limit,
    matchFrom = "any",
    stringify: stringify2,
    trim: trim2 = false
  } = config2;
  return (options, {
    inputValue,
    getOptionLabel
  }) => {
    let input = trim2 ? inputValue.trim() : inputValue;
    if (ignoreCase) {
      input = input.toLowerCase();
    }
    if (ignoreAccents) {
      input = stripDiacritics(input);
    }
    const filteredOptions = !input ? options : options.filter((option) => {
      let candidate = (stringify2 || getOptionLabel)(option);
      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
    });
    return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
  };
}
__name(createFilterOptions, "createFilterOptions");
function findIndex(array, comp) {
  for (let i = 0; i < array.length; i += 1) {
    if (comp(array[i])) {
      return i;
    }
  }
  return -1;
}
__name(findIndex, "findIndex");
const defaultFilterOptions = createFilterOptions();
const pageSize = 5;
const defaultIsActiveElementInListbox = /* @__PURE__ */ __name((listboxRef) => {
  var _listboxRef$current$p;
  return listboxRef.current !== null && ((_listboxRef$current$p = listboxRef.current.parentElement) == null ? void 0 : _listboxRef$current$p.contains(document.activeElement));
}, "defaultIsActiveElementInListbox");
function useAutocomplete(props) {
  const {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_isActiveElementInListbox = defaultIsActiveElementInListbox,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_classNamePrefix = "Mui",
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    componentName = "useAutocomplete",
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled: disabledProp,
    disabledItemsFocusable = false,
    disableListWrap = false,
    filterOptions = defaultFilterOptions,
    filterSelectedOptions = false,
    freeSolo = false,
    getOptionDisabled,
    getOptionKey,
    getOptionLabel: getOptionLabelProp = /* @__PURE__ */ __name((option) => {
      var _option$label;
      return (_option$label = option.label) != null ? _option$label : option;
    }, "getOptionLabelProp"),
    groupBy,
    handleHomeEndKeys = !props.freeSolo,
    id: idProp,
    includeInputInList = false,
    inputValue: inputValueProp,
    isOptionEqualToValue = /* @__PURE__ */ __name((option, value2) => option === value2, "isOptionEqualToValue"),
    multiple = false,
    onChange,
    onClose,
    onHighlightChange,
    onInputChange,
    onOpen,
    open: openProp,
    openOnFocus = false,
    options,
    readOnly = false,
    selectOnFocus = !props.freeSolo,
    value: valueProp
  } = props;
  const id2 = useId(idProp);
  let getOptionLabel = getOptionLabelProp;
  getOptionLabel = /* @__PURE__ */ __name((option) => {
    const optionLabel = getOptionLabelProp(option);
    if (typeof optionLabel !== "string") {
      return String(optionLabel);
    }
    return optionLabel;
  }, "getOptionLabel");
  const ignoreFocus = reactExports.useRef(false);
  const firstFocus = reactExports.useRef(true);
  const inputRef = reactExports.useRef(null);
  const listboxRef = reactExports.useRef(null);
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const [focusedTag, setFocusedTag] = reactExports.useState(-1);
  const defaultHighlighted = autoHighlight ? 0 : -1;
  const highlightedIndexRef = reactExports.useRef(defaultHighlighted);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: componentName
  });
  const [inputValue, setInputValueState] = useControlled({
    controlled: inputValueProp,
    default: "",
    name: componentName,
    state: "inputValue"
  });
  const [focused, setFocused] = reactExports.useState(false);
  const resetInputValue = reactExports.useCallback((event, newValue) => {
    const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
    if (!isOptionSelected && !clearOnBlur) {
      return;
    }
    let newInputValue;
    if (multiple) {
      newInputValue = "";
    } else if (newValue == null) {
      newInputValue = "";
    } else {
      const optionLabel = getOptionLabel(newValue);
      newInputValue = typeof optionLabel === "string" ? optionLabel : "";
    }
    if (inputValue === newInputValue) {
      return;
    }
    setInputValueState(newInputValue);
    if (onInputChange) {
      onInputChange(event, newInputValue, "reset");
    }
  }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
  const [open2, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: componentName,
    state: "open"
  });
  const [inputPristine, setInputPristine] = reactExports.useState(true);
  const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
  const popupOpen = open2 && !readOnly;
  const filteredOptions = popupOpen ? filterOptions(
    options.filter((option) => {
      if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
        return false;
      }
      return true;
    }),
    // we use the empty string to manipulate `filterOptions` to not filter any options
    // i.e. the filter predicate always returns true
    {
      inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue,
      getOptionLabel
    }
  ) : [];
  const previousProps = usePreviousProps({
    filteredOptions,
    value,
    inputValue
  });
  reactExports.useEffect(() => {
    const valueChange = value !== previousProps.value;
    if (focused && !valueChange) {
      return;
    }
    if (freeSolo && !valueChange) {
      return;
    }
    resetInputValue(null, value);
  }, [value, resetInputValue, focused, previousProps.value, freeSolo]);
  const listboxAvailable = open2 && filteredOptions.length > 0 && !readOnly;
  const focusTag = useEventCallback((tagToFocus) => {
    if (tagToFocus === -1) {
      inputRef.current.focus();
    } else {
      anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
    }
  });
  reactExports.useEffect(() => {
    if (multiple && focusedTag > value.length - 1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
  }, [value, multiple, focusedTag, focusTag]);
  function validOptionIndex(index2, direction) {
    if (!listboxRef.current || index2 < 0 || index2 >= filteredOptions.length) {
      return -1;
    }
    let nextFocus = index2;
    while (true) {
      const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
      const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
      if (option && option.hasAttribute("tabindex") && !nextFocusDisabled) {
        return nextFocus;
      }
      if (direction === "next") {
        nextFocus = (nextFocus + 1) % filteredOptions.length;
      } else {
        nextFocus = (nextFocus - 1 + filteredOptions.length) % filteredOptions.length;
      }
      if (nextFocus === index2) {
        return -1;
      }
    }
  }
  __name(validOptionIndex, "validOptionIndex");
  const setHighlightedIndex = useEventCallback(({
    event,
    index: index2,
    reason = "auto"
  }) => {
    highlightedIndexRef.current = index2;
    if (index2 === -1) {
      inputRef.current.removeAttribute("aria-activedescendant");
    } else {
      inputRef.current.setAttribute("aria-activedescendant", `${id2}-option-${index2}`);
    }
    if (onHighlightChange) {
      onHighlightChange(event, index2 === -1 ? null : filteredOptions[index2], reason);
    }
    if (!listboxRef.current) {
      return;
    }
    const prev2 = listboxRef.current.querySelector(`[role="option"].${unstable_classNamePrefix}-focused`);
    if (prev2) {
      prev2.classList.remove(`${unstable_classNamePrefix}-focused`);
      prev2.classList.remove(`${unstable_classNamePrefix}-focusVisible`);
    }
    let listboxNode = listboxRef.current;
    if (listboxRef.current.getAttribute("role") !== "listbox") {
      listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
    }
    if (!listboxNode) {
      return;
    }
    if (index2 === -1) {
      listboxNode.scrollTop = 0;
      return;
    }
    const option = listboxRef.current.querySelector(`[data-option-index="${index2}"]`);
    if (!option) {
      return;
    }
    option.classList.add(`${unstable_classNamePrefix}-focused`);
    if (reason === "keyboard") {
      option.classList.add(`${unstable_classNamePrefix}-focusVisible`);
    }
    if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse" && reason !== "touch") {
      const element = option;
      const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
      const elementBottom = element.offsetTop + element.offsetHeight;
      if (elementBottom > scrollBottom) {
        listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
      } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
        listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
      }
    }
  });
  const changeHighlightedIndex = useEventCallback(({
    event,
    diff,
    direction = "next",
    reason = "auto"
  }) => {
    if (!popupOpen) {
      return;
    }
    const getNextIndex = /* @__PURE__ */ __name(() => {
      const maxIndex = filteredOptions.length - 1;
      if (diff === "reset") {
        return defaultHighlighted;
      }
      if (diff === "start") {
        return 0;
      }
      if (diff === "end") {
        return maxIndex;
      }
      const newIndex = highlightedIndexRef.current + diff;
      if (newIndex < 0) {
        if (newIndex === -1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
          return 0;
        }
        return maxIndex;
      }
      if (newIndex > maxIndex) {
        if (newIndex === maxIndex + 1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap || Math.abs(diff) > 1) {
          return maxIndex;
        }
        return 0;
      }
      return newIndex;
    }, "getNextIndex");
    const nextIndex = validOptionIndex(getNextIndex(), direction);
    setHighlightedIndex({
      index: nextIndex,
      reason,
      event
    });
    if (autoComplete && diff !== "reset") {
      if (nextIndex === -1) {
        inputRef.current.value = inputValue;
      } else {
        const option = getOptionLabel(filteredOptions[nextIndex]);
        inputRef.current.value = option;
        const index2 = option.toLowerCase().indexOf(inputValue.toLowerCase());
        if (index2 === 0 && inputValue.length > 0) {
          inputRef.current.setSelectionRange(inputValue.length, option.length);
        }
      }
    }
  });
  const getPreviousHighlightedOptionIndex = /* @__PURE__ */ __name(() => {
    const isSameValue = /* @__PURE__ */ __name((value1, value2) => {
      const label1 = value1 ? getOptionLabel(value1) : "";
      const label2 = value2 ? getOptionLabel(value2) : "";
      return label1 === label2;
    }, "isSameValue");
    if (highlightedIndexRef.current !== -1 && previousProps.filteredOptions && previousProps.filteredOptions.length !== filteredOptions.length && previousProps.inputValue === inputValue && (multiple ? value.length === previousProps.value.length && previousProps.value.every((val, i) => getOptionLabel(value[i]) === getOptionLabel(val)) : isSameValue(previousProps.value, value))) {
      const previousHighlightedOption = previousProps.filteredOptions[highlightedIndexRef.current];
      if (previousHighlightedOption) {
        return findIndex(filteredOptions, (option) => {
          return getOptionLabel(option) === getOptionLabel(previousHighlightedOption);
        });
      }
    }
    return -1;
  }, "getPreviousHighlightedOptionIndex");
  const syncHighlightedIndex = reactExports.useCallback(() => {
    if (!popupOpen) {
      return;
    }
    const previousHighlightedOptionIndex = getPreviousHighlightedOptionIndex();
    if (previousHighlightedOptionIndex !== -1) {
      highlightedIndexRef.current = previousHighlightedOptionIndex;
      return;
    }
    const valueItem = multiple ? value[0] : value;
    if (filteredOptions.length === 0 || valueItem == null) {
      changeHighlightedIndex({
        diff: "reset"
      });
      return;
    }
    if (!listboxRef.current) {
      return;
    }
    if (valueItem != null) {
      const currentOption = filteredOptions[highlightedIndexRef.current];
      if (multiple && currentOption && findIndex(value, (val) => isOptionEqualToValue(currentOption, val)) !== -1) {
        return;
      }
      const itemIndex = findIndex(filteredOptions, (optionItem) => isOptionEqualToValue(optionItem, valueItem));
      if (itemIndex === -1) {
        changeHighlightedIndex({
          diff: "reset"
        });
      } else {
        setHighlightedIndex({
          index: itemIndex
        });
      }
      return;
    }
    if (highlightedIndexRef.current >= filteredOptions.length - 1) {
      setHighlightedIndex({
        index: filteredOptions.length - 1
      });
      return;
    }
    setHighlightedIndex({
      index: highlightedIndexRef.current
    });
  }, [
    // Only sync the highlighted index when the option switch between empty and not
    filteredOptions.length,
    // Don't sync the highlighted index with the value when multiple
    // eslint-disable-next-line react-hooks/exhaustive-deps
    multiple ? false : value,
    filterSelectedOptions,
    changeHighlightedIndex,
    setHighlightedIndex,
    popupOpen,
    inputValue,
    multiple
  ]);
  const handleListboxRef = useEventCallback((node2) => {
    setRef(listboxRef, node2);
    if (!node2) {
      return;
    }
    syncHighlightedIndex();
  });
  reactExports.useEffect(() => {
    syncHighlightedIndex();
  }, [syncHighlightedIndex]);
  const handleOpen = /* @__PURE__ */ __name((event) => {
    if (open2) {
      return;
    }
    setOpenState(true);
    setInputPristine(true);
    if (onOpen) {
      onOpen(event);
    }
  }, "handleOpen");
  const handleClose = /* @__PURE__ */ __name((event, reason) => {
    if (!open2) {
      return;
    }
    setOpenState(false);
    if (onClose) {
      onClose(event, reason);
    }
  }, "handleClose");
  const handleValue = /* @__PURE__ */ __name((event, newValue, reason, details) => {
    if (multiple) {
      if (value.length === newValue.length && value.every((val, i) => val === newValue[i])) {
        return;
      }
    } else if (value === newValue) {
      return;
    }
    if (onChange) {
      onChange(event, newValue, reason, details);
    }
    setValueState(newValue);
  }, "handleValue");
  const isTouch = reactExports.useRef(false);
  const selectNewValue = /* @__PURE__ */ __name((event, option, reasonProp = "selectOption", origin2 = "options") => {
    let reason = reasonProp;
    let newValue = option;
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = findIndex(newValue, (valueItem) => isOptionEqualToValue(option, valueItem));
      if (itemIndex === -1) {
        newValue.push(option);
      } else if (origin2 !== "freeSolo") {
        newValue.splice(itemIndex, 1);
        reason = "removeOption";
      }
    }
    resetInputValue(event, newValue);
    handleValue(event, newValue, reason, {
      option
    });
    if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
      handleClose(event, reason);
    }
    if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
      inputRef.current.blur();
    }
  }, "selectNewValue");
  function validTagIndex(index2, direction) {
    if (index2 === -1) {
      return -1;
    }
    let nextFocus = index2;
    while (true) {
      if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
      if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  __name(validTagIndex, "validTagIndex");
  const handleFocusTag = /* @__PURE__ */ __name((event, direction) => {
    if (!multiple) {
      return;
    }
    if (inputValue === "") {
      handleClose(event, "toggleInput");
    }
    let nextTag = focusedTag;
    if (focusedTag === -1) {
      if (inputValue === "" && direction === "previous") {
        nextTag = value.length - 1;
      }
    } else {
      nextTag += direction === "next" ? 1 : -1;
      if (nextTag < 0) {
        nextTag = 0;
      }
      if (nextTag === value.length) {
        nextTag = -1;
      }
    }
    nextTag = validTagIndex(nextTag, direction);
    setFocusedTag(nextTag);
    focusTag(nextTag);
  }, "handleFocusTag");
  const handleClear = /* @__PURE__ */ __name((event) => {
    ignoreFocus.current = true;
    setInputValueState("");
    if (onInputChange) {
      onInputChange(event, "", "clear");
    }
    handleValue(event, multiple ? [] : null, "clear");
  }, "handleClear");
  const handleKeyDown2 = /* @__PURE__ */ __name((other) => (event) => {
    if (other.onKeyDown) {
      other.onKeyDown(event);
    }
    if (event.defaultMuiPrevented) {
      return;
    }
    if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
    if (event.which !== 229) {
      switch (event.key) {
        case "Home":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "start",
              direction: "next",
              reason: "keyboard",
              event
            });
          }
          break;
        case "End":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "end",
              direction: "previous",
              reason: "keyboard",
              event
            });
          }
          break;
        case "PageUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -pageSize,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "PageDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: pageSize,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: 1,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -1,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowLeft":
          handleFocusTag(event, "previous");
          break;
        case "ArrowRight":
          handleFocusTag(event, "next");
          break;
        case "Enter":
          if (highlightedIndexRef.current !== -1 && popupOpen) {
            const option = filteredOptions[highlightedIndexRef.current];
            const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
            event.preventDefault();
            if (disabled) {
              return;
            }
            selectNewValue(event, option, "selectOption");
            if (autoComplete) {
              inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            }
          } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
            if (multiple) {
              event.preventDefault();
            }
            selectNewValue(event, inputValue, "createOption", "freeSolo");
          }
          break;
        case "Escape":
          if (popupOpen) {
            event.preventDefault();
            event.stopPropagation();
            handleClose(event, "escape");
          } else if (clearOnEscape && (inputValue !== "" || multiple && value.length > 0)) {
            event.preventDefault();
            event.stopPropagation();
            handleClear(event);
          }
          break;
        case "Backspace":
          if (multiple && !readOnly && inputValue === "" && value.length > 0) {
            const index2 = focusedTag === -1 ? value.length - 1 : focusedTag;
            const newValue = value.slice();
            newValue.splice(index2, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index2]
            });
          }
          break;
        case "Delete":
          if (multiple && !readOnly && inputValue === "" && value.length > 0 && focusedTag !== -1) {
            const index2 = focusedTag;
            const newValue = value.slice();
            newValue.splice(index2, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index2]
            });
          }
          break;
      }
    }
  }, "handleKeyDown");
  const handleFocus = /* @__PURE__ */ __name((event) => {
    setFocused(true);
    if (openOnFocus && !ignoreFocus.current) {
      handleOpen(event);
    }
  }, "handleFocus");
  const handleBlur2 = /* @__PURE__ */ __name((event) => {
    if (unstable_isActiveElementInListbox(listboxRef)) {
      inputRef.current.focus();
      return;
    }
    setFocused(false);
    firstFocus.current = true;
    ignoreFocus.current = false;
    if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
      selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
    } else if (autoSelect && freeSolo && inputValue !== "") {
      selectNewValue(event, inputValue, "blur", "freeSolo");
    } else if (clearOnBlur) {
      resetInputValue(event, value);
    }
    handleClose(event, "blur");
  }, "handleBlur");
  const handleInputChange = /* @__PURE__ */ __name((event) => {
    const newValue = event.target.value;
    if (inputValue !== newValue) {
      setInputValueState(newValue);
      setInputPristine(false);
      if (onInputChange) {
        onInputChange(event, newValue, "input");
      }
    }
    if (newValue === "") {
      if (!disableClearable && !multiple) {
        handleValue(event, null, "clear");
      }
    } else {
      handleOpen(event);
    }
  }, "handleInputChange");
  const handleOptionMouseMove = /* @__PURE__ */ __name((event) => {
    const index2 = Number(event.currentTarget.getAttribute("data-option-index"));
    if (highlightedIndexRef.current !== index2) {
      setHighlightedIndex({
        event,
        index: index2,
        reason: "mouse"
      });
    }
  }, "handleOptionMouseMove");
  const handleOptionTouchStart = /* @__PURE__ */ __name((event) => {
    setHighlightedIndex({
      event,
      index: Number(event.currentTarget.getAttribute("data-option-index")),
      reason: "touch"
    });
    isTouch.current = true;
  }, "handleOptionTouchStart");
  const handleOptionClick = /* @__PURE__ */ __name((event) => {
    const index2 = Number(event.currentTarget.getAttribute("data-option-index"));
    selectNewValue(event, filteredOptions[index2], "selectOption");
    isTouch.current = false;
  }, "handleOptionClick");
  const handleTagDelete = /* @__PURE__ */ __name((index2) => (event) => {
    const newValue = value.slice();
    newValue.splice(index2, 1);
    handleValue(event, newValue, "removeOption", {
      option: value[index2]
    });
  }, "handleTagDelete");
  const handlePopupIndicator = /* @__PURE__ */ __name((event) => {
    if (open2) {
      handleClose(event, "toggleInput");
    } else {
      handleOpen(event);
    }
  }, "handlePopupIndicator");
  const handleMouseDown = /* @__PURE__ */ __name((event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    if (event.target.getAttribute("id") !== id2) {
      event.preventDefault();
    }
  }, "handleMouseDown");
  const handleClick = /* @__PURE__ */ __name((event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    inputRef.current.focus();
    if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
      inputRef.current.select();
    }
    firstFocus.current = false;
  }, "handleClick");
  const handleInputMouseDown = /* @__PURE__ */ __name((event) => {
    if (!disabledProp && (inputValue === "" || !open2)) {
      handlePopupIndicator(event);
    }
  }, "handleInputMouseDown");
  let dirty = freeSolo && inputValue.length > 0;
  dirty = dirty || (multiple ? value.length > 0 : value !== null);
  let groupedOptions = filteredOptions;
  if (groupBy) {
    groupedOptions = filteredOptions.reduce((acc, option, index2) => {
      const group = groupBy(option);
      if (acc.length > 0 && acc[acc.length - 1].group === group) {
        acc[acc.length - 1].options.push(option);
      } else {
        acc.push({
          key: index2,
          index: index2,
          group,
          options: [option]
        });
      }
      return acc;
    }, []);
  }
  if (disabledProp && focused) {
    handleBlur2();
  }
  return {
    getRootProps: (other = {}) => _extends$4({
      "aria-owns": listboxAvailable ? `${id2}-listbox` : null
    }, other, {
      onKeyDown: handleKeyDown2(other),
      onMouseDown: handleMouseDown,
      onClick: handleClick
    }),
    getInputLabelProps: () => ({
      id: `${id2}-label`,
      htmlFor: id2
    }),
    getInputProps: () => ({
      id: id2,
      value: inputValue,
      onBlur: handleBlur2,
      onFocus: handleFocus,
      onChange: handleInputChange,
      onMouseDown: handleInputMouseDown,
      // if open then this is handled imperatively so don't let react override
      // only have an opinion about this when closed
      "aria-activedescendant": popupOpen ? "" : null,
      "aria-autocomplete": autoComplete ? "both" : "list",
      "aria-controls": listboxAvailable ? `${id2}-listbox` : void 0,
      "aria-expanded": listboxAvailable,
      // Disable browser's suggestion that might overlap with the popup.
      // Handle autocomplete but not autofill.
      autoComplete: "off",
      ref: inputRef,
      autoCapitalize: "none",
      spellCheck: "false",
      role: "combobox",
      disabled: disabledProp
    }),
    getClearProps: () => ({
      tabIndex: -1,
      type: "button",
      onClick: handleClear
    }),
    getPopupIndicatorProps: () => ({
      tabIndex: -1,
      type: "button",
      onClick: handlePopupIndicator
    }),
    getTagProps: ({
      index: index2
    }) => _extends$4({
      key: index2,
      "data-tag-index": index2,
      tabIndex: -1
    }, !readOnly && {
      onDelete: handleTagDelete(index2)
    }),
    getListboxProps: () => ({
      role: "listbox",
      id: `${id2}-listbox`,
      "aria-labelledby": `${id2}-label`,
      ref: handleListboxRef,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }),
    getOptionProps: ({
      index: index2,
      option
    }) => {
      var _getOptionKey;
      const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
      const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
      return {
        key: (_getOptionKey = getOptionKey == null ? void 0 : getOptionKey(option)) != null ? _getOptionKey : getOptionLabel(option),
        tabIndex: -1,
        role: "option",
        id: `${id2}-option-${index2}`,
        onMouseMove: handleOptionMouseMove,
        onClick: handleOptionClick,
        onTouchStart: handleOptionTouchStart,
        "data-option-index": index2,
        "aria-disabled": disabled,
        "aria-selected": selected
      };
    },
    id: id2,
    inputValue,
    value,
    dirty,
    expanded: popupOpen && anchorEl,
    popupOpen,
    focused: focused || focusedTag !== -1,
    anchorEl,
    setAnchorEl,
    focusedTag,
    groupedOptions
  };
}
__name(useAutocomplete, "useAutocomplete");
function getListSubheaderUtilityClass(slot) {
  return generateUtilityClass$1("MuiListSubheader", slot);
}
__name(getListSubheaderUtilityClass, "getListSubheaderUtilityClass");
generateUtilityClasses$1("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
const _excluded$1y = ["className", "color", "component", "disableGutters", "disableSticky", "inset"];
const useUtilityClasses$1h = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    color: color2,
    disableGutters,
    inset,
    disableSticky
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "default" && `color${capitalize$1(color2)}`, !disableGutters && "gutters", inset && "inset", !disableSticky && "sticky"]
  };
  return composeClasses(slots, getListSubheaderUtilityClass, classes2);
}, "useUtilityClasses$1h");
const ListSubheaderRoot = styled("li", {
  name: "MuiListSubheader",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], !ownerState.disableGutters && styles2.gutters, ownerState.inset && styles2.inset, !ownerState.disableSticky && styles2.sticky];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  boxSizing: "border-box",
  lineHeight: "48px",
  listStyle: "none",
  color: (theme2.vars || theme2).palette.text.secondary,
  fontFamily: theme2.typography.fontFamily,
  fontWeight: theme2.typography.fontWeightMedium,
  fontSize: theme2.typography.pxToRem(14)
}, ownerState.color === "primary" && {
  color: (theme2.vars || theme2).palette.primary.main
}, ownerState.color === "inherit" && {
  color: "inherit"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.inset && {
  paddingLeft: 72
}, !ownerState.disableSticky && {
  position: "sticky",
  top: 0,
  zIndex: 1,
  backgroundColor: (theme2.vars || theme2).palette.background.paper
}));
const ListSubheader = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function ListSubheader2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListSubheader"
  });
  const {
    className,
    color: color2 = "default",
    component = "li",
    disableGutters = false,
    disableSticky = false,
    inset = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1y);
  const ownerState = _extends$4({}, props, {
    color: color2,
    component,
    disableGutters,
    disableSticky,
    inset
  });
  const classes2 = useUtilityClasses$1h(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListSubheaderRoot, _extends$4({
    as: component,
    className: clsx(classes2.root, className),
    ref,
    ownerState
  }, other));
}, "ListSubheader2"));
ListSubheader.muiSkipListHighlight = true;
const CancelIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}), "Cancel");
function getChipUtilityClass(slot) {
  return generateUtilityClass$1("MuiChip", slot);
}
__name(getChipUtilityClass, "getChipUtilityClass");
const chipClasses = generateUtilityClasses$1("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
const _excluded$1x = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"];
const useUtilityClasses$1g = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disabled,
    size: size2,
    color: color2,
    iconColor,
    onDelete,
    clickable,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, disabled && "disabled", `size${capitalize$1(size2)}`, `color${capitalize$1(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize$1(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize$1(color2)}`, `${variant}${capitalize$1(color2)}`],
    label: ["label", `label${capitalize$1(size2)}`],
    avatar: ["avatar", `avatar${capitalize$1(size2)}`, `avatarColor${capitalize$1(color2)}`],
    icon: ["icon", `icon${capitalize$1(size2)}`, `iconColor${capitalize$1(iconColor)}`],
    deleteIcon: ["deleteIcon", `deleteIcon${capitalize$1(size2)}`, `deleteIconColor${capitalize$1(color2)}`, `deleteIcon${capitalize$1(variant)}Color${capitalize$1(color2)}`]
  };
  return composeClasses(slots, getChipUtilityClass, classes2);
}, "useUtilityClasses$1g");
const ChipRoot = styled("div", {
  name: "MuiChip",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      color: color2,
      iconColor,
      clickable,
      onDelete,
      size: size2,
      variant
    } = ownerState;
    return [{
      [`& .${chipClasses.avatar}`]: styles2.avatar
    }, {
      [`& .${chipClasses.avatar}`]: styles2[`avatar${capitalize$1(size2)}`]
    }, {
      [`& .${chipClasses.avatar}`]: styles2[`avatarColor${capitalize$1(color2)}`]
    }, {
      [`& .${chipClasses.icon}`]: styles2.icon
    }, {
      [`& .${chipClasses.icon}`]: styles2[`icon${capitalize$1(size2)}`]
    }, {
      [`& .${chipClasses.icon}`]: styles2[`iconColor${capitalize$1(iconColor)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2.deleteIcon
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize$1(size2)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIconColor${capitalize$1(color2)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize$1(variant)}Color${capitalize$1(color2)}`]
    }, styles2.root, styles2[`size${capitalize$1(size2)}`], styles2[`color${capitalize$1(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize$1(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize$1(color2)}`], styles2[variant], styles2[`${variant}${capitalize$1(color2)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const textColor = theme2.palette.mode === "light" ? theme2.palette.grey[700] : theme2.palette.grey[300];
  return _extends$4({
    maxWidth: "100%",
    fontFamily: theme2.typography.fontFamily,
    fontSize: theme2.typography.pxToRem(13),
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    height: 32,
    color: (theme2.vars || theme2).palette.text.primary,
    backgroundColor: (theme2.vars || theme2).palette.action.selected,
    borderRadius: 32 / 2,
    whiteSpace: "nowrap",
    transition: theme2.transitions.create(["background-color", "box-shadow"]),
    // reset cursor explicitly in case ButtonBase is used
    cursor: "unset",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    textDecoration: "none",
    border: 0,
    // Remove `button` border
    padding: 0,
    // Remove `button` padding
    verticalAlign: "middle",
    boxSizing: "border-box",
    [`&.${chipClasses.disabled}`]: {
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`& .${chipClasses.avatar}`]: {
      marginLeft: 5,
      marginRight: -6,
      width: 24,
      height: 24,
      color: theme2.vars ? theme2.vars.palette.Chip.defaultAvatarColor : textColor,
      fontSize: theme2.typography.pxToRem(12)
    },
    [`& .${chipClasses.avatarColorPrimary}`]: {
      color: (theme2.vars || theme2).palette.primary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.primary.dark
    },
    [`& .${chipClasses.avatarColorSecondary}`]: {
      color: (theme2.vars || theme2).palette.secondary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.secondary.dark
    },
    [`& .${chipClasses.avatarSmall}`]: {
      marginLeft: 4,
      marginRight: -4,
      width: 18,
      height: 18,
      fontSize: theme2.typography.pxToRem(10)
    },
    [`& .${chipClasses.icon}`]: _extends$4({
      marginLeft: 5,
      marginRight: -6
    }, ownerState.size === "small" && {
      fontSize: 18,
      marginLeft: 4,
      marginRight: -4
    }, ownerState.iconColor === ownerState.color && _extends$4({
      color: theme2.vars ? theme2.vars.palette.Chip.defaultIconColor : textColor
    }, ownerState.color !== "default" && {
      color: "inherit"
    })),
    [`& .${chipClasses.deleteIcon}`]: _extends$4({
      WebkitTapHighlightColor: "transparent",
      color: theme2.vars ? `rgba(${theme2.vars.palette.text.primaryChannel} / 0.26)` : alpha_1(theme2.palette.text.primary, 0.26),
      fontSize: 22,
      cursor: "pointer",
      margin: "0 5px 0 -6px",
      "&:hover": {
        color: theme2.vars ? `rgba(${theme2.vars.palette.text.primaryChannel} / 0.4)` : alpha_1(theme2.palette.text.primary, 0.4)
      }
    }, ownerState.size === "small" && {
      fontSize: 16,
      marginRight: 4,
      marginLeft: -4
    }, ownerState.color !== "default" && {
      color: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha_1(theme2.palette[ownerState.color].contrastText, 0.7),
      "&:hover, &:active": {
        color: (theme2.vars || theme2).palette[ownerState.color].contrastText
      }
    })
  }, ownerState.size === "small" && {
    height: 24
  }, ownerState.color !== "default" && {
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main,
    color: (theme2.vars || theme2).palette[ownerState.color].contrastText
  }, ownerState.onDelete && {
    [`&.${chipClasses.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.selectedChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha_1(theme2.palette.action.selected, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  }, ownerState.onDelete && ownerState.color !== "default" && {
    [`&.${chipClasses.focusVisible}`]: {
      backgroundColor: (theme2.vars || theme2).palette[ownerState.color].dark
    }
  });
}, ({
  theme: theme2,
  ownerState
}) => _extends$4({}, ownerState.clickable && {
  userSelect: "none",
  WebkitTapHighlightColor: "transparent",
  cursor: "pointer",
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.selectedChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha_1(theme2.palette.action.selected, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity)
  },
  [`&.${chipClasses.focusVisible}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.selectedChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha_1(theme2.palette.action.selected, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
  },
  "&:active": {
    boxShadow: (theme2.vars || theme2).shadows[1]
  }
}, ownerState.clickable && ownerState.color !== "default" && {
  [`&:hover, &.${chipClasses.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].dark
  }
}), ({
  theme: theme2,
  ownerState
}) => _extends$4({}, ownerState.variant === "outlined" && {
  backgroundColor: "transparent",
  border: theme2.vars ? `1px solid ${theme2.vars.palette.Chip.defaultBorder}` : `1px solid ${theme2.palette.mode === "light" ? theme2.palette.grey[400] : theme2.palette.grey[700]}`,
  [`&.${chipClasses.clickable}:hover`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.hover
  },
  [`&.${chipClasses.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`& .${chipClasses.avatar}`]: {
    marginLeft: 4
  },
  [`& .${chipClasses.avatarSmall}`]: {
    marginLeft: 2
  },
  [`& .${chipClasses.icon}`]: {
    marginLeft: 4
  },
  [`& .${chipClasses.iconSmall}`]: {
    marginLeft: 2
  },
  [`& .${chipClasses.deleteIcon}`]: {
    marginRight: 5
  },
  [`& .${chipClasses.deleteIconSmall}`]: {
    marginRight: 3
  }
}, ownerState.variant === "outlined" && ownerState.color !== "default" && {
  color: (theme2.vars || theme2).palette[ownerState.color].main,
  border: `1px solid ${theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha_1(theme2.palette[ownerState.color].main, 0.7)}`,
  [`&.${chipClasses.clickable}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha_1(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity)
  },
  [`&.${chipClasses.focusVisible}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.focusOpacity})` : alpha_1(theme2.palette[ownerState.color].main, theme2.palette.action.focusOpacity)
  },
  [`& .${chipClasses.deleteIcon}`]: {
    color: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha_1(theme2.palette[ownerState.color].main, 0.7),
    "&:hover, &:active": {
      color: (theme2.vars || theme2).palette[ownerState.color].main
    }
  }
}));
const ChipLabel = styled("span", {
  name: "MuiChip",
  slot: "Label",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      size: size2
    } = ownerState;
    return [styles2.label, styles2[`label${capitalize$1(size2)}`]];
  }
})(({
  ownerState
}) => _extends$4({
  overflow: "hidden",
  textOverflow: "ellipsis",
  paddingLeft: 12,
  paddingRight: 12,
  whiteSpace: "nowrap"
}, ownerState.variant === "outlined" && {
  paddingLeft: 11,
  paddingRight: 11
}, ownerState.size === "small" && {
  paddingLeft: 8,
  paddingRight: 8
}, ownerState.size === "small" && ownerState.variant === "outlined" && {
  paddingLeft: 7,
  paddingRight: 7
}));
function isDeleteKeyboardEvent(keyboardEvent) {
  return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
}
__name(isDeleteKeyboardEvent, "isDeleteKeyboardEvent");
const Chip = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Chip2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiChip"
  });
  const {
    avatar: avatarProp,
    className,
    clickable: clickableProp,
    color: color2 = "default",
    component: ComponentProp,
    deleteIcon: deleteIconProp,
    disabled = false,
    icon: iconProp,
    label,
    onClick,
    onDelete,
    onKeyDown,
    onKeyUp,
    size: size2 = "medium",
    variant = "filled",
    tabIndex,
    skipFocusWhenDisabled = false
    // TODO v6: Rename to `focusableWhenDisabled`.
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1x);
  const chipRef = reactExports.useRef(null);
  const handleRef = useForkRef(chipRef, ref);
  const handleDeleteIconClick = /* @__PURE__ */ __name((event) => {
    event.stopPropagation();
    if (onDelete) {
      onDelete(event);
    }
  }, "handleDeleteIconClick");
  const handleKeyDown2 = /* @__PURE__ */ __name((event) => {
    if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, "handleKeyDown");
  const handleKeyUp = /* @__PURE__ */ __name((event) => {
    if (event.currentTarget === event.target) {
      if (onDelete && isDeleteKeyboardEvent(event)) {
        onDelete(event);
      } else if (event.key === "Escape" && chipRef.current) {
        chipRef.current.blur();
      }
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
  }, "handleKeyUp");
  const clickable = clickableProp !== false && onClick ? true : clickableProp;
  const component = clickable || onDelete ? ButtonBase : ComponentProp || "div";
  const ownerState = _extends$4({}, props, {
    component,
    disabled,
    size: size2,
    color: color2,
    iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
    onDelete: !!onDelete,
    clickable,
    variant
  });
  const classes2 = useUtilityClasses$1g(ownerState);
  const moreProps = component === ButtonBase ? _extends$4({
    component: ComponentProp || "div",
    focusVisibleClassName: classes2.focusVisible
  }, onDelete && {
    disableRipple: true
  }) : {};
  let deleteIcon = null;
  if (onDelete) {
    deleteIcon = deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
      className: clsx(deleteIconProp.props.className, classes2.deleteIcon),
      onClick: handleDeleteIconClick
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
      className: clsx(classes2.deleteIcon),
      onClick: handleDeleteIconClick
    });
  }
  let avatar = null;
  if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
    avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
      className: clsx(classes2.avatar, avatarProp.props.className)
    });
  }
  let icon = null;
  if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
    icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
      className: clsx(classes2.icon, iconProp.props.className)
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChipRoot, _extends$4({
    as: component,
    className: clsx(classes2.root, className),
    disabled: clickable && disabled ? true : void 0,
    onClick,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    ref: handleRef,
    tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
    ownerState
  }, moreProps, other, {
    children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(ChipLabel, {
      className: clsx(classes2.label),
      ownerState,
      children: label
    }), deleteIcon]
  }));
}, "Chip2"));
function getAutocompleteUtilityClass(slot) {
  return generateUtilityClass$1("MuiAutocomplete", slot);
}
__name(getAutocompleteUtilityClass, "getAutocompleteUtilityClass");
const autocompleteClasses = generateUtilityClasses$1("MuiAutocomplete", ["root", "expanded", "fullWidth", "focused", "focusVisible", "tag", "tagSizeSmall", "tagSizeMedium", "hasPopupIcon", "hasClearIcon", "inputRoot", "input", "inputFocused", "endAdornment", "clearIndicator", "popupIndicator", "popupIndicatorOpen", "popper", "popperDisablePortal", "paper", "listbox", "loading", "noOptions", "option", "groupLabel", "groupUl"]);
var _ClearIcon, _ArrowDropDownIcon;
const _excluded$1w = ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "className", "clearIcon", "clearOnBlur", "clearOnEscape", "clearText", "closeText", "componentsProps", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionKey", "getOptionLabel", "isOptionEqualToValue", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "readOnly", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "slotProps", "value"], _excluded2$b = ["ref"], _excluded3$1 = ["key"], _excluded4 = ["key"];
const useUtilityClasses$1f = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disablePortal,
    expanded,
    focused,
    fullWidth,
    hasClearIcon,
    hasPopupIcon,
    inputFocused,
    popupOpen,
    size: size2
  } = ownerState;
  const slots = {
    root: ["root", expanded && "expanded", focused && "focused", fullWidth && "fullWidth", hasClearIcon && "hasClearIcon", hasPopupIcon && "hasPopupIcon"],
    inputRoot: ["inputRoot"],
    input: ["input", inputFocused && "inputFocused"],
    tag: ["tag", `tagSize${capitalize$1(size2)}`],
    endAdornment: ["endAdornment"],
    clearIndicator: ["clearIndicator"],
    popupIndicator: ["popupIndicator", popupOpen && "popupIndicatorOpen"],
    popper: ["popper", disablePortal && "popperDisablePortal"],
    paper: ["paper"],
    listbox: ["listbox"],
    loading: ["loading"],
    noOptions: ["noOptions"],
    option: ["option"],
    groupLabel: ["groupLabel"],
    groupUl: ["groupUl"]
  };
  return composeClasses(slots, getAutocompleteUtilityClass, classes2);
}, "useUtilityClasses$1f");
const AutocompleteRoot = styled("div", {
  name: "MuiAutocomplete",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      fullWidth,
      hasClearIcon,
      hasPopupIcon,
      inputFocused,
      size: size2
    } = ownerState;
    return [{
      [`& .${autocompleteClasses.tag}`]: styles2.tag
    }, {
      [`& .${autocompleteClasses.tag}`]: styles2[`tagSize${capitalize$1(size2)}`]
    }, {
      [`& .${autocompleteClasses.inputRoot}`]: styles2.inputRoot
    }, {
      [`& .${autocompleteClasses.input}`]: styles2.input
    }, {
      [`& .${autocompleteClasses.input}`]: inputFocused && styles2.inputFocused
    }, styles2.root, fullWidth && styles2.fullWidth, hasPopupIcon && styles2.hasPopupIcon, hasClearIcon && styles2.hasClearIcon];
  }
})({
  [`&.${autocompleteClasses.focused} .${autocompleteClasses.clearIndicator}`]: {
    visibility: "visible"
  },
  /* Avoid double tap issue on iOS */
  "@media (pointer: fine)": {
    [`&:hover .${autocompleteClasses.clearIndicator}`]: {
      visibility: "visible"
    }
  },
  [`& .${autocompleteClasses.tag}`]: {
    margin: 3,
    maxWidth: "calc(100% - 6px)"
  },
  [`& .${autocompleteClasses.inputRoot}`]: {
    [`.${autocompleteClasses.hasPopupIcon}&, .${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 26 + 4
    },
    [`.${autocompleteClasses.hasPopupIcon}.${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 52 + 4
    },
    [`& .${autocompleteClasses.input}`]: {
      width: 0,
      minWidth: 30
    }
  },
  [`& .${inputClasses.root}`]: {
    paddingBottom: 1,
    "& .MuiInput-input": {
      padding: "4px 4px 4px 0px"
    }
  },
  [`& .${inputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
    [`& .${inputClasses.input}`]: {
      padding: "2px 4px 3px 0"
    }
  },
  [`& .${outlinedInputClasses.root}`]: {
    padding: 9,
    [`.${autocompleteClasses.hasPopupIcon}&, .${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 26 + 4 + 9
    },
    [`.${autocompleteClasses.hasPopupIcon}.${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 52 + 4 + 9
    },
    [`& .${autocompleteClasses.input}`]: {
      padding: "7.5px 4px 7.5px 5px"
    },
    [`& .${autocompleteClasses.endAdornment}`]: {
      right: 9
    }
  },
  [`& .${outlinedInputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
    // Don't specify paddingRight, as it overrides the default value set when there is only
    // one of the popup or clear icon as the specificity is equal so the latter one wins
    paddingTop: 6,
    paddingBottom: 6,
    paddingLeft: 6,
    [`& .${autocompleteClasses.input}`]: {
      padding: "2.5px 4px 2.5px 8px"
    }
  },
  [`& .${filledInputClasses.root}`]: {
    paddingTop: 19,
    paddingLeft: 8,
    [`.${autocompleteClasses.hasPopupIcon}&, .${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 26 + 4 + 9
    },
    [`.${autocompleteClasses.hasPopupIcon}.${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 52 + 4 + 9
    },
    [`& .${filledInputClasses.input}`]: {
      padding: "7px 4px"
    },
    [`& .${autocompleteClasses.endAdornment}`]: {
      right: 9
    }
  },
  [`& .${filledInputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
    paddingBottom: 1,
    [`& .${filledInputClasses.input}`]: {
      padding: "2.5px 4px"
    }
  },
  [`& .${inputBaseClasses.hiddenLabel}`]: {
    paddingTop: 8
  },
  [`& .${filledInputClasses.root}.${inputBaseClasses.hiddenLabel}`]: {
    paddingTop: 0,
    paddingBottom: 0,
    [`& .${autocompleteClasses.input}`]: {
      paddingTop: 16,
      paddingBottom: 17
    }
  },
  [`& .${filledInputClasses.root}.${inputBaseClasses.hiddenLabel}.${inputBaseClasses.sizeSmall}`]: {
    [`& .${autocompleteClasses.input}`]: {
      paddingTop: 8,
      paddingBottom: 9
    }
  },
  [`& .${autocompleteClasses.input}`]: {
    flexGrow: 1,
    textOverflow: "ellipsis",
    opacity: 0
  },
  variants: [{
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      [`& .${autocompleteClasses.tag}`]: {
        margin: 2,
        maxWidth: "calc(100% - 4px)"
      }
    }
  }, {
    props: {
      inputFocused: true
    },
    style: {
      [`& .${autocompleteClasses.input}`]: {
        opacity: 1
      }
    }
  }, {
    props: {
      multiple: true
    },
    style: {
      [`& .${autocompleteClasses.inputRoot}`]: {
        flexWrap: "wrap"
      }
    }
  }]
});
const AutocompleteEndAdornment = styled("div", {
  name: "MuiAutocomplete",
  slot: "EndAdornment",
  overridesResolver: (props, styles2) => styles2.endAdornment
})({
  // We use a position absolute to support wrapping tags.
  position: "absolute",
  right: 0,
  top: "50%",
  transform: "translate(0, -50%)"
});
const AutocompleteClearIndicator = styled(IconButton, {
  name: "MuiAutocomplete",
  slot: "ClearIndicator",
  overridesResolver: (props, styles2) => styles2.clearIndicator
})({
  marginRight: -2,
  padding: 4,
  visibility: "hidden"
});
const AutocompletePopupIndicator = styled(IconButton, {
  name: "MuiAutocomplete",
  slot: "PopupIndicator",
  overridesResolver: ({
    ownerState
  }, styles2) => _extends$4({}, styles2.popupIndicator, ownerState.popupOpen && styles2.popupIndicatorOpen)
})({
  padding: 2,
  marginRight: -2,
  variants: [{
    props: {
      popupOpen: true
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
});
const AutocompletePopper = styled(Popper, {
  name: "MuiAutocomplete",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${autocompleteClasses.option}`]: styles2.option
    }, styles2.popper, ownerState.disablePortal && styles2.popperDisablePortal];
  }
})(({
  theme: theme2
}) => ({
  zIndex: (theme2.vars || theme2).zIndex.modal,
  variants: [{
    props: {
      disablePortal: true
    },
    style: {
      position: "absolute"
    }
  }]
}));
const AutocompletePaper = styled(Paper, {
  name: "MuiAutocomplete",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})(({
  theme: theme2
}) => _extends$4({}, theme2.typography.body1, {
  overflow: "auto"
}));
const AutocompleteLoading = styled("div", {
  name: "MuiAutocomplete",
  slot: "Loading",
  overridesResolver: (props, styles2) => styles2.loading
})(({
  theme: theme2
}) => ({
  color: (theme2.vars || theme2).palette.text.secondary,
  padding: "14px 16px"
}));
const AutocompleteNoOptions = styled("div", {
  name: "MuiAutocomplete",
  slot: "NoOptions",
  overridesResolver: (props, styles2) => styles2.noOptions
})(({
  theme: theme2
}) => ({
  color: (theme2.vars || theme2).palette.text.secondary,
  padding: "14px 16px"
}));
const AutocompleteListbox = styled("div", {
  name: "MuiAutocomplete",
  slot: "Listbox",
  overridesResolver: (props, styles2) => styles2.listbox
})(({
  theme: theme2
}) => ({
  listStyle: "none",
  margin: 0,
  padding: "8px 0",
  maxHeight: "40vh",
  overflow: "auto",
  position: "relative",
  [`& .${autocompleteClasses.option}`]: {
    minHeight: 48,
    display: "flex",
    overflow: "hidden",
    justifyContent: "flex-start",
    alignItems: "center",
    cursor: "pointer",
    paddingTop: 6,
    boxSizing: "border-box",
    outline: "0",
    WebkitTapHighlightColor: "transparent",
    paddingBottom: 6,
    paddingLeft: 16,
    paddingRight: 16,
    [theme2.breakpoints.up("sm")]: {
      minHeight: "auto"
    },
    [`&.${autocompleteClasses.focused}`]: {
      backgroundColor: (theme2.vars || theme2).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    '&[aria-disabled="true"]': {
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`&.${autocompleteClasses.focusVisible}`]: {
      backgroundColor: (theme2.vars || theme2).palette.action.focus
    },
    '&[aria-selected="true"]': {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
      [`&.${autocompleteClasses.focused}`]: {
        backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme2.vars || theme2).palette.action.selected
        }
      },
      [`&.${autocompleteClasses.focusVisible}`]: {
        backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
      }
    }
  }
}));
const AutocompleteGroupLabel = styled(ListSubheader, {
  name: "MuiAutocomplete",
  slot: "GroupLabel",
  overridesResolver: (props, styles2) => styles2.groupLabel
})(({
  theme: theme2
}) => ({
  backgroundColor: (theme2.vars || theme2).palette.background.paper,
  top: -8
}));
const AutocompleteGroupUl = styled("ul", {
  name: "MuiAutocomplete",
  slot: "GroupUl",
  overridesResolver: (props, styles2) => styles2.groupUl
})({
  padding: 0,
  [`& .${autocompleteClasses.option}`]: {
    paddingLeft: 24
  }
});
const Autocomplete = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Autocomplete2(inProps, ref) {
  var _slotProps$clearIndic, _slotProps$paper, _slotProps$popper, _slotProps$popupIndic;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAutocomplete"
  });
  const {
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    ChipProps,
    className,
    clearIcon = _ClearIcon || (_ClearIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ClearIcon$1, {
      fontSize: "small"
    })),
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    clearText = "Clear",
    closeText = "Close",
    componentsProps = {},
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled = false,
    disabledItemsFocusable = false,
    disableListWrap = false,
    disablePortal = false,
    filterSelectedOptions = false,
    forcePopupIcon = "auto",
    freeSolo = false,
    fullWidth = false,
    getLimitTagsText = /* @__PURE__ */ __name((more) => `+${more}`, "getLimitTagsText"),
    getOptionLabel: getOptionLabelProp,
    groupBy,
    handleHomeEndKeys = !props.freeSolo,
    includeInputInList = false,
    limitTags = -1,
    ListboxComponent = "ul",
    ListboxProps,
    loading = false,
    loadingText = "Loading",
    multiple = false,
    noOptionsText = "No options",
    openOnFocus = false,
    openText = "Open",
    PaperComponent = Paper,
    PopperComponent = Popper,
    popupIcon = _ArrowDropDownIcon || (_ArrowDropDownIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon, {})),
    readOnly = false,
    renderGroup: renderGroupProp,
    renderInput,
    renderOption: renderOptionProp,
    renderTags,
    selectOnFocus = !props.freeSolo,
    size: size2 = "medium",
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1w);
  const {
    getRootProps,
    getInputProps,
    getInputLabelProps,
    getPopupIndicatorProps,
    getClearProps,
    getTagProps,
    getListboxProps,
    getOptionProps,
    value,
    dirty,
    expanded,
    id: id2,
    popupOpen,
    focused,
    focusedTag,
    anchorEl,
    setAnchorEl,
    inputValue,
    groupedOptions
  } = useAutocomplete(_extends$4({}, props, {
    componentName: "Autocomplete"
  }));
  const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
  const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
  const {
    onMouseDown: handleInputMouseDown
  } = getInputProps();
  const {
    ref: externalListboxRef
  } = ListboxProps != null ? ListboxProps : {};
  const _getListboxProps = getListboxProps(), {
    ref: listboxRef
  } = _getListboxProps, otherListboxProps = _objectWithoutPropertiesLoose$1(_getListboxProps, _excluded2$b);
  const combinedListboxRef = useForkRef(listboxRef, externalListboxRef);
  const defaultGetOptionLabel2 = /* @__PURE__ */ __name((option) => {
    var _option$label;
    return (_option$label = option.label) != null ? _option$label : option;
  }, "defaultGetOptionLabel");
  const getOptionLabel = getOptionLabelProp || defaultGetOptionLabel2;
  const ownerState = _extends$4({}, props, {
    disablePortal,
    expanded,
    focused,
    fullWidth,
    getOptionLabel,
    hasClearIcon,
    hasPopupIcon,
    inputFocused: focusedTag === -1,
    popupOpen,
    size: size2
  });
  const classes2 = useUtilityClasses$1f(ownerState);
  let startAdornment;
  if (multiple && value.length > 0) {
    const getCustomizedTagProps = /* @__PURE__ */ __name((params) => _extends$4({
      className: classes2.tag,
      disabled
    }, getTagProps(params)), "getCustomizedTagProps");
    if (renderTags) {
      startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
    } else {
      startAdornment = value.map((option, index2) => {
        const _getCustomizedTagProp = getCustomizedTagProps({
          index: index2
        }), {
          key
        } = _getCustomizedTagProp, customTagProps = _objectWithoutPropertiesLoose$1(_getCustomizedTagProp, _excluded3$1);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, _extends$4({
          label: getOptionLabel(option),
          size: size2
        }, customTagProps, ChipProps), key);
      });
    }
  }
  if (limitTags > -1 && Array.isArray(startAdornment)) {
    const more = startAdornment.length - limitTags;
    if (!focused && more > 0) {
      startAdornment = startAdornment.splice(0, limitTags);
      startAdornment.push(/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes2.tag,
        children: getLimitTagsText(more)
      }, startAdornment.length));
    }
  }
  const defaultRenderGroup = /* @__PURE__ */ __name((params) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupLabel, {
      className: classes2.groupLabel,
      ownerState,
      component: "div",
      children: params.group
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupUl, {
      className: classes2.groupUl,
      ownerState,
      children: params.children
    })]
  }, params.key), "defaultRenderGroup");
  const renderGroup = renderGroupProp || defaultRenderGroup;
  const defaultRenderOption = /* @__PURE__ */ __name((props2, option) => {
    const {
      key
    } = props2, otherProps = _objectWithoutPropertiesLoose$1(props2, _excluded4);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("li", _extends$4({}, otherProps, {
      children: getOptionLabel(option)
    }), key);
  }, "defaultRenderOption");
  const renderOption = renderOptionProp || defaultRenderOption;
  const renderListOption = /* @__PURE__ */ __name((option, index2) => {
    const optionProps = getOptionProps({
      option,
      index: index2
    });
    return renderOption(_extends$4({}, optionProps, {
      className: classes2.option
    }), option, {
      selected: optionProps["aria-selected"],
      index: index2,
      inputValue
    }, ownerState);
  }, "renderListOption");
  const clearIndicatorSlotProps = (_slotProps$clearIndic = slotProps.clearIndicator) != null ? _slotProps$clearIndic : componentsProps.clearIndicator;
  const paperSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : componentsProps.paper;
  const popperSlotProps = (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper;
  const popupIndicatorSlotProps = (_slotProps$popupIndic = slotProps.popupIndicator) != null ? _slotProps$popupIndic : componentsProps.popupIndicator;
  const renderAutocompletePopperChildren = /* @__PURE__ */ __name((children) => /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopper, _extends$4({
    as: PopperComponent,
    disablePortal,
    style: {
      width: anchorEl ? anchorEl.clientWidth : null
    },
    ownerState,
    role: "presentation",
    anchorEl,
    open: popupOpen
  }, popperSlotProps, {
    className: clsx(classes2.popper, popperSlotProps == null ? void 0 : popperSlotProps.className),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePaper, _extends$4({
      ownerState,
      as: PaperComponent
    }, paperSlotProps, {
      className: clsx(classes2.paper, paperSlotProps == null ? void 0 : paperSlotProps.className),
      children
    }))
  })), "renderAutocompletePopperChildren");
  let autocompletePopper = null;
  if (groupedOptions.length > 0) {
    autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteListbox, _extends$4({
      as: ListboxComponent,
      className: classes2.listbox,
      ownerState
    }, otherListboxProps, ListboxProps, {
      ref: combinedListboxRef,
      children: groupedOptions.map((option, index2) => {
        if (groupBy) {
          return renderGroup({
            key: option.key,
            group: option.group,
            children: option.options.map((option2, index22) => renderListOption(option2, option.index + index22))
          });
        }
        return renderListOption(option, index2);
      })
    })));
  } else if (loading && groupedOptions.length === 0) {
    autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteLoading, {
      className: classes2.loading,
      ownerState,
      children: loadingText
    }));
  } else if (groupedOptions.length === 0 && !freeSolo && !loading) {
    autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteNoOptions, {
      className: classes2.noOptions,
      ownerState,
      role: "presentation",
      onMouseDown: (event) => {
        event.preventDefault();
      },
      children: noOptionsText
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteRoot, _extends$4({
      ref,
      className: clsx(classes2.root, className),
      ownerState
    }, getRootProps(other), {
      children: renderInput({
        id: id2,
        disabled,
        fullWidth: true,
        size: size2 === "small" ? "small" : void 0,
        InputLabelProps: getInputLabelProps(),
        InputProps: _extends$4({
          ref: setAnchorEl,
          className: classes2.inputRoot,
          startAdornment,
          onClick: (event) => {
            if (event.target === event.currentTarget) {
              handleInputMouseDown(event);
            }
          }
        }, (hasClearIcon || hasPopupIcon) && {
          endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompleteEndAdornment, {
            className: classes2.endAdornment,
            ownerState,
            children: [hasClearIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteClearIndicator, _extends$4({}, getClearProps(), {
              "aria-label": clearText,
              title: clearText,
              ownerState
            }, clearIndicatorSlotProps, {
              className: clsx(classes2.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
              children: clearIcon
            })) : null, hasPopupIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopupIndicator, _extends$4({}, getPopupIndicatorProps(), {
              disabled,
              "aria-label": popupOpen ? closeText : openText,
              title: popupOpen ? closeText : openText,
              ownerState
            }, popupIndicatorSlotProps, {
              className: clsx(classes2.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
              children: popupIcon
            })) : null]
          })
        }),
        inputProps: _extends$4({
          className: classes2.input,
          disabled,
          readOnly
        }, getInputProps())
      })
    })), anchorEl ? autocompletePopper : null]
  });
}, "Autocomplete2"));
const Person = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}), "Person");
function getAvatarUtilityClass(slot) {
  return generateUtilityClass$1("MuiAvatar", slot);
}
__name(getAvatarUtilityClass, "getAvatarUtilityClass");
generateUtilityClasses$1("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const _excluded$1v = ["alt", "children", "className", "component", "slots", "slotProps", "imgProps", "sizes", "src", "srcSet", "variant"];
const useUtilityClasses$1e = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    variant,
    colorDefault
  } = ownerState;
  const slots = {
    root: ["root", variant, colorDefault && "colorDefault"],
    img: ["img"],
    fallback: ["fallback"]
  };
  return composeClasses(slots, getAvatarUtilityClass, classes2);
}, "useUtilityClasses$1e");
const AvatarRoot = styled("div", {
  name: "MuiAvatar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.colorDefault && styles2.colorDefault];
  }
})(({
  theme: theme2
}) => ({
  position: "relative",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0,
  width: 40,
  height: 40,
  fontFamily: theme2.typography.fontFamily,
  fontSize: theme2.typography.pxToRem(20),
  lineHeight: 1,
  borderRadius: "50%",
  overflow: "hidden",
  userSelect: "none",
  variants: [{
    props: {
      variant: "rounded"
    },
    style: {
      borderRadius: (theme2.vars || theme2).shape.borderRadius
    }
  }, {
    props: {
      variant: "square"
    },
    style: {
      borderRadius: 0
    }
  }, {
    props: {
      colorDefault: true
    },
    style: _extends$4({
      color: (theme2.vars || theme2).palette.background.default
    }, theme2.vars ? {
      backgroundColor: theme2.vars.palette.Avatar.defaultBg
    } : _extends$4({
      backgroundColor: theme2.palette.grey[400]
    }, theme2.applyStyles("dark", {
      backgroundColor: theme2.palette.grey[600]
    })))
  }]
}));
const AvatarImg = styled("img", {
  name: "MuiAvatar",
  slot: "Img",
  overridesResolver: (props, styles2) => styles2.img
})({
  width: "100%",
  height: "100%",
  textAlign: "center",
  // Handle non-square image. The property isn't supported by IE11.
  objectFit: "cover",
  // Hide alt text.
  color: "transparent",
  // Hide the image broken icon, only works on Chrome.
  textIndent: 1e4
});
const AvatarFallback = styled(Person, {
  name: "MuiAvatar",
  slot: "Fallback",
  overridesResolver: (props, styles2) => styles2.fallback
})({
  width: "75%",
  height: "75%"
});
function useLoaded({
  crossOrigin,
  referrerPolicy,
  src: src2,
  srcSet
}) {
  const [loaded, setLoaded] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!src2 && !srcSet) {
      return void 0;
    }
    setLoaded(false);
    let active = true;
    const image = new Image();
    image.onload = () => {
      if (!active) {
        return;
      }
      setLoaded("loaded");
    };
    image.onerror = () => {
      if (!active) {
        return;
      }
      setLoaded("error");
    };
    image.crossOrigin = crossOrigin;
    image.referrerPolicy = referrerPolicy;
    image.src = src2;
    if (srcSet) {
      image.srcset = srcSet;
    }
    return () => {
      active = false;
    };
  }, [crossOrigin, referrerPolicy, src2, srcSet]);
  return loaded;
}
__name(useLoaded, "useLoaded");
const Avatar = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Avatar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAvatar"
  });
  const {
    alt,
    children: childrenProp,
    className,
    component = "div",
    slots = {},
    slotProps = {},
    imgProps,
    sizes,
    src: src2,
    srcSet,
    variant = "circular"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1v);
  let children = null;
  const loaded = useLoaded(_extends$4({}, imgProps, {
    src: src2,
    srcSet
  }));
  const hasImg = src2 || srcSet;
  const hasImgNotFailing = hasImg && loaded !== "error";
  const ownerState = _extends$4({}, props, {
    colorDefault: !hasImgNotFailing,
    component,
    variant
  });
  const classes2 = useUtilityClasses$1e(ownerState);
  const [ImgSlot, imgSlotProps] = useSlot("img", {
    className: classes2.img,
    elementType: AvatarImg,
    externalForwardedProps: {
      slots,
      slotProps: {
        img: _extends$4({}, imgProps, slotProps.img)
      }
    },
    additionalProps: {
      alt,
      src: src2,
      srcSet,
      sizes
    },
    ownerState
  });
  if (hasImgNotFailing) {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(ImgSlot, _extends$4({}, imgSlotProps));
  } else if (!!childrenProp || childrenProp === 0) {
    children = childrenProp;
  } else if (hasImg && alt) {
    children = alt[0];
  } else {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallback, {
      ownerState,
      className: classes2.fallback
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarRoot, _extends$4({
    as: component,
    ownerState,
    className: clsx(classes2.root, className),
    ref
  }, other, {
    children
  }));
}, "Avatar2"));
function useBadge(parameters) {
  const {
    badgeContent: badgeContentProp,
    invisible: invisibleProp = false,
    max: maxProp = 99,
    showZero = false
  } = parameters;
  const prevProps = usePreviousProps({
    badgeContent: badgeContentProp,
    max: maxProp
  });
  let invisible = invisibleProp;
  if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
    invisible = true;
  }
  const {
    badgeContent,
    max: max2 = maxProp
  } = invisible ? prevProps : parameters;
  const displayValue = badgeContent && Number(badgeContent) > max2 ? `${max2}+` : badgeContent;
  return {
    badgeContent,
    invisible,
    max: max2,
    displayValue
  };
}
__name(useBadge, "useBadge");
function getBadgeUtilityClass(slot) {
  return generateUtilityClass$1("MuiBadge", slot);
}
__name(getBadgeUtilityClass, "getBadgeUtilityClass");
const badgeClasses = generateUtilityClasses$1("MuiBadge", [
  "root",
  "badge",
  "dot",
  "standard",
  "anchorOriginTopRight",
  "anchorOriginBottomRight",
  "anchorOriginTopLeft",
  "anchorOriginBottomLeft",
  "invisible",
  "colorError",
  "colorInfo",
  "colorPrimary",
  "colorSecondary",
  "colorSuccess",
  "colorWarning",
  "overlapRectangular",
  "overlapCircular",
  // TODO: v6 remove the overlap value from these class keys
  "anchorOriginTopLeftCircular",
  "anchorOriginTopLeftRectangular",
  "anchorOriginTopRightCircular",
  "anchorOriginTopRightRectangular",
  "anchorOriginBottomLeftCircular",
  "anchorOriginBottomLeftRectangular",
  "anchorOriginBottomRightCircular",
  "anchorOriginBottomRightRectangular"
]);
const _excluded$1u = ["anchorOrigin", "className", "classes", "component", "components", "componentsProps", "children", "overlap", "color", "invisible", "max", "badgeContent", "slots", "slotProps", "showZero", "variant"];
const RADIUS_STANDARD = 10;
const RADIUS_DOT = 4;
const useUtilityClasses$1d = /* @__PURE__ */ __name((ownerState) => {
  const {
    color: color2,
    anchorOrigin,
    invisible,
    overlap,
    variant,
    classes: classes2 = {}
  } = ownerState;
  const slots = {
    root: ["root"],
    badge: ["badge", variant, invisible && "invisible", `anchorOrigin${capitalize$1(anchorOrigin.vertical)}${capitalize$1(anchorOrigin.horizontal)}`, `anchorOrigin${capitalize$1(anchorOrigin.vertical)}${capitalize$1(anchorOrigin.horizontal)}${capitalize$1(overlap)}`, `overlap${capitalize$1(overlap)}`, color2 !== "default" && `color${capitalize$1(color2)}`]
  };
  return composeClasses(slots, getBadgeUtilityClass, classes2);
}, "useUtilityClasses$1d");
const BadgeRoot = styled("span", {
  name: "MuiBadge",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  position: "relative",
  display: "inline-flex",
  // For correct alignment with the text.
  verticalAlign: "middle",
  flexShrink: 0
});
const BadgeBadge = styled("span", {
  name: "MuiBadge",
  slot: "Badge",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.badge, styles2[ownerState.variant], styles2[`anchorOrigin${capitalize$1(ownerState.anchorOrigin.vertical)}${capitalize$1(ownerState.anchorOrigin.horizontal)}${capitalize$1(ownerState.overlap)}`], ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.invisible && styles2.invisible];
  }
})(({
  theme: theme2
}) => {
  var _theme$vars;
  return {
    display: "flex",
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    alignContent: "center",
    alignItems: "center",
    position: "absolute",
    boxSizing: "border-box",
    fontFamily: theme2.typography.fontFamily,
    fontWeight: theme2.typography.fontWeightMedium,
    fontSize: theme2.typography.pxToRem(12),
    minWidth: RADIUS_STANDARD * 2,
    lineHeight: 1,
    padding: "0 6px",
    height: RADIUS_STANDARD * 2,
    borderRadius: RADIUS_STANDARD,
    zIndex: 1,
    // Render the badge on top of potential ripples.
    transition: theme2.transitions.create("transform", {
      easing: theme2.transitions.easing.easeInOut,
      duration: theme2.transitions.duration.enteringScreen
    }),
    variants: [...Object.keys(((_theme$vars = theme2.vars) != null ? _theme$vars : theme2).palette).filter((key) => {
      var _theme$vars2, _theme$vars3;
      return ((_theme$vars2 = theme2.vars) != null ? _theme$vars2 : theme2).palette[key].main && ((_theme$vars3 = theme2.vars) != null ? _theme$vars3 : theme2).palette[key].contrastText;
    }).map((color2) => ({
      props: {
        color: color2
      },
      style: {
        backgroundColor: (theme2.vars || theme2).palette[color2].main,
        color: (theme2.vars || theme2).palette[color2].contrastText
      }
    })), {
      props: {
        variant: "dot"
      },
      style: {
        borderRadius: RADIUS_DOT,
        height: RADIUS_DOT * 2,
        minWidth: RADIUS_DOT * 2,
        padding: 0
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
      style: {
        top: 0,
        right: 0,
        transform: "scale(1) translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&.${badgeClasses.invisible}`]: {
          transform: "scale(0) translate(50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
      style: {
        bottom: 0,
        right: 0,
        transform: "scale(1) translate(50%, 50%)",
        transformOrigin: "100% 100%",
        [`&.${badgeClasses.invisible}`]: {
          transform: "scale(0) translate(50%, 50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
      style: {
        top: 0,
        left: 0,
        transform: "scale(1) translate(-50%, -50%)",
        transformOrigin: "0% 0%",
        [`&.${badgeClasses.invisible}`]: {
          transform: "scale(0) translate(-50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
      style: {
        bottom: 0,
        left: 0,
        transform: "scale(1) translate(-50%, 50%)",
        transformOrigin: "0% 100%",
        [`&.${badgeClasses.invisible}`]: {
          transform: "scale(0) translate(-50%, 50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
      style: {
        top: "14%",
        right: "14%",
        transform: "scale(1) translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&.${badgeClasses.invisible}`]: {
          transform: "scale(0) translate(50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
      style: {
        bottom: "14%",
        right: "14%",
        transform: "scale(1) translate(50%, 50%)",
        transformOrigin: "100% 100%",
        [`&.${badgeClasses.invisible}`]: {
          transform: "scale(0) translate(50%, 50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
      style: {
        top: "14%",
        left: "14%",
        transform: "scale(1) translate(-50%, -50%)",
        transformOrigin: "0% 0%",
        [`&.${badgeClasses.invisible}`]: {
          transform: "scale(0) translate(-50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
      style: {
        bottom: "14%",
        left: "14%",
        transform: "scale(1) translate(-50%, 50%)",
        transformOrigin: "0% 100%",
        [`&.${badgeClasses.invisible}`]: {
          transform: "scale(0) translate(-50%, 50%)"
        }
      }
    }, {
      props: {
        invisible: true
      },
      style: {
        transition: theme2.transitions.create("transform", {
          easing: theme2.transitions.easing.easeInOut,
          duration: theme2.transitions.duration.leavingScreen
        })
      }
    }]
  };
});
const Badge = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Badge2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$badge, _slotProps$root, _slotProps$badge;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBadge"
  });
  const {
    anchorOrigin: anchorOriginProp = {
      vertical: "top",
      horizontal: "right"
    },
    className,
    component,
    components = {},
    componentsProps = {},
    children,
    overlap: overlapProp = "rectangular",
    color: colorProp = "default",
    invisible: invisibleProp = false,
    max: maxProp = 99,
    badgeContent: badgeContentProp,
    slots,
    slotProps,
    showZero = false,
    variant: variantProp = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1u);
  const {
    badgeContent,
    invisible: invisibleFromHook,
    max: max2,
    displayValue: displayValueFromHook
  } = useBadge({
    max: maxProp,
    invisible: invisibleProp,
    badgeContent: badgeContentProp,
    showZero
  });
  const prevProps = usePreviousProps({
    anchorOrigin: anchorOriginProp,
    color: colorProp,
    overlap: overlapProp,
    variant: variantProp,
    badgeContent: badgeContentProp
  });
  const invisible = invisibleFromHook || badgeContent == null && variantProp !== "dot";
  const {
    color: color2 = colorProp,
    overlap = overlapProp,
    anchorOrigin = anchorOriginProp,
    variant = variantProp
  } = invisible ? prevProps : props;
  const displayValue = variant !== "dot" ? displayValueFromHook : void 0;
  const ownerState = _extends$4({}, props, {
    badgeContent,
    invisible,
    max: max2,
    displayValue,
    showZero,
    anchorOrigin,
    color: color2,
    overlap,
    variant
  });
  const classes2 = useUtilityClasses$1d(ownerState);
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : BadgeRoot;
  const BadgeSlot = (_ref2 = (_slots$badge = slots == null ? void 0 : slots.badge) != null ? _slots$badge : components.Badge) != null ? _ref2 : BadgeBadge;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const badgeSlotProps = (_slotProps$badge = slotProps == null ? void 0 : slotProps.badge) != null ? _slotProps$badge : componentsProps.badge;
  const rootProps = useSlotProps$1({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: {
      ref,
      as: component
    },
    ownerState,
    className: clsx(rootSlotProps == null ? void 0 : rootSlotProps.className, classes2.root, className)
  });
  const badgeProps = useSlotProps$1({
    elementType: BadgeSlot,
    externalSlotProps: badgeSlotProps,
    ownerState,
    className: clsx(classes2.badge, badgeSlotProps == null ? void 0 : badgeSlotProps.className)
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$4({}, rootProps, {
    children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(BadgeSlot, _extends$4({}, badgeProps, {
      children: displayValue
    }))]
  }));
}, "Badge2"));
function getButtonUtilityClass(slot) {
  return generateUtilityClass$1("MuiButton", slot);
}
__name(getButtonUtilityClass, "getButtonUtilityClass");
const buttonClasses = generateUtilityClasses$1("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
const _excluded$1t = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
const useUtilityClasses$1c = /* @__PURE__ */ __name((ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size: size2,
    variant,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", variant, `${variant}${capitalize$1(color2)}`, `size${capitalize$1(size2)}`, `${variant}Size${capitalize$1(size2)}`, `color${capitalize$1(color2)}`, disableElevation && "disableElevation", fullWidth && "fullWidth"],
    label: ["label"],
    startIcon: ["icon", "startIcon", `iconSize${capitalize$1(size2)}`],
    endIcon: ["icon", "endIcon", `iconSize${capitalize$1(size2)}`]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$1c");
const commonIconStyles = /* @__PURE__ */ __name((ownerState) => _extends$4({}, ownerState.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, ownerState.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, ownerState.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
}), "commonIconStyles");
const ButtonRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize$1(ownerState.color)}`], styles2[`size${capitalize$1(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize$1(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  const inheritContainedBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey[300] : theme2.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey.A100 : theme2.palette.grey[700];
  return _extends$4({}, theme2.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme2.transitions.duration.short
    }),
    "&:hover": _extends$4({
      textDecoration: "none",
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.text.primaryChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha_1(theme2.palette.text.primary, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha_1(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
      border: `1px solid ${(theme2.vars || theme2).palette[ownerState.color].main}`,
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha_1(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "contained" && {
      backgroundColor: theme2.vars ? theme2.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
      boxShadow: (theme2.vars || theme2).shadows[4],
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        boxShadow: (theme2.vars || theme2).shadows[2],
        backgroundColor: (theme2.vars || theme2).palette.grey[300]
      }
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      backgroundColor: (theme2.vars || theme2).palette[ownerState.color].dark,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main
      }
    }),
    "&:active": _extends$4({}, ownerState.variant === "contained" && {
      boxShadow: (theme2.vars || theme2).shadows[8]
    }),
    [`&.${buttonClasses.focusVisible}`]: _extends$4({}, ownerState.variant === "contained" && {
      boxShadow: (theme2.vars || theme2).shadows[6]
    }),
    [`&.${buttonClasses.disabled}`]: _extends$4({
      color: (theme2.vars || theme2).palette.action.disabled
    }, ownerState.variant === "outlined" && {
      border: `1px solid ${(theme2.vars || theme2).palette.action.disabledBackground}`
    }, ownerState.variant === "contained" && {
      color: (theme2.vars || theme2).palette.action.disabled,
      boxShadow: (theme2.vars || theme2).shadows[0],
      backgroundColor: (theme2.vars || theme2).palette.action.disabledBackground
    })
  }, ownerState.variant === "text" && {
    padding: "6px 8px"
  }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  }, ownerState.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].main,
    border: theme2.vars ? `1px solid rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha_1(theme2.palette[ownerState.color].main, 0.5)}`
  }, ownerState.variant === "contained" && {
    color: theme2.vars ? (
      // this is safe because grey does not change between default light/dark mode
      theme2.vars.palette.text.primary
    ) : (_theme$palette$getCon = (_theme$palette = theme2.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme2.palette.grey[300]),
    backgroundColor: theme2.vars ? theme2.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
    boxShadow: (theme2.vars || theme2).shadows[2]
  }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].contrastText,
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main
  }, ownerState.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, ownerState.size === "small" && ownerState.variant === "text" && {
    padding: "4px 5px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "text" && {
    padding: "8px 11px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "contained" && {
    padding: "4px 10px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "contained" && {
    padding: "8px 22px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState
}) => ownerState.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${buttonClasses.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${buttonClasses.disabled}`]: {
    boxShadow: "none"
  }
});
const ButtonStartIcon = styled("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, styles2[`iconSize${capitalize$1(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$4({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, ownerState.size === "small" && {
  marginLeft: -2
}, commonIconStyles(ownerState)));
const ButtonEndIcon = styled("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, styles2[`iconSize${capitalize$1(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$4({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, ownerState.size === "small" && {
  marginRight: -2
}, commonIconStyles(ownerState)));
const Button = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Button2(inProps, ref) {
  const contextProps = reactExports.useContext(ButtonGroupContext);
  const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useDefaultProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    size: size2 = "medium",
    startIcon: startIconProp,
    type,
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1t);
  const ownerState = _extends$4({}, props, {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    size: size2,
    type,
    variant
  });
  const classes2 = useUtilityClasses$1c(ownerState);
  const startIcon = startIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes2.startIcon,
    ownerState,
    children: startIconProp
  });
  const endIcon = endIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes2.endIcon,
    ownerState,
    children: endIconProp
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, _extends$4({
    ownerState,
    className: clsx(contextProps.className, classes2.root, className, positionClassName),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes2.focusVisible, focusVisibleClassName),
    ref,
    type
  }, other, {
    classes: classes2,
    children: [startIcon, children, endIcon]
  }));
}, "Button2"));
function getCardUtilityClass(slot) {
  return generateUtilityClass$1("MuiCard", slot);
}
__name(getCardUtilityClass, "getCardUtilityClass");
generateUtilityClasses$1("MuiCard", ["root"]);
const _excluded$1s = ["className", "raised"];
const useUtilityClasses$1b = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardUtilityClass, classes2);
}, "useUtilityClasses$1b");
const CardRoot = styled(Paper, {
  name: "MuiCard",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(() => {
  return {
    overflow: "hidden"
  };
});
const Card = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Card2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCard"
  });
  const {
    className,
    raised = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1s);
  const ownerState = _extends$4({}, props, {
    raised
  });
  const classes2 = useUtilityClasses$1b(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardRoot, _extends$4({
    className: clsx(classes2.root, className),
    elevation: raised ? 8 : void 0,
    ref,
    ownerState
  }, other));
}, "Card2"));
function getCardActionAreaUtilityClass(slot) {
  return generateUtilityClass$1("MuiCardActionArea", slot);
}
__name(getCardActionAreaUtilityClass, "getCardActionAreaUtilityClass");
const cardActionAreaClasses = generateUtilityClasses$1("MuiCardActionArea", ["root", "focusVisible", "focusHighlight"]);
const _excluded$1r = ["children", "className", "focusVisibleClassName"];
const useUtilityClasses$1a = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    focusHighlight: ["focusHighlight"]
  };
  return composeClasses(slots, getCardActionAreaUtilityClass, classes2);
}, "useUtilityClasses$1a");
const CardActionAreaRoot = styled(ButtonBase, {
  name: "MuiCardActionArea",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => ({
  display: "block",
  textAlign: "inherit",
  borderRadius: "inherit",
  // for Safari to work https://github.com/mui/material-ui/issues/36285.
  width: "100%",
  [`&:hover .${cardActionAreaClasses.focusHighlight}`]: {
    opacity: (theme2.vars || theme2).palette.action.hoverOpacity,
    "@media (hover: none)": {
      opacity: 0
    }
  },
  [`&.${cardActionAreaClasses.focusVisible} .${cardActionAreaClasses.focusHighlight}`]: {
    opacity: (theme2.vars || theme2).palette.action.focusOpacity
  }
}));
const CardActionAreaFocusHighlight = styled("span", {
  name: "MuiCardActionArea",
  slot: "FocusHighlight",
  overridesResolver: (props, styles2) => styles2.focusHighlight
})(({
  theme: theme2
}) => ({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit",
  opacity: 0,
  backgroundColor: "currentcolor",
  transition: theme2.transitions.create("opacity", {
    duration: theme2.transitions.duration.short
  })
}));
const CardActionArea = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function CardActionArea2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCardActionArea"
  });
  const {
    children,
    className,
    focusVisibleClassName
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1r);
  const ownerState = props;
  const classes2 = useUtilityClasses$1a(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(CardActionAreaRoot, _extends$4({
    className: clsx(classes2.root, className),
    focusVisibleClassName: clsx(focusVisibleClassName, classes2.focusVisible),
    ref,
    ownerState
  }, other, {
    children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(CardActionAreaFocusHighlight, {
      className: classes2.focusHighlight,
      ownerState
    })]
  }));
}, "CardActionArea2"));
function getCardContentUtilityClass(slot) {
  return generateUtilityClass$1("MuiCardContent", slot);
}
__name(getCardContentUtilityClass, "getCardContentUtilityClass");
generateUtilityClasses$1("MuiCardContent", ["root"]);
const _excluded$1q = ["className", "component"];
const useUtilityClasses$19 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardContentUtilityClass, classes2);
}, "useUtilityClasses$19");
const CardContentRoot = styled("div", {
  name: "MuiCardContent",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(() => {
  return {
    padding: 16,
    "&:last-child": {
      paddingBottom: 24
    }
  };
});
const CardContent = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function CardContent2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCardContent"
  });
  const {
    className,
    component = "div"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1q);
  const ownerState = _extends$4({}, props, {
    component
  });
  const classes2 = useUtilityClasses$19(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardContentRoot, _extends$4({
    as: component,
    className: clsx(classes2.root, className),
    ownerState,
    ref
  }, other));
}, "CardContent2"));
function getCardMediaUtilityClass(slot) {
  return generateUtilityClass$1("MuiCardMedia", slot);
}
__name(getCardMediaUtilityClass, "getCardMediaUtilityClass");
generateUtilityClasses$1("MuiCardMedia", ["root", "media", "img"]);
const _excluded$1p = ["children", "className", "component", "image", "src", "style"];
const useUtilityClasses$18 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    isMediaComponent,
    isImageComponent
  } = ownerState;
  const slots = {
    root: ["root", isMediaComponent && "media", isImageComponent && "img"]
  };
  return composeClasses(slots, getCardMediaUtilityClass, classes2);
}, "useUtilityClasses$18");
const CardMediaRoot = styled("div", {
  name: "MuiCardMedia",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      isMediaComponent,
      isImageComponent
    } = ownerState;
    return [styles2.root, isMediaComponent && styles2.media, isImageComponent && styles2.img];
  }
})(({
  ownerState
}) => _extends$4({
  display: "block",
  backgroundSize: "cover",
  backgroundRepeat: "no-repeat",
  backgroundPosition: "center"
}, ownerState.isMediaComponent && {
  width: "100%"
}, ownerState.isImageComponent && {
  //  object-fit is not supported by IE11.
  objectFit: "cover"
}));
const MEDIA_COMPONENTS = ["video", "audio", "picture", "iframe", "img"];
const IMAGE_COMPONENTS = ["picture", "img"];
const CardMedia = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function CardMedia2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCardMedia"
  });
  const {
    children,
    className,
    component = "div",
    image,
    src: src2,
    style: style2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1p);
  const isMediaComponent = MEDIA_COMPONENTS.indexOf(component) !== -1;
  const composedStyle = !isMediaComponent && image ? _extends$4({
    backgroundImage: `url("${image}")`
  }, style2) : style2;
  const ownerState = _extends$4({}, props, {
    component,
    isMediaComponent,
    isImageComponent: IMAGE_COMPONENTS.indexOf(component) !== -1
  });
  const classes2 = useUtilityClasses$18(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardMediaRoot, _extends$4({
    className: clsx(classes2.root, className),
    as: component,
    role: !isMediaComponent && image ? "img" : void 0,
    ref,
    style: composedStyle,
    ownerState,
    src: isMediaComponent ? image || src2 : void 0
  }, other, {
    children
  }));
}, "CardMedia2"));
const CheckBoxOutlineBlankIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "CheckBoxOutlineBlank");
const CheckBoxIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckBox");
const IndeterminateCheckBoxIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}), "IndeterminateCheckBox");
function getCheckboxUtilityClass(slot) {
  return generateUtilityClass$1("MuiCheckbox", slot);
}
__name(getCheckboxUtilityClass, "getCheckboxUtilityClass");
const checkboxClasses = generateUtilityClasses$1("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]);
const _excluded$1o = ["checkedIcon", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size", "className"];
const useUtilityClasses$17 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    indeterminate,
    color: color2,
    size: size2
  } = ownerState;
  const slots = {
    root: ["root", indeterminate && "indeterminate", `color${capitalize$1(color2)}`, `size${capitalize$1(size2)}`]
  };
  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$17");
const CheckboxRoot = styled(SwitchBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.indeterminate && styles2.indeterminate, styles2[`size${capitalize$1(ownerState.size)}`], ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  color: (theme2.vars || theme2).palette.text.secondary
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${ownerState.color === "default" ? theme2.vars.palette.action.activeChannel : theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha_1(ownerState.color === "default" ? theme2.palette.action.active : theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.color !== "default" && {
  [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  },
  [`&.${checkboxClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  }
}));
const defaultCheckedIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxIcon, {});
const defaultIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {});
const defaultIndeterminateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {});
const Checkbox = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Checkbox2(inProps, ref) {
  var _icon$props$fontSize, _indeterminateIcon$pr;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCheckbox"
  });
  const {
    checkedIcon = defaultCheckedIcon,
    color: color2 = "primary",
    icon: iconProp = defaultIcon,
    indeterminate = false,
    indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,
    inputProps,
    size: size2 = "medium",
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1o);
  const icon = indeterminate ? indeterminateIconProp : iconProp;
  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
  const ownerState = _extends$4({}, props, {
    color: color2,
    indeterminate,
    size: size2
  });
  const classes2 = useUtilityClasses$17(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxRoot, _extends$4({
    type: "checkbox",
    inputProps: _extends$4({
      "data-indeterminate": indeterminate
    }, inputProps),
    icon: /* @__PURE__ */ reactExports.cloneElement(icon, {
      fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size2
    }),
    checkedIcon: /* @__PURE__ */ reactExports.cloneElement(indeterminateIcon, {
      fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size2
    }),
    ownerState,
    ref,
    className: clsx(classes2.root, className)
  }, other, {
    classes: classes2
  }));
}, "Checkbox2"));
function getCircularProgressUtilityClass(slot) {
  return generateUtilityClass$1("MuiCircularProgress", slot);
}
__name(getCircularProgressUtilityClass, "getCircularProgressUtilityClass");
generateUtilityClasses$1("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const _excluded$1n = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
let _$2 = /* @__PURE__ */ __name((t2) => t2, "_$2"), _t$2, _t2$2, _t3$2, _t4$2;
const SIZE = 44;
const circularRotateKeyframe = keyframes$1(_t$2 || (_t$2 = _$2`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`));
const circularDashKeyframe = keyframes$1(_t2$2 || (_t2$2 = _$2`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`));
const useUtilityClasses$16 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    variant,
    color: color2,
    disableShrink
  } = ownerState;
  const slots = {
    root: ["root", variant, `color${capitalize$1(color2)}`],
    svg: ["svg"],
    circle: ["circle", `circle${capitalize$1(variant)}`, disableShrink && "circleDisableShrink"]
  };
  return composeClasses(slots, getCircularProgressUtilityClass, classes2);
}, "useUtilityClasses$16");
const CircularProgressRoot = styled("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$4({
  display: "inline-block"
}, ownerState.variant === "determinate" && {
  transition: theme2.transitions.create("transform")
}, ownerState.color !== "inherit" && {
  color: (theme2.vars || theme2).palette[ownerState.color].main
}), ({
  ownerState
}) => ownerState.variant === "indeterminate" && css(_t3$2 || (_t3$2 = _$2`
      animation: ${0} 1.4s linear infinite;
    `), circularRotateKeyframe));
const CircularProgressSVG = styled("svg", {
  name: "MuiCircularProgress",
  slot: "Svg",
  overridesResolver: (props, styles2) => styles2.svg
})({
  display: "block"
  // Keeps the progress centered
});
const CircularProgressCircle = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.circle, styles2[`circle${capitalize$1(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$4({
  stroke: "currentColor"
}, ownerState.variant === "determinate" && {
  transition: theme2.transitions.create("stroke-dashoffset")
}, ownerState.variant === "indeterminate" && {
  // Some default value that looks fine waiting for the animation to kicks in.
  strokeDasharray: "80px, 200px",
  strokeDashoffset: 0
  // Add the unit to fix a Edge 16 and below bug.
}), ({
  ownerState
}) => ownerState.variant === "indeterminate" && !ownerState.disableShrink && css(_t4$2 || (_t4$2 = _$2`
      animation: ${0} 1.4s ease-in-out infinite;
    `), circularDashKeyframe));
const CircularProgress = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function CircularProgress2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCircularProgress"
  });
  const {
    className,
    color: color2 = "primary",
    disableShrink = false,
    size: size2 = 40,
    style: style2,
    thickness = 3.6,
    value = 0,
    variant = "indeterminate"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1n);
  const ownerState = _extends$4({}, props, {
    color: color2,
    disableShrink,
    size: size2,
    thickness,
    value,
    variant
  });
  const classes2 = useUtilityClasses$16(ownerState);
  const circleStyle = {};
  const rootStyle = {};
  const rootProps = {};
  if (variant === "determinate") {
    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
    rootStyle.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, _extends$4({
    className: clsx(classes2.root, className),
    style: _extends$4({
      width: size2,
      height: size2
    }, rootStyle, style2),
    ownerState,
    ref,
    role: "progressbar"
  }, rootProps, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
      className: classes2.svg,
      ownerState,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
        className: classes2.circle,
        style: circleStyle,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })
    })
  }));
}, "CircularProgress2"));
function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}
__name(mapEventPropToEvent, "mapEventPropToEvent");
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
__name(clickedRootScrollbar, "clickedRootScrollbar");
function ClickAwayListener(props) {
  const {
    children,
    disableReactTree = false,
    mouseEvent = "onClick",
    onClickAway,
    touchEvent = "onTouchEnd"
  } = props;
  const movedRef = reactExports.useRef(false);
  const nodeRef = reactExports.useRef(null);
  const activatedRef = reactExports.useRef(false);
  const syntheticEventRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    setTimeout(() => {
      activatedRef.current = true;
    }, 0);
    return () => {
      activatedRef.current = false;
    };
  }, []);
  const handleRef = useForkRef(
    // @ts-expect-error TODO upstream fix
    children.ref,
    nodeRef
  );
  const handleClickAway = useEventCallback((event) => {
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
    } else {
      insideDOM = !doc.documentElement.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      ) || nodeRef.current.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      );
    }
    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  });
  const createHandleSynthetic = /* @__PURE__ */ __name((handlerName) => (event) => {
    syntheticEventRef.current = true;
    const childrenPropsHandler = children.props[handlerName];
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  }, "createHandleSynthetic");
  const childrenProps = {
    ref: handleRef
  };
  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }
  reactExports.useEffect(() => {
    if (touchEvent !== false) {
      const mappedTouchEvent = mapEventPropToEvent(touchEvent);
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = /* @__PURE__ */ __name(() => {
        movedRef.current = true;
      }, "handleTouchMove");
      doc.addEventListener(mappedTouchEvent, handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener(mappedTouchEvent, handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [handleClickAway, touchEvent]);
  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }
  reactExports.useEffect(() => {
    if (mouseEvent !== false) {
      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener(mappedMouseEvent, handleClickAway);
      return () => {
        doc.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }
    return void 0;
  }, [handleClickAway, mouseEvent]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(children, childrenProps)
  });
}
__name(ClickAwayListener, "ClickAwayListener");
const Container = createContainer({
  createStyledComponent: styled("div", {
    name: "MuiContainer",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[`maxWidth${capitalize$1(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
    }
  }),
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiContainer"
  })
});
const html = /* @__PURE__ */ __name((theme2, enableColorScheme) => _extends$4({
  WebkitFontSmoothing: "antialiased",
  // Antialiasing.
  MozOsxFontSmoothing: "grayscale",
  // Antialiasing.
  // Change from `box-sizing: content-box` so that `width`
  // is not affected by `padding` or `border`.
  boxSizing: "border-box",
  // Fix font resize problem in iOS
  WebkitTextSizeAdjust: "100%"
}, enableColorScheme && !theme2.vars && {
  colorScheme: theme2.palette.mode
}), "html");
const body = /* @__PURE__ */ __name((theme2) => _extends$4({
  color: (theme2.vars || theme2).palette.text.primary
}, theme2.typography.body1, {
  backgroundColor: (theme2.vars || theme2).palette.background.default,
  "@media print": {
    // Save printer ink.
    backgroundColor: (theme2.vars || theme2).palette.common.white
  }
}), "body");
const styles$b = /* @__PURE__ */ __name((theme2, enableColorScheme = false) => {
  var _theme$components;
  const colorSchemeStyles = {};
  if (enableColorScheme && theme2.colorSchemes) {
    Object.entries(theme2.colorSchemes).forEach(([key, scheme]) => {
      var _scheme$palette;
      colorSchemeStyles[theme2.getColorSchemeSelector(key).replace(/\s*&/, "")] = {
        colorScheme: (_scheme$palette = scheme.palette) == null ? void 0 : _scheme$palette.mode
      };
    });
  }
  let defaultStyles = _extends$4({
    html: html(theme2, enableColorScheme),
    "*, *::before, *::after": {
      boxSizing: "inherit"
    },
    "strong, b": {
      fontWeight: theme2.typography.fontWeightBold
    },
    body: _extends$4({
      margin: 0
    }, body(theme2), {
      // Add support for document.body.requestFullScreen().
      // Other elements, if background transparent, are not supported.
      "&::backdrop": {
        backgroundColor: (theme2.vars || theme2).palette.background.default
      }
    })
  }, colorSchemeStyles);
  const themeOverrides = (_theme$components = theme2.components) == null || (_theme$components = _theme$components.MuiCssBaseline) == null ? void 0 : _theme$components.styleOverrides;
  if (themeOverrides) {
    defaultStyles = [defaultStyles, themeOverrides];
  }
  return defaultStyles;
}, "styles$b");
function CssBaseline(inProps) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCssBaseline"
  });
  const {
    children,
    enableColorScheme = false
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
      styles: (theme2) => styles$b(theme2, enableColorScheme)
    }), children]
  });
}
__name(CssBaseline, "CssBaseline");
function getDialogUtilityClass(slot) {
  return generateUtilityClass$1("MuiDialog", slot);
}
__name(getDialogUtilityClass, "getDialogUtilityClass");
const dialogClasses = generateUtilityClasses$1("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
const DialogContext = /* @__PURE__ */ reactExports.createContext({});
const _excluded$1m = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"];
const DialogBackdrop = styled(Backdrop$2, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (props, styles2) => styles2.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
});
const useUtilityClasses$15 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    scroll,
    maxWidth: maxWidth2,
    fullWidth,
    fullScreen
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container", `scroll${capitalize$1(scroll)}`],
    paper: ["paper", `paperScroll${capitalize$1(scroll)}`, `paperWidth${capitalize$1(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
  };
  return composeClasses(slots, getDialogUtilityClass, classes2);
}, "useUtilityClasses$15");
const DialogRoot = styled(Modal$3, {
  name: "MuiDialog",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
});
const DialogContainer = styled("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.container, styles2[`scroll${capitalize$1(ownerState.scroll)}`]];
  }
})(({
  ownerState
}) => _extends$4({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}, ownerState.scroll === "paper" && {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}, ownerState.scroll === "body" && {
  overflowY: "auto",
  overflowX: "hidden",
  textAlign: "center",
  "&::after": {
    content: '""',
    display: "inline-block",
    verticalAlign: "middle",
    height: "100%",
    width: "0"
  }
}));
const DialogPaper = styled(Paper, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.paper, styles2[`scrollPaper${capitalize$1(ownerState.scroll)}`], styles2[`paperWidth${capitalize$1(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  // Fix IE11 issue, to remove at some point.
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  }
}, ownerState.scroll === "paper" && {
  display: "flex",
  flexDirection: "column",
  maxHeight: "calc(100% - 64px)"
}, ownerState.scroll === "body" && {
  display: "inline-block",
  verticalAlign: "middle",
  textAlign: "left"
  // 'initial' doesn't work on IE11
}, !ownerState.maxWidth && {
  maxWidth: "calc(100% - 64px)"
}, ownerState.maxWidth === "xs" && {
  maxWidth: theme2.breakpoints.unit === "px" ? Math.max(theme2.breakpoints.values.xs, 444) : `max(${theme2.breakpoints.values.xs}${theme2.breakpoints.unit}, 444px)`,
  [`&.${dialogClasses.paperScrollBody}`]: {
    [theme2.breakpoints.down(Math.max(theme2.breakpoints.values.xs, 444) + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
  maxWidth: `${theme2.breakpoints.values[ownerState.maxWidth]}${theme2.breakpoints.unit}`,
  [`&.${dialogClasses.paperScrollBody}`]: {
    [theme2.breakpoints.down(theme2.breakpoints.values[ownerState.maxWidth] + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.fullWidth && {
  width: "calc(100% - 64px)"
}, ownerState.fullScreen && {
  margin: 0,
  width: "100%",
  maxWidth: "100%",
  height: "100%",
  maxHeight: "none",
  borderRadius: 0,
  [`&.${dialogClasses.paperScrollBody}`]: {
    margin: 0,
    maxWidth: "100%"
  }
}));
const Dialog = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Dialog2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialog"
  });
  const theme2 = useTheme$1();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledbyProp,
    BackdropComponent,
    BackdropProps,
    children,
    className,
    disableEscapeKeyDown = false,
    fullScreen = false,
    fullWidth = false,
    maxWidth: maxWidth2 = "sm",
    onBackdropClick,
    onClick,
    onClose,
    open: open2,
    PaperComponent = Paper,
    PaperProps = {},
    scroll = "paper",
    TransitionComponent = Fade,
    transitionDuration = defaultTransitionDuration,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1m);
  const ownerState = _extends$4({}, props, {
    disableEscapeKeyDown,
    fullScreen,
    fullWidth,
    maxWidth: maxWidth2,
    scroll
  });
  const classes2 = useUtilityClasses$15(ownerState);
  const backdropClick = reactExports.useRef();
  const handleMouseDown = /* @__PURE__ */ __name((event) => {
    backdropClick.current = event.target === event.currentTarget;
  }, "handleMouseDown");
  const handleBackdropClick = /* @__PURE__ */ __name((event) => {
    if (onClick) {
      onClick(event);
    }
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  }, "handleBackdropClick");
  const ariaLabelledby = useId(ariaLabelledbyProp);
  const dialogContextValue = reactExports.useMemo(() => {
    return {
      titleId: ariaLabelledby
    };
  }, [ariaLabelledby]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogRoot, _extends$4({
    className: clsx(classes2.root, className),
    closeAfterTransition: true,
    components: {
      Backdrop: DialogBackdrop
    },
    componentsProps: {
      backdrop: _extends$4({
        transitionDuration,
        as: BackdropComponent
      }, BackdropProps)
    },
    disableEscapeKeyDown,
    onClose,
    open: open2,
    ref,
    onClick: handleBackdropClick,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$4({
      appear: true,
      in: open2,
      timeout: transitionDuration,
      role: "presentation"
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContainer, {
        className: clsx(classes2.container),
        onMouseDown: handleMouseDown,
        ownerState,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPaper, _extends$4({
          as: PaperComponent,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ariaDescribedby,
          "aria-labelledby": ariaLabelledby
        }, PaperProps, {
          className: clsx(classes2.paper, PaperProps.className),
          ownerState,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext.Provider, {
            value: dialogContextValue,
            children
          })
        }))
      })
    }))
  }));
}, "Dialog2"));
function getDialogActionsUtilityClass(slot) {
  return generateUtilityClass$1("MuiDialogActions", slot);
}
__name(getDialogActionsUtilityClass, "getDialogActionsUtilityClass");
generateUtilityClasses$1("MuiDialogActions", ["root", "spacing"]);
const _excluded$1l = ["className", "disableSpacing"];
const useUtilityClasses$14 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disableSpacing
  } = ownerState;
  const slots = {
    root: ["root", !disableSpacing && "spacing"]
  };
  return composeClasses(slots, getDialogActionsUtilityClass, classes2);
}, "useUtilityClasses$14");
const DialogActionsRoot = styled("div", {
  name: "MuiDialogActions",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
  }
})(({
  ownerState
}) => _extends$4({
  display: "flex",
  alignItems: "center",
  padding: 8,
  justifyContent: "flex-end",
  flex: "0 0 auto"
}, !ownerState.disableSpacing && {
  "& > :not(style) ~ :not(style)": {
    marginLeft: 8
  }
}));
const DialogActions = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function DialogActions2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogActions"
  });
  const {
    className,
    disableSpacing = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1l);
  const ownerState = _extends$4({}, props, {
    disableSpacing
  });
  const classes2 = useUtilityClasses$14(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActionsRoot, _extends$4({
    className: clsx(classes2.root, className),
    ownerState,
    ref
  }, other));
}, "DialogActions2"));
function getDialogContentUtilityClass(slot) {
  return generateUtilityClass$1("MuiDialogContent", slot);
}
__name(getDialogContentUtilityClass, "getDialogContentUtilityClass");
generateUtilityClasses$1("MuiDialogContent", ["root", "dividers"]);
function getDialogTitleUtilityClass(slot) {
  return generateUtilityClass$1("MuiDialogTitle", slot);
}
__name(getDialogTitleUtilityClass, "getDialogTitleUtilityClass");
const dialogTitleClasses = generateUtilityClasses$1("MuiDialogTitle", ["root"]);
const _excluded$1k = ["className", "dividers"];
const useUtilityClasses$13 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    dividers
  } = ownerState;
  const slots = {
    root: ["root", dividers && "dividers"]
  };
  return composeClasses(slots, getDialogContentUtilityClass, classes2);
}, "useUtilityClasses$13");
const DialogContentRoot = styled("div", {
  name: "MuiDialogContent",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.dividers && styles2.dividers];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  flex: "1 1 auto",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  overflowY: "auto",
  padding: "20px 24px"
}, ownerState.dividers ? {
  padding: "16px 24px",
  borderTop: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`
} : {
  [`.${dialogTitleClasses.root} + &`]: {
    paddingTop: 0
  }
}));
const DialogContent = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function DialogContent2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogContent"
  });
  const {
    className,
    dividers = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1k);
  const ownerState = _extends$4({}, props, {
    dividers
  });
  const classes2 = useUtilityClasses$13(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentRoot, _extends$4({
    className: clsx(classes2.root, className),
    ownerState,
    ref
  }, other));
}, "DialogContent2"));
function getDialogContentTextUtilityClass(slot) {
  return generateUtilityClass$1("MuiDialogContentText", slot);
}
__name(getDialogContentTextUtilityClass, "getDialogContentTextUtilityClass");
generateUtilityClasses$1("MuiDialogContentText", ["root"]);
const _excluded$1j = ["children", "className"];
const useUtilityClasses$12 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  const composedClasses = composeClasses(slots, getDialogContentTextUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$12");
const DialogContentTextRoot = styled(Typography, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiDialogContentText",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const DialogContentText = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function DialogContentText2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogContentText"
  });
  const {
    className
  } = props, ownerState = _objectWithoutPropertiesLoose$1(props, _excluded$1j);
  const classes2 = useUtilityClasses$12(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentTextRoot, _extends$4({
    component: "p",
    variant: "body1",
    color: "text.secondary",
    ref,
    ownerState,
    className: clsx(classes2.root, className)
  }, props, {
    classes: classes2
  }));
}, "DialogContentText2"));
const _excluded$1i = ["className", "id"];
const useUtilityClasses$11 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getDialogTitleUtilityClass, classes2);
}, "useUtilityClasses$11");
const DialogTitleRoot = styled(Typography, {
  name: "MuiDialogTitle",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  padding: "16px 24px",
  flex: "0 0 auto"
});
const DialogTitle = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function DialogTitle2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogTitle"
  });
  const {
    className,
    id: idProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1i);
  const ownerState = props;
  const classes2 = useUtilityClasses$11(ownerState);
  const {
    titleId = idProp
  } = reactExports.useContext(DialogContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitleRoot, _extends$4({
    component: "h2",
    className: clsx(classes2.root, className),
    ownerState,
    ref,
    variant: "h6",
    id: idProp != null ? idProp : titleId
  }, other));
}, "DialogTitle2"));
function getFormHelperTextUtilityClasses(slot) {
  return generateUtilityClass$1("MuiFormHelperText", slot);
}
__name(getFormHelperTextUtilityClasses, "getFormHelperTextUtilityClasses");
const formHelperTextClasses = generateUtilityClasses$1("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var _span$1;
const _excluded$1h = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
const useUtilityClasses$10 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    contained,
    size: size2,
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", error && "error", size2 && `size${capitalize$1(size2)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
  };
  return composeClasses(slots, getFormHelperTextUtilityClasses, classes2);
}, "useUtilityClasses$10");
const FormHelperTextRoot = styled("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.size && styles2[`size${capitalize$1(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.caption, {
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${formHelperTextClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formHelperTextClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}, ownerState.size === "small" && {
  marginTop: 4
}, ownerState.contained && {
  marginLeft: 14,
  marginRight: 14
}));
const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function FormHelperText2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormHelperText"
  });
  const {
    children,
    className,
    component = "p"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1h);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  });
  const ownerState = _extends$4({}, props, {
    component,
    contained: fcs.variant === "filled" || fcs.variant === "outlined",
    variant: fcs.variant,
    size: fcs.size,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes2 = useUtilityClasses$10(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, _extends$4({
    as: component,
    ownerState,
    className: clsx(classes2.root, className),
    ref
  }, other, {
    children: children === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: "notranslate",
        children: ""
      }))
    ) : children
  }));
}, "FormHelperText2"));
function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass$1("MuiFormLabel", slot);
}
__name(getFormLabelUtilityClasses, "getFormLabelUtilityClasses");
const formLabelClasses = generateUtilityClasses$1("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
const _excluded$1g = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
const useUtilityClasses$$ = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    color: color2,
    focused,
    disabled,
    error,
    filled,
    required
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses(slots, getFormLabelUtilityClasses, classes2);
}, "useUtilityClasses$$");
const FormLabelRoot = styled("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles2) => {
    return _extends$4({}, styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled);
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.body1, {
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  [`&.${formLabelClasses.focused}`]: {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  },
  [`&.${formLabelClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formLabelClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const AsteriskComponent = styled("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (props, styles2) => styles2.asterisk
})(({
  theme: theme2
}) => ({
  [`&.${formLabelClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const FormLabel = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function FormLabel2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormLabel"
  });
  const {
    children,
    className,
    component = "label"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1g);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  });
  const ownerState = _extends$4({}, props, {
    color: fcs.color || "primary",
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes2 = useUtilityClasses$$(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, _extends$4({
    as: component,
    ownerState,
    className: clsx(classes2.root, className),
    ref
  }, other, {
    children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
      ownerState,
      "aria-hidden": true,
      className: classes2.asterisk,
      children: ["", "*"]
    })]
  }));
}, "FormLabel2"));
function getInputAdornmentUtilityClass(slot) {
  return generateUtilityClass$1("MuiInputAdornment", slot);
}
__name(getInputAdornmentUtilityClass, "getInputAdornmentUtilityClass");
const inputAdornmentClasses = generateUtilityClasses$1("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
var _span;
const _excluded$1f = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"];
const overridesResolver$2 = /* @__PURE__ */ __name((props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, styles2[`position${capitalize$1(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
}, "overridesResolver$2");
const useUtilityClasses$_ = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disablePointerEvents,
    hiddenLabel,
    position: position2,
    size: size2,
    variant
  } = ownerState;
  const slots = {
    root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize$1(position2)}`, variant, hiddenLabel && "hiddenLabel", size2 && `size${capitalize$1(size2)}`]
  };
  return composeClasses(slots, getInputAdornmentUtilityClass, classes2);
}, "useUtilityClasses$_");
const InputAdornmentRoot = styled("div", {
  name: "MuiInputAdornment",
  slot: "Root",
  overridesResolver: overridesResolver$2
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  display: "flex",
  height: "0.01em",
  // Fix IE11 flexbox alignment. To remove at some point.
  maxHeight: "2em",
  alignItems: "center",
  whiteSpace: "nowrap",
  color: (theme2.vars || theme2).palette.action.active
}, ownerState.variant === "filled" && {
  // Styles applied to the root element if `variant="filled"`.
  [`&.${inputAdornmentClasses.positionStart}&:not(.${inputAdornmentClasses.hiddenLabel})`]: {
    marginTop: 16
  }
}, ownerState.position === "start" && {
  // Styles applied to the root element if `position="start"`.
  marginRight: 8
}, ownerState.position === "end" && {
  // Styles applied to the root element if `position="end"`.
  marginLeft: 8
}, ownerState.disablePointerEvents === true && {
  // Styles applied to the root element if `disablePointerEvents={true}`.
  pointerEvents: "none"
}));
const InputAdornment = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function InputAdornment2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInputAdornment"
  });
  const {
    children,
    className,
    component = "div",
    disablePointerEvents = false,
    disableTypography = false,
    position: position2,
    variant: variantProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1f);
  const muiFormControl = useFormControl() || {};
  let variant = variantProp;
  if (variantProp && muiFormControl.variant)
    ;
  if (muiFormControl && !variant) {
    variant = muiFormControl.variant;
  }
  const ownerState = _extends$4({}, props, {
    hiddenLabel: muiFormControl.hiddenLabel,
    size: muiFormControl.size,
    disablePointerEvents,
    position: position2,
    variant
  });
  const classes2 = useUtilityClasses$_(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
    value: null,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornmentRoot, _extends$4({
      as: component,
      ownerState,
      className: clsx(classes2.root, className),
      ref
    }, other, {
      children: typeof children === "string" && !disableTypography ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
        color: "text.secondary",
        children
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [position2 === "start" ? (
          /* notranslate needed while Google Translate will not fix zero-width space issue */
          _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            children: ""
          }))
        ) : null, children]
      })
    }))
  });
}, "InputAdornment2"));
function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass$1("MuiInputLabel", slot);
}
__name(getInputLabelUtilityClasses, "getInputLabelUtilityClasses");
generateUtilityClasses$1("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const _excluded$1e = ["disableAnimation", "margin", "shrink", "variant", "className"];
const useUtilityClasses$Z = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    formControl,
    size: size2,
    shrink,
    disableAnimation,
    variant,
    required
  } = ownerState;
  const slots = {
    root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size2 && size2 !== "normal" && `size${capitalize$1(size2)}`, variant],
    asterisk: [required && "asterisk"]
  };
  const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$Z");
const InputLabelRoot = styled(FormLabel, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses.asterisk}`]: styles2.asterisk
    }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, ownerState.focused && styles2.focused, styles2[ownerState.variant]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%"
}, ownerState.formControl && {
  position: "absolute",
  left: 0,
  top: 0,
  // slight alteration to spec spacing to match visual spec result
  transform: "translate(0, 20px) scale(1)"
}, ownerState.size === "small" && {
  // Compensation for the `Input.inputSizeSmall` style.
  transform: "translate(0, 17px) scale(1)"
}, ownerState.shrink && {
  transform: "translate(0, -1.5px) scale(0.75)",
  transformOrigin: "top left",
  maxWidth: "133%"
}, !ownerState.disableAnimation && {
  transition: theme2.transitions.create(["color", "transform", "max-width"], {
    duration: theme2.transitions.duration.shorter,
    easing: theme2.transitions.easing.easeOut
  })
}, ownerState.variant === "filled" && _extends$4({
  // Chrome's autofill feature gives the input field a yellow background.
  // Since the input field is behind the label in the HTML tree,
  // the input field is drawn last and hides the label with an opaque background color.
  // zIndex: 1 will raise the label above opaque background-colors of input.
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(12px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(12px, 13px) scale(1)"
}, ownerState.shrink && _extends$4({
  userSelect: "none",
  pointerEvents: "auto",
  transform: "translate(12px, 7px) scale(0.75)",
  maxWidth: "calc(133% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(12px, 4px) scale(0.75)"
})), ownerState.variant === "outlined" && _extends$4({
  // see comment above on filled.zIndex
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(14px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(14px, 9px) scale(1)"
}, ownerState.shrink && {
  userSelect: "none",
  pointerEvents: "auto",
  // Theoretically, we should have (8+5)*2/0.75 = 34px
  // but it feels a better when it bleeds a bit on the left, so 32px.
  maxWidth: "calc(133% - 32px)",
  transform: "translate(14px, -9px) scale(0.75)"
})));
const InputLabel = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function InputLabel2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiInputLabel",
    props: inProps
  });
  const {
    disableAnimation = false,
    shrink: shrinkProp,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1e);
  const muiFormControl = useFormControl();
  let shrink = shrinkProp;
  if (typeof shrink === "undefined" && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["size", "variant", "required", "focused"]
  });
  const ownerState = _extends$4({}, props, {
    disableAnimation,
    formControl: muiFormControl,
    shrink,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required,
    focused: fcs.focused
  });
  const classes2 = useUtilityClasses$Z(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, _extends$4({
    "data-shrink": shrink,
    ownerState,
    ref,
    className: clsx(classes2.root, className)
  }, other, {
    classes: classes2
  }));
}, "InputLabel2"));
function getLinearProgressUtilityClass(slot) {
  return generateUtilityClass$1("MuiLinearProgress", slot);
}
__name(getLinearProgressUtilityClass, "getLinearProgressUtilityClass");
generateUtilityClasses$1("MuiLinearProgress", ["root", "colorPrimary", "colorSecondary", "determinate", "indeterminate", "buffer", "query", "dashed", "dashedColorPrimary", "dashedColorSecondary", "bar", "barColorPrimary", "barColorSecondary", "bar1Indeterminate", "bar1Determinate", "bar1Buffer", "bar2Indeterminate", "bar2Buffer"]);
const _excluded$1d = ["className", "color", "value", "valueBuffer", "variant"];
let _$1 = /* @__PURE__ */ __name((t2) => t2, "_$1"), _t$1, _t2$1, _t3$1, _t4$1, _t5, _t6;
const TRANSITION_DURATION = 4;
const indeterminate1Keyframe = keyframes$1(_t$1 || (_t$1 = _$1`
  0% {
    left: -35%;
    right: 100%;
  }

  60% {
    left: 100%;
    right: -90%;
  }

  100% {
    left: 100%;
    right: -90%;
  }
`));
const indeterminate2Keyframe = keyframes$1(_t2$1 || (_t2$1 = _$1`
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
`));
const bufferKeyframe = keyframes$1(_t3$1 || (_t3$1 = _$1`
  0% {
    opacity: 1;
    background-position: 0 -23px;
  }

  60% {
    opacity: 0;
    background-position: 0 -23px;
  }

  100% {
    opacity: 1;
    background-position: -200px -23px;
  }
`));
const useUtilityClasses$Y = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    variant,
    color: color2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, variant],
    dashed: ["dashed", `dashedColor${capitalize$1(color2)}`],
    bar1: ["bar", `barColor${capitalize$1(color2)}`, (variant === "indeterminate" || variant === "query") && "bar1Indeterminate", variant === "determinate" && "bar1Determinate", variant === "buffer" && "bar1Buffer"],
    bar2: ["bar", variant !== "buffer" && `barColor${capitalize$1(color2)}`, variant === "buffer" && `color${capitalize$1(color2)}`, (variant === "indeterminate" || variant === "query") && "bar2Indeterminate", variant === "buffer" && "bar2Buffer"]
  };
  return composeClasses(slots, getLinearProgressUtilityClass, classes2);
}, "useUtilityClasses$Y");
const getColorShade = /* @__PURE__ */ __name((theme2, color2) => {
  if (color2 === "inherit") {
    return "currentColor";
  }
  if (theme2.vars) {
    return theme2.vars.palette.LinearProgress[`${color2}Bg`];
  }
  return theme2.palette.mode === "light" ? lighten_1(theme2.palette[color2].main, 0.62) : darken_1(theme2.palette[color2].main, 0.5);
}, "getColorShade");
const LinearProgressRoot = styled("span", {
  name: "MuiLinearProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize$1(ownerState.color)}`], styles2[ownerState.variant]];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$4({
  position: "relative",
  overflow: "hidden",
  display: "block",
  height: 4,
  zIndex: 0,
  // Fix Safari's bug during composition of different paint.
  "@media print": {
    colorAdjust: "exact"
  },
  backgroundColor: getColorShade(theme2, ownerState.color)
}, ownerState.color === "inherit" && ownerState.variant !== "buffer" && {
  backgroundColor: "none",
  "&::before": {
    content: '""',
    position: "absolute",
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "currentColor",
    opacity: 0.3
  }
}, ownerState.variant === "buffer" && {
  backgroundColor: "transparent"
}, ownerState.variant === "query" && {
  transform: "rotate(180deg)"
}));
const LinearProgressDashed = styled("span", {
  name: "MuiLinearProgress",
  slot: "Dashed",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.dashed, styles2[`dashedColor${capitalize$1(ownerState.color)}`]];
  }
})(({
  ownerState,
  theme: theme2
}) => {
  const backgroundColor2 = getColorShade(theme2, ownerState.color);
  return _extends$4({
    position: "absolute",
    marginTop: 0,
    height: "100%",
    width: "100%"
  }, ownerState.color === "inherit" && {
    opacity: 0.3
  }, {
    backgroundImage: `radial-gradient(${backgroundColor2} 0%, ${backgroundColor2} 16%, transparent 42%)`,
    backgroundSize: "10px 10px",
    backgroundPosition: "0 -23px"
  });
}, css(_t4$1 || (_t4$1 = _$1`
    animation: ${0} 3s infinite linear;
  `), bufferKeyframe));
const LinearProgressBar1 = styled("span", {
  name: "MuiLinearProgress",
  slot: "Bar1",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2[`barColor${capitalize$1(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar1Indeterminate, ownerState.variant === "determinate" && styles2.bar1Determinate, ownerState.variant === "buffer" && styles2.bar1Buffer];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$4({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left",
  backgroundColor: ownerState.color === "inherit" ? "currentColor" : (theme2.vars || theme2).palette[ownerState.color].main
}, ownerState.variant === "determinate" && {
  transition: `transform .${TRANSITION_DURATION}s linear`
}, ownerState.variant === "buffer" && {
  zIndex: 1,
  transition: `transform .${TRANSITION_DURATION}s linear`
}), ({
  ownerState
}) => (ownerState.variant === "indeterminate" || ownerState.variant === "query") && css(_t5 || (_t5 = _$1`
      width: auto;
      animation: ${0} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
    `), indeterminate1Keyframe));
const LinearProgressBar2 = styled("span", {
  name: "MuiLinearProgress",
  slot: "Bar2",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2[`barColor${capitalize$1(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar2Indeterminate, ownerState.variant === "buffer" && styles2.bar2Buffer];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$4({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left"
}, ownerState.variant !== "buffer" && {
  backgroundColor: ownerState.color === "inherit" ? "currentColor" : (theme2.vars || theme2).palette[ownerState.color].main
}, ownerState.color === "inherit" && {
  opacity: 0.3
}, ownerState.variant === "buffer" && {
  backgroundColor: getColorShade(theme2, ownerState.color),
  transition: `transform .${TRANSITION_DURATION}s linear`
}), ({
  ownerState
}) => (ownerState.variant === "indeterminate" || ownerState.variant === "query") && css(_t6 || (_t6 = _$1`
      width: auto;
      animation: ${0} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
    `), indeterminate2Keyframe));
const LinearProgress = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function LinearProgress2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiLinearProgress"
  });
  const {
    className,
    color: color2 = "primary",
    value,
    valueBuffer,
    variant = "indeterminate"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1d);
  const ownerState = _extends$4({}, props, {
    color: color2,
    variant
  });
  const classes2 = useUtilityClasses$Y(ownerState);
  const isRtl = useRtl();
  const rootProps = {};
  const inlineStyles = {
    bar1: {},
    bar2: {}
  };
  if (variant === "determinate" || variant === "buffer") {
    if (value !== void 0) {
      rootProps["aria-valuenow"] = Math.round(value);
      rootProps["aria-valuemin"] = 0;
      rootProps["aria-valuemax"] = 100;
      let transform = value - 100;
      if (isRtl) {
        transform = -transform;
      }
      inlineStyles.bar1.transform = `translateX(${transform}%)`;
    }
  }
  if (variant === "buffer") {
    if (valueBuffer !== void 0) {
      let transform = (valueBuffer || 0) - 100;
      if (isRtl) {
        transform = -transform;
      }
      inlineStyles.bar2.transform = `translateX(${transform}%)`;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(LinearProgressRoot, _extends$4({
    className: clsx(classes2.root, className),
    ownerState,
    role: "progressbar"
  }, rootProps, {
    ref
  }, other, {
    children: [variant === "buffer" ? /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressDashed, {
      className: classes2.dashed,
      ownerState
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressBar1, {
      className: classes2.bar1,
      ownerState,
      style: inlineStyles.bar1
    }), variant === "determinate" ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressBar2, {
      className: classes2.bar2,
      ownerState,
      style: inlineStyles.bar2
    })]
  }));
}, "LinearProgress2"));
function getListItemUtilityClass(slot) {
  return generateUtilityClass$1("MuiListItem", slot);
}
__name(getListItemUtilityClass, "getListItemUtilityClass");
const listItemClasses = generateUtilityClasses$1("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]);
function getListItemButtonUtilityClass(slot) {
  return generateUtilityClass$1("MuiListItemButton", slot);
}
__name(getListItemButtonUtilityClass, "getListItemButtonUtilityClass");
const listItemButtonClasses = generateUtilityClasses$1("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
const _excluded$1c = ["alignItems", "autoFocus", "component", "children", "dense", "disableGutters", "divider", "focusVisibleClassName", "selected", "className"];
const overridesResolver$1 = /* @__PURE__ */ __name((props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
}, "overridesResolver$1");
const useUtilityClasses$X = /* @__PURE__ */ __name((ownerState) => {
  const {
    alignItems,
    classes: classes2,
    dense,
    disabled,
    disableGutters,
    divider,
    selected
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", !disableGutters && "gutters", divider && "divider", disabled && "disabled", alignItems === "flex-start" && "alignItemsFlexStart", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getListItemButtonUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$X");
const ListItemButtonRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiListItemButton",
  slot: "Root",
  overridesResolver: overridesResolver$1
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  display: "flex",
  flexGrow: 1,
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minWidth: 0,
  boxSizing: "border-box",
  textAlign: "left",
  paddingTop: 8,
  paddingBottom: 8,
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  }),
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${listItemButtonClasses.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    [`&.${listItemButtonClasses.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  },
  [`&.${listItemButtonClasses.selected}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
    }
  },
  [`&.${listItemButtonClasses.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${listItemButtonClasses.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  }
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  backgroundClip: "padding-box"
}, ownerState.alignItems === "flex-start" && {
  alignItems: "flex-start"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.dense && {
  paddingTop: 4,
  paddingBottom: 4
}));
const ListItemButton = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function ListItemButton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemButton"
  });
  const {
    alignItems = "center",
    autoFocus = false,
    component = "div",
    children,
    dense = false,
    disableGutters = false,
    divider = false,
    focusVisibleClassName,
    selected = false,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1c);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    alignItems,
    disableGutters
  }), [alignItems, context.dense, dense, disableGutters]);
  const listItemRef = reactExports.useRef(null);
  useEnhancedEffect(() => {
    if (autoFocus) {
      if (listItemRef.current) {
        listItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = _extends$4({}, props, {
    alignItems,
    dense: childContext.dense,
    disableGutters,
    divider,
    selected
  });
  const classes2 = useUtilityClasses$X(ownerState);
  const handleRef = useForkRef(listItemRef, ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemButtonRoot, _extends$4({
      ref: handleRef,
      href: other.href || other.to,
      component: (other.href || other.to) && component === "div" ? "button" : component,
      focusVisibleClassName: clsx(classes2.focusVisible, focusVisibleClassName),
      ownerState,
      className: clsx(classes2.root, className)
    }, other, {
      classes: classes2,
      children
    }))
  });
}, "ListItemButton2"));
function getListItemSecondaryActionClassesUtilityClass(slot) {
  return generateUtilityClass$1("MuiListItemSecondaryAction", slot);
}
__name(getListItemSecondaryActionClassesUtilityClass, "getListItemSecondaryActionClassesUtilityClass");
generateUtilityClasses$1("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const _excluded$1b = ["className"];
const useUtilityClasses$W = /* @__PURE__ */ __name((ownerState) => {
  const {
    disableGutters,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes2);
}, "useUtilityClasses$W");
const ListItemSecondaryActionRoot = styled("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.disableGutters && styles2.disableGutters];
  }
})(({
  ownerState
}) => _extends$4({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)"
}, ownerState.disableGutters && {
  right: 0
}));
const ListItemSecondaryAction = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function ListItemSecondaryAction2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemSecondaryAction"
  });
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1b);
  const context = reactExports.useContext(ListContext$1);
  const ownerState = _extends$4({}, props, {
    disableGutters: context.disableGutters
  });
  const classes2 = useUtilityClasses$W(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, _extends$4({
    className: clsx(classes2.root, className),
    ownerState,
    ref
  }, other));
}, "ListItemSecondaryAction2"));
ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
const _excluded$1a = ["className"], _excluded2$a = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"];
const overridesResolver = /* @__PURE__ */ __name((props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters, !ownerState.disablePadding && styles2.padding, ownerState.button && styles2.button, ownerState.hasSecondaryAction && styles2.secondaryAction];
}, "overridesResolver");
const useUtilityClasses$V = /* @__PURE__ */ __name((ownerState) => {
  const {
    alignItems,
    button,
    classes: classes2,
    dense,
    disabled,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction,
    selected
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", disabled && "disabled", button && "button", alignItems === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction", selected && "selected"],
    container: ["container"]
  };
  return composeClasses(slots, getListItemUtilityClass, classes2);
}, "useUtilityClasses$V");
const ListItemRoot = styled("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left"
}, !ownerState.disablePadding && _extends$4({
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.dense && {
  paddingTop: 4,
  paddingBottom: 4
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, !!ownerState.secondaryAction && {
  // Add some space to avoid collision as `ListItemSecondaryAction`
  // is absolutely positioned.
  paddingRight: 48
}), !!ownerState.secondaryAction && {
  [`& > .${listItemButtonClasses.root}`]: {
    paddingRight: 48
  }
}, {
  [`&.${listItemClasses.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${listItemClasses.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    [`&.${listItemClasses.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  },
  [`&.${listItemClasses.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  }
}, ownerState.alignItems === "flex-start" && {
  alignItems: "flex-start"
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  backgroundClip: "padding-box"
}, ownerState.button && {
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  }),
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${listItemClasses.selected}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha_1(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
    }
  }
}, ownerState.hasSecondaryAction && {
  // Add some space to avoid collision as `ListItemSecondaryAction`
  // is absolutely positioned.
  paddingRight: 48
}));
const ListItemContainer = styled("li", {
  name: "MuiListItem",
  slot: "Container",
  overridesResolver: (props, styles2) => styles2.container
})({
  position: "relative"
});
const ListItem = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function ListItem2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItem"
  });
  const {
    alignItems = "center",
    autoFocus = false,
    button = false,
    children: childrenProp,
    className,
    component: componentProp,
    components = {},
    componentsProps = {},
    ContainerComponent = "li",
    ContainerProps: {
      className: ContainerClassName
    } = {},
    dense = false,
    disabled = false,
    disableGutters = false,
    disablePadding = false,
    divider = false,
    focusVisibleClassName,
    secondaryAction,
    selected = false,
    slotProps = {},
    slots = {}
  } = props, ContainerProps = _objectWithoutPropertiesLoose$1(props.ContainerProps, _excluded$1a), other = _objectWithoutPropertiesLoose$1(props, _excluded2$a);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    alignItems,
    disableGutters
  }), [alignItems, context.dense, dense, disableGutters]);
  const listItemRef = reactExports.useRef(null);
  useEnhancedEffect(() => {
    if (autoFocus) {
      if (listItemRef.current) {
        listItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const children = reactExports.Children.toArray(childrenProp);
  const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
  const ownerState = _extends$4({}, props, {
    alignItems,
    autoFocus,
    button,
    dense: childContext.dense,
    disabled,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction,
    selected
  });
  const classes2 = useUtilityClasses$V(ownerState);
  const handleRef = useForkRef(listItemRef, ref);
  const Root = slots.root || components.Root || ListItemRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const componentProps = _extends$4({
    className: clsx(classes2.root, rootProps.className, className),
    disabled
  }, other);
  let Component = componentProp || "li";
  if (button) {
    componentProps.component = componentProp || "div";
    componentProps.focusVisibleClassName = clsx(listItemClasses.focusVisible, focusVisibleClassName);
    Component = ButtonBase;
  }
  if (hasSecondaryAction) {
    Component = !componentProps.component && !componentProp ? "div" : Component;
    if (ContainerComponent === "li") {
      if (Component === "li") {
        Component = "div";
      } else if (componentProps.component === "li") {
        componentProps.component = "div";
      }
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemContainer, _extends$4({
        as: ContainerComponent,
        className: clsx(classes2.container, ContainerClassName),
        ref: handleRef,
        ownerState
      }, ContainerProps, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$4({}, rootProps, !isHostComponent$1(Root) && {
          as: Component,
          ownerState: _extends$4({}, ownerState, rootProps.ownerState)
        }, componentProps, {
          children
        })), children.pop()]
      }))
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$4({}, rootProps, {
      as: Component,
      ref: handleRef
    }, !isHostComponent$1(Root) && {
      ownerState: _extends$4({}, ownerState, rootProps.ownerState)
    }, componentProps, {
      children: [children, secondaryAction && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryAction, {
        children: secondaryAction
      })]
    }))
  });
}, "ListItem2"));
function getListItemAvatarUtilityClass(slot) {
  return generateUtilityClass$1("MuiListItemAvatar", slot);
}
__name(getListItemAvatarUtilityClass, "getListItemAvatarUtilityClass");
generateUtilityClasses$1("MuiListItemAvatar", ["root", "alignItemsFlexStart"]);
const _excluded$19 = ["className"];
const useUtilityClasses$U = /* @__PURE__ */ __name((ownerState) => {
  const {
    alignItems,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", alignItems === "flex-start" && "alignItemsFlexStart"]
  };
  return composeClasses(slots, getListItemAvatarUtilityClass, classes2);
}, "useUtilityClasses$U");
const ListItemAvatarRoot = styled("div", {
  name: "MuiListItemAvatar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
  }
})(({
  ownerState
}) => _extends$4({
  minWidth: 56,
  flexShrink: 0
}, ownerState.alignItems === "flex-start" && {
  marginTop: 8
}));
const ListItemAvatar = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function ListItemAvatar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemAvatar"
  });
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$19);
  const context = reactExports.useContext(ListContext$1);
  const ownerState = _extends$4({}, props, {
    alignItems: context.alignItems
  });
  const classes2 = useUtilityClasses$U(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemAvatarRoot, _extends$4({
    className: clsx(classes2.root, className),
    ownerState,
    ref
  }, other));
}, "ListItemAvatar2"));
function getSkeletonUtilityClass(slot) {
  return generateUtilityClass$1("MuiSkeleton", slot);
}
__name(getSkeletonUtilityClass, "getSkeletonUtilityClass");
generateUtilityClasses$1("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
const _excluded$18 = ["animation", "className", "component", "height", "style", "variant", "width"];
let _ = /* @__PURE__ */ __name((t2) => t2, "_"), _t, _t2, _t3, _t4;
const useUtilityClasses$T = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    variant,
    animation,
    hasChildren,
    width: width2,
    height: height2
  } = ownerState;
  const slots = {
    root: ["root", variant, animation, hasChildren && "withChildren", hasChildren && !width2 && "fitContent", hasChildren && !height2 && "heightAuto"]
  };
  return composeClasses(slots, getSkeletonUtilityClass, classes2);
}, "useUtilityClasses$T");
const pulseKeyframe = keyframes$1(_t || (_t = _`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`));
const waveKeyframe = keyframes$1(_t2 || (_t2 = _`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`));
const SkeletonRoot = styled("span", {
  name: "MuiSkeleton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.animation !== false && styles2[ownerState.animation], ownerState.hasChildren && styles2.withChildren, ownerState.hasChildren && !ownerState.width && styles2.fitContent, ownerState.hasChildren && !ownerState.height && styles2.heightAuto];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const radiusUnit = getUnit(theme2.shape.borderRadius) || "px";
  const radiusValue = toUnitless(theme2.shape.borderRadius);
  return _extends$4({
    display: "block",
    // Create a "on paper" color with sufficient contrast retaining the color
    backgroundColor: theme2.vars ? theme2.vars.palette.Skeleton.bg : alpha$2(theme2.palette.text.primary, theme2.palette.mode === "light" ? 0.11 : 0.13),
    height: "1.2em"
  }, ownerState.variant === "text" && {
    marginTop: 0,
    marginBottom: 0,
    height: "auto",
    transformOrigin: "0 55%",
    transform: "scale(1, 0.60)",
    borderRadius: `${radiusValue}${radiusUnit}/${Math.round(radiusValue / 0.6 * 10) / 10}${radiusUnit}`,
    "&:empty:before": {
      content: '"\\00a0"'
    }
  }, ownerState.variant === "circular" && {
    borderRadius: "50%"
  }, ownerState.variant === "rounded" && {
    borderRadius: (theme2.vars || theme2).shape.borderRadius
  }, ownerState.hasChildren && {
    "& > *": {
      visibility: "hidden"
    }
  }, ownerState.hasChildren && !ownerState.width && {
    maxWidth: "fit-content"
  }, ownerState.hasChildren && !ownerState.height && {
    height: "auto"
  });
}, ({
  ownerState
}) => ownerState.animation === "pulse" && css(_t3 || (_t3 = _`
      animation: ${0} 2s ease-in-out 0.5s infinite;
    `), pulseKeyframe), ({
  ownerState,
  theme: theme2
}) => ownerState.animation === "wave" && css(_t4 || (_t4 = _`
      position: relative;
      overflow: hidden;

      /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
      -webkit-mask-image: -webkit-radial-gradient(white, black);

      &::after {
        animation: ${0} 2s linear 0.5s infinite;
        background: linear-gradient(
          90deg,
          transparent,
          ${0},
          transparent
        );
        content: '';
        position: absolute;
        transform: translateX(-100%); /* Avoid flash during server-side hydration */
        bottom: 0;
        left: 0;
        right: 0;
        top: 0;
      }
    `), waveKeyframe, (theme2.vars || theme2).palette.action.hover));
const Skeleton = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Skeleton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSkeleton"
  });
  const {
    animation = "pulse",
    className,
    component = "span",
    height: height2,
    style: style2,
    variant = "text",
    width: width2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$18);
  const ownerState = _extends$4({}, props, {
    animation,
    component,
    variant,
    hasChildren: Boolean(other.children)
  });
  const classes2 = useUtilityClasses$T(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonRoot, _extends$4({
    as: component,
    ref,
    className: clsx(classes2.root, className),
    ownerState
  }, other, {
    style: _extends$4({
      width: width2,
      height: height2
    }, style2)
  }));
}, "Skeleton2"));
const StepperContext = /* @__PURE__ */ reactExports.createContext({});
const StepContext = /* @__PURE__ */ reactExports.createContext({});
function getStepUtilityClass(slot) {
  return generateUtilityClass$1("MuiStep", slot);
}
__name(getStepUtilityClass, "getStepUtilityClass");
generateUtilityClasses$1("MuiStep", ["root", "horizontal", "vertical", "alternativeLabel", "completed"]);
const _excluded$17 = ["active", "children", "className", "component", "completed", "disabled", "expanded", "index", "last"];
const useUtilityClasses$S = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    orientation,
    alternativeLabel,
    completed
  } = ownerState;
  const slots = {
    root: ["root", orientation, alternativeLabel && "alternativeLabel", completed && "completed"]
  };
  return composeClasses(slots, getStepUtilityClass, classes2);
}, "useUtilityClasses$S");
const StepRoot = styled("div", {
  name: "MuiStep",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.alternativeLabel && styles2.alternativeLabel, ownerState.completed && styles2.completed];
  }
})(({
  ownerState
}) => _extends$4({}, ownerState.orientation === "horizontal" && {
  paddingLeft: 8,
  paddingRight: 8
}, ownerState.alternativeLabel && {
  flex: 1,
  position: "relative"
}));
const Step = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Step2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStep"
  });
  const {
    active: activeProp,
    children,
    className,
    component = "div",
    completed: completedProp,
    disabled: disabledProp,
    expanded = false,
    index: index2,
    last: last2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$17);
  const {
    activeStep,
    connector,
    alternativeLabel,
    orientation,
    nonLinear
  } = reactExports.useContext(StepperContext);
  let [active = false, completed = false, disabled = false] = [activeProp, completedProp, disabledProp];
  if (activeStep === index2) {
    active = activeProp !== void 0 ? activeProp : true;
  } else if (!nonLinear && activeStep > index2) {
    completed = completedProp !== void 0 ? completedProp : true;
  } else if (!nonLinear && activeStep < index2) {
    disabled = disabledProp !== void 0 ? disabledProp : true;
  }
  const contextValue = reactExports.useMemo(() => ({
    index: index2,
    last: last2,
    expanded,
    icon: index2 + 1,
    active,
    completed,
    disabled
  }), [index2, last2, expanded, active, completed, disabled]);
  const ownerState = _extends$4({}, props, {
    active,
    orientation,
    alternativeLabel,
    completed,
    disabled,
    expanded,
    component
  });
  const classes2 = useUtilityClasses$S(ownerState);
  const newChildren = /* @__PURE__ */ jsxRuntimeExports.jsxs(StepRoot, _extends$4({
    as: component,
    className: clsx(classes2.root, className),
    ref,
    ownerState
  }, other, {
    children: [connector && alternativeLabel && index2 !== 0 ? connector : null, children]
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StepContext.Provider, {
    value: contextValue,
    children: connector && !alternativeLabel && index2 !== 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [connector, newChildren]
    }) : newChildren
  });
}, "Step2"));
const CheckCircle$1 = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24zm-2 17l-5-5 1.4-1.4 3.6 3.6 7.6-7.6L19 8l-9 9z"
}), "CheckCircle");
const Warning = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"
}), "Warning");
function getStepIconUtilityClass(slot) {
  return generateUtilityClass$1("MuiStepIcon", slot);
}
__name(getStepIconUtilityClass, "getStepIconUtilityClass");
const stepIconClasses = generateUtilityClasses$1("MuiStepIcon", ["root", "active", "completed", "error", "text"]);
var _circle;
const _excluded$16 = ["active", "className", "completed", "error", "icon"];
const useUtilityClasses$R = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    active,
    completed,
    error
  } = ownerState;
  const slots = {
    root: ["root", active && "active", completed && "completed", error && "error"],
    text: ["text"]
  };
  return composeClasses(slots, getStepIconUtilityClass, classes2);
}, "useUtilityClasses$R");
const StepIconRoot = styled(SvgIcon, {
  name: "MuiStepIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => ({
  display: "block",
  transition: theme2.transitions.create("color", {
    duration: theme2.transitions.duration.shortest
  }),
  color: (theme2.vars || theme2).palette.text.disabled,
  [`&.${stepIconClasses.completed}`]: {
    color: (theme2.vars || theme2).palette.primary.main
  },
  [`&.${stepIconClasses.active}`]: {
    color: (theme2.vars || theme2).palette.primary.main
  },
  [`&.${stepIconClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const StepIconText = styled("text", {
  name: "MuiStepIcon",
  slot: "Text",
  overridesResolver: (props, styles2) => styles2.text
})(({
  theme: theme2
}) => ({
  fill: (theme2.vars || theme2).palette.primary.contrastText,
  fontSize: theme2.typography.caption.fontSize,
  fontFamily: theme2.typography.fontFamily
}));
const StepIcon = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function StepIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepIcon"
  });
  const {
    active = false,
    className: classNameProp,
    completed = false,
    error = false,
    icon
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$16);
  const ownerState = _extends$4({}, props, {
    active,
    completed,
    error
  });
  const classes2 = useUtilityClasses$R(ownerState);
  if (typeof icon === "number" || typeof icon === "string") {
    const className = clsx(classNameProp, classes2.root);
    if (error) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconRoot, _extends$4({
        as: Warning,
        className,
        ref,
        ownerState
      }, other));
    }
    if (completed) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconRoot, _extends$4({
        as: CheckCircle$1,
        className,
        ref,
        ownerState
      }, other));
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(StepIconRoot, _extends$4({
      className,
      ref,
      ownerState
    }, other, {
      children: [_circle || (_circle = /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
        cx: "12",
        cy: "12",
        r: "12"
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconText, {
        className: classes2.text,
        x: "12",
        y: "12",
        textAnchor: "middle",
        dominantBaseline: "central",
        ownerState,
        children: icon
      })]
    }));
  }
  return icon;
}, "StepIcon2"));
function getStepLabelUtilityClass(slot) {
  return generateUtilityClass$1("MuiStepLabel", slot);
}
__name(getStepLabelUtilityClass, "getStepLabelUtilityClass");
const stepLabelClasses = generateUtilityClasses$1("MuiStepLabel", ["root", "horizontal", "vertical", "label", "active", "completed", "error", "disabled", "iconContainer", "alternativeLabel", "labelContainer"]);
const _excluded$15 = ["children", "className", "componentsProps", "error", "icon", "optional", "slotProps", "StepIconComponent", "StepIconProps"];
const useUtilityClasses$Q = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    orientation,
    active,
    completed,
    error,
    disabled,
    alternativeLabel
  } = ownerState;
  const slots = {
    root: ["root", orientation, error && "error", disabled && "disabled", alternativeLabel && "alternativeLabel"],
    label: ["label", active && "active", completed && "completed", error && "error", disabled && "disabled", alternativeLabel && "alternativeLabel"],
    iconContainer: ["iconContainer", active && "active", completed && "completed", error && "error", disabled && "disabled", alternativeLabel && "alternativeLabel"],
    labelContainer: ["labelContainer", alternativeLabel && "alternativeLabel"]
  };
  return composeClasses(slots, getStepLabelUtilityClass, classes2);
}, "useUtilityClasses$Q");
const StepLabelRoot = styled("span", {
  name: "MuiStepLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation]];
  }
})(({
  ownerState
}) => _extends$4({
  display: "flex",
  alignItems: "center",
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    flexDirection: "column"
  },
  [`&.${stepLabelClasses.disabled}`]: {
    cursor: "default"
  }
}, ownerState.orientation === "vertical" && {
  textAlign: "left",
  padding: "8px 0"
}));
const StepLabelLabel = styled("span", {
  name: "MuiStepLabel",
  slot: "Label",
  overridesResolver: (props, styles2) => styles2.label
})(({
  theme: theme2
}) => _extends$4({}, theme2.typography.body2, {
  display: "block",
  transition: theme2.transitions.create("color", {
    duration: theme2.transitions.duration.shortest
  }),
  [`&.${stepLabelClasses.active}`]: {
    color: (theme2.vars || theme2).palette.text.primary,
    fontWeight: 500
  },
  [`&.${stepLabelClasses.completed}`]: {
    color: (theme2.vars || theme2).palette.text.primary,
    fontWeight: 500
  },
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    marginTop: 16
  },
  [`&.${stepLabelClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const StepLabelIconContainer = styled("span", {
  name: "MuiStepLabel",
  slot: "IconContainer",
  overridesResolver: (props, styles2) => styles2.iconContainer
})(() => ({
  flexShrink: 0,
  // Fix IE11 issue
  display: "flex",
  paddingRight: 8,
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    paddingRight: 0
  }
}));
const StepLabelLabelContainer = styled("span", {
  name: "MuiStepLabel",
  slot: "LabelContainer",
  overridesResolver: (props, styles2) => styles2.labelContainer
})(({
  theme: theme2
}) => ({
  width: "100%",
  color: (theme2.vars || theme2).palette.text.secondary,
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    textAlign: "center"
  }
}));
const StepLabel = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function StepLabel2(inProps, ref) {
  var _slotProps$label;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepLabel"
  });
  const {
    children,
    className,
    componentsProps = {},
    error = false,
    icon: iconProp,
    optional,
    slotProps = {},
    StepIconComponent: StepIconComponentProp,
    StepIconProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$15);
  const {
    alternativeLabel,
    orientation
  } = reactExports.useContext(StepperContext);
  const {
    active,
    disabled,
    completed,
    icon: iconContext
  } = reactExports.useContext(StepContext);
  const icon = iconProp || iconContext;
  let StepIconComponent = StepIconComponentProp;
  if (icon && !StepIconComponent) {
    StepIconComponent = StepIcon;
  }
  const ownerState = _extends$4({}, props, {
    active,
    alternativeLabel,
    completed,
    disabled,
    error,
    orientation
  });
  const classes2 = useUtilityClasses$Q(ownerState);
  const labelSlotProps = (_slotProps$label = slotProps.label) != null ? _slotProps$label : componentsProps.label;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(StepLabelRoot, _extends$4({
    className: clsx(classes2.root, className),
    ref,
    ownerState
  }, other, {
    children: [icon || StepIconComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(StepLabelIconContainer, {
      className: classes2.iconContainer,
      ownerState,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconComponent, _extends$4({
        completed,
        active,
        error,
        icon
      }, StepIconProps))
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsxs(StepLabelLabelContainer, {
      className: classes2.labelContainer,
      ownerState,
      children: [children ? /* @__PURE__ */ jsxRuntimeExports.jsx(StepLabelLabel, _extends$4({
        ownerState
      }, labelSlotProps, {
        className: clsx(classes2.label, labelSlotProps == null ? void 0 : labelSlotProps.className),
        children
      })) : null, optional]
    })]
  }));
}, "StepLabel2"));
StepLabel.muiName = "StepLabel";
function getStepConnectorUtilityClass(slot) {
  return generateUtilityClass$1("MuiStepConnector", slot);
}
__name(getStepConnectorUtilityClass, "getStepConnectorUtilityClass");
generateUtilityClasses$1("MuiStepConnector", ["root", "horizontal", "vertical", "alternativeLabel", "active", "completed", "disabled", "line", "lineHorizontal", "lineVertical"]);
const _excluded$14 = ["className"];
const useUtilityClasses$P = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    orientation,
    alternativeLabel,
    active,
    completed,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation, alternativeLabel && "alternativeLabel", active && "active", completed && "completed", disabled && "disabled"],
    line: ["line", `line${capitalize$1(orientation)}`]
  };
  return composeClasses(slots, getStepConnectorUtilityClass, classes2);
}, "useUtilityClasses$P");
const StepConnectorRoot = styled("div", {
  name: "MuiStepConnector",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.alternativeLabel && styles2.alternativeLabel, ownerState.completed && styles2.completed];
  }
})(({
  ownerState
}) => _extends$4({
  flex: "1 1 auto"
}, ownerState.orientation === "vertical" && {
  marginLeft: 12
  // half icon
}, ownerState.alternativeLabel && {
  position: "absolute",
  top: 8 + 4,
  left: "calc(-50% + 20px)",
  right: "calc(50% + 20px)"
}));
const StepConnectorLine = styled("span", {
  name: "MuiStepConnector",
  slot: "Line",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.line, styles2[`line${capitalize$1(ownerState.orientation)}`]];
  }
})(({
  ownerState,
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? theme2.palette.grey[400] : theme2.palette.grey[600];
  return _extends$4({
    display: "block",
    borderColor: theme2.vars ? theme2.vars.palette.StepConnector.border : borderColor2
  }, ownerState.orientation === "horizontal" && {
    borderTopStyle: "solid",
    borderTopWidth: 1
  }, ownerState.orientation === "vertical" && {
    borderLeftStyle: "solid",
    borderLeftWidth: 1,
    minHeight: 24
  });
});
const StepConnector = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function StepConnector2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepConnector"
  });
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$14);
  const {
    alternativeLabel,
    orientation = "horizontal"
  } = reactExports.useContext(StepperContext);
  const {
    active,
    disabled,
    completed
  } = reactExports.useContext(StepContext);
  const ownerState = _extends$4({}, props, {
    alternativeLabel,
    orientation,
    active,
    completed,
    disabled
  });
  const classes2 = useUtilityClasses$P(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StepConnectorRoot, _extends$4({
    className: clsx(classes2.root, className),
    ref,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepConnectorLine, {
      className: classes2.line,
      ownerState
    })
  }));
}, "StepConnector2"));
function getStepperUtilityClass(slot) {
  return generateUtilityClass$1("MuiStepper", slot);
}
__name(getStepperUtilityClass, "getStepperUtilityClass");
generateUtilityClasses$1("MuiStepper", ["root", "horizontal", "vertical", "nonLinear", "alternativeLabel"]);
const _excluded$13 = ["activeStep", "alternativeLabel", "children", "className", "component", "connector", "nonLinear", "orientation"];
const useUtilityClasses$O = /* @__PURE__ */ __name((ownerState) => {
  const {
    orientation,
    nonLinear,
    alternativeLabel,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", orientation, nonLinear && "nonLinear", alternativeLabel && "alternativeLabel"]
  };
  return composeClasses(slots, getStepperUtilityClass, classes2);
}, "useUtilityClasses$O");
const StepperRoot = styled("div", {
  name: "MuiStepper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.alternativeLabel && styles2.alternativeLabel, ownerState.nonLinear && styles2.nonLinear];
  }
})(({
  ownerState
}) => _extends$4({
  display: "flex"
}, ownerState.orientation === "horizontal" && {
  flexDirection: "row",
  alignItems: "center"
}, ownerState.orientation === "vertical" && {
  flexDirection: "column"
}, ownerState.alternativeLabel && {
  alignItems: "flex-start"
}));
const defaultConnector = /* @__PURE__ */ jsxRuntimeExports.jsx(StepConnector, {});
const Stepper = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Stepper2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepper"
  });
  const {
    activeStep = 0,
    alternativeLabel = false,
    children,
    className,
    component = "div",
    connector = defaultConnector,
    nonLinear = false,
    orientation = "horizontal"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$13);
  const ownerState = _extends$4({}, props, {
    nonLinear,
    alternativeLabel,
    orientation,
    component
  });
  const classes2 = useUtilityClasses$O(ownerState);
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  const steps2 = childrenArray.map((step, index2) => {
    return /* @__PURE__ */ reactExports.cloneElement(step, _extends$4({
      index: index2,
      last: index2 + 1 === childrenArray.length
    }, step.props));
  });
  const contextValue = reactExports.useMemo(() => ({
    activeStep,
    alternativeLabel,
    connector,
    nonLinear,
    orientation
  }), [activeStep, alternativeLabel, connector, nonLinear, orientation]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StepperContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepperRoot, _extends$4({
      as: component,
      ownerState,
      className: clsx(classes2.root, className),
      ref
    }, other, {
      children: steps2
    }))
  });
}, "Stepper2"));
function getTextFieldUtilityClass(slot) {
  return generateUtilityClass$1("MuiTextField", slot);
}
__name(getTextFieldUtilityClass, "getTextFieldUtilityClass");
const textFieldClasses = generateUtilityClasses$1("MuiTextField", ["root"]);
const _excluded$12 = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
const variantComponent = {
  standard: Input,
  filled: FilledInput,
  outlined: OutlinedInput
};
const useUtilityClasses$N = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTextFieldUtilityClass, classes2);
}, "useUtilityClasses$N");
const TextFieldRoot = styled(FormControl, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const TextField = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function TextField2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTextField"
  });
  const {
    autoComplete,
    autoFocus = false,
    children,
    className,
    color: color2 = "primary",
    defaultValue,
    disabled = false,
    error = false,
    FormHelperTextProps,
    fullWidth = false,
    helperText,
    id: idOverride,
    InputLabelProps,
    inputProps,
    InputProps,
    inputRef,
    label,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    required = false,
    rows,
    select = false,
    SelectProps,
    type,
    value,
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$12);
  const ownerState = _extends$4({}, props, {
    autoFocus,
    color: color2,
    disabled,
    error,
    fullWidth,
    multiline,
    required,
    select,
    variant
  });
  const classes2 = useUtilityClasses$N(ownerState);
  const InputMore = {};
  if (variant === "outlined") {
    if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
      InputMore.notched = InputLabelProps.shrink;
    }
    InputMore.label = label;
  }
  if (select) {
    if (!SelectProps || !SelectProps.native) {
      InputMore.id = void 0;
    }
    InputMore["aria-describedby"] = void 0;
  }
  const id2 = useId(idOverride);
  const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
  const inputLabelId = label && id2 ? `${id2}-label` : void 0;
  const InputComponent = variantComponent[variant];
  const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputComponent, _extends$4({
    "aria-describedby": helperTextId,
    autoComplete,
    autoFocus,
    defaultValue,
    fullWidth,
    multiline,
    name,
    rows,
    maxRows,
    minRows,
    type,
    value,
    id: id2,
    inputRef,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    inputProps
  }, InputMore, InputProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TextFieldRoot, _extends$4({
    className: clsx(classes2.root, className),
    disabled,
    error,
    fullWidth,
    ref,
    required,
    color: color2,
    variant,
    ownerState
  }, other, {
    children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, _extends$4({
      htmlFor: id2,
      id: inputLabelId
    }, InputLabelProps, {
      children: label
    })), select ? /* @__PURE__ */ jsxRuntimeExports.jsx(Select, _extends$4({
      "aria-describedby": helperTextId,
      id: id2,
      labelId: inputLabelId,
      value,
      input: InputElement
    }, SelectProps, {
      children
    })) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText, _extends$4({
      id: helperTextId
    }, FormHelperTextProps, {
      children: helperText
    }))]
  }));
}, "TextField2"));
var Delete = {};
var _interopRequireDefault$y = interopRequireDefaultExports;
Object.defineProperty(Delete, "__esModule", {
  value: true
});
var default_1$t = Delete.default = void 0;
var _createSvgIcon$t = _interopRequireDefault$y(requireCreateSvgIcon());
var _jsxRuntime$t = jsxRuntimeExports;
default_1$t = Delete.default = (0, _createSvgIcon$t.default)(/* @__PURE__ */ (0, _jsxRuntime$t.jsx)("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"
}), "Delete");
var Search$2 = {};
var _interopRequireDefault$x = interopRequireDefaultExports;
Object.defineProperty(Search$2, "__esModule", {
  value: true
});
var default_1$s = Search$2.default = void 0;
var _createSvgIcon$s = _interopRequireDefault$x(requireCreateSvgIcon());
var _jsxRuntime$s = jsxRuntimeExports;
default_1$s = Search$2.default = (0, _createSvgIcon$s.default)(/* @__PURE__ */ (0, _jsxRuntime$s.jsx)("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
}), "Search");
const motionItemsVariants = {
  open: { opacity: 1, x: 0 },
  closed: { opacity: 0, x: "-100%" }
};
const GridApiContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useGridApiContext() {
  const apiRef = reactExports.useContext(GridApiContext);
  if (apiRef === void 0) {
    throw new Error(["MUI X: Could not find the Data Grid context.", "It looks like you rendered your component outside of a DataGrid, DataGridPro or DataGridPremium parent component.", "This can also happen if you are bundling multiple versions of the Data Grid."].join("\n"));
  }
  return apiRef;
}
__name(useGridApiContext, "useGridApiContext");
const useGridApiRef = /* @__PURE__ */ __name(() => reactExports.useRef({}), "useGridApiRef");
const GridRootPropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
const useGridRootProps = /* @__PURE__ */ __name(() => {
  const contextValue = reactExports.useContext(GridRootPropsContext);
  if (!contextValue) {
    throw new Error("MUI X: useGridRootProps should only be used inside the DataGrid, DataGridPro or DataGridPremium component.");
  }
  return contextValue;
}, "useGridRootProps");
const is = Object.is;
function fastObjectShallowCompare(a, b2) {
  if (a === b2) {
    return true;
  }
  if (!(a instanceof Object) || !(b2 instanceof Object)) {
    return false;
  }
  let aLength = 0;
  let bLength = 0;
  for (const key in a) {
    aLength += 1;
    if (!is(a[key], b2[key])) {
      return false;
    }
    if (!(key in b2)) {
      return false;
    }
  }
  for (const _2 in b2) {
    bLength += 1;
  }
  return aLength === bLength;
}
__name(fastObjectShallowCompare, "fastObjectShallowCompare");
function fastMemo(component) {
  return /* @__PURE__ */ reactExports.memo(component, fastObjectShallowCompare);
}
__name(fastMemo, "fastMemo");
const GRID_DEFAULT_LOCALE_TEXT = {
  // Root
  noRowsLabel: "No rows",
  noResultsOverlayLabel: "No results found.",
  // Density selector toolbar button text
  toolbarDensity: "Density",
  toolbarDensityLabel: "Density",
  toolbarDensityCompact: "Compact",
  toolbarDensityStandard: "Standard",
  toolbarDensityComfortable: "Comfortable",
  // Columns selector toolbar button text
  toolbarColumns: "Columns",
  toolbarColumnsLabel: "Select columns",
  // Filters toolbar button text
  toolbarFilters: "Filters",
  toolbarFiltersLabel: "Show filters",
  toolbarFiltersTooltipHide: "Hide filters",
  toolbarFiltersTooltipShow: "Show filters",
  toolbarFiltersTooltipActive: (count) => count !== 1 ? `${count} active filters` : `${count} active filter`,
  // Quick filter toolbar field
  toolbarQuickFilterPlaceholder: "Search",
  toolbarQuickFilterLabel: "Search",
  toolbarQuickFilterDeleteIconLabel: "Clear",
  // Export selector toolbar button text
  toolbarExport: "Export",
  toolbarExportLabel: "Export",
  toolbarExportCSV: "Download as CSV",
  toolbarExportPrint: "Print",
  toolbarExportExcel: "Download as Excel",
  // Columns management text
  columnsManagementSearchTitle: "Search",
  columnsManagementNoColumns: "No columns",
  columnsManagementShowHideAllText: "Show/Hide All",
  columnsManagementReset: "Reset",
  columnsManagementDeleteIconLabel: "Clear",
  // Filter panel text
  filterPanelAddFilter: "Add filter",
  filterPanelRemoveAll: "Remove all",
  filterPanelDeleteIconLabel: "Delete",
  filterPanelLogicOperator: "Logic operator",
  filterPanelOperator: "Operator",
  filterPanelOperatorAnd: "And",
  filterPanelOperatorOr: "Or",
  filterPanelColumns: "Columns",
  filterPanelInputLabel: "Value",
  filterPanelInputPlaceholder: "Filter value",
  // Filter operators text
  filterOperatorContains: "contains",
  filterOperatorDoesNotContain: "does not contain",
  filterOperatorEquals: "equals",
  filterOperatorDoesNotEqual: "does not equal",
  filterOperatorStartsWith: "starts with",
  filterOperatorEndsWith: "ends with",
  filterOperatorIs: "is",
  filterOperatorNot: "is not",
  filterOperatorAfter: "is after",
  filterOperatorOnOrAfter: "is on or after",
  filterOperatorBefore: "is before",
  filterOperatorOnOrBefore: "is on or before",
  filterOperatorIsEmpty: "is empty",
  filterOperatorIsNotEmpty: "is not empty",
  filterOperatorIsAnyOf: "is any of",
  "filterOperator=": "=",
  "filterOperator!=": "!=",
  "filterOperator>": ">",
  "filterOperator>=": ">=",
  "filterOperator<": "<",
  "filterOperator<=": "<=",
  // Header filter operators text
  headerFilterOperatorContains: "Contains",
  headerFilterOperatorDoesNotContain: "Does not contain",
  headerFilterOperatorEquals: "Equals",
  headerFilterOperatorDoesNotEqual: "Does not equal",
  headerFilterOperatorStartsWith: "Starts with",
  headerFilterOperatorEndsWith: "Ends with",
  headerFilterOperatorIs: "Is",
  headerFilterOperatorNot: "Is not",
  headerFilterOperatorAfter: "Is after",
  headerFilterOperatorOnOrAfter: "Is on or after",
  headerFilterOperatorBefore: "Is before",
  headerFilterOperatorOnOrBefore: "Is on or before",
  headerFilterOperatorIsEmpty: "Is empty",
  headerFilterOperatorIsNotEmpty: "Is not empty",
  headerFilterOperatorIsAnyOf: "Is any of",
  "headerFilterOperator=": "Equals",
  "headerFilterOperator!=": "Not equals",
  "headerFilterOperator>": "Greater than",
  "headerFilterOperator>=": "Greater than or equal to",
  "headerFilterOperator<": "Less than",
  "headerFilterOperator<=": "Less than or equal to",
  // Filter values text
  filterValueAny: "any",
  filterValueTrue: "true",
  filterValueFalse: "false",
  // Column menu text
  columnMenuLabel: "Menu",
  columnMenuShowColumns: "Show columns",
  columnMenuManageColumns: "Manage columns",
  columnMenuFilter: "Filter",
  columnMenuHideColumn: "Hide column",
  columnMenuUnsort: "Unsort",
  columnMenuSortAsc: "Sort by ASC",
  columnMenuSortDesc: "Sort by DESC",
  // Column header text
  columnHeaderFiltersTooltipActive: (count) => count !== 1 ? `${count} active filters` : `${count} active filter`,
  columnHeaderFiltersLabel: "Show filters",
  columnHeaderSortIconLabel: "Sort",
  // Rows selected footer text
  footerRowSelected: (count) => count !== 1 ? `${count.toLocaleString()} rows selected` : `${count.toLocaleString()} row selected`,
  // Total row amount footer text
  footerTotalRows: "Total Rows:",
  // Total visible row amount footer text
  footerTotalVisibleRows: (visibleCount, totalCount) => `${visibleCount.toLocaleString()} of ${totalCount.toLocaleString()}`,
  // Checkbox selection text
  checkboxSelectionHeaderName: "Checkbox selection",
  checkboxSelectionSelectAllRows: "Select all rows",
  checkboxSelectionUnselectAllRows: "Unselect all rows",
  checkboxSelectionSelectRow: "Select row",
  checkboxSelectionUnselectRow: "Unselect row",
  // Boolean cell text
  booleanCellTrueLabel: "yes",
  booleanCellFalseLabel: "no",
  // Actions cell more text
  actionsCellMore: "more",
  // Column pinning text
  pinToLeft: "Pin to left",
  pinToRight: "Pin to right",
  unpin: "Unpin",
  // Tree Data
  treeDataGroupingHeaderName: "Group",
  treeDataExpand: "see children",
  treeDataCollapse: "hide children",
  // Grouping columns
  groupingColumnHeaderName: "Group",
  groupColumn: (name) => `Group by ${name}`,
  unGroupColumn: (name) => `Stop grouping by ${name}`,
  // Master/detail
  detailPanelToggle: "Detail panel toggle",
  expandDetailPanel: "Expand",
  collapseDetailPanel: "Collapse",
  // Used core components translation keys
  MuiTablePagination: {},
  // Row reordering text
  rowReorderingHeaderName: "Row reordering",
  // Aggregation
  aggregationMenuItemHeader: "Aggregation",
  aggregationFunctionLabelSum: "sum",
  aggregationFunctionLabelAvg: "avg",
  aggregationFunctionLabelMin: "min",
  aggregationFunctionLabelMax: "max",
  aggregationFunctionLabelSize: "size"
};
function getDataGridUtilityClass(slot) {
  return generateUtilityClass$1("MuiDataGrid", slot);
}
__name(getDataGridUtilityClass, "getDataGridUtilityClass");
const gridClasses = generateUtilityClasses$1("MuiDataGrid", ["actionsCell", "aggregationColumnHeader", "aggregationColumnHeader--alignLeft", "aggregationColumnHeader--alignCenter", "aggregationColumnHeader--alignRight", "aggregationColumnHeaderLabel", "autoHeight", "autosizing", "booleanCell", "cell--editable", "cell--editing", "cell--flex", "cell--textCenter", "cell--textLeft", "cell--textRight", "cell--rangeTop", "cell--rangeBottom", "cell--rangeLeft", "cell--rangeRight", "cell--pinnedLeft", "cell--pinnedRight", "cell--selectionMode", "cell", "cellCheckbox", "cellEmpty", "cellSkeleton", "cellOffsetLeft", "checkboxInput", "columnHeader", "columnHeader--alignCenter", "columnHeader--alignLeft", "columnHeader--alignRight", "columnHeader--dragging", "columnHeader--moving", "columnHeader--numeric", "columnHeader--sortable", "columnHeader--sorted", "columnHeader--filtered", "columnHeader--pinnedLeft", "columnHeader--pinnedRight", "columnHeader--last", "columnHeader--lastUnpinned", "columnHeader--siblingFocused", "columnHeaderCheckbox", "columnHeaderDraggableContainer", "columnHeaderTitle", "columnHeaderTitleContainer", "columnHeaderTitleContainerContent", "columnHeader--filledGroup", "columnHeader--emptyGroup", "columnHeaders", "columnSeparator--resizable", "columnSeparator--resizing", "columnSeparator--sideLeft", "columnSeparator--sideRight", "columnSeparator", "columnsManagement", "columnsManagementRow", "columnsManagementHeader", "columnsManagementSearchInput", "columnsManagementFooter", "container--top", "container--bottom", "detailPanel", "detailPanels", "detailPanelToggleCell", "detailPanelToggleCell--expanded", "footerCell", "panel", "panelHeader", "panelWrapper", "panelContent", "panelFooter", "paper", "editBooleanCell", "editInputCell", "filler", "filler--borderBottom", "filler--pinnedLeft", "filler--pinnedRight", "filterForm", "filterFormDeleteIcon", "filterFormLogicOperatorInput", "filterFormColumnInput", "filterFormOperatorInput", "filterFormValueInput", "filterIcon", "footerContainer", "headerFilterRow", "iconButtonContainer", "iconSeparator", "main", "main--hasPinnedRight", "main--hasSkeletonLoadingOverlay", "menu", "menuIcon", "menuIconButton", "menuOpen", "menuList", "overlay", "overlayWrapper", "overlayWrapperInner", "root", "root--densityStandard", "root--densityComfortable", "root--densityCompact", "root--disableUserSelection", "root--noToolbar", "row", "row--editable", "row--editing", "row--firstVisible", "row--lastVisible", "row--dragging", "row--dynamicHeight", "row--detailPanelExpanded", "row--borderBottom", "rowReorderCellPlaceholder", "rowCount", "rowReorderCellContainer", "rowReorderCell", "rowReorderCell--draggable", "rowSkeleton", "scrollArea--left", "scrollArea--right", "scrollArea", "scrollbar", "scrollbar--vertical", "scrollbar--horizontal", "scrollbarFiller", "scrollbarFiller--header", "scrollbarFiller--borderTop", "scrollbarFiller--borderBottom", "scrollbarFiller--pinnedRight", "selectedRowCount", "sortIcon", "toolbarContainer", "toolbarFilterList", "virtualScroller", "virtualScroller--hasScrollX", "virtualScrollerContent", "virtualScrollerContent--overflowed", "virtualScrollerRenderZone", "pinnedColumns", "withVerticalBorder", "withBorderColor", "cell--withRightBorder", "cell--withLeftBorder", "columnHeader--withRightBorder", "columnHeader--withLeftBorder", "treeDataGroupingCell", "treeDataGroupingCellToggle", "treeDataGroupingCellLoadingContainer", "groupingCriteriaCell", "groupingCriteriaCellToggle", "groupingCriteriaCellLoadingContainer", "pinnedRows", "pinnedRows--top", "pinnedRows--bottom", "pinnedRowsRenderZone"]);
const CLEANUP_TIMER_LOOP_MILLIS = 1e3;
const _TimerBasedCleanupTracking = class _TimerBasedCleanupTracking {
  constructor(timeout = CLEANUP_TIMER_LOOP_MILLIS) {
    this.timeouts = /* @__PURE__ */ new Map();
    this.cleanupTimeout = CLEANUP_TIMER_LOOP_MILLIS;
    this.cleanupTimeout = timeout;
  }
  register(object, unsubscribe, unregisterToken) {
    if (!this.timeouts) {
      this.timeouts = /* @__PURE__ */ new Map();
    }
    const timeout = setTimeout(() => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
      this.timeouts.delete(unregisterToken.cleanupToken);
    }, this.cleanupTimeout);
    this.timeouts.set(unregisterToken.cleanupToken, timeout);
  }
  unregister(unregisterToken) {
    const timeout = this.timeouts.get(unregisterToken.cleanupToken);
    if (timeout) {
      this.timeouts.delete(unregisterToken.cleanupToken);
      clearTimeout(timeout);
    }
  }
  reset() {
    if (this.timeouts) {
      this.timeouts.forEach((value, key) => {
        this.unregister({
          cleanupToken: key
        });
      });
      this.timeouts = void 0;
    }
  }
};
__name(_TimerBasedCleanupTracking, "TimerBasedCleanupTracking");
let TimerBasedCleanupTracking = _TimerBasedCleanupTracking;
const _FinalizationRegistryBasedCleanupTracking = class _FinalizationRegistryBasedCleanupTracking {
  constructor() {
    this.registry = new FinalizationRegistry((unsubscribe) => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
    });
  }
  register(object, unsubscribe, unregisterToken) {
    this.registry.register(object, unsubscribe, unregisterToken);
  }
  unregister(unregisterToken) {
    this.registry.unregister(unregisterToken);
  }
  // eslint-disable-next-line class-methods-use-this
  reset() {
  }
};
__name(_FinalizationRegistryBasedCleanupTracking, "FinalizationRegistryBasedCleanupTracking");
let FinalizationRegistryBasedCleanupTracking = _FinalizationRegistryBasedCleanupTracking;
var GridSignature = /* @__PURE__ */ function(GridSignature2) {
  GridSignature2["DataGrid"] = "DataGrid";
  GridSignature2["DataGridPro"] = "DataGridPro";
  GridSignature2["DataGridPremium"] = "DataGridPremium";
  return GridSignature2;
}(GridSignature || {});
const _ObjectToBeRetainedByReact = class _ObjectToBeRetainedByReact {
};
__name(_ObjectToBeRetainedByReact, "ObjectToBeRetainedByReact");
let ObjectToBeRetainedByReact = _ObjectToBeRetainedByReact;
function createUseGridApiEventHandler(registryContainer2) {
  let cleanupTokensCounter = 0;
  return /* @__PURE__ */ __name(function useGridApiEventHandler2(apiRef, eventName, handler, options) {
    if (registryContainer2.registry === null) {
      registryContainer2.registry = typeof FinalizationRegistry !== "undefined" ? new FinalizationRegistryBasedCleanupTracking() : new TimerBasedCleanupTracking();
    }
    const [objectRetainedByReact] = reactExports.useState(new ObjectToBeRetainedByReact());
    const subscription = reactExports.useRef(null);
    const handlerRef = reactExports.useRef();
    handlerRef.current = handler;
    const cleanupTokenRef = reactExports.useRef(null);
    if (!subscription.current && handlerRef.current) {
      const enhancedHandler = /* @__PURE__ */ __name((params, event, details) => {
        var _a2;
        if (!event.defaultMuiPrevented) {
          (_a2 = handlerRef.current) == null ? void 0 : _a2.call(handlerRef, params, event, details);
        }
      }, "enhancedHandler");
      subscription.current = apiRef.current.subscribeEvent(eventName, enhancedHandler, options);
      cleanupTokensCounter += 1;
      cleanupTokenRef.current = {
        cleanupToken: cleanupTokensCounter
      };
      registryContainer2.registry.register(
        objectRetainedByReact,
        // The callback below will be called once this reference stops being retained
        () => {
          var _a2;
          (_a2 = subscription.current) == null ? void 0 : _a2.call(subscription);
          subscription.current = null;
          cleanupTokenRef.current = null;
        },
        cleanupTokenRef.current
      );
    } else if (!handlerRef.current && subscription.current) {
      subscription.current();
      subscription.current = null;
      if (cleanupTokenRef.current) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
    }
    reactExports.useEffect(() => {
      if (!subscription.current && handlerRef.current) {
        const enhancedHandler = /* @__PURE__ */ __name((params, event, details) => {
          var _a2;
          if (!event.defaultMuiPrevented) {
            (_a2 = handlerRef.current) == null ? void 0 : _a2.call(handlerRef, params, event, details);
          }
        }, "enhancedHandler");
        subscription.current = apiRef.current.subscribeEvent(eventName, enhancedHandler, options);
      }
      if (cleanupTokenRef.current && registryContainer2.registry) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
      return () => {
        var _a2;
        (_a2 = subscription.current) == null ? void 0 : _a2.call(subscription);
        subscription.current = null;
      };
    }, [apiRef, eventName, options]);
  }, "useGridApiEventHandler");
}
__name(createUseGridApiEventHandler, "createUseGridApiEventHandler");
const registryContainer = {
  registry: null
};
const useGridApiEventHandler = createUseGridApiEventHandler(registryContainer);
const optionsSubscriberOptions = {
  isFirst: true
};
function useGridApiOptionHandler(apiRef, eventName, handler) {
  useGridApiEventHandler(apiRef, eventName, handler, optionsSubscriberOptions);
}
__name(useGridApiOptionHandler, "useGridApiOptionHandler");
function isOutputSelector(selector) {
  return selector.acceptsApiRef;
}
__name(isOutputSelector, "isOutputSelector");
function applySelector(apiRef, selector) {
  if (isOutputSelector(selector)) {
    return selector(apiRef);
  }
  return selector(apiRef.current.state);
}
__name(applySelector, "applySelector");
const defaultCompare = Object.is;
const objectShallowCompare = fastObjectShallowCompare;
const createRefs = /* @__PURE__ */ __name(() => ({
  state: null,
  equals: null,
  selector: null,
  args: null
}), "createRefs");
const useGridSelector = /* @__PURE__ */ __name((apiRef, selector, equals = defaultCompare) => {
  const refs = useLazyRef(createRefs);
  const didInit = refs.current.selector !== null;
  const [state, setState] = reactExports.useState(
    // We don't use an initialization function to avoid allocations
    didInit ? null : applySelector(apiRef, selector)
  );
  refs.current.state = state;
  refs.current.equals = equals;
  refs.current.selector = selector;
  useOnMount(() => {
    return apiRef.current.store.subscribe(() => {
      const newState = applySelector(apiRef, refs.current.selector);
      if (!refs.current.equals(refs.current.state, newState)) {
        refs.current.state = newState;
        setState(newState);
      }
    });
  });
  return state;
}, "useGridSelector");
const gridDimensionsSelector = /* @__PURE__ */ __name((state) => state.dimensions, "gridDimensionsSelector");
var NOT_FOUND = /* @__PURE__ */ Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
__name(assertIsFunction, "assertIsFunction");
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
__name(assertIsObject, "assertIsObject");
function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array.every((item) => typeof item === "function")) {
    const itemTypes = array.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
__name(assertIsArrayOfFunctions, "assertIsArrayOfFunctions");
var ensureIsArray = /* @__PURE__ */ __name((item) => {
  return Array.isArray(item) ? item : [item];
}, "ensureIsArray");
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
__name(getDependencies, "getDependencies");
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length: length2 } = dependencies;
  for (let i = 0; i < length2; i++) {
    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
__name(collectInputSelectorResults, "collectInputSelectorResults");
function createSingletonCache(equals) {
  let entry;
  return {
    get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put(key, value) {
      entry = { key, value };
    },
    getEntries() {
      return entry ? [entry] : [];
    },
    clear() {
      entry = void 0;
    }
  };
}
__name(createSingletonCache, "createSingletonCache");
function createLruCache(maxSize, equals) {
  let entries = [];
  function get(key) {
    const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));
    if (cacheIndex > -1) {
      const entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  __name(get, "get");
  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      entries.unshift({ key, value });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  __name(put, "put");
  function getEntries() {
    return entries;
  }
  __name(getEntries, "getEntries");
  function clear() {
    entries = [];
  }
  __name(clear, "clear");
  return { get, put, getEntries, clear };
}
__name(createLruCache, "createLruCache");
var referenceEqualityCheck = /* @__PURE__ */ __name((a, b2) => a === b2, "referenceEqualityCheck");
function createCacheKeyComparator(equalityCheck) {
  return /* @__PURE__ */ __name(function areArgumentsShallowlyEqual(prev2, next2) {
    if (prev2 === null || next2 === null || prev2.length !== next2.length) {
      return false;
    }
    const { length: length2 } = prev2;
    for (let i = 0; i < length2; i++) {
      if (!equalityCheck(prev2[i], next2[i])) {
        return false;
      }
    }
    return true;
  }, "areArgumentsShallowlyEqual");
}
__name(createCacheKeyComparator, "createCacheKeyComparator");
function lruMemoize(func, equalityCheckOrOptions) {
  const providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };
  const {
    equalityCheck = referenceEqualityCheck,
    maxSize = 1,
    resultEqualityCheck
  } = providedOptions;
  const comparator = createCacheKeyComparator(equalityCheck);
  let resultsCount = 0;
  const cache2 = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    let value = cache2.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const entries = cache2.getEntries();
        const matchingEntry = entries.find(
          (entry) => resultEqualityCheck(entry.value, value)
        );
        if (matchingEntry) {
          value = matchingEntry.value;
          resultsCount !== 0 && resultsCount--;
        }
      }
      cache2.put(arguments, value);
    }
    return value;
  }
  __name(memoized, "memoized");
  memoized.clearCache = () => {
    cache2.clear();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
__name(lruMemoize, "lruMemoize");
var StrongRef = (_b = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
}, __name(_b, "StrongRef"), _b);
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
__name(createCacheNode, "createCacheNode");
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    var _a2;
    let cacheNode = fnNode;
    const { length: length2 } = arguments;
    for (let i = 0, l2 = length2; i < l2; i++) {
      const arg = arguments[i];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = ((_a2 = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a2.call(lastResult)) ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  __name(memoized, "memoized");
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
__name(weakMapMemoize, "weakMapMemoize");
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = /* @__PURE__ */ __name((...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize: memoize2,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize2(/* @__PURE__ */ __name(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, "recomputationWrapper"), ...finalMemoizeOptions);
    const selector = argsMemoize(/* @__PURE__ */ __name(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      return lastResult;
    }, "dependenciesChecker"), ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize: memoize2,
      argsMemoize
    });
  }, "createSelector2");
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
__name(createSelectorCreator, "createSelectorCreator");
var createSelector$1 = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector$1) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index2) => {
          composition[inputSelectorKeys[index2]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);
const reselectCreateSelector = createSelectorCreator({
  memoize: lruMemoize,
  memoizeOptions: {
    maxSize: 1,
    equalityCheck: Object.is
  }
});
const cache = /* @__PURE__ */ new WeakMap();
function checkIsAPIRef(value) {
  return "current" in value && "instanceId" in value.current;
}
__name(checkIsAPIRef, "checkIsAPIRef");
const DEFAULT_INSTANCE_ID = {
  id: "default"
};
const createSelector = /* @__PURE__ */ __name((a, b2, c2, d2, e2, f2, ...other) => {
  if (other.length > 0) {
    throw new Error("Unsupported number of selectors");
  }
  let selector;
  if (a && b2 && c2 && d2 && e2 && f2) {
    selector = /* @__PURE__ */ __name((stateOrApiRef, instanceIdParam) => {
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const instanceId = instanceIdParam ?? (isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID);
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const va2 = a(state, instanceId);
      const vb2 = b2(state, instanceId);
      const vc2 = c2(state, instanceId);
      const vd2 = d2(state, instanceId);
      const ve2 = e2(state, instanceId);
      return f2(va2, vb2, vc2, vd2, ve2);
    }, "selector");
  } else if (a && b2 && c2 && d2 && e2) {
    selector = /* @__PURE__ */ __name((stateOrApiRef, instanceIdParam) => {
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const instanceId = instanceIdParam ?? (isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID);
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const va2 = a(state, instanceId);
      const vb2 = b2(state, instanceId);
      const vc2 = c2(state, instanceId);
      const vd2 = d2(state, instanceId);
      return e2(va2, vb2, vc2, vd2);
    }, "selector");
  } else if (a && b2 && c2 && d2) {
    selector = /* @__PURE__ */ __name((stateOrApiRef, instanceIdParam) => {
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const instanceId = instanceIdParam ?? (isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID);
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const va2 = a(state, instanceId);
      const vb2 = b2(state, instanceId);
      const vc2 = c2(state, instanceId);
      return d2(va2, vb2, vc2);
    }, "selector");
  } else if (a && b2 && c2) {
    selector = /* @__PURE__ */ __name((stateOrApiRef, instanceIdParam) => {
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const instanceId = instanceIdParam ?? (isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID);
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const va2 = a(state, instanceId);
      const vb2 = b2(state, instanceId);
      return c2(va2, vb2);
    }, "selector");
  } else if (a && b2) {
    selector = /* @__PURE__ */ __name((stateOrApiRef, instanceIdParam) => {
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const instanceId = instanceIdParam ?? (isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID);
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const va2 = a(state, instanceId);
      return b2(va2);
    }, "selector");
  } else {
    throw new Error("Missing arguments");
  }
  selector.acceptsApiRef = true;
  return selector;
}, "createSelector");
const createSelectorMemoized = /* @__PURE__ */ __name((...args) => {
  const selector = /* @__PURE__ */ __name((stateOrApiRef, instanceId) => {
    const isAPIRef = checkIsAPIRef(stateOrApiRef);
    const cacheKey = isAPIRef ? stateOrApiRef.current.instanceId : instanceId ?? DEFAULT_INSTANCE_ID;
    const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
    const cacheArgsInit = cache.get(cacheKey);
    const cacheArgs = cacheArgsInit ?? /* @__PURE__ */ new Map();
    const cacheFn = cacheArgs == null ? void 0 : cacheArgs.get(args);
    if (cacheArgs && cacheFn) {
      return cacheFn(state, cacheKey);
    }
    const fn2 = reselectCreateSelector(...args);
    if (!cacheArgsInit) {
      cache.set(cacheKey, cacheArgs);
    }
    cacheArgs.set(args, fn2);
    return fn2(state, cacheKey);
  }, "selector");
  selector.acceptsApiRef = true;
  return selector;
}, "createSelectorMemoized");
const COMPACT_DENSITY_FACTOR = 0.7;
const COMFORTABLE_DENSITY_FACTOR = 1.3;
const DENSITY_FACTORS = {
  compact: COMPACT_DENSITY_FACTOR,
  comfortable: COMFORTABLE_DENSITY_FACTOR,
  standard: 1
};
const gridDensitySelector = /* @__PURE__ */ __name((state) => state.density, "gridDensitySelector");
const gridDensityFactorSelector = createSelector(gridDensitySelector, (density) => DENSITY_FACTORS[density]);
let GridPinnedColumnPosition = /* @__PURE__ */ function(GridPinnedColumnPosition2) {
  GridPinnedColumnPosition2["LEFT"] = "left";
  GridPinnedColumnPosition2["RIGHT"] = "right";
  return GridPinnedColumnPosition2;
}({});
const EMPTY_PINNED_COLUMN_FIELDS = {
  left: [],
  right: []
};
const gridIsRtlSelector = /* @__PURE__ */ __name((state) => state.isRtl, "gridIsRtlSelector");
const gridColumnsStateSelector = /* @__PURE__ */ __name((state) => state.columns, "gridColumnsStateSelector");
const gridColumnFieldsSelector = createSelector(gridColumnsStateSelector, (columnsState) => columnsState.orderedFields);
const gridColumnLookupSelector = createSelector(gridColumnsStateSelector, (columnsState) => columnsState.lookup);
const gridColumnDefinitionsSelector = createSelectorMemoized(gridColumnFieldsSelector, gridColumnLookupSelector, (allFields, lookup) => allFields.map((field) => lookup[field]));
const gridColumnVisibilityModelSelector = createSelector(gridColumnsStateSelector, (columnsState) => columnsState.columnVisibilityModel);
const gridVisibleColumnDefinitionsSelector = createSelectorMemoized(gridColumnDefinitionsSelector, gridColumnVisibilityModelSelector, (columns2, columnVisibilityModel) => columns2.filter((column2) => columnVisibilityModel[column2.field] !== false));
const gridVisibleColumnFieldsSelector = createSelectorMemoized(gridVisibleColumnDefinitionsSelector, (visibleColumns) => visibleColumns.map((column2) => column2.field));
const gridPinnedColumnsSelector = /* @__PURE__ */ __name((state) => state.pinnedColumns, "gridPinnedColumnsSelector");
const gridVisiblePinnedColumnDefinitionsSelector = createSelectorMemoized(gridColumnsStateSelector, gridPinnedColumnsSelector, gridVisibleColumnFieldsSelector, gridIsRtlSelector, (columnsState, model, visibleColumnFields, isRtl) => {
  const visiblePinnedFields = filterVisibleColumns(model, visibleColumnFields, isRtl);
  const visiblePinnedColumns = {
    left: visiblePinnedFields.left.map((field) => columnsState.lookup[field]),
    right: visiblePinnedFields.right.map((field) => columnsState.lookup[field])
  };
  return visiblePinnedColumns;
});
function filterVisibleColumns(pinnedColumns, columns2, invert) {
  var _a2, _b2;
  if (!Array.isArray(pinnedColumns.left) && !Array.isArray(pinnedColumns.right)) {
    return EMPTY_PINNED_COLUMN_FIELDS;
  }
  if (((_a2 = pinnedColumns.left) == null ? void 0 : _a2.length) === 0 && ((_b2 = pinnedColumns.right) == null ? void 0 : _b2.length) === 0) {
    return EMPTY_PINNED_COLUMN_FIELDS;
  }
  const filter3 = /* @__PURE__ */ __name((newPinnedColumns, remainingColumns) => {
    if (!Array.isArray(newPinnedColumns)) {
      return [];
    }
    return newPinnedColumns.filter((field) => remainingColumns.includes(field));
  }, "filter");
  const leftPinnedColumns = filter3(pinnedColumns.left, columns2);
  const columnsWithoutLeftPinnedColumns = columns2.filter(
    // Filter out from the remaining columns those columns already pinned to the left
    (field) => !leftPinnedColumns.includes(field)
  );
  const rightPinnedColumns = filter3(pinnedColumns.right, columnsWithoutLeftPinnedColumns);
  if (invert) {
    return {
      left: rightPinnedColumns,
      right: leftPinnedColumns
    };
  }
  return {
    left: leftPinnedColumns,
    right: rightPinnedColumns
  };
}
__name(filterVisibleColumns, "filterVisibleColumns");
const gridColumnPositionsSelector = createSelectorMemoized(gridVisibleColumnDefinitionsSelector, (visibleColumns) => {
  const positions = [];
  let currentPosition = 0;
  for (let i = 0; i < visibleColumns.length; i += 1) {
    positions.push(currentPosition);
    currentPosition += visibleColumns[i].computedWidth;
  }
  return positions;
});
const gridColumnsTotalWidthSelector = createSelector(gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector, (visibleColumns, positions) => {
  const colCount = visibleColumns.length;
  if (colCount === 0) {
    return 0;
  }
  return positions[colCount - 1] + visibleColumns[colCount - 1].computedWidth;
});
const gridFilterableColumnDefinitionsSelector = createSelectorMemoized(gridColumnDefinitionsSelector, (columns2) => columns2.filter((col) => col.filterable));
const gridFilterableColumnLookupSelector = createSelectorMemoized(gridColumnDefinitionsSelector, (columns2) => columns2.reduce((acc, col) => {
  if (col.filterable) {
    acc[col.field] = col;
  }
  return acc;
}, {}));
const gridHasColSpanSelector = createSelectorMemoized(gridColumnDefinitionsSelector, (columns2) => columns2.some((column2) => column2.colSpan !== void 0));
const _excluded$11 = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "hasFocus", "isValidating", "debounceMs", "isProcessingProps", "onValueChange"];
const useUtilityClasses$M = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["editInputCell"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$M");
const GridEditInputCellRoot = styled(InputBase, {
  name: "MuiDataGrid",
  slot: "EditInputCell",
  overridesResolver: (props, styles2) => styles2.editInputCell
})(({
  theme: theme2
}) => _extends$4({}, theme2.typography.body2, {
  padding: "1px 0",
  "& input": {
    padding: "0 16px",
    height: "100%"
  }
}));
const GridEditInputCell = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  const rootProps = useGridRootProps();
  const {
    id: id2,
    value,
    field,
    colDef,
    hasFocus,
    debounceMs = 200,
    isProcessingProps,
    onValueChange
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$11);
  const apiRef = useGridApiContext();
  const inputRef = reactExports.useRef();
  const [valueState, setValueState] = reactExports.useState(value);
  const classes2 = useUtilityClasses$M(rootProps);
  const handleChange = reactExports.useCallback(async (event) => {
    const newValue = event.target.value;
    if (onValueChange) {
      await onValueChange(event, newValue);
    }
    const column2 = apiRef.current.getColumn(field);
    let parsedValue = newValue;
    if (column2.valueParser) {
      parsedValue = column2.valueParser(newValue, apiRef.current.getRow(id2), column2, apiRef);
    }
    setValueState(parsedValue);
    apiRef.current.setEditCellValue({
      id: id2,
      field,
      value: parsedValue,
      debounceMs,
      unstable_skipValueParser: true
    }, event);
  }, [apiRef, debounceMs, field, id2, onValueChange]);
  const meta = apiRef.current.unstable_getEditCellMeta(id2, field);
  reactExports.useEffect(() => {
    if ((meta == null ? void 0 : meta.changeReason) !== "debouncedSetEditCellValue") {
      setValueState(value);
    }
  }, [meta, value]);
  useEnhancedEffect(() => {
    if (hasFocus) {
      inputRef.current.focus();
    }
  }, [hasFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditInputCellRoot, _extends$4({
    ref,
    inputRef,
    className: classes2.root,
    ownerState: rootProps,
    fullWidth: true,
    type: colDef.type === "number" ? colDef.type : "text",
    value: valueState ?? "",
    onChange: handleChange,
    endAdornment: isProcessingProps ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadIcon, {
      fontSize: "small",
      color: "action"
    }) : void 0
  }, other));
});
const renderEditInputCell = /* @__PURE__ */ __name((params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditInputCell, _extends$4({}, params)), "renderEditInputCell");
const sanitizeSortModel = /* @__PURE__ */ __name((model, disableMultipleColumnsSorting) => {
  if (disableMultipleColumnsSorting && model.length > 1) {
    return [model[0]];
  }
  return model;
}, "sanitizeSortModel");
const mergeStateWithSortModel = /* @__PURE__ */ __name((sortModel, disableMultipleColumnsSorting) => (state) => _extends$4({}, state, {
  sorting: _extends$4({}, state.sorting, {
    sortModel: sanitizeSortModel(sortModel, disableMultipleColumnsSorting)
  })
}), "mergeStateWithSortModel");
const isDesc = /* @__PURE__ */ __name((direction) => direction === "desc", "isDesc");
const parseSortItem = /* @__PURE__ */ __name((sortItem, apiRef) => {
  const column2 = apiRef.current.getColumn(sortItem.field);
  if (!column2 || sortItem.sort === null) {
    return null;
  }
  let comparator;
  if (column2.getSortComparator) {
    comparator = column2.getSortComparator(sortItem.sort);
  } else {
    comparator = isDesc(sortItem.sort) ? (...args) => -1 * column2.sortComparator(...args) : column2.sortComparator;
  }
  if (!comparator) {
    return null;
  }
  const getSortCellParams = /* @__PURE__ */ __name((id2) => ({
    id: id2,
    field: column2.field,
    rowNode: apiRef.current.getRowNode(id2),
    value: apiRef.current.getCellValue(id2, column2.field),
    api: apiRef.current
  }), "getSortCellParams");
  return {
    getSortCellParams,
    comparator
  };
}, "parseSortItem");
const compareRows = /* @__PURE__ */ __name((parsedSortItems, row1, row2) => {
  return parsedSortItems.reduce((res, item, index2) => {
    if (res !== 0) {
      return res;
    }
    const sortCellParams1 = row1.params[index2];
    const sortCellParams2 = row2.params[index2];
    res = item.comparator(sortCellParams1.value, sortCellParams2.value, sortCellParams1, sortCellParams2);
    return res;
  }, 0);
}, "compareRows");
const buildAggregatedSortingApplier = /* @__PURE__ */ __name((sortModel, apiRef) => {
  const comparatorList = sortModel.map((item) => parseSortItem(item, apiRef)).filter((comparator) => !!comparator);
  if (comparatorList.length === 0) {
    return null;
  }
  return (rowList) => rowList.map((node2) => ({
    node: node2,
    params: comparatorList.map((el2) => el2.getSortCellParams(node2.id))
  })).sort((a, b2) => compareRows(comparatorList, a, b2)).map((row) => row.node.id);
}, "buildAggregatedSortingApplier");
const getNextGridSortDirection = /* @__PURE__ */ __name((sortingOrder, current) => {
  const currentIdx = sortingOrder.indexOf(current);
  if (!current || currentIdx === -1 || currentIdx + 1 === sortingOrder.length) {
    return sortingOrder[0];
  }
  return sortingOrder[currentIdx + 1];
}, "getNextGridSortDirection");
const gridNillComparator = /* @__PURE__ */ __name((v1, v2) => {
  if (v1 == null && v2 != null) {
    return -1;
  }
  if (v2 == null && v1 != null) {
    return 1;
  }
  if (v1 == null && v2 == null) {
    return 0;
  }
  return null;
}, "gridNillComparator");
const collator$2 = new Intl.Collator();
const gridStringOrNumberComparator = /* @__PURE__ */ __name((value1, value2) => {
  const nillResult = gridNillComparator(value1, value2);
  if (nillResult !== null) {
    return nillResult;
  }
  if (typeof value1 === "string") {
    return collator$2.compare(value1.toString(), value2.toString());
  }
  return value1 - value2;
}, "gridStringOrNumberComparator");
const gridNumberComparator = /* @__PURE__ */ __name((value1, value2) => {
  const nillResult = gridNillComparator(value1, value2);
  if (nillResult !== null) {
    return nillResult;
  }
  return Number(value1) - Number(value2);
}, "gridNumberComparator");
const gridDateComparator = /* @__PURE__ */ __name((value1, value2) => {
  const nillResult = gridNillComparator(value1, value2);
  if (nillResult !== null) {
    return nillResult;
  }
  if (value1 > value2) {
    return 1;
  }
  if (value1 < value2) {
    return -1;
  }
  return 0;
}, "gridDateComparator");
const _excluded$10 = ["item", "applyValue", "type", "apiRef", "focusElementRef", "tabIndex", "disabled", "isFilterActive", "clearButton", "InputProps", "variant"];
function GridFilterInputValue(props) {
  var _a2;
  const {
    item,
    applyValue,
    type,
    apiRef,
    focusElementRef,
    tabIndex,
    disabled,
    clearButton,
    InputProps,
    variant = "standard"
  } = props, others = _objectWithoutPropertiesLoose$1(props, _excluded$10);
  const filterTimeout = useTimeout();
  const [filterValueState, setFilterValueState] = reactExports.useState(item.value ?? "");
  const [applying, setIsApplying] = reactExports.useState(false);
  const id2 = useId();
  const rootProps = useGridRootProps();
  const onFilterChange = reactExports.useCallback((event) => {
    const {
      value
    } = event.target;
    setFilterValueState(String(value));
    setIsApplying(true);
    filterTimeout.start(rootProps.filterDebounceMs, () => {
      const newItem = _extends$4({}, item, {
        value: type === "number" ? Number(value) : value,
        fromInput: id2
      });
      applyValue(newItem);
      setIsApplying(false);
    });
  }, [filterTimeout, rootProps.filterDebounceMs, item, type, id2, applyValue]);
  reactExports.useEffect(() => {
    const itemPlusTag = item;
    if (itemPlusTag.fromInput !== id2 || item.value === void 0) {
      setFilterValueState(String(item.value ?? ""));
    }
  }, [id2, item]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends$4({
    id: id2,
    label: apiRef.current.getLocaleText("filterPanelInputLabel"),
    placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
    value: filterValueState,
    onChange: onFilterChange,
    variant,
    type: type || "text",
    InputProps: _extends$4({}, applying || clearButton ? {
      endAdornment: applying ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadIcon, {
        fontSize: "small",
        color: "action"
      }) : clearButton
    } : {}, {
      disabled
    }, InputProps, {
      inputProps: _extends$4({
        tabIndex
      }, InputProps == null ? void 0 : InputProps.inputProps)
    }),
    InputLabelProps: {
      shrink: true
    },
    inputRef: focusElementRef
  }, others, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseTextField));
}
__name(GridFilterInputValue, "GridFilterInputValue");
function isNumber$1(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
__name(isNumber$1, "isNumber$1");
function isFunction$1(value) {
  return typeof value === "function";
}
__name(isFunction$1, "isFunction$1");
function isObject$2(value) {
  return typeof value === "object" && value !== null;
}
__name(isObject$2, "isObject$2");
function localStorageAvailable() {
  try {
    const key = "__some_random_key_you_are_not_going_to_use__";
    window.localStorage.setItem(key, key);
    window.localStorage.removeItem(key);
    return true;
  } catch (err) {
    return false;
  }
}
__name(localStorageAvailable, "localStorageAvailable");
function escapeRegExp(value) {
  return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
__name(escapeRegExp, "escapeRegExp");
const clamp$3 = /* @__PURE__ */ __name((value, min2, max2) => Math.max(min2, Math.min(max2, value)), "clamp$3");
function range(from2, to) {
  return Array.from({
    length: to - from2
  }).map((_2, i) => from2 + i);
}
__name(range, "range");
function isDeepEqual(a, b2) {
  if (a === b2) {
    return true;
  }
  if (a && b2 && typeof a === "object" && typeof b2 === "object") {
    if (a.constructor !== b2.constructor) {
      return false;
    }
    if (Array.isArray(a)) {
      const length3 = a.length;
      if (length3 !== b2.length) {
        return false;
      }
      for (let i = 0; i < length3; i += 1) {
        if (!isDeepEqual(a[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    if (a instanceof Map && b2 instanceof Map) {
      if (a.size !== b2.size) {
        return false;
      }
      const entriesA = Array.from(a.entries());
      for (let i = 0; i < entriesA.length; i += 1) {
        if (!b2.has(entriesA[i][0])) {
          return false;
        }
      }
      for (let i = 0; i < entriesA.length; i += 1) {
        const entryA = entriesA[i];
        if (!isDeepEqual(entryA[1], b2.get(entryA[0]))) {
          return false;
        }
      }
      return true;
    }
    if (a instanceof Set && b2 instanceof Set) {
      if (a.size !== b2.size) {
        return false;
      }
      const entries = Array.from(a.entries());
      for (let i = 0; i < entries.length; i += 1) {
        if (!b2.has(entries[i][0])) {
          return false;
        }
      }
      return true;
    }
    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b2)) {
      const length3 = a.length;
      if (length3 !== b2.length) {
        return false;
      }
      for (let i = 0; i < length3; i += 1) {
        if (a[i] !== b2[i]) {
          return false;
        }
      }
      return true;
    }
    if (a.constructor === RegExp) {
      return a.source === b2.source && a.flags === b2.flags;
    }
    if (a.valueOf !== Object.prototype.valueOf) {
      return a.valueOf() === b2.valueOf();
    }
    if (a.toString !== Object.prototype.toString) {
      return a.toString() === b2.toString();
    }
    const keys = Object.keys(a);
    const length2 = keys.length;
    if (length2 !== Object.keys(b2).length) {
      return false;
    }
    for (let i = 0; i < length2; i += 1) {
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i])) {
        return false;
      }
    }
    for (let i = 0; i < length2; i += 1) {
      const key = keys[i];
      if (!isDeepEqual(a[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b2 !== b2;
}
__name(isDeepEqual, "isDeepEqual");
function mulberry32(a) {
  return () => {
    let t2 = a += 1831565813;
    t2 = Math.imul(t2 ^ t2 >>> 15, t2 | 1);
    t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, t2 | 61);
    return ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
  };
}
__name(mulberry32, "mulberry32");
function createRandomNumberGenerator(seed) {
  const random = mulberry32(seed);
  return (min2, max2) => min2 + (max2 - min2) * random();
}
__name(createRandomNumberGenerator, "createRandomNumberGenerator");
function deepClone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
__name(deepClone, "deepClone");
const _excluded$$ = ["item", "applyValue", "type", "apiRef", "focusElementRef", "color", "error", "helperText", "size", "variant"], _excluded2$9 = ["key"];
function GridFilterInputMultipleValue(props) {
  const {
    item,
    applyValue,
    type,
    apiRef,
    focusElementRef,
    color: color2,
    error,
    helperText,
    size: size2,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$$);
  const TextFieldProps = {
    color: color2,
    error,
    helperText,
    size: size2,
    variant
  };
  const [filterValueState, setFilterValueState] = reactExports.useState(item.value || []);
  const id2 = useId();
  const rootProps = useGridRootProps();
  reactExports.useEffect(() => {
    const itemValue = item.value ?? [];
    setFilterValueState(itemValue.map(String));
  }, [item.value]);
  const handleChange = reactExports.useCallback((event, value) => {
    setFilterValueState(value.map(String));
    applyValue(_extends$4({}, item, {
      value: [...value.map((filterItemValue) => type === "number" ? Number(filterItemValue) : filterItemValue)]
    }));
  }, [applyValue, item, type]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete, _extends$4({
    multiple: true,
    freeSolo: true,
    options: [],
    filterOptions: (options, params) => {
      const {
        inputValue
      } = params;
      return inputValue == null || inputValue === "" ? [] : [inputValue];
    },
    id: id2,
    value: filterValueState,
    onChange: handleChange,
    renderTags: (value, getTagProps) => value.map((option, index2) => {
      const _getTagProps = getTagProps({
        index: index2
      }), {
        key
      } = _getTagProps, tagProps = _objectWithoutPropertiesLoose$1(_getTagProps, _excluded2$9);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseChip, _extends$4({
        variant: "outlined",
        size: "small",
        label: option
      }, tagProps), key);
    }),
    renderInput: (params) => {
      var _a2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends$4({}, params, {
        label: apiRef.current.getLocaleText("filterPanelInputLabel"),
        placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
        InputLabelProps: _extends$4({}, params.InputLabelProps, {
          shrink: true
        }),
        inputRef: focusElementRef,
        type: type || "text"
      }, TextFieldProps, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseTextField));
    }
  }, other));
}
__name(GridFilterInputMultipleValue, "GridFilterInputMultipleValue");
var GridEditModes = /* @__PURE__ */ function(GridEditModes2) {
  GridEditModes2["Cell"] = "cell";
  GridEditModes2["Row"] = "row";
  return GridEditModes2;
}(GridEditModes || {});
var GridCellModes = /* @__PURE__ */ function(GridCellModes2) {
  GridCellModes2["Edit"] = "edit";
  GridCellModes2["View"] = "view";
  return GridCellModes2;
}(GridCellModes || {});
var GridRowModes = /* @__PURE__ */ function(GridRowModes2) {
  GridRowModes2["Edit"] = "edit";
  GridRowModes2["View"] = "view";
  return GridRowModes2;
}(GridRowModes || {});
var GridLogicOperator = /* @__PURE__ */ function(GridLogicOperator2) {
  GridLogicOperator2["And"] = "and";
  GridLogicOperator2["Or"] = "or";
  return GridLogicOperator2;
}(GridLogicOperator || {});
var GridCellEditStartReasons = /* @__PURE__ */ function(GridCellEditStartReasons2) {
  GridCellEditStartReasons2["enterKeyDown"] = "enterKeyDown";
  GridCellEditStartReasons2["cellDoubleClick"] = "cellDoubleClick";
  GridCellEditStartReasons2["printableKeyDown"] = "printableKeyDown";
  GridCellEditStartReasons2["deleteKeyDown"] = "deleteKeyDown";
  GridCellEditStartReasons2["pasteKeyDown"] = "pasteKeyDown";
  return GridCellEditStartReasons2;
}(GridCellEditStartReasons || {});
var GridCellEditStopReasons = /* @__PURE__ */ function(GridCellEditStopReasons2) {
  GridCellEditStopReasons2["cellFocusOut"] = "cellFocusOut";
  GridCellEditStopReasons2["escapeKeyDown"] = "escapeKeyDown";
  GridCellEditStopReasons2["enterKeyDown"] = "enterKeyDown";
  GridCellEditStopReasons2["tabKeyDown"] = "tabKeyDown";
  GridCellEditStopReasons2["shiftTabKeyDown"] = "shiftTabKeyDown";
  return GridCellEditStopReasons2;
}(GridCellEditStopReasons || {});
var GridRowEditStartReasons = /* @__PURE__ */ function(GridRowEditStartReasons2) {
  GridRowEditStartReasons2["enterKeyDown"] = "enterKeyDown";
  GridRowEditStartReasons2["cellDoubleClick"] = "cellDoubleClick";
  GridRowEditStartReasons2["printableKeyDown"] = "printableKeyDown";
  GridRowEditStartReasons2["deleteKeyDown"] = "deleteKeyDown";
  return GridRowEditStartReasons2;
}(GridRowEditStartReasons || {});
var GridRowEditStopReasons = /* @__PURE__ */ function(GridRowEditStopReasons2) {
  GridRowEditStopReasons2["rowFocusOut"] = "rowFocusOut";
  GridRowEditStopReasons2["escapeKeyDown"] = "escapeKeyDown";
  GridRowEditStopReasons2["enterKeyDown"] = "enterKeyDown";
  GridRowEditStopReasons2["tabKeyDown"] = "tabKeyDown";
  GridRowEditStopReasons2["shiftTabKeyDown"] = "shiftTabKeyDown";
  return GridRowEditStopReasons2;
}(GridRowEditStopReasons || {});
function isLeaf(node2) {
  return node2.field !== void 0;
}
__name(isLeaf, "isLeaf");
const getDefaultGridFilterModel = /* @__PURE__ */ __name(() => ({
  items: [],
  logicOperator: GridLogicOperator.And,
  quickFilterValues: [],
  quickFilterLogicOperator: GridLogicOperator.And
}), "getDefaultGridFilterModel");
function getPublicApiRef(apiRef) {
  return {
    current: apiRef.current.getPublicApi()
  };
}
__name(getPublicApiRef, "getPublicApiRef");
let hasEval;
function getHasEval() {
  if (hasEval !== void 0) {
    return hasEval;
  }
  try {
    hasEval = new Function("return true")();
  } catch (_2) {
    hasEval = false;
  }
  return hasEval;
}
__name(getHasEval, "getHasEval");
const cleanFilterItem = /* @__PURE__ */ __name((item, apiRef) => {
  const cleanItem = _extends$4({}, item);
  if (cleanItem.id == null) {
    cleanItem.id = Math.round(Math.random() * 1e5);
  }
  if (cleanItem.operator == null) {
    const column2 = gridColumnLookupSelector(apiRef)[cleanItem.field];
    cleanItem.operator = column2 && column2.filterOperators[0].value;
  }
  return cleanItem;
}, "cleanFilterItem");
const sanitizeFilterModel = /* @__PURE__ */ __name((model, disableMultipleColumnsFiltering, apiRef) => {
  const hasSeveralItems = model.items.length > 1;
  let items;
  if (hasSeveralItems && disableMultipleColumnsFiltering) {
    items = [model.items[0]];
  } else {
    items = model.items;
  }
  const hasItemsWithoutIds = hasSeveralItems && items.some((item) => item.id == null);
  const hasItemWithoutOperator = items.some((item) => item.operator == null);
  if (hasItemWithoutOperator || hasItemsWithoutIds) {
    return _extends$4({}, model, {
      items: items.map((item) => cleanFilterItem(item, apiRef))
    });
  }
  if (model.items !== items) {
    return _extends$4({}, model, {
      items
    });
  }
  return model;
}, "sanitizeFilterModel");
const mergeStateWithFilterModel = /* @__PURE__ */ __name((filterModel, disableMultipleColumnsFiltering, apiRef) => (filteringState) => _extends$4({}, filteringState, {
  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)
}), "mergeStateWithFilterModel");
const removeDiacritics = /* @__PURE__ */ __name((value) => {
  if (typeof value === "string") {
    return value.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  }
  return value;
}, "removeDiacritics");
const getFilterCallbackFromItem = /* @__PURE__ */ __name((filterItem, apiRef) => {
  var _a2;
  if (!filterItem.field || !filterItem.operator) {
    return null;
  }
  const column2 = apiRef.current.getColumn(filterItem.field);
  if (!column2) {
    return null;
  }
  let parsedValue;
  if (column2.valueParser) {
    const parser = column2.valueParser;
    parsedValue = Array.isArray(filterItem.value) ? (_a2 = filterItem.value) == null ? void 0 : _a2.map((x2) => parser(x2, void 0, column2, apiRef)) : parser(filterItem.value, void 0, column2, apiRef);
  } else {
    parsedValue = filterItem.value;
  }
  const {
    ignoreDiacritics
  } = apiRef.current.rootProps;
  if (ignoreDiacritics) {
    parsedValue = removeDiacritics(parsedValue);
  }
  const newFilterItem = _extends$4({}, filterItem, {
    value: parsedValue
  });
  const filterOperators = column2.filterOperators;
  if (!(filterOperators == null ? void 0 : filterOperators.length)) {
    throw new Error(`MUI X: No filter operators found for column '${column2.field}'.`);
  }
  const filterOperator = filterOperators.find((operator) => operator.value === newFilterItem.operator);
  if (!filterOperator) {
    throw new Error(`MUI X: No filter operator found for column '${column2.field}' and operator value '${newFilterItem.operator}'.`);
  }
  const publicApiRef = getPublicApiRef(apiRef);
  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column2);
  if (typeof applyFilterOnRow !== "function") {
    return null;
  }
  return {
    item: newFilterItem,
    fn: (row) => {
      let value = apiRef.current.getRowValue(row, column2);
      if (ignoreDiacritics) {
        value = removeDiacritics(value);
      }
      return applyFilterOnRow(value, row, column2, publicApiRef);
    }
  };
}, "getFilterCallbackFromItem");
let filterItemsApplierId = 1;
const buildAggregatedFilterItemsApplier = /* @__PURE__ */ __name((filterModel, apiRef, disableEval) => {
  const {
    items
  } = filterModel;
  const appliers = items.map((item) => getFilterCallbackFromItem(item, apiRef)).filter((callback) => !!callback);
  if (appliers.length === 0) {
    return null;
  }
  if (disableEval || !getHasEval()) {
    return (row, shouldApplyFilter) => {
      const resultPerItemId = {};
      for (let i = 0; i < appliers.length; i += 1) {
        const applier = appliers[i];
        if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {
          resultPerItemId[applier.item.id] = applier.fn(row);
        }
      }
      return resultPerItemId;
    };
  }
  const filterItemCore = new Function("appliers", "row", "shouldApplyFilter", `"use strict";
${appliers.map((applier, i) => `const shouldApply${i} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(applier.item.field)});`).join("\n")}

const result$$ = {
${appliers.map((applier, i) => `  ${JSON.stringify(String(applier.item.id))}: !shouldApply${i} ? false : appliers[${i}].fn(row),`).join("\n")}
};

return result$$;`.replaceAll("$$", String(filterItemsApplierId)));
  filterItemsApplierId += 1;
  const filterItem = /* @__PURE__ */ __name((row, shouldApplyItem) => filterItemCore(appliers, row, shouldApplyItem), "filterItem");
  return filterItem;
}, "buildAggregatedFilterItemsApplier");
const shouldQuickFilterExcludeHiddenColumns = /* @__PURE__ */ __name((filterModel) => {
  return filterModel.quickFilterExcludeHiddenColumns ?? true;
}, "shouldQuickFilterExcludeHiddenColumns");
const buildAggregatedQuickFilterApplier = /* @__PURE__ */ __name((filterModel, apiRef) => {
  var _a2;
  const quickFilterValues = ((_a2 = filterModel.quickFilterValues) == null ? void 0 : _a2.filter(Boolean)) ?? [];
  if (quickFilterValues.length === 0) {
    return null;
  }
  const columnFields = shouldQuickFilterExcludeHiddenColumns(filterModel) ? gridVisibleColumnFieldsSelector(apiRef) : gridColumnFieldsSelector(apiRef);
  const appliersPerField = [];
  const {
    ignoreDiacritics
  } = apiRef.current.rootProps;
  const publicApiRef = getPublicApiRef(apiRef);
  columnFields.forEach((field) => {
    const column2 = apiRef.current.getColumn(field);
    const getApplyQuickFilterFn = column2 == null ? void 0 : column2.getApplyQuickFilterFn;
    if (getApplyQuickFilterFn) {
      appliersPerField.push({
        column: column2,
        appliers: quickFilterValues.map((quickFilterValue) => {
          const value = ignoreDiacritics ? removeDiacritics(quickFilterValue) : quickFilterValue;
          return {
            fn: getApplyQuickFilterFn(value, column2, publicApiRef)
          };
        })
      });
    }
  });
  return /* @__PURE__ */ __name(function isRowMatchingQuickFilter(row, shouldApplyFilter) {
    const result = {};
    outer:
      for (let v2 = 0; v2 < quickFilterValues.length; v2 += 1) {
        const filterValue = quickFilterValues[v2];
        for (let i = 0; i < appliersPerField.length; i += 1) {
          const {
            column: column2,
            appliers
          } = appliersPerField[i];
          const {
            field
          } = column2;
          if (shouldApplyFilter && !shouldApplyFilter(field)) {
            continue;
          }
          const applier = appliers[v2];
          let value = apiRef.current.getRowValue(row, column2);
          if (applier.fn === null) {
            continue;
          }
          if (ignoreDiacritics) {
            value = removeDiacritics(value);
          }
          const isMatching = applier.fn(value, row, column2, publicApiRef);
          if (isMatching) {
            result[filterValue] = true;
            continue outer;
          }
        }
        result[filterValue] = false;
      }
    return result;
  }, "isRowMatchingQuickFilter");
}, "buildAggregatedQuickFilterApplier");
const buildAggregatedFilterApplier = /* @__PURE__ */ __name((filterModel, apiRef, disableEval) => {
  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef, disableEval);
  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);
  return /* @__PURE__ */ __name(function isRowMatchingFilters(row, shouldApplyFilter, result) {
    result.passingFilterItems = (isRowMatchingFilterItems == null ? void 0 : isRowMatchingFilterItems(row, shouldApplyFilter)) ?? null;
    result.passingQuickFilterValues = (isRowMatchingQuickFilter == null ? void 0 : isRowMatchingQuickFilter(row, shouldApplyFilter)) ?? null;
  }, "isRowMatchingFilters");
}, "buildAggregatedFilterApplier");
const isNotNull$1 = /* @__PURE__ */ __name((result) => result != null, "isNotNull$1");
const filterModelItems = /* @__PURE__ */ __name((cache2, apiRef, items) => {
  if (!cache2.cleanedFilterItems) {
    cache2.cleanedFilterItems = items.filter((item) => getFilterCallbackFromItem(item, apiRef) !== null);
  }
  return cache2.cleanedFilterItems;
}, "filterModelItems");
const passFilterLogic = /* @__PURE__ */ __name((allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache2) => {
  const cleanedFilterItems = filterModelItems(cache2, apiRef, filterModel.items);
  const cleanedFilterItemResults = allFilterItemResults.filter(isNotNull$1);
  const cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull$1);
  if (cleanedFilterItemResults.length > 0) {
    const filterItemPredicate = /* @__PURE__ */ __name((item) => {
      return cleanedFilterItemResults.some((filterItemResult) => filterItemResult[item.id]);
    }, "filterItemPredicate");
    const logicOperator = filterModel.logicOperator ?? getDefaultGridFilterModel().logicOperator;
    if (logicOperator === GridLogicOperator.And) {
      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);
      if (!passesAllFilters) {
        return false;
      }
    } else {
      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);
      if (!passesSomeFilters) {
        return false;
      }
    }
  }
  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {
    const quickFilterValuePredicate = /* @__PURE__ */ __name((value) => {
      return cleanedQuickFilterResults.some((quickFilterValueResult) => quickFilterValueResult[value]);
    }, "quickFilterValuePredicate");
    const quickFilterLogicOperator = filterModel.quickFilterLogicOperator ?? getDefaultGridFilterModel().quickFilterLogicOperator;
    if (quickFilterLogicOperator === GridLogicOperator.And) {
      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);
      if (!passesAllQuickFilterValues) {
        return false;
      }
    } else {
      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);
      if (!passesSomeQuickFilterValues) {
        return false;
      }
    }
  }
  return true;
}, "passFilterLogic");
const getGridStringQuickFilterFn = /* @__PURE__ */ __name((value) => {
  if (!value) {
    return null;
  }
  const filterRegex = new RegExp(escapeRegExp(value), "i");
  return (_2, row, column2, apiRef) => {
    let columnValue = apiRef.current.getRowFormattedValue(row, column2);
    if (apiRef.current.ignoreDiacritics) {
      columnValue = removeDiacritics(columnValue);
    }
    return columnValue != null ? filterRegex.test(columnValue.toString()) : false;
  };
}, "getGridStringQuickFilterFn");
const createContainsFilterFn = /* @__PURE__ */ __name((disableTrim, negate) => (filterItem) => {
  if (!filterItem.value) {
    return null;
  }
  const trimmedValue = disableTrim ? filterItem.value : filterItem.value.trim();
  const filterRegex = new RegExp(escapeRegExp(trimmedValue), "i");
  return (value) => {
    if (value == null) {
      return negate;
    }
    const matches = filterRegex.test(String(value));
    return negate ? !matches : matches;
  };
}, "createContainsFilterFn");
const createEqualityFilterFn = /* @__PURE__ */ __name((disableTrim, negate) => (filterItem) => {
  if (!filterItem.value) {
    return null;
  }
  const trimmedValue = disableTrim ? filterItem.value : filterItem.value.trim();
  const collator2 = new Intl.Collator(void 0, {
    sensitivity: "base",
    usage: "search"
  });
  return (value) => {
    if (value == null) {
      return negate;
    }
    const isEqual2 = collator2.compare(trimmedValue, value.toString()) === 0;
    return negate ? !isEqual2 : isEqual2;
  };
}, "createEqualityFilterFn");
const createEmptyFilterFn = /* @__PURE__ */ __name((negate) => () => {
  return (value) => {
    const isEmpty2 = value === "" || value == null;
    return negate ? !isEmpty2 : isEmpty2;
  };
}, "createEmptyFilterFn");
const getGridStringOperators = /* @__PURE__ */ __name((disableTrim = false) => [{
  value: "contains",
  getApplyFilterFn: createContainsFilterFn(disableTrim, false),
  InputComponent: GridFilterInputValue
}, {
  value: "doesNotContain",
  getApplyFilterFn: createContainsFilterFn(disableTrim, true),
  InputComponent: GridFilterInputValue
}, {
  value: "equals",
  getApplyFilterFn: createEqualityFilterFn(disableTrim, false),
  InputComponent: GridFilterInputValue
}, {
  value: "doesNotEqual",
  getApplyFilterFn: createEqualityFilterFn(disableTrim, true),
  InputComponent: GridFilterInputValue
}, {
  value: "startsWith",
  getApplyFilterFn: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const filterItemValue = disableTrim ? filterItem.value : filterItem.value.trim();
    const filterRegex = new RegExp(`^${escapeRegExp(filterItemValue)}.*$`, "i");
    return (value) => {
      return value != null ? filterRegex.test(value.toString()) : false;
    };
  },
  InputComponent: GridFilterInputValue
}, {
  value: "endsWith",
  getApplyFilterFn: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const filterItemValue = disableTrim ? filterItem.value : filterItem.value.trim();
    const filterRegex = new RegExp(`.*${escapeRegExp(filterItemValue)}$`, "i");
    return (value) => {
      return value != null ? filterRegex.test(value.toString()) : false;
    };
  },
  InputComponent: GridFilterInputValue
}, {
  value: "isEmpty",
  getApplyFilterFn: createEmptyFilterFn(false),
  requiresFilterValue: false
}, {
  value: "isNotEmpty",
  getApplyFilterFn: createEmptyFilterFn(true),
  requiresFilterValue: false
}, {
  value: "isAnyOf",
  getApplyFilterFn: (filterItem) => {
    if (!Array.isArray(filterItem.value) || filterItem.value.length === 0) {
      return null;
    }
    const filterItemValue = disableTrim ? filterItem.value : filterItem.value.map((val) => val.trim());
    const collator2 = new Intl.Collator(void 0, {
      sensitivity: "base",
      usage: "search"
    });
    return (value) => value != null ? filterItemValue.some((filterValue) => {
      return collator2.compare(filterValue, value.toString() || "") === 0;
    }) : false;
  },
  InputComponent: GridFilterInputMultipleValue
}], "getGridStringOperators");
const GRID_STRING_COL_DEF = {
  width: 100,
  minWidth: 50,
  maxWidth: Infinity,
  hideable: true,
  sortable: true,
  resizable: true,
  filterable: true,
  groupable: true,
  pinnable: true,
  // @ts-ignore
  aggregable: true,
  editable: false,
  sortComparator: gridStringOrNumberComparator,
  type: "string",
  align: "left",
  filterOperators: getGridStringOperators(),
  renderEditCell: renderEditInputCell,
  getApplyQuickFilterFn: getGridStringQuickFilterFn
};
const _excluded$_ = ["open", "target", "onClose", "children", "position", "className", "onExited"];
const useUtilityClasses$L = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["menu"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$L");
const GridMenuRoot = styled(Popper, {
  name: "MuiDataGrid",
  slot: "Menu",
  overridesResolver: (_2, styles2) => styles2.menu
})(({
  theme: theme2
}) => ({
  zIndex: theme2.zIndex.modal,
  [`& .${gridClasses.menuList}`]: {
    outline: 0
  }
}));
const transformOrigin = {
  "bottom-start": "top left",
  "bottom-end": "top right"
};
function GridMenu(props) {
  var _a2;
  const {
    open: open2,
    target,
    onClose,
    children,
    position: position2,
    className,
    onExited
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$_);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$L(rootProps);
  const savedFocusRef = reactExports.useRef(null);
  useEnhancedEffect(() => {
    var _a3, _b2;
    if (open2) {
      savedFocusRef.current = document.activeElement instanceof HTMLElement ? document.activeElement : null;
    } else {
      (_b2 = (_a3 = savedFocusRef.current) == null ? void 0 : _a3.focus) == null ? void 0 : _b2.call(_a3);
      savedFocusRef.current = null;
    }
  }, [open2]);
  reactExports.useEffect(() => {
    const eventName = open2 ? "menuOpen" : "menuClose";
    apiRef.current.publishEvent(eventName, {
      target
    });
  }, [apiRef, open2, target]);
  const handleExited = /* @__PURE__ */ __name((popperOnExited) => (node2) => {
    if (popperOnExited) {
      popperOnExited();
    }
    if (onExited) {
      onExited(node2);
    }
  }, "handleExited");
  const handleClickAway = /* @__PURE__ */ __name((event) => {
    if (event.target && (target === event.target || (target == null ? void 0 : target.contains(event.target)))) {
      return;
    }
    onClose(event);
  }, "handleClickAway");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenuRoot, _extends$4({
    as: rootProps.slots.basePopper,
    className: clsx(classes2.root, className),
    ownerState: rootProps,
    open: open2,
    anchorEl: target,
    transition: true,
    placement: position2
  }, other, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.basePopper, {
    children: ({
      TransitionProps,
      placement
    }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwayListener, {
      onClickAway: handleClickAway,
      mouseEvent: "onMouseDown",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grow, _extends$4({}, TransitionProps, {
        style: {
          transformOrigin: transformOrigin[placement]
        },
        onExited: handleExited(TransitionProps == null ? void 0 : TransitionProps.onExited),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Paper, {
          children
        })
      }))
    })
  }));
}
__name(GridMenu, "GridMenu");
const _excluded$Z = ["api", "colDef", "id", "hasFocus", "isEditable", "field", "value", "formattedValue", "row", "rowNode", "cellMode", "tabIndex", "position", "focusElementRef"];
const hasActions = /* @__PURE__ */ __name((colDef) => typeof colDef.getActions === "function", "hasActions");
function GridActionsCell(props) {
  var _a2;
  const {
    colDef,
    id: id2,
    hasFocus,
    tabIndex,
    position: position2 = "bottom-end",
    focusElementRef
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Z);
  const [focusedButtonIndex, setFocusedButtonIndex] = reactExports.useState(-1);
  const [open2, setOpen] = reactExports.useState(false);
  const apiRef = useGridApiContext();
  const rootRef = reactExports.useRef(null);
  const buttonRef = reactExports.useRef(null);
  const ignoreCallToFocus = reactExports.useRef(false);
  const touchRippleRefs = reactExports.useRef({});
  const isRtl = useRtl();
  const menuId = useId();
  const buttonId = useId();
  const rootProps = useGridRootProps();
  if (!hasActions(colDef)) {
    throw new Error("MUI X: Missing the `getActions` property in the `GridColDef`.");
  }
  const options = colDef.getActions(apiRef.current.getRowParams(id2));
  const iconButtons = options.filter((option) => !option.props.showInMenu);
  const menuButtons = options.filter((option) => option.props.showInMenu);
  const numberOfButtons = iconButtons.length + (menuButtons.length ? 1 : 0);
  reactExports.useLayoutEffect(() => {
    if (!hasFocus) {
      Object.entries(touchRippleRefs.current).forEach(([index2, ref]) => {
        ref == null ? void 0 : ref.stop({}, () => {
          delete touchRippleRefs.current[index2];
        });
      });
    }
  }, [hasFocus]);
  reactExports.useEffect(() => {
    if (focusedButtonIndex < 0 || !rootRef.current) {
      return;
    }
    if (focusedButtonIndex >= rootRef.current.children.length) {
      return;
    }
    const child = rootRef.current.children[focusedButtonIndex];
    child.focus({
      preventScroll: true
    });
  }, [focusedButtonIndex]);
  reactExports.useEffect(() => {
    if (!hasFocus) {
      setFocusedButtonIndex(-1);
      ignoreCallToFocus.current = false;
    }
  }, [hasFocus]);
  reactExports.useImperativeHandle(focusElementRef, () => ({
    focus() {
      if (!ignoreCallToFocus.current) {
        const focusableButtonIndex = options.findIndex((o) => !o.props.disabled);
        setFocusedButtonIndex(focusableButtonIndex);
      }
    }
  }), [options]);
  reactExports.useEffect(() => {
    if (focusedButtonIndex >= numberOfButtons) {
      setFocusedButtonIndex(numberOfButtons - 1);
    }
  }, [focusedButtonIndex, numberOfButtons]);
  const showMenu = /* @__PURE__ */ __name(() => {
    setOpen(true);
    setFocusedButtonIndex(numberOfButtons - 1);
    ignoreCallToFocus.current = true;
  }, "showMenu");
  const hideMenu = /* @__PURE__ */ __name(() => {
    setOpen(false);
  }, "hideMenu");
  const handleTouchRippleRef = /* @__PURE__ */ __name((index2) => (instance) => {
    touchRippleRefs.current[index2] = instance;
  }, "handleTouchRippleRef");
  const handleButtonClick = /* @__PURE__ */ __name((index2, onClick) => (event) => {
    setFocusedButtonIndex(index2);
    ignoreCallToFocus.current = true;
    if (onClick) {
      onClick(event);
    }
  }, "handleButtonClick");
  const handleRootKeyDown = /* @__PURE__ */ __name((event) => {
    if (numberOfButtons <= 1) {
      return;
    }
    const getNewIndex = /* @__PURE__ */ __name((index2, direction) => {
      var _a3;
      if (index2 < 0 || index2 > options.length) {
        return index2;
      }
      const rtlMod = isRtl ? -1 : 1;
      const indexMod = (direction === "left" ? -1 : 1) * rtlMod;
      return ((_a3 = options[index2 + indexMod]) == null ? void 0 : _a3.props.disabled) ? getNewIndex(index2 + indexMod, direction) : index2 + indexMod;
    }, "getNewIndex");
    let newIndex = focusedButtonIndex;
    if (event.key === "ArrowRight") {
      newIndex = getNewIndex(focusedButtonIndex, "right");
    } else if (event.key === "ArrowLeft") {
      newIndex = getNewIndex(focusedButtonIndex, "left");
    }
    if (newIndex < 0 || newIndex >= numberOfButtons) {
      return;
    }
    if (newIndex !== focusedButtonIndex) {
      event.preventDefault();
      event.stopPropagation();
      setFocusedButtonIndex(newIndex);
    }
  }, "handleRootKeyDown");
  const handleListKeyDown = /* @__PURE__ */ __name((event) => {
    if (event.key === "Tab") {
      event.preventDefault();
    }
    if (["Tab", "Escape"].includes(event.key)) {
      hideMenu();
    }
  }, "handleListKeyDown");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$4({
    role: "menu",
    ref: rootRef,
    tabIndex: -1,
    className: gridClasses.actionsCell,
    onKeyDown: handleRootKeyDown
  }, other, {
    children: [iconButtons.map((button, index2) => /* @__PURE__ */ reactExports.cloneElement(button, {
      key: index2,
      touchRippleRef: handleTouchRippleRef(index2),
      onClick: handleButtonClick(index2, button.props.onClick),
      tabIndex: focusedButtonIndex === index2 ? tabIndex : -1
    })), menuButtons.length > 0 && buttonId && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$4({
      ref: buttonRef,
      id: buttonId,
      "aria-label": apiRef.current.getLocaleText("actionsCellMore"),
      "aria-haspopup": "menu",
      "aria-expanded": open2,
      "aria-controls": open2 ? menuId : void 0,
      role: "menuitem",
      size: "small",
      onClick: showMenu,
      touchRippleRef: handleTouchRippleRef(buttonId),
      tabIndex: focusedButtonIndex === iconButtons.length ? tabIndex : -1
    }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseIconButton, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.moreActionsIcon, {
        fontSize: "small"
      })
    })), menuButtons.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenu, {
      open: open2,
      target: buttonRef.current,
      position: position2,
      onClose: hideMenu,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuList, {
        id: menuId,
        className: gridClasses.menuList,
        onKeyDown: handleListKeyDown,
        "aria-labelledby": buttonId,
        variant: "menu",
        autoFocusItem: true,
        children: menuButtons.map((button, index2) => /* @__PURE__ */ reactExports.cloneElement(button, {
          key: index2,
          closeMenu: hideMenu
        }))
      })
    })]
  }));
}
__name(GridActionsCell, "GridActionsCell");
const renderActionsCell = /* @__PURE__ */ __name((params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridActionsCell, _extends$4({}, params)), "renderActionsCell");
const GRID_ACTIONS_COLUMN_TYPE = "actions";
const GRID_ACTIONS_COL_DEF = _extends$4({}, GRID_STRING_COL_DEF, {
  sortable: false,
  filterable: false,
  // @ts-ignore
  aggregable: false,
  width: 100,
  display: "flex",
  align: "center",
  headerAlign: "center",
  headerName: "",
  disableColumnMenu: true,
  disableExport: true,
  renderCell: renderActionsCell,
  getApplyQuickFilterFn: void 0
});
const gridRowsStateSelector = /* @__PURE__ */ __name((state) => state.rows, "gridRowsStateSelector");
const gridRowCountSelector = createSelector(gridRowsStateSelector, (rows) => rows.totalRowCount);
const gridRowsLoadingSelector = createSelector(gridRowsStateSelector, (rows) => rows.loading);
const gridTopLevelRowCountSelector = createSelector(gridRowsStateSelector, (rows) => rows.totalTopLevelRowCount);
const gridRowsLookupSelector = createSelector(gridRowsStateSelector, (rows) => rows.dataRowIdToModelLookup);
const gridRowsDataRowIdToIdLookupSelector = createSelector(gridRowsStateSelector, (rows) => rows.dataRowIdToIdLookup);
const gridRowTreeSelector = createSelector(gridRowsStateSelector, (rows) => rows.tree);
const gridRowGroupsToFetchSelector = createSelector(gridRowsStateSelector, (rows) => rows.groupsToFetch);
const gridRowGroupingNameSelector = createSelector(gridRowsStateSelector, (rows) => rows.groupingName);
const gridRowTreeDepthsSelector = createSelector(gridRowsStateSelector, (rows) => rows.treeDepths);
const gridRowMaximumTreeDepthSelector = createSelectorMemoized(gridRowsStateSelector, (rows) => {
  const entries = Object.entries(rows.treeDepths);
  if (entries.length === 0) {
    return 1;
  }
  return entries.filter(([, nodeCount]) => nodeCount > 0).map(([depth]) => Number(depth)).sort((a, b2) => b2 - a)[0] + 1;
});
const gridDataRowIdsSelector = createSelector(gridRowsStateSelector, (rows) => rows.dataRowIds);
const gridAdditionalRowGroupsSelector = createSelector(gridRowsStateSelector, (rows) => rows == null ? void 0 : rows.additionalRowGroups);
const gridPinnedRowsSelector = createSelectorMemoized(gridAdditionalRowGroupsSelector, (additionalRowGroups) => {
  var _a2, _b2;
  const rawPinnedRows = additionalRowGroups == null ? void 0 : additionalRowGroups.pinnedRows;
  return {
    bottom: ((_a2 = rawPinnedRows == null ? void 0 : rawPinnedRows.bottom) == null ? void 0 : _a2.map((rowEntry) => ({
      id: rowEntry.id,
      model: rowEntry.model ?? {}
    }))) ?? [],
    top: ((_b2 = rawPinnedRows == null ? void 0 : rawPinnedRows.top) == null ? void 0 : _b2.map((rowEntry) => ({
      id: rowEntry.id,
      model: rowEntry.model ?? {}
    }))) ?? []
  };
});
const gridPinnedRowsCountSelector = createSelector(gridPinnedRowsSelector, (pinnedRows) => {
  var _a2, _b2;
  return (((_a2 = pinnedRows == null ? void 0 : pinnedRows.top) == null ? void 0 : _a2.length) || 0) + (((_b2 = pinnedRows == null ? void 0 : pinnedRows.bottom) == null ? void 0 : _b2.length) || 0);
});
const GRID_ROOT_GROUP_ID = `auto-generated-group-node-root`;
const GRID_ID_AUTOGENERATED = Symbol("mui.id_autogenerated");
const buildRootGroup = /* @__PURE__ */ __name(() => ({
  type: "group",
  id: GRID_ROOT_GROUP_ID,
  depth: -1,
  groupingField: null,
  groupingKey: null,
  isAutoGenerated: true,
  children: [],
  childrenFromPath: {},
  childrenExpanded: true,
  parent: null
}), "buildRootGroup");
function checkGridRowIdIsValid(id2, row, detailErrorMessage = "A row was provided without id in the rows prop:") {
  if (id2 == null) {
    throw new Error(["MUI X: The Data Grid component requires all rows to have a unique `id` property.", "Alternatively, you can use the `getRowId` prop to specify a custom id for each row.", detailErrorMessage, JSON.stringify(row)].join("\n"));
  }
}
__name(checkGridRowIdIsValid, "checkGridRowIdIsValid");
const getRowIdFromRowModel = /* @__PURE__ */ __name((rowModel, getRowId, detailErrorMessage) => {
  const id2 = getRowId ? getRowId(rowModel) : rowModel.id;
  checkGridRowIdIsValid(id2, rowModel, detailErrorMessage);
  return id2;
}, "getRowIdFromRowModel");
const createRowsInternalCache = /* @__PURE__ */ __name(({
  rows,
  getRowId,
  loading,
  rowCount
}) => {
  const updates = {
    type: "full",
    rows: []
  };
  const dataRowIdToModelLookup = {};
  const dataRowIdToIdLookup = {};
  for (let i = 0; i < rows.length; i += 1) {
    const model = rows[i];
    const id2 = getRowIdFromRowModel(model, getRowId);
    dataRowIdToModelLookup[id2] = model;
    dataRowIdToIdLookup[id2] = id2;
    updates.rows.push(id2);
  }
  return {
    rowsBeforePartialUpdates: rows,
    loadingPropBeforePartialUpdates: loading,
    rowCountPropBeforePartialUpdates: rowCount,
    updates,
    dataRowIdToIdLookup,
    dataRowIdToModelLookup
  };
}, "createRowsInternalCache");
const getTopLevelRowCount = /* @__PURE__ */ __name(({
  tree,
  rowCountProp = 0
}) => {
  const rootGroupNode = tree[GRID_ROOT_GROUP_ID];
  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));
}, "getTopLevelRowCount");
const getRowsStateFromCache = /* @__PURE__ */ __name(({
  apiRef,
  rowCountProp = 0,
  loadingProp,
  previousTree,
  previousTreeDepths,
  previousGroupsToFetch
}) => {
  const cache2 = apiRef.current.caches.rows;
  const {
    tree: unProcessedTree,
    treeDepths: unProcessedTreeDepths,
    dataRowIds: unProcessedDataRowIds,
    groupingName,
    groupsToFetch = []
  } = apiRef.current.applyStrategyProcessor("rowTreeCreation", {
    previousTree,
    previousTreeDepths,
    updates: cache2.updates,
    dataRowIdToIdLookup: cache2.dataRowIdToIdLookup,
    dataRowIdToModelLookup: cache2.dataRowIdToModelLookup,
    previousGroupsToFetch
  });
  const groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors("hydrateRows", {
    tree: unProcessedTree,
    treeDepths: unProcessedTreeDepths,
    dataRowIdToIdLookup: cache2.dataRowIdToIdLookup,
    dataRowIds: unProcessedDataRowIds,
    dataRowIdToModelLookup: cache2.dataRowIdToModelLookup
  });
  apiRef.current.caches.rows.updates = {
    type: "partial",
    actions: {
      insert: [],
      modify: [],
      remove: []
    },
    idToActionLookup: {}
  };
  return _extends$4({}, groupingParamsWithHydrateRows, {
    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),
    totalTopLevelRowCount: getTopLevelRowCount({
      tree: groupingParamsWithHydrateRows.tree,
      rowCountProp
    }),
    groupingName,
    loading: loadingProp,
    groupsToFetch
  });
}, "getRowsStateFromCache");
const isAutogeneratedRowNode = /* @__PURE__ */ __name((rowNode) => rowNode.type === "skeletonRow" || rowNode.type === "footer" || rowNode.type === "group" && rowNode.isAutoGenerated || rowNode.type === "pinnedRow" && rowNode.isAutoGenerated, "isAutogeneratedRowNode");
const getTreeNodeDescendants = /* @__PURE__ */ __name((tree, parentId, skipAutoGeneratedRows) => {
  const node2 = tree[parentId];
  if (node2.type !== "group") {
    return [];
  }
  const validDescendants = [];
  for (let i = 0; i < node2.children.length; i += 1) {
    const child = node2.children[i];
    if (!skipAutoGeneratedRows || !isAutogeneratedRowNode(tree[child])) {
      validDescendants.push(child);
    }
    const childDescendants = getTreeNodeDescendants(tree, child, skipAutoGeneratedRows);
    for (let j = 0; j < childDescendants.length; j += 1) {
      validDescendants.push(childDescendants[j]);
    }
  }
  if (!skipAutoGeneratedRows && node2.footerId != null) {
    validDescendants.push(node2.footerId);
  }
  return validDescendants;
}, "getTreeNodeDescendants");
const updateCacheWithNewRows = /* @__PURE__ */ __name(({
  previousCache,
  getRowId,
  updates,
  groupKeys
}) => {
  if (previousCache.updates.type === "full") {
    throw new Error("MUI X: Unable to prepare a partial update if a full update is not applied yet.");
  }
  const uniqueUpdates = /* @__PURE__ */ new Map();
  updates.forEach((update) => {
    const id2 = getRowIdFromRowModel(update, getRowId, "A row was provided without id when calling updateRows():");
    if (uniqueUpdates.has(id2)) {
      uniqueUpdates.set(id2, _extends$4({}, uniqueUpdates.get(id2), update));
    } else {
      uniqueUpdates.set(id2, update);
    }
  });
  const partialUpdates = {
    type: "partial",
    actions: {
      insert: [...previousCache.updates.actions.insert ?? []],
      modify: [...previousCache.updates.actions.modify ?? []],
      remove: [...previousCache.updates.actions.remove ?? []]
    },
    idToActionLookup: _extends$4({}, previousCache.updates.idToActionLookup),
    groupKeys
  };
  const dataRowIdToModelLookup = _extends$4({}, previousCache.dataRowIdToModelLookup);
  const dataRowIdToIdLookup = _extends$4({}, previousCache.dataRowIdToIdLookup);
  const alreadyAppliedActionsToRemove = {
    insert: {},
    modify: {},
    remove: {}
  };
  uniqueUpdates.forEach((partialRow, id2) => {
    const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id2];
    if (partialRow._action === "delete") {
      if (actionAlreadyAppliedToRow === "remove" || !dataRowIdToModelLookup[id2]) {
        return;
      }
      if (actionAlreadyAppliedToRow != null) {
        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id2] = true;
      }
      partialUpdates.actions.remove.push(id2);
      delete dataRowIdToModelLookup[id2];
      delete dataRowIdToIdLookup[id2];
      return;
    }
    const oldRow = dataRowIdToModelLookup[id2];
    if (oldRow) {
      if (actionAlreadyAppliedToRow === "remove") {
        alreadyAppliedActionsToRemove.remove[id2] = true;
        partialUpdates.actions.modify.push(id2);
      } else if (actionAlreadyAppliedToRow == null) {
        partialUpdates.actions.modify.push(id2);
      }
      dataRowIdToModelLookup[id2] = _extends$4({}, oldRow, partialRow);
      return;
    }
    if (actionAlreadyAppliedToRow === "remove") {
      alreadyAppliedActionsToRemove.remove[id2] = true;
      partialUpdates.actions.insert.push(id2);
    } else if (actionAlreadyAppliedToRow == null) {
      partialUpdates.actions.insert.push(id2);
    }
    dataRowIdToModelLookup[id2] = partialRow;
    dataRowIdToIdLookup[id2] = id2;
  });
  const actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);
  for (let i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {
    const actionType = actionTypeWithActionsToRemove[i];
    const idsToRemove = alreadyAppliedActionsToRemove[actionType];
    if (Object.keys(idsToRemove).length > 0) {
      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter((id2) => !idsToRemove[id2]);
    }
  }
  return {
    dataRowIdToModelLookup,
    dataRowIdToIdLookup,
    updates: partialUpdates,
    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,
    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,
    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates
  };
}, "updateCacheWithNewRows");
function calculatePinnedRowsHeight(apiRef) {
  var _a2, _b2;
  const pinnedRows = gridPinnedRowsSelector(apiRef);
  const topPinnedRowsHeight = ((_a2 = pinnedRows == null ? void 0 : pinnedRows.top) == null ? void 0 : _a2.reduce((acc, value) => {
    acc += apiRef.current.unstable_getRowHeight(value.id);
    return acc;
  }, 0)) || 0;
  const bottomPinnedRowsHeight = ((_b2 = pinnedRows == null ? void 0 : pinnedRows.bottom) == null ? void 0 : _b2.reduce((acc, value) => {
    acc += apiRef.current.unstable_getRowHeight(value.id);
    return acc;
  }, 0)) || 0;
  return {
    top: topPinnedRowsHeight,
    bottom: bottomPinnedRowsHeight
  };
}
__name(calculatePinnedRowsHeight, "calculatePinnedRowsHeight");
const minimalContentHeight = "var(--DataGrid-overlayHeight, calc(var(--height) * 2))";
function computeRowsUpdates(apiRef, updates, getRowId) {
  const nonPinnedRowsUpdates = [];
  updates.forEach((update) => {
    const id2 = getRowIdFromRowModel(update, getRowId, "A row was provided without id when calling updateRows():");
    const rowNode = apiRef.current.getRowNode(id2);
    if ((rowNode == null ? void 0 : rowNode.type) === "pinnedRow") {
      const pinnedRowsCache = apiRef.current.caches.pinnedRows;
      const prevModel = pinnedRowsCache.idLookup[id2];
      if (prevModel) {
        pinnedRowsCache.idLookup[id2] = _extends$4({}, prevModel, update);
      }
    } else {
      nonPinnedRowsUpdates.push(update);
    }
  });
  return nonPinnedRowsUpdates;
}
__name(computeRowsUpdates, "computeRowsUpdates");
const getValidRowHeight = /* @__PURE__ */ __name((rowHeightProp, defaultRowHeight, warningMessage) => {
  if (typeof rowHeightProp === "number" && rowHeightProp > 0) {
    return rowHeightProp;
  }
  return defaultRowHeight;
}, "getValidRowHeight");
const GRID_TREE_DATA_GROUPING_FIELD = "__tree_data_group__";
const GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = "__row_group_by_columns_group__";
const GRID_DETAIL_PANEL_TOGGLE_FIELD = "__detail_panel_toggle__";
const _excluded$Y = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "hasFocus", "tabIndex", "hideDescendantCount"];
const useUtilityClasses$K = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["booleanCell"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$K");
function GridBooleanCellRaw(props) {
  const {
    value,
    rowNode
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Y);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$K(ownerState);
  const maxDepth = useGridSelector(apiRef, gridRowMaximumTreeDepthSelector);
  const isServerSideRowGroupingRow = (
    // @ts-expect-error - Access tree data prop
    maxDepth > 0 && rowNode.type === "group" && rootProps.treeData === false
  );
  const Icon = reactExports.useMemo(() => value ? rootProps.slots.booleanCellTrueIcon : rootProps.slots.booleanCellFalseIcon, [rootProps.slots.booleanCellFalseIcon, rootProps.slots.booleanCellTrueIcon, value]);
  if (isServerSideRowGroupingRow && value === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, _extends$4({
    fontSize: "small",
    className: classes2.root,
    titleAccess: apiRef.current.getLocaleText(value ? "booleanCellTrueLabel" : "booleanCellFalseLabel"),
    "data-value": Boolean(value)
  }, other));
}
__name(GridBooleanCellRaw, "GridBooleanCellRaw");
const GridBooleanCell = /* @__PURE__ */ reactExports.memo(GridBooleanCellRaw);
const renderBooleanCell = /* @__PURE__ */ __name((params) => {
  if (params.field !== GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD && isAutogeneratedRowNode(params.rowNode)) {
    return "";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridBooleanCell, _extends$4({}, params));
}, "renderBooleanCell");
const _excluded$X = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "className", "hasFocus", "isValidating", "isProcessingProps", "error", "onValueChange"];
const useUtilityClasses$J = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["editBooleanCell"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$J");
function GridEditBooleanCell(props) {
  var _a2;
  const {
    id: idProp,
    value,
    field,
    className,
    hasFocus,
    onValueChange
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$X);
  const apiRef = useGridApiContext();
  const inputRef = reactExports.useRef(null);
  const id2 = useId();
  const [valueState, setValueState] = reactExports.useState(value);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$J(ownerState);
  const handleChange = reactExports.useCallback(async (event) => {
    const newValue = event.target.checked;
    if (onValueChange) {
      await onValueChange(event, newValue);
    }
    setValueState(newValue);
    await apiRef.current.setEditCellValue({
      id: idProp,
      field,
      value: newValue
    }, event);
  }, [apiRef, field, idProp, onValueChange]);
  reactExports.useEffect(() => {
    setValueState(value);
  }, [value]);
  useEnhancedEffect(() => {
    if (hasFocus) {
      inputRef.current.focus();
    }
  }, [hasFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("label", _extends$4({
    htmlFor: id2,
    className: clsx(classes2.root, className)
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends$4({
      id: id2,
      inputRef,
      checked: Boolean(valueState),
      onChange: handleChange,
      size: "small"
    }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseCheckbox))
  }));
}
__name(GridEditBooleanCell, "GridEditBooleanCell");
const renderEditBooleanCell = /* @__PURE__ */ __name((params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditBooleanCell, _extends$4({}, params)), "renderEditBooleanCell");
const _excluded$W = ["item", "applyValue", "apiRef", "focusElementRef", "isFilterActive", "clearButton", "tabIndex", "label", "variant", "InputLabelProps"];
const sanitizeFilterItemValue = /* @__PURE__ */ __name((value) => {
  if (String(value).toLowerCase() === "true") {
    return true;
  }
  if (String(value).toLowerCase() === "false") {
    return false;
  }
  return void 0;
}, "sanitizeFilterItemValue");
const BooleanOperatorContainer = styled("div")({
  display: "flex",
  alignItems: "center",
  width: "100%",
  [`& button`]: {
    margin: "auto 0px 5px 5px"
  }
});
function GridFilterInputBoolean(props) {
  var _a2, _b2, _c2;
  const {
    item,
    applyValue,
    apiRef,
    focusElementRef,
    clearButton,
    tabIndex,
    label: labelProp,
    variant = "standard"
  } = props, others = _objectWithoutPropertiesLoose$1(props, _excluded$W);
  const [filterValueState, setFilterValueState] = reactExports.useState(sanitizeFilterItemValue(item.value));
  const rootProps = useGridRootProps();
  const labelId = useId();
  const selectId = useId();
  const baseSelectProps = ((_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseSelect) || {};
  const isSelectNative = baseSelectProps.native ?? false;
  const baseSelectOptionProps = ((_b2 = rootProps.slotProps) == null ? void 0 : _b2.baseSelectOption) || {};
  const onFilterChange = reactExports.useCallback((event) => {
    const value = sanitizeFilterItemValue(event.target.value);
    setFilterValueState(value);
    applyValue(_extends$4({}, item, {
      value
    }));
  }, [applyValue, item]);
  reactExports.useEffect(() => {
    setFilterValueState(sanitizeFilterItemValue(item.value));
  }, [item.value]);
  const label = labelProp ?? apiRef.current.getLocaleText("filterPanelInputLabel");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(BooleanOperatorContainer, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(rootProps.slots.baseFormControl, {
      fullWidth: true,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends$4({}, (_c2 = rootProps.slotProps) == null ? void 0 : _c2.baseInputLabel, {
        id: labelId,
        shrink: true,
        variant,
        children: label
      })), /* @__PURE__ */ jsxRuntimeExports.jsxs(rootProps.slots.baseSelect, _extends$4({
        labelId,
        id: selectId,
        label,
        value: filterValueState === void 0 ? "" : String(filterValueState),
        onChange: onFilterChange,
        variant,
        notched: variant === "outlined" ? true : void 0,
        native: isSelectNative,
        displayEmpty: true,
        inputProps: {
          ref: focusElementRef,
          tabIndex
        }
      }, others, baseSelectProps, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelectOption, _extends$4({}, baseSelectOptionProps, {
          native: isSelectNative,
          value: "",
          children: apiRef.current.getLocaleText("filterValueAny")
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelectOption, _extends$4({}, baseSelectOptionProps, {
          native: isSelectNative,
          value: "true",
          children: apiRef.current.getLocaleText("filterValueTrue")
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelectOption, _extends$4({}, baseSelectOptionProps, {
          native: isSelectNative,
          value: "false",
          children: apiRef.current.getLocaleText("filterValueFalse")
        }))]
      }))]
    }), clearButton]
  });
}
__name(GridFilterInputBoolean, "GridFilterInputBoolean");
const getGridBooleanOperators = /* @__PURE__ */ __name(() => [{
  value: "is",
  getApplyFilterFn: (filterItem) => {
    const sanitizedValue = sanitizeFilterItemValue(filterItem.value);
    if (sanitizedValue === void 0) {
      return null;
    }
    return (value) => Boolean(value) === sanitizedValue;
  },
  InputComponent: GridFilterInputBoolean
}], "getGridBooleanOperators");
const gridBooleanFormatter = /* @__PURE__ */ __name((value, row, column2, apiRef) => {
  return value ? apiRef.current.getLocaleText("booleanCellTrueLabel") : apiRef.current.getLocaleText("booleanCellFalseLabel");
}, "gridBooleanFormatter");
const stringToBoolean = /* @__PURE__ */ __name((value) => {
  switch (value.toLowerCase().trim()) {
    case "true":
    case "yes":
    case "1":
      return true;
    case "false":
    case "no":
    case "0":
    case "null":
    case "undefined":
      return false;
    default:
      return void 0;
  }
}, "stringToBoolean");
const GRID_BOOLEAN_COL_DEF = _extends$4({}, GRID_STRING_COL_DEF, {
  type: "boolean",
  display: "flex",
  align: "center",
  headerAlign: "center",
  renderCell: renderBooleanCell,
  renderEditCell: renderEditBooleanCell,
  sortComparator: gridNumberComparator,
  valueFormatter: gridBooleanFormatter,
  filterOperators: getGridBooleanOperators(),
  getApplyQuickFilterFn: void 0,
  // @ts-ignore
  aggregable: false,
  // @ts-ignore
  pastedValueParser: (value) => stringToBoolean(value)
});
const gridSortingStateSelector = /* @__PURE__ */ __name((state) => state.sorting, "gridSortingStateSelector");
const gridSortedRowIdsSelector = createSelector(gridSortingStateSelector, (sortingState) => sortingState.sortedRows);
const gridSortedRowEntriesSelector = createSelectorMemoized(gridSortedRowIdsSelector, gridRowsLookupSelector, gridRowTreeSelector, (sortedIds, idRowsLookup, rowTree) => sortedIds.reduce((acc, id2) => {
  const model = idRowsLookup[id2];
  if (model) {
    acc.push({
      id: id2,
      model
    });
  }
  const rowNode = rowTree[id2];
  if (rowNode && isAutogeneratedRowNode(rowNode)) {
    acc.push({
      id: id2,
      model: {
        [GRID_ID_AUTOGENERATED]: id2
      }
    });
  }
  return acc;
}, []));
const gridSortModelSelector = createSelector(gridSortingStateSelector, (sorting) => sorting.sortModel);
const gridSortColumnLookupSelector = createSelectorMemoized(gridSortModelSelector, (sortModel) => {
  const result = sortModel.reduce((res, sortItem, index2) => {
    res[sortItem.field] = {
      sortDirection: sortItem.sort,
      sortIndex: sortModel.length > 1 ? index2 + 1 : void 0
    };
    return res;
  }, {});
  return result;
});
const gridFilterStateSelector = /* @__PURE__ */ __name((state) => state.filter, "gridFilterStateSelector");
const gridFilterModelSelector = createSelector(gridFilterStateSelector, (filterState) => filterState.filterModel);
createSelector(gridFilterModelSelector, (filterModel) => filterModel.quickFilterValues);
const gridVisibleRowsLookupSelector = /* @__PURE__ */ __name((state) => state.visibleRowsLookup, "gridVisibleRowsLookupSelector");
const gridFilteredRowsLookupSelector = createSelector(gridFilterStateSelector, (filterState) => filterState.filteredRowsLookup);
createSelector(gridFilterStateSelector, (filterState) => filterState.filteredChildrenCountLookup);
createSelector(gridFilterStateSelector, (filterState) => filterState.filteredDescendantCountLookup);
const gridExpandedSortedRowEntriesSelector = createSelectorMemoized(gridVisibleRowsLookupSelector, gridSortedRowEntriesSelector, (visibleRowsLookup, sortedRows) => sortedRows.filter((row) => visibleRowsLookup[row.id] !== false));
const gridExpandedSortedRowIdsSelector = createSelectorMemoized(gridExpandedSortedRowEntriesSelector, (visibleSortedRowEntries) => visibleSortedRowEntries.map((row) => row.id));
const gridFilteredSortedRowEntriesSelector = createSelectorMemoized(gridFilteredRowsLookupSelector, gridSortedRowEntriesSelector, (filteredRowsLookup, sortedRows) => sortedRows.filter((row) => filteredRowsLookup[row.id] !== false));
const gridFilteredSortedRowIdsSelector = createSelectorMemoized(gridFilteredSortedRowEntriesSelector, (filteredSortedRowEntries) => filteredSortedRowEntries.map((row) => row.id));
createSelectorMemoized(gridExpandedSortedRowIdsSelector, gridRowTreeSelector, (visibleSortedRowIds, rowTree) => {
  const depthPositionCounter = {};
  let lastDepth = 0;
  return visibleSortedRowIds.reduce((acc, rowId) => {
    const rowNode = rowTree[rowId];
    if (!depthPositionCounter[rowNode.depth]) {
      depthPositionCounter[rowNode.depth] = 0;
    }
    if (rowNode.depth > lastDepth) {
      depthPositionCounter[rowNode.depth] = 0;
    }
    lastDepth = rowNode.depth;
    depthPositionCounter[rowNode.depth] += 1;
    acc[rowId] = depthPositionCounter[rowNode.depth];
    return acc;
  }, {});
});
const gridFilteredSortedTopLevelRowEntriesSelector = createSelectorMemoized(gridExpandedSortedRowEntriesSelector, gridRowTreeSelector, gridRowMaximumTreeDepthSelector, (visibleSortedRows, rowTree, rowTreeDepth) => {
  if (rowTreeDepth < 2) {
    return visibleSortedRows;
  }
  return visibleSortedRows.filter((row) => {
    var _a2;
    return ((_a2 = rowTree[row.id]) == null ? void 0 : _a2.depth) === 0;
  });
});
const gridExpandedRowCountSelector = createSelector(gridExpandedSortedRowEntriesSelector, (visibleSortedRows) => visibleSortedRows.length);
const gridFilteredTopLevelRowCountSelector = createSelector(gridFilteredSortedTopLevelRowEntriesSelector, (visibleSortedTopLevelRows) => visibleSortedTopLevelRows.length);
const gridFilteredRowCountSelector = createSelector(gridFilteredSortedRowEntriesSelector, (filteredSortedRowEntries) => filteredSortedRowEntries.length);
createSelector(gridFilteredRowCountSelector, gridFilteredTopLevelRowCountSelector, (totalRowCount, topLevelRowCount) => totalRowCount - topLevelRowCount);
const gridFilterActiveItemsSelector = createSelectorMemoized(gridFilterModelSelector, gridColumnLookupSelector, (filterModel, columnLookup) => {
  var _a2;
  return (_a2 = filterModel.items) == null ? void 0 : _a2.filter((item) => {
    var _a3, _b2;
    if (!item.field) {
      return false;
    }
    const column2 = columnLookup[item.field];
    if (!(column2 == null ? void 0 : column2.filterOperators) || ((_a3 = column2 == null ? void 0 : column2.filterOperators) == null ? void 0 : _a3.length) === 0) {
      return false;
    }
    const filterOperator = column2.filterOperators.find((operator) => operator.value === item.operator);
    if (!filterOperator) {
      return false;
    }
    return !filterOperator.InputComponent || item.value != null && ((_b2 = item.value) == null ? void 0 : _b2.toString()) !== "";
  });
});
const gridFilterActiveItemsLookupSelector = createSelectorMemoized(gridFilterActiveItemsSelector, (activeFilters) => {
  const result = activeFilters.reduce((res, filterItem) => {
    if (!res[filterItem.field]) {
      res[filterItem.field] = [filterItem];
    } else {
      res[filterItem.field].push(filterItem);
    }
    return res;
  }, {});
  return result;
});
const gridRowSelectionStateSelector = /* @__PURE__ */ __name((state) => state.rowSelection, "gridRowSelectionStateSelector");
const selectedGridRowsCountSelector = createSelector(gridRowSelectionStateSelector, (selection) => selection.length);
const selectedGridRowsSelector = createSelectorMemoized(gridRowSelectionStateSelector, gridRowsLookupSelector, (selectedRows, rowsLookup) => new Map(selectedRows.map((id2) => [id2, rowsLookup[id2]])));
const selectedIdsLookupSelector = createSelectorMemoized(gridRowSelectionStateSelector, (selection) => selection.reduce((lookup, rowId) => {
  lookup[rowId] = rowId;
  return lookup;
}, {}));
function getGridRowGroupSelectableDescendants(apiRef, groupId) {
  var _a2;
  const rowTree = gridRowTreeSelector(apiRef);
  const sortedRowIds = gridSortedRowIdsSelector(apiRef);
  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);
  const groupNode = rowTree[groupId];
  if (!groupNode || groupNode.type !== "group") {
    return [];
  }
  const descendants = [];
  const startIndex = sortedRowIds.findIndex((id2) => id2 === groupId) + 1;
  for (let index2 = startIndex; index2 < sortedRowIds.length && ((_a2 = rowTree[sortedRowIds[index2]]) == null ? void 0 : _a2.depth) > groupNode.depth; index2 += 1) {
    const id2 = sortedRowIds[index2];
    if (filteredRowsLookup[id2] !== false && apiRef.current.isRowSelectable(id2)) {
      descendants.push(id2);
    }
  }
  return descendants;
}
__name(getGridRowGroupSelectableDescendants, "getGridRowGroupSelectableDescendants");
function getCheckboxPropsSelector(groupId, autoSelectParents) {
  return createSelector(gridRowTreeSelector, gridSortedRowIdsSelector, gridFilteredRowsLookupSelector, selectedIdsLookupSelector, (rowTree, sortedRowIds, filteredRowsLookup, rowSelectionLookup) => {
    var _a2;
    const groupNode = rowTree[groupId];
    if (!groupNode || groupNode.type !== "group") {
      return {
        isIndeterminate: false,
        isChecked: rowSelectionLookup[groupId] === groupId
      };
    }
    if (rowSelectionLookup[groupId] === groupId) {
      return {
        isIndeterminate: false,
        isChecked: true
      };
    }
    let selectableDescendantsCount = 0;
    let selectedDescendantsCount = 0;
    const startIndex = sortedRowIds.findIndex((id2) => id2 === groupId) + 1;
    for (let index2 = startIndex; index2 < sortedRowIds.length && ((_a2 = rowTree[sortedRowIds[index2]]) == null ? void 0 : _a2.depth) > groupNode.depth; index2 += 1) {
      const id2 = sortedRowIds[index2];
      if (filteredRowsLookup[id2] !== false) {
        selectableDescendantsCount += 1;
        if (rowSelectionLookup[id2] !== void 0) {
          selectedDescendantsCount += 1;
        }
      }
    }
    return {
      isIndeterminate: selectedDescendantsCount > 0 && (selectedDescendantsCount < selectableDescendantsCount || rowSelectionLookup[groupId] === void 0),
      isChecked: autoSelectParents ? selectedDescendantsCount > 0 : rowSelectionLookup[groupId] === groupId
    };
  });
}
__name(getCheckboxPropsSelector, "getCheckboxPropsSelector");
function isMultipleRowSelectionEnabled(props) {
  if (props.signature === GridSignature.DataGrid) {
    return props.checkboxSelection && props.disableMultipleRowSelection !== true;
  }
  return !props.disableMultipleRowSelection;
}
__name(isMultipleRowSelectionEnabled, "isMultipleRowSelectionEnabled");
const getRowNodeParents = /* @__PURE__ */ __name((tree, id2) => {
  const parents = [];
  let parent = id2;
  while (parent != null && parent !== GRID_ROOT_GROUP_ID) {
    const node2 = tree[parent];
    if (!node2) {
      return parents;
    }
    parents.push(parent);
    parent = node2.parent;
  }
  return parents;
}, "getRowNodeParents");
const getFilteredRowNodeSiblings = /* @__PURE__ */ __name((tree, filteredRows, id2) => {
  const node2 = tree[id2];
  if (!node2) {
    return [];
  }
  const parent = node2.parent;
  if (parent == null) {
    return [];
  }
  const parentNode = tree[parent];
  return parentNode.children.filter((childId) => childId !== id2 && filteredRows[childId]);
}, "getFilteredRowNodeSiblings");
const findRowsToSelect = /* @__PURE__ */ __name((apiRef, tree, selectedRow, autoSelectDescendants, autoSelectParents, addRow) => {
  const filteredRows = gridFilteredRowsLookupSelector(apiRef);
  const selectedIdsLookup = selectedIdsLookupSelector(apiRef);
  const selectedDescendants = /* @__PURE__ */ new Set([]);
  if (!autoSelectDescendants && !autoSelectParents) {
    return;
  }
  if (autoSelectDescendants) {
    const rowNode = tree[selectedRow];
    if ((rowNode == null ? void 0 : rowNode.type) === "group") {
      const descendants = getGridRowGroupSelectableDescendants(apiRef, selectedRow);
      descendants.forEach((rowId) => {
        addRow(rowId);
        selectedDescendants.add(rowId);
      });
    }
  }
  if (autoSelectParents) {
    const checkAllDescendantsSelected = /* @__PURE__ */ __name((rowId) => {
      if (selectedIdsLookup[rowId] !== rowId && !selectedDescendants.has(rowId)) {
        return false;
      }
      const node2 = tree[rowId];
      if ((node2 == null ? void 0 : node2.type) !== "group") {
        return true;
      }
      return node2.children.every(checkAllDescendantsSelected);
    }, "checkAllDescendantsSelected");
    const traverseParents = /* @__PURE__ */ __name((rowId) => {
      const siblings = getFilteredRowNodeSiblings(tree, filteredRows, rowId);
      if (siblings.length === 0 || siblings.every(checkAllDescendantsSelected)) {
        const rowNode = tree[rowId];
        const parent = rowNode.parent;
        if (parent != null && parent !== GRID_ROOT_GROUP_ID && apiRef.current.isRowSelectable(parent)) {
          addRow(parent);
          selectedDescendants.add(parent);
          traverseParents(parent);
        }
      }
    }, "traverseParents");
    traverseParents(selectedRow);
  }
}, "findRowsToSelect");
const findRowsToDeselect = /* @__PURE__ */ __name((apiRef, tree, deselectedRow, autoSelectDescendants, autoSelectParents, removeRow) => {
  const selectedIdsLookup = selectedIdsLookupSelector(apiRef);
  if (!autoSelectParents && !autoSelectDescendants) {
    return;
  }
  if (autoSelectParents) {
    const allParents = getRowNodeParents(tree, deselectedRow);
    allParents.forEach((parent) => {
      const isSelected = selectedIdsLookup[parent] === parent;
      if (isSelected) {
        removeRow(parent);
      }
    });
  }
  if (autoSelectDescendants) {
    const rowNode = tree[deselectedRow];
    if ((rowNode == null ? void 0 : rowNode.type) === "group") {
      const descendants = getGridRowGroupSelectableDescendants(apiRef, deselectedRow);
      descendants.forEach((descendant) => {
        removeRow(descendant);
      });
    }
  }
}, "findRowsToDeselect");
const _excluded$V = ["field", "id", "formattedValue", "row", "rowNode", "colDef", "isEditable", "cellMode", "hasFocus", "tabIndex", "api"];
const useUtilityClasses$I = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["checkboxInput"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$I");
const GridCellCheckboxForwardRef = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridCellCheckboxRenderer2(props, ref) {
  var _a2, _b2;
  const {
    field,
    id: id2,
    rowNode,
    hasFocus,
    tabIndex
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$V);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$I(ownerState);
  const checkboxElement = reactExports.useRef(null);
  const rippleRef = reactExports.useRef(null);
  const handleRef = useForkRef(checkboxElement, ref);
  const handleChange = /* @__PURE__ */ __name((event) => {
    const params = {
      value: event.target.checked,
      id: id2
    };
    apiRef.current.publishEvent("rowSelectionCheckboxChange", params, event);
  }, "handleChange");
  reactExports.useLayoutEffect(() => {
    if (tabIndex === 0) {
      const element = apiRef.current.getCellElement(id2, field);
      if (element) {
        element.tabIndex = -1;
      }
    }
  }, [apiRef, tabIndex, id2, field]);
  reactExports.useEffect(() => {
    var _a3;
    if (hasFocus) {
      const input = (_a3 = checkboxElement.current) == null ? void 0 : _a3.querySelector("input");
      input == null ? void 0 : input.focus({
        preventScroll: true
      });
    } else if (rippleRef.current) {
      rippleRef.current.stop({});
    }
  }, [hasFocus]);
  const handleKeyDown2 = reactExports.useCallback((event) => {
    if (event.key === " ") {
      event.stopPropagation();
    }
  }, []);
  const isSelectable = apiRef.current.isRowSelectable(id2);
  const checkboxPropsSelector = getCheckboxPropsSelector(id2, ((_a2 = rootProps.rowSelectionPropagation) == null ? void 0 : _a2.parents) ?? false);
  const {
    isIndeterminate,
    isChecked
  } = useGridSelector(apiRef, checkboxPropsSelector);
  if (rowNode.type === "footer" || rowNode.type === "pinnedRow") {
    return null;
  }
  const label = apiRef.current.getLocaleText(isChecked ? "checkboxSelectionUnselectRow" : "checkboxSelectionSelectRow");
  const checked = rootProps.indeterminateCheckboxAction === "select" ? isChecked && !isIndeterminate : isChecked;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends$4({
    ref: handleRef,
    tabIndex,
    checked,
    onChange: handleChange,
    className: classes2.root,
    inputProps: {
      "aria-label": label
    },
    onKeyDown: handleKeyDown2,
    indeterminate: isIndeterminate,
    disabled: !isSelectable,
    touchRippleRef: rippleRef
    /* FIXME: typing error */
  }, (_b2 = rootProps.slotProps) == null ? void 0 : _b2.baseCheckbox, other));
}, "GridCellCheckboxRenderer2"));
const GridCellCheckboxRenderer = GridCellCheckboxForwardRef;
const gridFocusStateSelector = /* @__PURE__ */ __name((state) => state.focus, "gridFocusStateSelector");
const gridFocusCellSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.cell);
const gridFocusColumnHeaderSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.columnHeader);
createSelector(gridFocusStateSelector, (focusState) => focusState.columnHeaderFilter);
const gridFocusColumnGroupHeaderSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.columnGroupHeader);
const gridTabIndexStateSelector = /* @__PURE__ */ __name((state) => state.tabIndex, "gridTabIndexStateSelector");
const gridTabIndexCellSelector = createSelector(gridTabIndexStateSelector, (state) => state.cell);
const gridTabIndexColumnHeaderSelector = createSelector(gridTabIndexStateSelector, (state) => state.columnHeader);
createSelector(gridTabIndexStateSelector, (state) => state.columnHeaderFilter);
const gridTabIndexColumnGroupHeaderSelector = createSelector(gridTabIndexStateSelector, (state) => state.columnGroupHeader);
function useGridApiMethod(privateApiRef, apiMethods, visibility) {
  const isFirstRender = reactExports.useRef(true);
  useEnhancedEffect(() => {
    isFirstRender.current = false;
    privateApiRef.current.register(visibility, apiMethods);
  }, [privateApiRef, visibility, apiMethods]);
  if (isFirstRender.current) {
    privateApiRef.current.register(visibility, apiMethods);
  }
}
__name(useGridApiMethod, "useGridApiMethod");
function useGridLogger(privateApiRef, name) {
  const logger = reactExports.useRef(null);
  if (logger.current) {
    return logger.current;
  }
  const newLogger = privateApiRef.current.getLogger(name);
  logger.current = newLogger;
  return newLogger;
}
__name(useGridLogger, "useGridLogger");
const useGridNativeEventListener = /* @__PURE__ */ __name((apiRef, ref, eventName, handler, options) => {
  const logger = useGridLogger(apiRef, "useNativeEventListener");
  const [added, setAdded] = reactExports.useState(false);
  const handlerRef = reactExports.useRef(handler);
  const targetElement = isFunction$1(ref) ? ref() : (ref == null ? void 0 : ref.current) ?? null;
  const wrapHandler = reactExports.useCallback((event) => {
    return handlerRef.current && handlerRef.current(event);
  }, []);
  reactExports.useEffect(() => {
    handlerRef.current = handler;
  }, [handler]);
  reactExports.useEffect(() => {
    if (targetElement && eventName && !added) {
      logger.debug(`Binding native ${eventName} event`);
      targetElement.addEventListener(eventName, wrapHandler, options);
      setAdded(true);
      const unsubscribe = /* @__PURE__ */ __name(() => {
        logger.debug(`Clearing native ${eventName} event`);
        targetElement.removeEventListener(eventName, wrapHandler, options);
      }, "unsubscribe");
      apiRef.current.subscribeEvent("unmount", unsubscribe);
    }
  }, [targetElement, wrapHandler, eventName, added, logger, options, apiRef]);
}, "useGridNativeEventListener");
const useFirstRender = /* @__PURE__ */ __name((callback) => {
  const isFirstRender = reactExports.useRef(true);
  if (isFirstRender.current) {
    isFirstRender.current = false;
    callback();
  }
}, "useFirstRender");
const noop$6 = /* @__PURE__ */ __name(() => {
}, "noop$6");
const useRunOnce = /* @__PURE__ */ __name((condition, effect2) => {
  const didRun = reactExports.useRef(false);
  useEnhancedEffect(() => {
    if (didRun.current || !condition) {
      return noop$6;
    }
    didRun.current = true;
    return effect2();
  }, [didRun.current || condition]);
}, "useRunOnce");
const MAX_PAGE_SIZE = 100;
const defaultPageSize = /* @__PURE__ */ __name((autoPageSize) => autoPageSize ? 0 : 100, "defaultPageSize");
const getPageCount = /* @__PURE__ */ __name((rowCount, pageSize2, page) => {
  if (pageSize2 > 0 && rowCount > 0) {
    return Math.ceil(rowCount / pageSize2);
  }
  if (rowCount === -1) {
    return page + 2;
  }
  return 0;
}, "getPageCount");
const getDefaultGridPaginationModel = /* @__PURE__ */ __name((autoPageSize) => ({
  page: 0,
  pageSize: autoPageSize ? 0 : 100
}), "getDefaultGridPaginationModel");
const getValidPage = /* @__PURE__ */ __name((page, pageCount = 0) => {
  if (pageCount === 0) {
    return page;
  }
  return Math.max(Math.min(page, pageCount - 1), 0);
}, "getValidPage");
const throwIfPageSizeExceedsTheLimit = /* @__PURE__ */ __name((pageSize2, signatureProp) => {
  if (signatureProp === GridSignature.DataGrid && pageSize2 > MAX_PAGE_SIZE) {
    throw new Error(["MUI X: `pageSize` cannot exceed 100 in the MIT version of the DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));
  }
}, "throwIfPageSizeExceedsTheLimit");
const ALL_RESULTS_PAGE_VALUE = -1;
const gridPaginationSelector = /* @__PURE__ */ __name((state) => state.pagination, "gridPaginationSelector");
const gridPaginationModelSelector = createSelector(gridPaginationSelector, (pagination) => pagination.paginationModel);
const gridPaginationRowCountSelector = createSelector(gridPaginationSelector, (pagination) => pagination.rowCount);
const gridPaginationMetaSelector = createSelector(gridPaginationSelector, (pagination) => pagination.meta);
const gridPageSelector = createSelector(gridPaginationModelSelector, (paginationModel) => paginationModel.page);
const gridPageSizeSelector = createSelector(gridPaginationModelSelector, (paginationModel) => paginationModel.pageSize);
const gridPageCountSelector = createSelector(gridPaginationModelSelector, gridPaginationRowCountSelector, (paginationModel, rowCount) => getPageCount(rowCount, paginationModel.pageSize, paginationModel.page));
const gridPaginationRowRangeSelector = createSelectorMemoized(gridPaginationModelSelector, gridRowTreeSelector, gridRowMaximumTreeDepthSelector, gridExpandedSortedRowEntriesSelector, gridFilteredSortedTopLevelRowEntriesSelector, (paginationModel, rowTree, rowTreeDepth, visibleSortedRowEntries, visibleSortedTopLevelRowEntries) => {
  var _a2;
  const visibleTopLevelRowCount = visibleSortedTopLevelRowEntries.length;
  const topLevelFirstRowIndex = Math.min(paginationModel.pageSize * paginationModel.page, visibleTopLevelRowCount - 1);
  const topLevelLastRowIndex = paginationModel.pageSize === ALL_RESULTS_PAGE_VALUE ? visibleTopLevelRowCount - 1 : Math.min(topLevelFirstRowIndex + paginationModel.pageSize - 1, visibleTopLevelRowCount - 1);
  if (topLevelFirstRowIndex === -1 || topLevelLastRowIndex === -1) {
    return null;
  }
  if (rowTreeDepth < 2) {
    return {
      firstRowIndex: topLevelFirstRowIndex,
      lastRowIndex: topLevelLastRowIndex
    };
  }
  const topLevelFirstRow = visibleSortedTopLevelRowEntries[topLevelFirstRowIndex];
  const topLevelRowsInCurrentPageCount = topLevelLastRowIndex - topLevelFirstRowIndex + 1;
  const firstRowIndex = visibleSortedRowEntries.findIndex((row) => row.id === topLevelFirstRow.id);
  let lastRowIndex = firstRowIndex;
  let topLevelRowAdded = 0;
  while (lastRowIndex < visibleSortedRowEntries.length && topLevelRowAdded <= topLevelRowsInCurrentPageCount) {
    const row = visibleSortedRowEntries[lastRowIndex];
    const depth = (_a2 = rowTree[row.id]) == null ? void 0 : _a2.depth;
    if (depth === void 0) {
      lastRowIndex += 1;
    } else {
      if (topLevelRowAdded < topLevelRowsInCurrentPageCount || depth > 0) {
        lastRowIndex += 1;
      }
      if (depth === 0) {
        topLevelRowAdded += 1;
      }
    }
  }
  return {
    firstRowIndex,
    lastRowIndex: lastRowIndex - 1
  };
});
const gridPaginatedVisibleSortedGridRowEntriesSelector = createSelectorMemoized(gridExpandedSortedRowEntriesSelector, gridPaginationRowRangeSelector, (visibleSortedRowEntries, paginationRange) => {
  if (!paginationRange) {
    return [];
  }
  return visibleSortedRowEntries.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);
});
const gridPaginatedVisibleSortedGridRowIdsSelector = createSelectorMemoized(gridExpandedSortedRowIdsSelector, gridPaginationRowRangeSelector, (visibleSortedRowIds, paginationRange) => {
  if (!paginationRange) {
    return [];
  }
  return visibleSortedRowIds.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);
});
const _excluded$U = ["field", "colDef"];
const useUtilityClasses$H = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["checkboxInput"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$H");
const GridHeaderCheckbox = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridHeaderCheckbox2(props, ref) {
  var _a2;
  const other = _objectWithoutPropertiesLoose$1(props, _excluded$U);
  const [, forceUpdate] = reactExports.useState(false);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$H(ownerState);
  const tabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);
  const selection = useGridSelector(apiRef, gridRowSelectionStateSelector);
  const visibleRowIds = useGridSelector(apiRef, gridExpandedSortedRowIdsSelector);
  const paginatedVisibleRowIds = useGridSelector(apiRef, gridPaginatedVisibleSortedGridRowIdsSelector);
  const filteredSelection = reactExports.useMemo(() => {
    if (typeof rootProps.isRowSelectable !== "function") {
      return selection;
    }
    return selection.filter((id2) => {
      if (!apiRef.current.getRow(id2)) {
        return false;
      }
      return rootProps.isRowSelectable(apiRef.current.getRowParams(id2));
    });
  }, [apiRef, rootProps.isRowSelectable, selection]);
  const selectionCandidates = reactExports.useMemo(() => {
    const rowIds = !rootProps.pagination || !rootProps.checkboxSelectionVisibleOnly ? visibleRowIds : paginatedVisibleRowIds;
    return rowIds.reduce((acc, id2) => {
      acc[id2] = true;
      return acc;
    }, {});
  }, [rootProps.pagination, rootProps.checkboxSelectionVisibleOnly, paginatedVisibleRowIds, visibleRowIds]);
  const currentSelectionSize = reactExports.useMemo(() => filteredSelection.filter((id2) => selectionCandidates[id2]).length, [filteredSelection, selectionCandidates]);
  const isIndeterminate = currentSelectionSize > 0 && currentSelectionSize < Object.keys(selectionCandidates).length;
  const isChecked = currentSelectionSize > 0;
  const handleChange = /* @__PURE__ */ __name((event) => {
    const params = {
      value: event.target.checked
    };
    apiRef.current.publishEvent("headerSelectionCheckboxChange", params);
  }, "handleChange");
  const tabIndex = tabIndexState !== null && tabIndexState.field === props.field ? 0 : -1;
  reactExports.useLayoutEffect(() => {
    const element = apiRef.current.getColumnHeaderElement(props.field);
    if (tabIndex === 0 && element) {
      element.tabIndex = -1;
    }
  }, [tabIndex, apiRef, props.field]);
  const handleKeyDown2 = reactExports.useCallback((event) => {
    if (event.key === " ") {
      apiRef.current.publishEvent("headerSelectionCheckboxChange", {
        value: !isChecked
      });
    }
  }, [apiRef, isChecked]);
  const handleSelectionChange = reactExports.useCallback(() => {
    forceUpdate((p2) => !p2);
  }, []);
  reactExports.useEffect(() => {
    return apiRef.current.subscribeEvent("rowSelectionChange", handleSelectionChange);
  }, [apiRef, handleSelectionChange]);
  const label = apiRef.current.getLocaleText(isChecked ? "checkboxSelectionUnselectAllRows" : "checkboxSelectionSelectAllRows");
  const checked = rootProps.indeterminateCheckboxAction === "select" ? isChecked && !isIndeterminate : isChecked;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends$4({
    ref,
    indeterminate: isIndeterminate,
    checked,
    onChange: handleChange,
    className: classes2.root,
    inputProps: {
      "aria-label": label
    },
    tabIndex,
    onKeyDown: handleKeyDown2,
    disabled: !isMultipleRowSelectionEnabled(rootProps)
  }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseCheckbox, other));
}, "GridHeaderCheckbox2"));
const GRID_CHECKBOX_SELECTION_FIELD = "__check__";
const GRID_CHECKBOX_SELECTION_COL_DEF = _extends$4({}, GRID_BOOLEAN_COL_DEF, {
  type: "custom",
  field: GRID_CHECKBOX_SELECTION_FIELD,
  width: 50,
  resizable: false,
  sortable: false,
  filterable: false,
  // @ts-ignore
  aggregable: false,
  disableColumnMenu: true,
  disableReorder: true,
  disableExport: true,
  getApplyQuickFilterFn: void 0,
  display: "flex",
  valueGetter: (value, row, column2, apiRef) => {
    const selectionLookup = selectedIdsLookupSelector(apiRef);
    const rowId = apiRef.current.getRowId(row);
    return selectionLookup[rowId] !== void 0;
  },
  renderHeader: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridHeaderCheckbox, _extends$4({}, params)),
  renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridCellCheckboxRenderer, _extends$4({}, params))
});
const _excluded$T = ["item", "applyValue", "type", "apiRef", "focusElementRef", "InputProps", "isFilterActive", "clearButton", "tabIndex", "disabled"];
function convertFilterItemValueToInputValue(itemValue, inputType) {
  if (itemValue == null) {
    return "";
  }
  const dateCopy = new Date(itemValue);
  if (Number.isNaN(dateCopy.getTime())) {
    return "";
  }
  if (inputType === "date") {
    return dateCopy.toISOString().substring(0, 10);
  }
  if (inputType === "datetime-local") {
    dateCopy.setMinutes(dateCopy.getMinutes() - dateCopy.getTimezoneOffset());
    return dateCopy.toISOString().substring(0, 19);
  }
  return dateCopy.toISOString().substring(0, 10);
}
__name(convertFilterItemValueToInputValue, "convertFilterItemValueToInputValue");
function GridFilterInputDate(props) {
  var _a2;
  const {
    item,
    applyValue,
    type,
    apiRef,
    focusElementRef,
    InputProps,
    clearButton,
    tabIndex,
    disabled
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$T);
  const filterTimeout = useTimeout();
  const [filterValueState, setFilterValueState] = reactExports.useState(() => convertFilterItemValueToInputValue(item.value, type));
  const [applying, setIsApplying] = reactExports.useState(false);
  const id2 = useId();
  const rootProps = useGridRootProps();
  const onFilterChange = reactExports.useCallback((event) => {
    filterTimeout.clear();
    const value = event.target.value;
    setFilterValueState(value);
    setIsApplying(true);
    filterTimeout.start(rootProps.filterDebounceMs, () => {
      const date = new Date(value);
      applyValue(_extends$4({}, item, {
        value: Number.isNaN(date.getTime()) ? void 0 : date
      }));
      setIsApplying(false);
    });
  }, [applyValue, item, rootProps.filterDebounceMs, filterTimeout]);
  reactExports.useEffect(() => {
    const value = convertFilterItemValueToInputValue(item.value, type);
    setFilterValueState(value);
  }, [item.value, type]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends$4({
    fullWidth: true,
    id: id2,
    label: apiRef.current.getLocaleText("filterPanelInputLabel"),
    placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
    value: filterValueState,
    onChange: onFilterChange,
    variant: "standard",
    type: type || "text",
    InputLabelProps: {
      shrink: true
    },
    inputRef: focusElementRef,
    InputProps: _extends$4({}, applying || clearButton ? {
      endAdornment: applying ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadIcon, {
        fontSize: "small",
        color: "action"
      }) : clearButton
    } : {}, {
      disabled
    }, InputProps, {
      inputProps: _extends$4({
        max: type === "datetime-local" ? "9999-12-31T23:59" : "9999-12-31",
        tabIndex
      }, InputProps == null ? void 0 : InputProps.inputProps)
    })
  }, other, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseTextField));
}
__name(GridFilterInputDate, "GridFilterInputDate");
function buildApplyFilterFn(filterItem, compareFn, showTime, keepHours) {
  if (!filterItem.value) {
    return null;
  }
  const date = new Date(filterItem.value);
  if (showTime) {
    date.setSeconds(0, 0);
  } else {
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    date.setHours(0, 0, 0, 0);
  }
  const time2 = date.getTime();
  return (value) => {
    if (!value) {
      return false;
    }
    if (keepHours) {
      return compareFn(value.getTime(), time2);
    }
    const dateCopy = new Date(value);
    if (showTime) {
      dateCopy.setSeconds(0, 0);
    } else {
      dateCopy.setHours(0, 0, 0, 0);
    }
    return compareFn(dateCopy.getTime(), time2);
  };
}
__name(buildApplyFilterFn, "buildApplyFilterFn");
const getGridDateOperators = /* @__PURE__ */ __name((showTime) => [{
  value: "is",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 === value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "not",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 !== value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "after",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 > value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "onOrAfter",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 >= value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "before",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 < value2, showTime, !showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "onOrBefore",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 <= value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "isEmpty",
  getApplyFilterFn: () => {
    return (value) => {
      return value == null;
    };
  },
  requiresFilterValue: false
}, {
  value: "isNotEmpty",
  getApplyFilterFn: () => {
    return (value) => {
      return value != null;
    };
  },
  requiresFilterValue: false
}], "getGridDateOperators");
const _excluded$S = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "hasFocus", "inputProps", "isValidating", "isProcessingProps", "onValueChange"];
const StyledInputBase$2 = styled(InputBase)({
  fontSize: "inherit"
});
const useUtilityClasses$G = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["editInputCell"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$G");
function GridEditDateCell(props) {
  const {
    id: id2,
    value: valueProp,
    field,
    colDef,
    hasFocus,
    inputProps,
    onValueChange
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$S);
  const isDateTime = colDef.type === "dateTime";
  const apiRef = useGridApiContext();
  const inputRef = reactExports.useRef();
  const valueTransformed = reactExports.useMemo(() => {
    let parsedDate;
    if (valueProp == null) {
      parsedDate = null;
    } else if (valueProp instanceof Date) {
      parsedDate = valueProp;
    } else {
      parsedDate = new Date((valueProp ?? "").toString());
    }
    let formattedDate;
    if (parsedDate == null || Number.isNaN(parsedDate.getTime())) {
      formattedDate = "";
    } else {
      const localDate = new Date(parsedDate.getTime() - parsedDate.getTimezoneOffset() * 60 * 1e3);
      formattedDate = localDate.toISOString().substr(0, isDateTime ? 16 : 10);
    }
    return {
      parsed: parsedDate,
      formatted: formattedDate
    };
  }, [valueProp, isDateTime]);
  const [valueState, setValueState] = reactExports.useState(valueTransformed);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$G(ownerState);
  const parseValueToDate = reactExports.useCallback((value) => {
    if (value === "") {
      return null;
    }
    const [date, time2] = value.split("T");
    const [year, month, day] = date.split("-");
    const parsedDate = /* @__PURE__ */ new Date();
    parsedDate.setFullYear(Number(year), Number(month) - 1, Number(day));
    parsedDate.setHours(0, 0, 0, 0);
    if (time2) {
      const [hours, minutes] = time2.split(":");
      parsedDate.setHours(Number(hours), Number(minutes), 0, 0);
    }
    return parsedDate;
  }, []);
  const handleChange = reactExports.useCallback(async (event) => {
    const newFormattedDate = event.target.value;
    const newParsedDate = parseValueToDate(newFormattedDate);
    if (onValueChange) {
      await onValueChange(event, newParsedDate);
    }
    setValueState({
      parsed: newParsedDate,
      formatted: newFormattedDate
    });
    apiRef.current.setEditCellValue({
      id: id2,
      field,
      value: newParsedDate
    }, event);
  }, [apiRef, field, id2, onValueChange, parseValueToDate]);
  reactExports.useEffect(() => {
    setValueState((state) => {
      var _a2, _b2;
      if (valueTransformed.parsed !== state.parsed && ((_a2 = valueTransformed.parsed) == null ? void 0 : _a2.getTime()) !== ((_b2 = state.parsed) == null ? void 0 : _b2.getTime())) {
        return valueTransformed;
      }
      return state;
    });
  }, [valueTransformed]);
  useEnhancedEffect(() => {
    if (hasFocus) {
      inputRef.current.focus();
    }
  }, [hasFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInputBase$2, _extends$4({
    inputRef,
    fullWidth: true,
    className: classes2.root,
    type: isDateTime ? "datetime-local" : "date",
    inputProps: _extends$4({
      max: isDateTime ? "9999-12-31T23:59" : "9999-12-31"
    }, inputProps),
    value: valueState.formatted,
    onChange: handleChange
  }, other));
}
__name(GridEditDateCell, "GridEditDateCell");
const renderEditDateCell = /* @__PURE__ */ __name((params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditDateCell, _extends$4({}, params)), "renderEditDateCell");
function throwIfNotDateObject({
  value,
  columnType,
  rowId,
  field
}) {
  if (!(value instanceof Date)) {
    throw new Error([`MUI X: \`${columnType}\` column type only accepts \`Date\` objects as values.`, "Use `valueGetter` to transform the value into a `Date` object.", `Row ID: ${rowId}, field: "${field}".`].join("\n"));
  }
}
__name(throwIfNotDateObject, "throwIfNotDateObject");
const gridDateFormatter = /* @__PURE__ */ __name((value, row, column2, apiRef) => {
  if (!value) {
    return "";
  }
  const rowId = apiRef.current.getRowId(row);
  throwIfNotDateObject({
    value,
    columnType: "date",
    rowId,
    field: column2.field
  });
  return value.toLocaleDateString();
}, "gridDateFormatter");
const gridDateTimeFormatter = /* @__PURE__ */ __name((value, row, column2, apiRef) => {
  if (!value) {
    return "";
  }
  const rowId = apiRef.current.getRowId(row);
  throwIfNotDateObject({
    value,
    columnType: "dateTime",
    rowId,
    field: column2.field
  });
  return value.toLocaleString();
}, "gridDateTimeFormatter");
const GRID_DATE_COL_DEF = _extends$4({}, GRID_STRING_COL_DEF, {
  type: "date",
  sortComparator: gridDateComparator,
  valueFormatter: gridDateFormatter,
  filterOperators: getGridDateOperators(),
  renderEditCell: renderEditDateCell,
  // @ts-ignore
  pastedValueParser: (value) => new Date(value)
});
const GRID_DATETIME_COL_DEF = _extends$4({}, GRID_STRING_COL_DEF, {
  type: "dateTime",
  sortComparator: gridDateComparator,
  valueFormatter: gridDateTimeFormatter,
  filterOperators: getGridDateOperators(true),
  renderEditCell: renderEditDateCell,
  // @ts-ignore
  pastedValueParser: (value) => new Date(value)
});
const parseNumericValue = /* @__PURE__ */ __name((value) => {
  if (value == null) {
    return null;
  }
  return Number(value);
}, "parseNumericValue");
const getGridNumericQuickFilterFn = /* @__PURE__ */ __name((value) => {
  if (value == null || Number.isNaN(value) || value === "") {
    return null;
  }
  return (columnValue) => {
    return parseNumericValue(columnValue) === parseNumericValue(value);
  };
}, "getGridNumericQuickFilterFn");
const getGridNumericOperators = /* @__PURE__ */ __name(() => [{
  value: "=",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      return parseNumericValue(value) === filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: "!=",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      return parseNumericValue(value) !== filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: ">",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) > filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: ">=",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) >= filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: "<",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) < filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: "<=",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) <= filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: "isEmpty",
  getApplyFilterFn: () => {
    return (value) => {
      return value == null;
    };
  },
  requiresFilterValue: false
}, {
  value: "isNotEmpty",
  getApplyFilterFn: () => {
    return (value) => {
      return value != null;
    };
  },
  requiresFilterValue: false
}, {
  value: "isAnyOf",
  getApplyFilterFn: (filterItem) => {
    if (!Array.isArray(filterItem.value) || filterItem.value.length === 0) {
      return null;
    }
    return (value) => {
      return value != null && filterItem.value.includes(Number(value));
    };
  },
  InputComponent: GridFilterInputMultipleValue,
  InputComponentProps: {
    type: "number"
  }
}], "getGridNumericOperators");
const GRID_NUMERIC_COL_DEF = _extends$4({}, GRID_STRING_COL_DEF, {
  type: "number",
  align: "right",
  headerAlign: "right",
  sortComparator: gridNumberComparator,
  valueParser: (value) => value === "" ? null : Number(value),
  valueFormatter: (value) => isNumber$1(value) ? value.toLocaleString() : value || "",
  filterOperators: getGridNumericOperators(),
  getApplyQuickFilterFn: getGridNumericQuickFilterFn
});
function isSingleSelectColDef(colDef) {
  return (colDef == null ? void 0 : colDef.type) === "singleSelect";
}
__name(isSingleSelectColDef, "isSingleSelectColDef");
function getValueOptions(column2, additionalParams) {
  if (!column2) {
    return void 0;
  }
  return typeof column2.valueOptions === "function" ? column2.valueOptions(_extends$4({
    field: column2.field
  }, additionalParams)) : column2.valueOptions;
}
__name(getValueOptions, "getValueOptions");
function getValueFromValueOptions(value, valueOptions, getOptionValue) {
  if (valueOptions === void 0) {
    return void 0;
  }
  const result = valueOptions.find((option) => {
    const optionValue = getOptionValue(option);
    return String(optionValue) === String(value);
  });
  return getOptionValue(result);
}
__name(getValueFromValueOptions, "getValueFromValueOptions");
const _excluded$R = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "className", "hasFocus", "isValidating", "isProcessingProps", "error", "onValueChange", "initialOpen"], _excluded2$8 = ["MenuProps"];
function isKeyboardEvent$1(event) {
  return !!event.key;
}
__name(isKeyboardEvent$1, "isKeyboardEvent$1");
function GridEditSingleSelectCell(props) {
  var _a2, _b2;
  const rootProps = useGridRootProps();
  const {
    id: id2,
    value: valueProp,
    field,
    row,
    colDef,
    hasFocus,
    error,
    onValueChange,
    initialOpen = rootProps.editMode === GridEditModes.Cell
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$R);
  const apiRef = useGridApiContext();
  const ref = reactExports.useRef();
  const inputRef = reactExports.useRef();
  const [open2, setOpen] = reactExports.useState(initialOpen);
  const baseSelectProps = ((_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseSelect) || {};
  const isSelectNative = baseSelectProps.native ?? false;
  const _ref = ((_b2 = rootProps.slotProps) == null ? void 0 : _b2.baseSelect) || {}, {
    MenuProps
  } = _ref, otherBaseSelectProps = _objectWithoutPropertiesLoose$1(_ref, _excluded2$8);
  useEnhancedEffect(() => {
    var _a3;
    if (hasFocus) {
      (_a3 = inputRef.current) == null ? void 0 : _a3.focus();
    }
  }, [hasFocus]);
  if (!isSingleSelectColDef(colDef)) {
    return null;
  }
  const valueOptions = getValueOptions(colDef, {
    id: id2,
    row
  });
  if (!valueOptions) {
    return null;
  }
  const getOptionValue = colDef.getOptionValue;
  const getOptionLabel = colDef.getOptionLabel;
  const handleChange = /* @__PURE__ */ __name(async (event) => {
    if (!isSingleSelectColDef(colDef) || !valueOptions) {
      return;
    }
    setOpen(false);
    const target = event.target;
    const formattedTargetValue = getValueFromValueOptions(target.value, valueOptions, getOptionValue);
    if (onValueChange) {
      await onValueChange(event, formattedTargetValue);
    }
    await apiRef.current.setEditCellValue({
      id: id2,
      field,
      value: formattedTargetValue
    }, event);
  }, "handleChange");
  const handleClose = /* @__PURE__ */ __name((event, reason) => {
    if (rootProps.editMode === GridEditModes.Row) {
      setOpen(false);
      return;
    }
    if (reason === "backdropClick" || event.key === "Escape") {
      const params = apiRef.current.getCellParams(id2, field);
      apiRef.current.publishEvent("cellEditStop", _extends$4({}, params, {
        reason: event.key === "Escape" ? GridCellEditStopReasons.escapeKeyDown : GridCellEditStopReasons.cellFocusOut
      }));
    }
  }, "handleClose");
  const handleOpen = /* @__PURE__ */ __name((event) => {
    if (isKeyboardEvent$1(event) && event.key === "Enter") {
      return;
    }
    setOpen(true);
  }, "handleOpen");
  if (!valueOptions || !colDef) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends$4({
    ref,
    inputRef,
    value: valueProp,
    onChange: handleChange,
    open: open2,
    onOpen: handleOpen,
    MenuProps: _extends$4({
      onClose: handleClose
    }, MenuProps),
    error,
    native: isSelectNative,
    fullWidth: true
  }, other, otherBaseSelectProps, {
    children: valueOptions.map((valueOption) => {
      var _a3;
      const value = getOptionValue(valueOption);
      return /* @__PURE__ */ reactExports.createElement(rootProps.slots.baseSelectOption, _extends$4({}, ((_a3 = rootProps.slotProps) == null ? void 0 : _a3.baseSelectOption) || {}, {
        native: isSelectNative,
        key: value,
        value
      }), getOptionLabel(valueOption));
    })
  }));
}
__name(GridEditSingleSelectCell, "GridEditSingleSelectCell");
const renderEditSingleSelectCell = /* @__PURE__ */ __name((params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditSingleSelectCell, _extends$4({}, params)), "renderEditSingleSelectCell");
const _excluded$Q = ["item", "applyValue", "type", "apiRef", "focusElementRef", "placeholder", "tabIndex", "label", "variant", "isFilterActive", "clearButton", "InputLabelProps"];
const renderSingleSelectOptions = /* @__PURE__ */ __name(({
  column: column2,
  OptionComponent,
  getOptionLabel,
  getOptionValue,
  isSelectNative,
  baseSelectOptionProps
}) => {
  const iterableColumnValues = ["", ...getValueOptions(column2) || []];
  return iterableColumnValues.map((option) => {
    const value = getOptionValue(option);
    let label = getOptionLabel(option);
    if (label === "") {
      label = "";
    }
    return /* @__PURE__ */ reactExports.createElement(OptionComponent, _extends$4({}, baseSelectOptionProps, {
      native: isSelectNative,
      key: value,
      value
    }), label);
  });
}, "renderSingleSelectOptions");
const SingleSelectOperatorContainer = styled("div")({
  display: "flex",
  alignItems: "flex-end",
  width: "100%",
  [`& button`]: {
    margin: "auto 0px 5px 5px"
  }
});
function GridFilterInputSingleSelect(props) {
  var _a2, _b2, _c2, _d2, _e2;
  const {
    item,
    applyValue,
    type,
    apiRef,
    focusElementRef,
    placeholder,
    tabIndex,
    label: labelProp,
    variant = "standard",
    clearButton
  } = props, others = _objectWithoutPropertiesLoose$1(props, _excluded$Q);
  const filterValue = item.value ?? "";
  const id2 = useId();
  const labelId = useId();
  const rootProps = useGridRootProps();
  const isSelectNative = ((_b2 = (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseSelect) == null ? void 0 : _b2.native) ?? false;
  let resolvedColumn = null;
  if (item.field) {
    const column2 = apiRef.current.getColumn(item.field);
    if (isSingleSelectColDef(column2)) {
      resolvedColumn = column2;
    }
  }
  const getOptionValue = resolvedColumn == null ? void 0 : resolvedColumn.getOptionValue;
  const getOptionLabel = resolvedColumn == null ? void 0 : resolvedColumn.getOptionLabel;
  const currentValueOptions = reactExports.useMemo(() => {
    return getValueOptions(resolvedColumn);
  }, [resolvedColumn]);
  const onFilterChange = reactExports.useCallback((event) => {
    let value = event.target.value;
    value = getValueFromValueOptions(value, currentValueOptions, getOptionValue);
    applyValue(_extends$4({}, item, {
      value
    }));
  }, [currentValueOptions, getOptionValue, applyValue, item]);
  if (!isSingleSelectColDef(resolvedColumn)) {
    return null;
  }
  const label = labelProp ?? apiRef.current.getLocaleText("filterPanelInputLabel");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SingleSelectOperatorContainer, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(rootProps.slots.baseFormControl, {
      fullWidth: true,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends$4({}, (_c2 = rootProps.slotProps) == null ? void 0 : _c2.baseInputLabel, {
        id: labelId,
        htmlFor: id2,
        shrink: true,
        variant,
        children: label
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends$4({
        id: id2,
        label,
        labelId,
        value: filterValue,
        onChange: onFilterChange,
        variant,
        type: type || "text",
        inputProps: {
          tabIndex,
          ref: focusElementRef,
          placeholder: placeholder ?? apiRef.current.getLocaleText("filterPanelInputPlaceholder")
        },
        native: isSelectNative,
        notched: variant === "outlined" ? true : void 0
      }, others, (_d2 = rootProps.slotProps) == null ? void 0 : _d2.baseSelect, {
        children: renderSingleSelectOptions({
          column: resolvedColumn,
          OptionComponent: rootProps.slots.baseSelectOption,
          getOptionLabel,
          getOptionValue,
          isSelectNative,
          baseSelectOptionProps: (_e2 = rootProps.slotProps) == null ? void 0 : _e2.baseSelectOption
        })
      }))]
    }), clearButton]
  });
}
__name(GridFilterInputSingleSelect, "GridFilterInputSingleSelect");
const _excluded$P = ["item", "applyValue", "type", "apiRef", "focusElementRef", "color", "error", "helperText", "size", "variant"], _excluded2$7 = ["key"];
const filter$2 = createFilterOptions();
function GridFilterInputMultipleSingleSelect(props) {
  const {
    item,
    applyValue,
    apiRef,
    focusElementRef,
    color: color2,
    error,
    helperText,
    size: size2,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$P);
  const TextFieldProps = {
    color: color2,
    error,
    helperText,
    size: size2,
    variant
  };
  const id2 = useId();
  const rootProps = useGridRootProps();
  let resolvedColumn = null;
  if (item.field) {
    const column2 = apiRef.current.getColumn(item.field);
    if (isSingleSelectColDef(column2)) {
      resolvedColumn = column2;
    }
  }
  const getOptionValue = resolvedColumn == null ? void 0 : resolvedColumn.getOptionValue;
  const getOptionLabel = resolvedColumn == null ? void 0 : resolvedColumn.getOptionLabel;
  const isOptionEqualToValue = reactExports.useCallback((option, value) => getOptionValue(option) === getOptionValue(value), [getOptionValue]);
  const resolvedValueOptions = reactExports.useMemo(() => {
    return getValueOptions(resolvedColumn) || [];
  }, [resolvedColumn]);
  const filteredValues = reactExports.useMemo(() => {
    if (!Array.isArray(item.value)) {
      return [];
    }
    return item.value.reduce((acc, value) => {
      const resolvedValue = resolvedValueOptions.find((v2) => getOptionValue(v2) === value);
      if (resolvedValue != null) {
        acc.push(resolvedValue);
      }
      return acc;
    }, []);
  }, [getOptionValue, item.value, resolvedValueOptions]);
  const handleChange = reactExports.useCallback((event, value) => {
    applyValue(_extends$4({}, item, {
      value: value.map(getOptionValue)
    }));
  }, [applyValue, item, getOptionValue]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete, _extends$4({
    multiple: true,
    options: resolvedValueOptions,
    isOptionEqualToValue,
    filterOptions: filter$2,
    id: id2,
    value: filteredValues,
    onChange: handleChange,
    getOptionLabel,
    renderTags: (value, getTagProps) => value.map((option, index2) => {
      const _getTagProps = getTagProps({
        index: index2
      }), {
        key
      } = _getTagProps, tagProps = _objectWithoutPropertiesLoose$1(_getTagProps, _excluded2$7);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseChip, _extends$4({
        variant: "outlined",
        size: "small",
        label: getOptionLabel(option)
      }, tagProps), key);
    }),
    renderInput: (params) => {
      var _a2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends$4({}, params, {
        label: apiRef.current.getLocaleText("filterPanelInputLabel"),
        placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
        InputLabelProps: _extends$4({}, params.InputLabelProps, {
          shrink: true
        }),
        inputRef: focusElementRef,
        type: "singleSelect"
      }, TextFieldProps, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseTextField));
    }
  }, other));
}
__name(GridFilterInputMultipleSingleSelect, "GridFilterInputMultipleSingleSelect");
const parseObjectValue = /* @__PURE__ */ __name((value) => {
  if (value == null || !isObject$2(value)) {
    return value;
  }
  return value.value;
}, "parseObjectValue");
const getGridSingleSelectOperators = /* @__PURE__ */ __name(() => [{
  value: "is",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || filterItem.value === "") {
      return null;
    }
    return (value) => parseObjectValue(value) === parseObjectValue(filterItem.value);
  },
  InputComponent: GridFilterInputSingleSelect
}, {
  value: "not",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || filterItem.value === "") {
      return null;
    }
    return (value) => parseObjectValue(value) !== parseObjectValue(filterItem.value);
  },
  InputComponent: GridFilterInputSingleSelect
}, {
  value: "isAnyOf",
  getApplyFilterFn: (filterItem) => {
    if (!Array.isArray(filterItem.value) || filterItem.value.length === 0) {
      return null;
    }
    const filterItemValues = filterItem.value.map(parseObjectValue);
    return (value) => filterItemValues.includes(parseObjectValue(value));
  },
  InputComponent: GridFilterInputMultipleSingleSelect
}], "getGridSingleSelectOperators");
const isArrayOfObjects = /* @__PURE__ */ __name((options) => {
  return typeof options[0] === "object";
}, "isArrayOfObjects");
const defaultGetOptionValue = /* @__PURE__ */ __name((value) => {
  return isObject$2(value) ? value.value : value;
}, "defaultGetOptionValue");
const defaultGetOptionLabel = /* @__PURE__ */ __name((value) => {
  return isObject$2(value) ? value.label : String(value);
}, "defaultGetOptionLabel");
const GRID_SINGLE_SELECT_COL_DEF = _extends$4({}, GRID_STRING_COL_DEF, {
  type: "singleSelect",
  getOptionLabel: defaultGetOptionLabel,
  getOptionValue: defaultGetOptionValue,
  valueFormatter(value, row, colDef, apiRef) {
    const rowId = apiRef.current.getRowId(row);
    if (!isSingleSelectColDef(colDef)) {
      return "";
    }
    const valueOptions = getValueOptions(colDef, {
      id: rowId,
      row
    });
    if (value == null) {
      return "";
    }
    if (!valueOptions) {
      return value;
    }
    if (!isArrayOfObjects(valueOptions)) {
      return colDef.getOptionLabel(value);
    }
    const valueOption = valueOptions.find((option) => colDef.getOptionValue(option) === value);
    return valueOption ? colDef.getOptionLabel(valueOption) : "";
  },
  renderEditCell: renderEditSingleSelectCell,
  filterOperators: getGridSingleSelectOperators(),
  // @ts-ignore
  pastedValueParser: (value, row, column2) => {
    const colDef = column2;
    const valueOptions = getValueOptions(colDef) || [];
    const getOptionValue = colDef.getOptionValue;
    const valueOption = valueOptions.find((option) => {
      if (getOptionValue(option) === value) {
        return true;
      }
      return false;
    });
    if (valueOption) {
      return value;
    }
    return void 0;
  }
});
const DEFAULT_GRID_COL_TYPE_KEY = "string";
const getGridDefaultColumnTypes = /* @__PURE__ */ __name(() => {
  const nativeColumnTypes = {
    string: GRID_STRING_COL_DEF,
    number: GRID_NUMERIC_COL_DEF,
    date: GRID_DATE_COL_DEF,
    dateTime: GRID_DATETIME_COL_DEF,
    boolean: GRID_BOOLEAN_COL_DEF,
    singleSelect: GRID_SINGLE_SELECT_COL_DEF,
    [GRID_ACTIONS_COLUMN_TYPE]: GRID_ACTIONS_COL_DEF,
    custom: GRID_STRING_COL_DEF
  };
  return nativeColumnTypes;
}, "getGridDefaultColumnTypes");
const gridHeaderFilteringStateSelector = /* @__PURE__ */ __name((state) => state.headerFiltering, "gridHeaderFilteringStateSelector");
const gridHeaderFilteringEnabledSelector = createSelector(
  gridHeaderFilteringStateSelector,
  // No initialization in MIT, so we need to default to false to be used by `getTotalHeaderHeight`
  (headerFilteringState) => (headerFilteringState == null ? void 0 : headerFilteringState.enabled) ?? false
);
const gridHeaderFilteringEditFieldSelector = createSelector(gridHeaderFilteringStateSelector, (headerFilteringState) => headerFilteringState.editing);
const gridHeaderFilteringMenuSelector = createSelector(gridHeaderFilteringStateSelector, (headerFilteringState) => headerFilteringState.menuOpen);
const gridColumnGroupingSelector = /* @__PURE__ */ __name((state) => state.columnGrouping, "gridColumnGroupingSelector");
const gridColumnGroupsUnwrappedModelSelector = createSelectorMemoized(gridColumnGroupingSelector, (columnGrouping) => (columnGrouping == null ? void 0 : columnGrouping.unwrappedGroupingModel) ?? {});
const gridColumnGroupsLookupSelector = createSelectorMemoized(gridColumnGroupingSelector, (columnGrouping) => (columnGrouping == null ? void 0 : columnGrouping.lookup) ?? {});
const gridColumnGroupsHeaderStructureSelector = createSelectorMemoized(gridColumnGroupingSelector, (columnGrouping) => (columnGrouping == null ? void 0 : columnGrouping.headerStructure) ?? []);
const gridColumnGroupsHeaderMaxDepthSelector = createSelector(gridColumnGroupingSelector, (columnGrouping) => (columnGrouping == null ? void 0 : columnGrouping.maxDepth) ?? 0);
const COLUMNS_DIMENSION_PROPERTIES = ["maxWidth", "minWidth", "width", "flex"];
const COLUMN_TYPES = getGridDefaultColumnTypes();
function computeFlexColumnsWidth({
  initialFreeSpace,
  totalFlexUnits,
  flexColumns
}) {
  const uniqueFlexColumns = new Set(flexColumns.map((col) => col.field));
  const flexColumnsLookup = {
    all: {},
    frozenFields: [],
    freeze: (field) => {
      const value = flexColumnsLookup.all[field];
      if (value && value.frozen !== true) {
        flexColumnsLookup.all[field].frozen = true;
        flexColumnsLookup.frozenFields.push(field);
      }
    }
  };
  function loopOverFlexItems() {
    if (flexColumnsLookup.frozenFields.length === uniqueFlexColumns.size) {
      return;
    }
    const violationsLookup = {
      min: {},
      max: {}
    };
    let remainingFreeSpace = initialFreeSpace;
    let flexUnits = totalFlexUnits;
    let totalViolation = 0;
    flexColumnsLookup.frozenFields.forEach((field) => {
      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;
      flexUnits -= flexColumnsLookup.all[field].flex;
    });
    for (let i = 0; i < flexColumns.length; i += 1) {
      const column2 = flexColumns[i];
      if (flexColumnsLookup.all[column2.field] && flexColumnsLookup.all[column2.field].frozen === true) {
        continue;
      }
      const widthPerFlexUnit = remainingFreeSpace / flexUnits;
      let computedWidth = widthPerFlexUnit * column2.flex;
      if (computedWidth < column2.minWidth) {
        totalViolation += column2.minWidth - computedWidth;
        computedWidth = column2.minWidth;
        violationsLookup.min[column2.field] = true;
      } else if (computedWidth > column2.maxWidth) {
        totalViolation += column2.maxWidth - computedWidth;
        computedWidth = column2.maxWidth;
        violationsLookup.max[column2.field] = true;
      }
      flexColumnsLookup.all[column2.field] = {
        frozen: false,
        computedWidth,
        flex: column2.flex
      };
    }
    if (totalViolation < 0) {
      Object.keys(violationsLookup.max).forEach((field) => {
        flexColumnsLookup.freeze(field);
      });
    } else if (totalViolation > 0) {
      Object.keys(violationsLookup.min).forEach((field) => {
        flexColumnsLookup.freeze(field);
      });
    } else {
      flexColumns.forEach(({
        field
      }) => {
        flexColumnsLookup.freeze(field);
      });
    }
    loopOverFlexItems();
  }
  __name(loopOverFlexItems, "loopOverFlexItems");
  loopOverFlexItems();
  return flexColumnsLookup.all;
}
__name(computeFlexColumnsWidth, "computeFlexColumnsWidth");
const hydrateColumnsWidth = /* @__PURE__ */ __name((rawState, dimensions) => {
  const columnsLookup = {};
  let totalFlexUnits = 0;
  let widthAllocatedBeforeFlex = 0;
  const flexColumns = [];
  rawState.orderedFields.forEach((columnField) => {
    let column2 = rawState.lookup[columnField];
    let computedWidth = 0;
    let isFlex = false;
    if (rawState.columnVisibilityModel[columnField] !== false) {
      if (column2.flex && column2.flex > 0) {
        totalFlexUnits += column2.flex;
        isFlex = true;
      } else {
        computedWidth = clamp$3(column2.width || GRID_STRING_COL_DEF.width, column2.minWidth || GRID_STRING_COL_DEF.minWidth, column2.maxWidth || GRID_STRING_COL_DEF.maxWidth);
      }
      widthAllocatedBeforeFlex += computedWidth;
    }
    if (column2.computedWidth !== computedWidth) {
      column2 = _extends$4({}, column2, {
        computedWidth
      });
    }
    if (isFlex) {
      flexColumns.push(column2);
    }
    columnsLookup[columnField] = column2;
  });
  const availableWidth = dimensions === void 0 ? 0 : dimensions.viewportOuterSize.width - (dimensions.hasScrollY ? dimensions.scrollbarSize : 0);
  const initialFreeSpace = Math.max(availableWidth - widthAllocatedBeforeFlex, 0);
  if (totalFlexUnits > 0 && availableWidth > 0) {
    const computedColumnWidths = computeFlexColumnsWidth({
      initialFreeSpace,
      totalFlexUnits,
      flexColumns
    });
    Object.keys(computedColumnWidths).forEach((field) => {
      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;
    });
  }
  return _extends$4({}, rawState, {
    lookup: columnsLookup
  });
}, "hydrateColumnsWidth");
const applyInitialState = /* @__PURE__ */ __name((columnsState, initialState2) => {
  if (!initialState2) {
    return columnsState;
  }
  const {
    orderedFields = [],
    dimensions = {}
  } = initialState2;
  const columnsWithUpdatedDimensions = Object.keys(dimensions);
  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {
    return columnsState;
  }
  const orderedFieldsLookup = {};
  const cleanOrderedFields = [];
  for (let i = 0; i < orderedFields.length; i += 1) {
    const field = orderedFields[i];
    if (columnsState.lookup[field]) {
      orderedFieldsLookup[field] = true;
      cleanOrderedFields.push(field);
    }
  }
  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter((field) => !orderedFieldsLookup[field])];
  const newColumnLookup = _extends$4({}, columnsState.lookup);
  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {
    const field = columnsWithUpdatedDimensions[i];
    const newColDef = _extends$4({}, newColumnLookup[field], {
      hasBeenResized: true
    });
    Object.entries(dimensions[field]).forEach(([key, value]) => {
      newColDef[key] = value === -1 ? Infinity : value;
    });
    newColumnLookup[field] = newColDef;
  }
  const newColumnsState = _extends$4({}, columnsState, {
    orderedFields: newOrderedFields,
    lookup: newColumnLookup
  });
  return newColumnsState;
}, "applyInitialState");
function getDefaultColTypeDef(type) {
  let colDef = COLUMN_TYPES[DEFAULT_GRID_COL_TYPE_KEY];
  if (type && COLUMN_TYPES[type]) {
    colDef = COLUMN_TYPES[type];
  }
  return colDef;
}
__name(getDefaultColTypeDef, "getDefaultColTypeDef");
const createColumnsState = /* @__PURE__ */ __name(({
  apiRef,
  columnsToUpsert,
  initialState: initialState2,
  columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),
  keepOnlyColumnsToUpsert = false
}) => {
  var _a2, _b2;
  const isInsideStateInitializer = !apiRef.current.state.columns;
  let columnsState;
  if (isInsideStateInitializer) {
    columnsState = {
      orderedFields: [],
      lookup: {},
      columnVisibilityModel
    };
  } else {
    const currentState = gridColumnsStateSelector(apiRef.current.state);
    columnsState = {
      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],
      lookup: _extends$4({}, currentState.lookup),
      // Will be cleaned later if keepOnlyColumnsToUpsert=true
      columnVisibilityModel
    };
  }
  let columnsToKeep = {};
  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {
    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => _extends$4({}, acc, {
      [key]: false
    }), {});
  }
  columnsToUpsert.forEach((newColumn) => {
    const {
      field
    } = newColumn;
    columnsToKeep[field] = true;
    let existingState = columnsState.lookup[field];
    if (existingState == null) {
      existingState = _extends$4({}, getDefaultColTypeDef(newColumn.type), {
        field,
        hasBeenResized: false
      });
      columnsState.orderedFields.push(field);
    } else if (keepOnlyColumnsToUpsert) {
      columnsState.orderedFields.push(field);
    }
    if (existingState && existingState.type !== newColumn.type) {
      existingState = _extends$4({}, getDefaultColTypeDef(newColumn.type), {
        field
      });
    }
    let hasBeenResized = existingState.hasBeenResized;
    COLUMNS_DIMENSION_PROPERTIES.forEach((key) => {
      if (newColumn[key] !== void 0) {
        hasBeenResized = true;
        if (newColumn[key] === -1) {
          newColumn[key] = Infinity;
        }
      }
    });
    columnsState.lookup[field] = resolveProps(existingState, _extends$4({}, newColumn, {
      hasBeenResized
    }));
  });
  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {
    Object.keys(columnsState.lookup).forEach((field) => {
      if (!columnsToKeep[field]) {
        delete columnsState.lookup[field];
      }
    });
  }
  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors("hydrateColumns", columnsState);
  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState2);
  return hydrateColumnsWidth(columnsStateWithPortableColumns, ((_b2 = (_a2 = apiRef.current).getRootDimensions) == null ? void 0 : _b2.call(_a2)) ?? void 0);
}, "createColumnsState");
function getFirstNonSpannedColumnToRender({
  firstColumnToRender,
  apiRef,
  firstRowToRender,
  lastRowToRender,
  visibleRows
}) {
  let firstNonSpannedColumnToRender = firstColumnToRender;
  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {
    const row = visibleRows[i];
    if (row) {
      const rowId = visibleRows[i].id;
      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);
      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {
        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;
      }
    }
  }
  return firstNonSpannedColumnToRender;
}
__name(getFirstNonSpannedColumnToRender, "getFirstNonSpannedColumnToRender");
function getTotalHeaderHeight(apiRef, props) {
  if (props.unstable_listView) {
    return 0;
  }
  const densityFactor = gridDensityFactorSelector(apiRef);
  const maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);
  const isHeaderFilteringEnabled = gridHeaderFilteringEnabledSelector(apiRef);
  const columnHeadersHeight = Math.floor(props.columnHeaderHeight * densityFactor);
  const filterHeadersHeight = isHeaderFilteringEnabled ? Math.floor((props.headerFilterHeight ?? props.columnHeaderHeight) * densityFactor) : 0;
  return columnHeadersHeight * (1 + (maxDepth ?? 0)) + filterHeadersHeight;
}
__name(getTotalHeaderHeight, "getTotalHeaderHeight");
const CLIFF = 1;
const SLOP = 1.5;
const useUtilityClasses$F = /* @__PURE__ */ __name((ownerState) => {
  const {
    scrollDirection,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["scrollArea", `scrollArea--${scrollDirection}`]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$F");
const GridScrollAreaRawRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "ScrollArea",
  overridesResolver: (props, styles2) => [{
    [`&.${gridClasses["scrollArea--left"]}`]: styles2["scrollArea--left"]
  }, {
    [`&.${gridClasses["scrollArea--right"]}`]: styles2["scrollArea--right"]
  }, styles2.scrollArea]
})(() => ({
  position: "absolute",
  top: 0,
  zIndex: 101,
  width: 20,
  bottom: 0,
  [`&.${gridClasses["scrollArea--left"]}`]: {
    left: 0
  },
  [`&.${gridClasses["scrollArea--right"]}`]: {
    right: 0
  }
}));
function GridScrollAreaRaw(props) {
  const {
    scrollDirection
  } = props;
  const rootRef = reactExports.useRef(null);
  const apiRef = useGridApiContext();
  const timeout = useTimeout();
  const densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);
  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);
  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);
  const scrollPosition = reactExports.useRef({
    left: 0,
    top: 0
  });
  const getCanScrollMore = /* @__PURE__ */ __name(() => {
    if (scrollDirection === "left") {
      return scrollPosition.current.left > 0;
    }
    if (scrollDirection === "right") {
      const maxScrollLeft = columnsTotalWidth - dimensions.viewportInnerSize.width;
      return scrollPosition.current.left < maxScrollLeft;
    }
    return false;
  }, "getCanScrollMore");
  const [dragging, setDragging] = reactExports.useState(false);
  const [canScrollMore, setCanScrollMore] = reactExports.useState(getCanScrollMore);
  const rootProps = useGridRootProps();
  const ownerState = _extends$4({}, rootProps, {
    scrollDirection
  });
  const classes2 = useUtilityClasses$F(ownerState);
  const totalHeaderHeight = getTotalHeaderHeight(apiRef, rootProps);
  const headerHeight = Math.floor(rootProps.columnHeaderHeight * densityFactor);
  const style2 = {
    height: headerHeight,
    top: totalHeaderHeight - headerHeight
  };
  if (scrollDirection === "left") {
    style2.left = dimensions.leftPinnedWidth;
  } else if (scrollDirection === "right") {
    style2.right = dimensions.rightPinnedWidth + (dimensions.hasScrollX ? dimensions.scrollbarSize : 0);
  }
  const handleScrolling = /* @__PURE__ */ __name((newScrollPosition) => {
    scrollPosition.current = newScrollPosition;
    setCanScrollMore(getCanScrollMore);
  }, "handleScrolling");
  const handleDragOver = useEventCallback((event) => {
    let offset2;
    event.preventDefault();
    if (scrollDirection === "left") {
      offset2 = event.clientX - rootRef.current.getBoundingClientRect().right;
    } else if (scrollDirection === "right") {
      offset2 = Math.max(1, event.clientX - rootRef.current.getBoundingClientRect().left);
    } else {
      throw new Error("MUI X: Wrong drag direction");
    }
    offset2 = (offset2 - CLIFF) * SLOP + CLIFF;
    timeout.start(0, () => {
      apiRef.current.scroll({
        left: scrollPosition.current.left + offset2,
        top: scrollPosition.current.top
      });
    });
  });
  const handleColumnHeaderDragStart = useEventCallback(() => {
    setDragging(true);
  });
  const handleColumnHeaderDragEnd = useEventCallback(() => {
    setDragging(false);
  });
  useGridApiEventHandler(apiRef, "scrollPositionChange", handleScrolling);
  useGridApiEventHandler(apiRef, "columnHeaderDragStart", handleColumnHeaderDragStart);
  useGridApiEventHandler(apiRef, "columnHeaderDragEnd", handleColumnHeaderDragEnd);
  if (!dragging || !canScrollMore) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridScrollAreaRawRoot, {
    ref: rootRef,
    className: clsx(classes2.root),
    ownerState,
    onDragOver: handleDragOver,
    style: style2
  });
}
__name(GridScrollAreaRaw, "GridScrollAreaRaw");
const GridScrollArea = fastMemo(GridScrollAreaRaw);
const noop$5 = /* @__PURE__ */ __name(() => {
}, "noop$5");
function useResizeObserver(ref, fn2, enabled) {
  const fnRef = reactExports.useRef(null);
  fnRef.current = fn2;
  useEnhancedEffect(() => {
    if (typeof ResizeObserver === "undefined") {
      return noop$5;
    }
    const target = ref.current;
    const observer = new ResizeObserver((entries) => {
      {
        fnRef.current(entries);
      }
    });
    if (target) {
      observer.observe(target);
    }
    return () => {
      observer.disconnect();
    };
  }, [ref, enabled]);
}
__name(useResizeObserver, "useResizeObserver");
const GridPrivateApiContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useGridPrivateApiContext() {
  const privateApiRef = reactExports.useContext(GridPrivateApiContext);
  if (privateApiRef === void 0) {
    throw new Error(["MUI X: Could not find the Data Grid private context.", "It looks like you rendered your component outside of a DataGrid, DataGridPro or DataGridPremium parent component.", "This can also happen if you are bundling multiple versions of the Data Grid."].join("\n"));
  }
  return privateApiRef;
}
__name(useGridPrivateApiContext, "useGridPrivateApiContext");
const getVisibleRows = /* @__PURE__ */ __name((apiRef, props) => {
  let rows;
  let range2;
  if (props.pagination && props.paginationMode === "client") {
    range2 = gridPaginationRowRangeSelector(apiRef);
    rows = gridPaginatedVisibleSortedGridRowEntriesSelector(apiRef);
  } else {
    rows = gridExpandedSortedRowEntriesSelector(apiRef);
    if (rows.length === 0) {
      range2 = null;
    } else {
      range2 = {
        firstRowIndex: 0,
        lastRowIndex: rows.length - 1
      };
    }
  }
  return {
    rows,
    range: range2
  };
}, "getVisibleRows");
const useGridVisibleRows = /* @__PURE__ */ __name((apiRef, props) => {
  const response = getVisibleRows(apiRef, props);
  return reactExports.useMemo(() => ({
    rows: response.rows,
    range: response.range
  }), [response.rows, response.range]);
}, "useGridVisibleRows");
const userAgent = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase() : "empty";
const isFirefox = userAgent.includes("firefox");
const gridRowsMetaSelector = /* @__PURE__ */ __name((state) => state.rowsMeta, "gridRowsMetaSelector");
const gridVirtualizationSelector = /* @__PURE__ */ __name((state) => state.virtualization, "gridVirtualizationSelector");
createSelector(gridVirtualizationSelector, (state) => state.enabled);
const gridVirtualizationColumnEnabledSelector = createSelector(gridVirtualizationSelector, (state) => state.enabledForColumns);
const gridVirtualizationRowEnabledSelector = createSelector(gridVirtualizationSelector, (state) => state.enabledForRows);
const gridRenderContextSelector = createSelector(gridVirtualizationSelector, (state) => state.renderContext);
const gridRenderContextColumnsSelector = createSelectorMemoized((state) => state.virtualization.renderContext.firstColumnIndex, (state) => state.virtualization.renderContext.lastColumnIndex, (firstColumnIndex, lastColumnIndex) => ({
  firstColumnIndex,
  lastColumnIndex
}));
const EMPTY_RENDER_CONTEXT = {
  firstRowIndex: 0,
  lastRowIndex: 0,
  firstColumnIndex: 0,
  lastColumnIndex: 0
};
const virtualizationStateInitializer = /* @__PURE__ */ __name((state, props) => {
  const {
    disableVirtualization,
    autoHeight
  } = props;
  const virtualization = {
    enabled: !disableVirtualization,
    enabledForColumns: !disableVirtualization,
    enabledForRows: !disableVirtualization && !autoHeight,
    renderContext: EMPTY_RENDER_CONTEXT
  };
  return _extends$4({}, state, {
    virtualization
  });
}, "virtualizationStateInitializer");
function useGridVirtualization(apiRef, props) {
  const setVirtualization = /* @__PURE__ */ __name((enabled) => {
    apiRef.current.setState((state) => _extends$4({}, state, {
      virtualization: _extends$4({}, state.virtualization, {
        enabled,
        enabledForColumns: enabled,
        enabledForRows: enabled && !props.autoHeight
      })
    }));
  }, "setVirtualization");
  const setColumnVirtualization = /* @__PURE__ */ __name((enabled) => {
    apiRef.current.setState((state) => _extends$4({}, state, {
      virtualization: _extends$4({}, state.virtualization, {
        enabledForColumns: enabled
      })
    }));
  }, "setColumnVirtualization");
  const api2 = {
    unstable_setVirtualization: setVirtualization,
    unstable_setColumnVirtualization: setColumnVirtualization
  };
  useGridApiMethod(apiRef, api2, "public");
  reactExports.useEffect(() => {
    setVirtualization(!props.disableVirtualization);
  }, [props.disableVirtualization, props.autoHeight]);
}
__name(useGridVirtualization, "useGridVirtualization");
const gridRowSpanningStateSelector = /* @__PURE__ */ __name((state) => state.rowSpanning, "gridRowSpanningStateSelector");
const gridRowSpanningHiddenCellsSelector = createSelector(gridRowSpanningStateSelector, (rowSpanning) => rowSpanning.hiddenCells);
const gridRowSpanningSpannedCellsSelector = createSelector(gridRowSpanningStateSelector, (rowSpanning) => rowSpanning.spannedCells);
const gridRowSpanningHiddenCellsOriginMapSelector = createSelector(gridRowSpanningStateSelector, (rowSpanning) => rowSpanning.hiddenCellOriginMap);
const gridListColumnSelector = /* @__PURE__ */ __name((state) => state.listViewColumn, "gridListColumnSelector");
const MINIMUM_COLUMN_WIDTH = 50;
var ScrollDirection = /* @__PURE__ */ function(ScrollDirection2) {
  ScrollDirection2[ScrollDirection2["NONE"] = 0] = "NONE";
  ScrollDirection2[ScrollDirection2["UP"] = 1] = "UP";
  ScrollDirection2[ScrollDirection2["DOWN"] = 2] = "DOWN";
  ScrollDirection2[ScrollDirection2["LEFT"] = 3] = "LEFT";
  ScrollDirection2[ScrollDirection2["RIGHT"] = 4] = "RIGHT";
  return ScrollDirection2;
}(ScrollDirection || {});
const EMPTY_SCROLL_POSITION = {
  top: 0,
  left: 0
};
const EMPTY_DETAIL_PANELS = Object.freeze(/* @__PURE__ */ new Map());
const createScrollCache = /* @__PURE__ */ __name((isRtl, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) => ({
  direction: ScrollDirection.NONE,
  buffer: bufferForDirection(isRtl, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)
}), "createScrollCache");
let isJSDOM = false;
try {
  if (typeof window !== "undefined") {
    isJSDOM = /jsdom/.test(window.navigator.userAgent);
  }
} catch (_2) {
}
const useGridVirtualScroller = /* @__PURE__ */ __name(() => {
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const {
    unstable_listView: listView
  } = rootProps;
  const visibleColumns = useGridSelector(apiRef, () => listView ? [gridListColumnSelector(apiRef.current.state)] : gridVisibleColumnDefinitionsSelector(apiRef));
  const enabledForRows = useGridSelector(apiRef, gridVirtualizationRowEnabledSelector) && !isJSDOM;
  const enabledForColumns = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector) && !isJSDOM;
  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);
  const outerSize = dimensions.viewportOuterSize;
  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);
  const pinnedColumnDefinitions = useGridSelector(apiRef, gridVisiblePinnedColumnDefinitionsSelector);
  const pinnedColumns = listView ? {
    left: [],
    right: []
  } : pinnedColumnDefinitions;
  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;
  const [panels, setPanels] = reactExports.useState(EMPTY_DETAIL_PANELS);
  const isRtl = useRtl();
  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);
  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);
  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);
  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);
  const currentPage = useGridVisibleRows(apiRef, rootProps);
  const gridRootRef = apiRef.current.rootElementRef;
  const mainRef = apiRef.current.mainElementRef;
  const scrollerRef = apiRef.current.virtualScrollerRef;
  const scrollbarVerticalRef = apiRef.current.virtualScrollbarVerticalRef;
  const scrollbarHorizontalRef = apiRef.current.virtualScrollbarHorizontalRef;
  const contentHeight = dimensions.contentSize.height;
  const columnsTotalWidth = dimensions.columnsTotalWidth;
  const hasColSpan = useGridSelector(apiRef, gridHasColSpanSelector);
  useResizeObserver(mainRef, () => apiRef.current.resize());
  const scrollPosition = reactExports.useRef(EMPTY_SCROLL_POSITION);
  const previousContextScrollPosition = reactExports.useRef(EMPTY_SCROLL_POSITION);
  const previousRowContext = reactExports.useRef(EMPTY_RENDER_CONTEXT);
  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);
  const scrollTimeout = useTimeout();
  const frozenContext = reactExports.useRef(void 0);
  const scrollCache = useLazyRef(() => createScrollCache(isRtl, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;
  const focusedCell = {
    rowIndex: reactExports.useMemo(() => cellFocus ? currentPage.rows.findIndex((row) => row.id === cellFocus.id) : -1, [cellFocus, currentPage.rows]),
    columnIndex: reactExports.useMemo(() => cellFocus ? visibleColumns.findIndex((column2) => column2.field === cellFocus.field) : -1, [cellFocus, visibleColumns])
  };
  const updateRenderContext = reactExports.useCallback((nextRenderContext) => {
    if (areRenderContextsEqual(nextRenderContext, apiRef.current.state.virtualization.renderContext)) {
      return;
    }
    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;
    apiRef.current.setState((state) => {
      return _extends$4({}, state, {
        virtualization: _extends$4({}, state.virtualization, {
          renderContext: nextRenderContext
        })
      });
    });
    if (dimensions.isReady && didRowsIntervalChange) {
      previousRowContext.current = nextRenderContext;
      apiRef.current.publishEvent("renderedRowsIntervalChange", nextRenderContext);
    }
    previousContextScrollPosition.current = scrollPosition.current;
  }, [apiRef, dimensions.isReady]);
  const triggerUpdateRenderContext = useEventCallback(() => {
    const newScroll = {
      top: scrollerRef.current.scrollTop,
      left: scrollerRef.current.scrollLeft
    };
    const dx = newScroll.left - scrollPosition.current.left;
    const dy = newScroll.top - scrollPosition.current.top;
    const isScrolling = dx !== 0 || dy !== 0;
    scrollPosition.current = newScroll;
    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE;
    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);
    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);
    const didCrossThreshold = rowScroll >= dimensions.rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;
    const didChangeDirection = scrollCache.direction !== direction;
    const shouldUpdate = didCrossThreshold || didChangeDirection;
    if (!shouldUpdate) {
      return renderContext;
    }
    if (didChangeDirection) {
      switch (direction) {
        case ScrollDirection.NONE:
        case ScrollDirection.LEFT:
        case ScrollDirection.RIGHT:
          frozenContext.current = void 0;
          break;
        default:
          frozenContext.current = renderContext;
          break;
      }
    }
    scrollCache.direction = direction;
    scrollCache.buffer = bufferForDirection(isRtl, direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);
    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);
    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);
    reactDomExports.flushSync(() => {
      updateRenderContext(nextRenderContext);
    });
    scrollTimeout.start(1e3, triggerUpdateRenderContext);
    return nextRenderContext;
  });
  const forceUpdateRenderContext = /* @__PURE__ */ __name(() => {
    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);
    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);
    frozenContext.current = void 0;
    updateRenderContext(nextRenderContext);
  }, "forceUpdateRenderContext");
  const handleScroll = useEventCallback((event) => {
    const {
      scrollTop,
      scrollLeft
    } = event.currentTarget;
    if (scrollTop < 0) {
      return;
    }
    if (!isRtl) {
      if (scrollLeft < 0) {
        return;
      }
    }
    if (isRtl) {
      if (scrollLeft > 0) {
        return;
      }
    }
    const nextRenderContext = triggerUpdateRenderContext();
    apiRef.current.publishEvent("scrollPositionChange", {
      top: scrollTop,
      left: scrollLeft,
      renderContext: nextRenderContext
    });
  });
  const handleWheel = useEventCallback((event) => {
    apiRef.current.publishEvent("virtualScrollerWheel", {}, event);
  });
  const handleTouchMove = useEventCallback((event) => {
    apiRef.current.publishEvent("virtualScrollerTouchMove", {}, event);
  });
  const getRows = /* @__PURE__ */ __name((params = {}) => {
    var _a2;
    if (!params.rows && !currentPage.range) {
      return [];
    }
    const baseRenderContext = params.renderContext ?? renderContext;
    const isLastSection = !hasBottomPinnedRows && params.position === void 0 || hasBottomPinnedRows && params.position === "bottom";
    const isPinnedSection = params.position !== void 0;
    let rowIndexOffset;
    switch (params.position) {
      case "top":
        rowIndexOffset = 0;
        break;
      case "bottom":
        rowIndexOffset = pinnedRows.top.length + currentPage.rows.length;
        break;
      case void 0:
        rowIndexOffset = pinnedRows.top.length;
        break;
    }
    const rowModels = params.rows ?? currentPage.rows;
    const firstRowToRender = baseRenderContext.firstRowIndex;
    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);
    const rowIndexes = params.rows ? range(0, params.rows.length) : range(firstRowToRender, lastRowToRender);
    let virtualRowIndex = -1;
    if (!isPinnedSection && focusedCell.rowIndex !== -1) {
      if (focusedCell.rowIndex < firstRowToRender) {
        virtualRowIndex = focusedCell.rowIndex;
        rowIndexes.unshift(virtualRowIndex);
      }
      if (focusedCell.rowIndex >= lastRowToRender) {
        virtualRowIndex = focusedCell.rowIndex;
        rowIndexes.push(virtualRowIndex);
      }
    }
    const rows = [];
    const rowProps = (_a2 = rootProps.slotProps) == null ? void 0 : _a2.row;
    const columnPositions = gridColumnPositionsSelector(apiRef);
    rowIndexes.forEach((rowIndexInPage) => {
      var _a3, _b2, _c2;
      const {
        id: id2,
        model
      } = rowModels[rowIndexInPage];
      const rowIndex = (((_a3 = currentPage == null ? void 0 : currentPage.range) == null ? void 0 : _a3.firstRowIndex) || 0) + rowIndexOffset + rowIndexInPage;
      if (hasColSpan) {
        const minFirstColumn = pinnedColumns.left.length;
        const maxLastColumn = visibleColumns.length - pinnedColumns.right.length;
        apiRef.current.calculateColSpan({
          rowId: id2,
          minFirstColumn,
          maxLastColumn,
          columns: visibleColumns
        });
        if (pinnedColumns.left.length > 0) {
          apiRef.current.calculateColSpan({
            rowId: id2,
            minFirstColumn: 0,
            maxLastColumn: pinnedColumns.left.length,
            columns: visibleColumns
          });
        }
        if (pinnedColumns.right.length > 0) {
          apiRef.current.calculateColSpan({
            rowId: id2,
            minFirstColumn: visibleColumns.length - pinnedColumns.right.length,
            maxLastColumn: visibleColumns.length,
            columns: visibleColumns
          });
        }
      }
      const hasFocus = (cellFocus == null ? void 0 : cellFocus.id) === id2;
      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id2) ? apiRef.current.unstable_getRowHeight(id2) : "auto";
      let isSelected;
      if (selectedRowsLookup[id2] == null) {
        isSelected = false;
      } else {
        isSelected = apiRef.current.isRowSelectable(id2);
      }
      let isFirstVisible = false;
      if (params.position === void 0) {
        isFirstVisible = rowIndexInPage === 0;
      }
      let isLastVisible = false;
      const isLastVisibleInSection = rowIndexInPage === rowModels.length - 1;
      if (isLastSection) {
        if (!isPinnedSection) {
          const lastIndex = currentPage.rows.length - 1;
          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;
          if (isLastVisibleRowIndex) {
            isLastVisible = true;
          }
        } else {
          isLastVisible = isLastVisibleInSection;
        }
      }
      const isVirtualRow = rowIndexInPage === virtualRowIndex;
      const isNotVisible = isVirtualRow;
      let tabbableCell = null;
      if (cellTabIndex !== null && cellTabIndex.id === id2) {
        const cellParams = apiRef.current.getCellParams(id2, cellTabIndex.field);
        tabbableCell = cellParams.cellMode === "view" ? cellTabIndex.field : null;
      }
      let currentRenderContext = baseRenderContext;
      if (!isPinnedSection && frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {
        currentRenderContext = frozenContext.current;
      }
      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, pinnedColumns.left.length);
      const showBottomBorder = isLastVisibleInSection && params.position === "top";
      rows.push(/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.row, _extends$4({
        row: model,
        rowId: id2,
        index: rowIndex,
        selected: isSelected,
        offsetTop: params.rows ? void 0 : rowsMeta.positions[rowIndexInPage],
        offsetLeft,
        dimensions,
        rowHeight: baseRowHeight,
        tabbableCell,
        pinnedColumns,
        visibleColumns,
        renderContext: currentRenderContext,
        focusedColumnIndex: hasFocus ? focusedCell.columnIndex : void 0,
        isFirstVisible,
        isLastVisible,
        isNotVisible,
        showBottomBorder
      }, rowProps), id2));
      if (isNotVisible) {
        return;
      }
      const panel = panels.get(id2);
      if (panel) {
        rows.push(panel);
      }
      if (params.position === void 0 && isLastVisibleInSection) {
        rows.push((_c2 = (_b2 = apiRef.current).getInfiniteLoadingTriggerElement) == null ? void 0 : _c2.call(_b2, {
          lastRowId: id2
        }));
      }
    });
    return rows;
  }, "getRows");
  const needsHorizontalScrollbar = outerSize.width && columnsTotalWidth > outerSize.width;
  const scrollerStyle2 = reactExports.useMemo(() => ({
    overflowX: !needsHorizontalScrollbar || listView ? "hidden" : void 0,
    overflowY: rootProps.autoHeight ? "hidden" : void 0
  }), [needsHorizontalScrollbar, rootProps.autoHeight, listView]);
  const contentSize = reactExports.useMemo(() => {
    const size2 = {
      width: needsHorizontalScrollbar ? columnsTotalWidth : "auto",
      flexBasis: contentHeight,
      flexShrink: 0
    };
    if (size2.flexBasis === 0) {
      size2.flexBasis = minimalContentHeight;
    }
    return size2;
  }, [columnsTotalWidth, contentHeight, needsHorizontalScrollbar]);
  reactExports.useEffect(() => {
    apiRef.current.publishEvent("virtualScrollerContentSizeChange");
  }, [apiRef, contentSize]);
  useEnhancedEffect(() => {
    apiRef.current.resize();
  }, [apiRef, rowsMeta.currentPageTotalHeight]);
  useEnhancedEffect(() => {
    if (enabledForColumns) {
      scrollerRef.current.scrollLeft = 0;
    }
    if (enabledForRows) {
      scrollerRef.current.scrollTop = 0;
    }
  }, [enabledForColumns, enabledForRows, gridRootRef, scrollerRef]);
  useEnhancedEffect(() => {
    if (listView) {
      scrollerRef.current.scrollLeft = 0;
    }
  }, [listView, scrollerRef]);
  useRunOnce(outerSize.width !== 0, () => {
    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);
    const initialRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);
    updateRenderContext(initialRenderContext);
    apiRef.current.publishEvent("scrollPositionChange", {
      top: scrollPosition.current.top,
      left: scrollPosition.current.left,
      renderContext: initialRenderContext
    });
  });
  apiRef.current.register("private", {
    updateRenderContext: forceUpdateRenderContext
  });
  useGridApiEventHandler(apiRef, "columnsChange", forceUpdateRenderContext);
  useGridApiEventHandler(apiRef, "filteredRowsSet", forceUpdateRenderContext);
  useGridApiEventHandler(apiRef, "rowExpansionChange", forceUpdateRenderContext);
  return {
    renderContext,
    setPanels,
    getRows,
    getContainerProps: () => ({
      ref: mainRef
    }),
    getScrollerProps: () => ({
      ref: scrollerRef,
      onScroll: handleScroll,
      onWheel: handleWheel,
      onTouchMove: handleTouchMove,
      style: scrollerStyle2,
      role: "presentation",
      // `tabIndex` shouldn't be used along role=presentation, but it fixes a Firefox bug
      // https://github.com/mui/mui-x/pull/13891#discussion_r1683416024
      tabIndex: isFirefox ? -1 : void 0
    }),
    getContentProps: () => ({
      style: contentSize,
      role: "presentation"
    }),
    getRenderZoneProps: () => ({
      role: "rowgroup"
    }),
    getScrollbarVerticalProps: () => ({
      ref: scrollbarVerticalRef,
      role: "presentation"
    }),
    getScrollbarHorizontalProps: () => ({
      ref: scrollbarHorizontalRef,
      role: "presentation"
    })
  };
}, "useGridVirtualScroller");
function inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns) {
  const dimensions = gridDimensionsSelector(apiRef.current.state);
  const currentPage = getVisibleRows(apiRef, rootProps);
  const visibleColumns = rootProps.unstable_listView ? [gridListColumnSelector(apiRef.current.state)] : gridVisibleColumnDefinitionsSelector(apiRef);
  const hiddenCellsOriginMap = gridRowSpanningHiddenCellsOriginMapSelector(apiRef);
  const lastRowId = apiRef.current.state.rows.dataRowIds.at(-1);
  const lastColumn = visibleColumns.at(-1);
  return {
    enabledForRows,
    enabledForColumns,
    apiRef,
    autoHeight: rootProps.autoHeight,
    rowBufferPx: rootProps.rowBufferPx,
    columnBufferPx: rootProps.columnBufferPx,
    leftPinnedWidth: dimensions.leftPinnedWidth,
    columnsTotalWidth: dimensions.columnsTotalWidth,
    viewportInnerWidth: dimensions.viewportInnerSize.width,
    viewportInnerHeight: dimensions.viewportInnerSize.height,
    lastRowHeight: lastRowId !== void 0 ? apiRef.current.unstable_getRowHeight(lastRowId) : 0,
    lastColumnWidth: (lastColumn == null ? void 0 : lastColumn.computedWidth) ?? 0,
    rowsMeta: gridRowsMetaSelector(apiRef.current.state),
    columnPositions: gridColumnPositionsSelector(apiRef),
    rows: currentPage.rows,
    range: currentPage.range,
    pinnedColumns: gridVisiblePinnedColumnDefinitionsSelector(apiRef),
    visibleColumns,
    hiddenCellsOriginMap,
    listView: rootProps.unstable_listView ?? false
  };
}
__name(inputsSelector, "inputsSelector");
function computeRenderContext(inputs, scrollPosition, scrollCache) {
  const renderContext = {
    firstRowIndex: 0,
    lastRowIndex: inputs.rows.length,
    firstColumnIndex: 0,
    lastColumnIndex: inputs.visibleColumns.length
  };
  const {
    top: top2,
    left: left2
  } = scrollPosition;
  const realLeft = Math.abs(left2) + inputs.leftPinnedWidth;
  if (inputs.enabledForRows) {
    let firstRowIndex = Math.min(getNearestIndexToRender(inputs, top2, {
      atStart: true,
      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight
    }), inputs.rowsMeta.positions.length - 1);
    const rowSpanHiddenCellOrigin = inputs.hiddenCellsOriginMap[firstRowIndex];
    if (rowSpanHiddenCellOrigin) {
      const minSpannedRowIndex = Math.min(...Object.values(rowSpanHiddenCellOrigin));
      firstRowIndex = Math.min(firstRowIndex, minSpannedRowIndex);
    }
    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top2 + inputs.viewportInnerHeight);
    renderContext.firstRowIndex = firstRowIndex;
    renderContext.lastRowIndex = lastRowIndex;
  }
  if (inputs.enabledForColumns) {
    let firstColumnIndex = 0;
    let lastColumnIndex = inputs.columnPositions.length;
    let hasRowWithAutoHeight = false;
    const [firstRowToRender, lastRowToRender] = getIndexesToRender({
      firstIndex: renderContext.firstRowIndex,
      lastIndex: renderContext.lastRowIndex,
      minFirstIndex: 0,
      maxLastIndex: inputs.rows.length,
      bufferBefore: scrollCache.buffer.rowBefore,
      bufferAfter: scrollCache.buffer.rowAfter,
      positions: inputs.rowsMeta.positions,
      lastSize: inputs.lastRowHeight
    });
    for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {
      const row = inputs.rows[i];
      hasRowWithAutoHeight = inputs.apiRef.current.rowHasAutoHeight(row.id);
    }
    if (!hasRowWithAutoHeight) {
      firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {
        atStart: true,
        lastPosition: inputs.columnsTotalWidth
      });
      lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);
    }
    renderContext.firstColumnIndex = firstColumnIndex;
    renderContext.lastColumnIndex = lastColumnIndex;
  }
  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);
  return actualRenderContext;
}
__name(computeRenderContext, "computeRenderContext");
function getNearestIndexToRender(inputs, offset2, options) {
  var _a2, _b2;
  const lastMeasuredIndexRelativeToAllRows = inputs.apiRef.current.getLastMeasuredRowIndex();
  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;
  if (((_a2 = inputs.range) == null ? void 0 : _a2.lastRowIndex) && !allRowsMeasured) {
    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;
  }
  const lastMeasuredIndexRelativeToCurrentPage = clamp$3(lastMeasuredIndexRelativeToAllRows - (((_b2 = inputs.range) == null ? void 0 : _b2.firstRowIndex) || 0), 0, inputs.rowsMeta.positions.length);
  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset2) {
    return binarySearch(offset2, inputs.rowsMeta.positions, options);
  }
  return exponentialSearch(offset2, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);
}
__name(getNearestIndexToRender, "getNearestIndexToRender");
function deriveRenderContext(inputs, nextRenderContext, scrollCache) {
  const [firstRowToRender, lastRowToRender] = getIndexesToRender({
    firstIndex: nextRenderContext.firstRowIndex,
    lastIndex: nextRenderContext.lastRowIndex,
    minFirstIndex: 0,
    maxLastIndex: inputs.rows.length,
    bufferBefore: scrollCache.buffer.rowBefore,
    bufferAfter: scrollCache.buffer.rowAfter,
    positions: inputs.rowsMeta.positions,
    lastSize: inputs.lastRowHeight
  });
  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({
    firstIndex: nextRenderContext.firstColumnIndex,
    lastIndex: nextRenderContext.lastColumnIndex,
    minFirstIndex: inputs.pinnedColumns.left.length,
    maxLastIndex: inputs.visibleColumns.length - inputs.pinnedColumns.right.length,
    bufferBefore: scrollCache.buffer.columnBefore,
    bufferAfter: scrollCache.buffer.columnAfter,
    positions: inputs.columnPositions,
    lastSize: inputs.lastColumnWidth
  });
  const firstColumnToRender = getFirstNonSpannedColumnToRender({
    firstColumnToRender: initialFirstColumnToRender,
    apiRef: inputs.apiRef,
    firstRowToRender,
    lastRowToRender,
    visibleRows: inputs.rows
  });
  return {
    firstRowIndex: firstRowToRender,
    lastRowIndex: lastRowToRender,
    firstColumnIndex: firstColumnToRender,
    lastColumnIndex: lastColumnToRender
  };
}
__name(deriveRenderContext, "deriveRenderContext");
function binarySearch(offset2, positions, options = void 0, sliceStart = 0, sliceEnd = positions.length) {
  if (positions.length <= 0) {
    return -1;
  }
  if (sliceStart >= sliceEnd) {
    return sliceStart;
  }
  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);
  const position2 = positions[pivot];
  let isBefore;
  if (options == null ? void 0 : options.atStart) {
    const width2 = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position2;
    isBefore = offset2 - width2 < position2;
  } else {
    isBefore = offset2 <= position2;
  }
  return isBefore ? binarySearch(offset2, positions, options, sliceStart, pivot) : binarySearch(offset2, positions, options, pivot + 1, sliceEnd);
}
__name(binarySearch, "binarySearch");
function exponentialSearch(offset2, positions, index2, options = void 0) {
  let interval = 1;
  while (index2 < positions.length && Math.abs(positions[index2]) < offset2) {
    index2 += interval;
    interval *= 2;
  }
  return binarySearch(offset2, positions, options, Math.floor(index2 / 2), Math.min(index2, positions.length));
}
__name(exponentialSearch, "exponentialSearch");
function getIndexesToRender({
  firstIndex,
  lastIndex,
  bufferBefore,
  bufferAfter,
  minFirstIndex,
  maxLastIndex,
  positions,
  lastSize
}) {
  const firstPosition = positions[firstIndex] - bufferBefore;
  const lastPosition = positions[lastIndex] + bufferAfter;
  const firstIndexPadded = binarySearch(firstPosition, positions, {
    atStart: true,
    lastPosition: positions[positions.length - 1] + lastSize
  });
  const lastIndexPadded = binarySearch(lastPosition, positions);
  return [clamp$3(firstIndexPadded, minFirstIndex, maxLastIndex), clamp$3(lastIndexPadded, minFirstIndex, maxLastIndex)];
}
__name(getIndexesToRender, "getIndexesToRender");
function areRenderContextsEqual(context1, context2) {
  if (context1 === context2) {
    return true;
  }
  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;
}
__name(areRenderContextsEqual, "areRenderContextsEqual");
function computeOffsetLeft(columnPositions, renderContext, pinnedLeftLength) {
  const left2 = (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);
  return Math.abs(left2);
}
__name(computeOffsetLeft, "computeOffsetLeft");
function directionForDelta(dx, dy) {
  if (dx === 0 && dy === 0) {
    return ScrollDirection.NONE;
  }
  if (Math.abs(dy) >= Math.abs(dx)) {
    if (dy > 0) {
      return ScrollDirection.DOWN;
    } else {
      return ScrollDirection.UP;
    }
  } else {
    if (dx > 0) {
      return ScrollDirection.RIGHT;
    } else {
      return ScrollDirection.LEFT;
    }
  }
}
__name(directionForDelta, "directionForDelta");
function bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {
  if (isRtl) {
    switch (direction) {
      case ScrollDirection.LEFT:
        direction = ScrollDirection.RIGHT;
        break;
      case ScrollDirection.RIGHT:
        direction = ScrollDirection.LEFT;
        break;
    }
  }
  switch (direction) {
    case ScrollDirection.NONE:
      return {
        rowAfter: rowBufferPx,
        rowBefore: rowBufferPx,
        columnAfter: columnBufferPx,
        columnBefore: columnBufferPx
      };
    case ScrollDirection.LEFT:
      return {
        rowAfter: 0,
        rowBefore: 0,
        columnAfter: 0,
        columnBefore: horizontalBuffer
      };
    case ScrollDirection.RIGHT:
      return {
        rowAfter: 0,
        rowBefore: 0,
        columnAfter: horizontalBuffer,
        columnBefore: 0
      };
    case ScrollDirection.UP:
      return {
        rowAfter: 0,
        rowBefore: verticalBuffer,
        columnAfter: 0,
        columnBefore: 0
      };
    case ScrollDirection.DOWN:
      return {
        rowAfter: verticalBuffer,
        rowBefore: 0,
        columnAfter: 0,
        columnBefore: 0
      };
    default:
      throw new Error("unreachable");
  }
}
__name(bufferForDirection, "bufferForDirection");
const useGridOverlays = /* @__PURE__ */ __name(() => {
  var _a2, _b2;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const totalRowCount = useGridSelector(apiRef, gridRowCountSelector);
  const visibleRowCount = useGridSelector(apiRef, gridExpandedRowCountSelector);
  const noRows = totalRowCount === 0;
  const loading = useGridSelector(apiRef, gridRowsLoadingSelector);
  const showNoRowsOverlay = !loading && noRows;
  const showNoResultsOverlay = !loading && totalRowCount > 0 && visibleRowCount === 0;
  let overlayType = null;
  let loadingOverlayVariant = null;
  if (showNoRowsOverlay) {
    overlayType = "noRowsOverlay";
  }
  if (showNoResultsOverlay) {
    overlayType = "noResultsOverlay";
  }
  if (loading) {
    overlayType = "loadingOverlay";
    loadingOverlayVariant = ((_b2 = (_a2 = rootProps.slotProps) == null ? void 0 : _a2.loadingOverlay) == null ? void 0 : _b2[noRows ? "noRowsVariant" : "variant"]) || null;
  }
  return {
    overlayType,
    loadingOverlayVariant
  };
}, "useGridOverlays");
const GridOverlayWrapperRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "OverlayWrapper",
  shouldForwardProp: (prop) => prop !== "overlayType" && prop !== "loadingOverlayVariant",
  overridesResolver: (props, styles2) => styles2.overlayWrapper
})(({
  overlayType,
  loadingOverlayVariant
}) => (
  // Skeleton overlay should flow with the scroll container and not be sticky
  loadingOverlayVariant !== "skeleton" ? {
    position: "sticky",
    // To stay in place while scrolling
    top: "var(--DataGrid-headersTotalHeight)",
    // TODO: take pinned rows into account
    left: 0,
    width: 0,
    // To stay above the content instead of shifting it down
    height: 0,
    // To stay above the content instead of shifting it down
    zIndex: overlayType === "loadingOverlay" ? 5 : 4
    // Should be above pinned columns and detail panel
  } : {}
));
const GridOverlayWrapperInner = styled$1("div", {
  name: "MuiDataGrid",
  slot: "OverlayWrapperInner",
  shouldForwardProp: (prop) => prop !== "overlayType" && prop !== "loadingOverlayVariant",
  overridesResolver: (props, styles2) => styles2.overlayWrapperInner
})({});
const useUtilityClasses$E = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["overlayWrapper"],
    inner: ["overlayWrapperInner"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$E");
function GridOverlayWrapper(props) {
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);
  let height2 = Math.max(dimensions.viewportOuterSize.height - dimensions.topContainerHeight - dimensions.bottomContainerHeight - (dimensions.hasScrollX ? dimensions.scrollbarSize : 0), 0);
  if (height2 === 0) {
    height2 = minimalContentHeight;
  }
  const classes2 = useUtilityClasses$E(_extends$4({}, props, {
    classes: rootProps.classes
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayWrapperRoot, _extends$4({
    className: clsx(classes2.root)
  }, props, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayWrapperInner, _extends$4({
      className: clsx(classes2.inner),
      style: {
        height: height2,
        width: dimensions.viewportOuterSize.width
      }
    }, props))
  }));
}
__name(GridOverlayWrapper, "GridOverlayWrapper");
function GridOverlays(props) {
  var _a2, _b2;
  const {
    overlayType
  } = props;
  const rootProps = useGridRootProps();
  if (!overlayType) {
    return null;
  }
  const Overlay = (_a2 = rootProps.slots) == null ? void 0 : _a2[overlayType];
  const overlayProps = (_b2 = rootProps.slotProps) == null ? void 0 : _b2[overlayType];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayWrapper, _extends$4({}, props, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay, _extends$4({}, overlayProps))
  }));
}
__name(GridOverlays, "GridOverlays");
const gridColumnMenuSelector = /* @__PURE__ */ __name((state) => state.columnMenu, "gridColumnMenuSelector");
function GridHeaders() {
  var _a2;
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const filterColumnLookup = useGridSelector(apiRef, gridFilterActiveItemsLookupSelector);
  const sortColumnLookup = useGridSelector(apiRef, gridSortColumnLookupSelector);
  const columnHeaderTabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);
  const cellTabIndexState = useGridSelector(apiRef, gridTabIndexCellSelector);
  const columnGroupHeaderTabIndexState = useGridSelector(apiRef, gridTabIndexColumnGroupHeaderSelector);
  const columnHeaderFocus = useGridSelector(apiRef, gridFocusColumnHeaderSelector);
  const columnGroupHeaderFocus = useGridSelector(apiRef, gridFocusColumnGroupHeaderSelector);
  const headerGroupingMaxDepth = useGridSelector(apiRef, gridColumnGroupsHeaderMaxDepthSelector);
  const columnMenuState = useGridSelector(apiRef, gridColumnMenuSelector);
  const columnVisibility = useGridSelector(apiRef, gridColumnVisibilityModelSelector);
  const columnGroupsHeaderStructure = useGridSelector(apiRef, gridColumnGroupsHeaderStructureSelector);
  const hasOtherElementInTabSequence = !(columnGroupHeaderTabIndexState === null && columnHeaderTabIndexState === null && cellTabIndexState === null);
  const columnsContainerRef = apiRef.current.columnHeadersContainerRef;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnHeaders, _extends$4({
    ref: columnsContainerRef,
    visibleColumns,
    filterColumnLookup,
    sortColumnLookup,
    columnHeaderTabIndexState,
    columnGroupHeaderTabIndexState,
    columnHeaderFocus,
    columnGroupHeaderFocus,
    headerGroupingMaxDepth,
    columnMenuState,
    columnVisibility,
    columnGroupsHeaderStructure,
    hasOtherElementInTabSequence
  }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.columnHeaders));
}
__name(GridHeaders, "GridHeaders");
const MemoizedGridHeaders = fastMemo(GridHeaders);
const GridConfigurationContext = /* @__PURE__ */ reactExports.createContext(void 0);
const useGridConfiguration = /* @__PURE__ */ __name(() => {
  const configuration2 = reactExports.useContext(GridConfigurationContext);
  if (configuration2 === void 0) {
    throw new Error(["MUI X: Could not find the Data Grid configuration context.", "It looks like you rendered your component outside of a DataGrid, DataGridPro or DataGridPremium parent component.", "This can also happen if you are bundling multiple versions of the Data Grid."].join("\n"));
  }
  return configuration2;
}, "useGridConfiguration");
const GridPanelAnchor = styled$1("div")({
  position: "absolute",
  top: `var(--DataGrid-headersTotalHeight)`,
  left: 0,
  width: "calc(100% - (var(--DataGrid-hasScrollY) * var(--DataGrid-scrollbarSize)))"
});
const Element$3 = styled$1("div", {
  name: "MuiDataGrid",
  slot: "Main",
  overridesResolver: (props, styles2) => styles2.main
})({
  flexGrow: 1,
  position: "relative",
  overflow: "hidden",
  display: "flex",
  flexDirection: "column"
});
const GridMainContainer = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  const rootProps = useGridRootProps();
  const configuration2 = useGridConfiguration();
  const ariaAttributes = configuration2.hooks.useGridAriaAttributes();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Element$3, _extends$4({
    ref,
    ownerState: rootProps,
    className: props.className,
    tabIndex: -1
  }, ariaAttributes, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelAnchor, {
      role: "presentation",
      "data-id": "gridPanelAnchor"
    }), props.children]
  }));
});
const useUtilityClasses$D = /* @__PURE__ */ __name(() => {
  const slots = {
    root: ["topContainer"]
  };
  return composeClasses(slots, getDataGridUtilityClass, {});
}, "useUtilityClasses$D");
const Element$2 = styled$1("div")({
  position: "sticky",
  zIndex: 4,
  top: 0
});
function GridTopContainer(props) {
  const classes2 = useUtilityClasses$D();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Element$2, _extends$4({}, props, {
    className: clsx(classes2.root, gridClasses["container--top"]),
    role: "presentation"
  }));
}
__name(GridTopContainer, "GridTopContainer");
const useUtilityClasses$C = /* @__PURE__ */ __name(() => {
  const slots = {
    root: ["bottomContainer"]
  };
  return composeClasses(slots, getDataGridUtilityClass, {});
}, "useUtilityClasses$C");
const Element$1 = styled$1("div")({
  position: "sticky",
  zIndex: 4,
  bottom: "calc(var(--DataGrid-hasScrollX) * var(--DataGrid-scrollbarSize))"
});
function GridBottomContainer(props) {
  const classes2 = useUtilityClasses$C();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Element$1, _extends$4({}, props, {
    className: clsx(classes2.root, gridClasses["container--bottom"]),
    role: "presentation"
  }));
}
__name(GridBottomContainer, "GridBottomContainer");
const useUtilityClasses$B = /* @__PURE__ */ __name((props, overflowedContent) => {
  const {
    classes: classes2
  } = props;
  const slots = {
    root: ["virtualScrollerContent", overflowedContent && "virtualScrollerContent--overflowed"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$B");
const VirtualScrollerContentRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "VirtualScrollerContent",
  overridesResolver: (props, styles2) => styles2.virtualScrollerContent
})({});
const GridVirtualScrollerContent = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridVirtualScrollerContent2(props, ref) {
  var _a2;
  const rootProps = useGridRootProps();
  const overflowedContent = !rootProps.autoHeight && ((_a2 = props.style) == null ? void 0 : _a2.minHeight) === "auto";
  const classes2 = useUtilityClasses$B(rootProps, overflowedContent);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualScrollerContentRoot, _extends$4({
    ref
  }, props, {
    ownerState: rootProps,
    className: clsx(classes2.root, props.className)
  }));
}, "GridVirtualScrollerContent"));
const Filler = styled$1("div")({
  display: "flex",
  flexDirection: "row",
  width: "var(--DataGrid-rowWidth)",
  boxSizing: "border-box"
});
const Pinned = styled$1("div")({
  position: "sticky",
  height: "100%",
  boxSizing: "border-box",
  borderTop: "1px solid var(--rowBorderColor)",
  backgroundColor: "var(--DataGrid-pinnedBackground)"
});
const PinnedLeft = styled$1(Pinned)({
  left: 0,
  borderRight: "1px solid var(--rowBorderColor)"
});
const PinnedRight = styled$1(Pinned)({
  right: 0,
  borderLeft: "1px solid var(--rowBorderColor)"
});
const Main = styled$1("div")({
  flexGrow: 1,
  borderTop: "1px solid var(--rowBorderColor)"
});
function GridVirtualScrollerFiller({
  rowsLength
}) {
  const apiRef = useGridApiContext();
  const {
    viewportOuterSize,
    minimumSize,
    hasScrollX,
    hasScrollY,
    scrollbarSize,
    leftPinnedWidth,
    rightPinnedWidth
  } = useGridSelector(apiRef, gridDimensionsSelector);
  const height2 = hasScrollX ? scrollbarSize : 0;
  const needsLastRowBorder = viewportOuterSize.height - minimumSize.height > 0;
  if (height2 === 0 && !needsLastRowBorder) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Filler, {
    className: gridClasses.filler,
    role: "presentation",
    style: {
      height: height2,
      "--rowBorderColor": rowsLength === 0 ? "transparent" : "var(--DataGrid-rowBorderColor)"
    },
    children: [leftPinnedWidth > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(PinnedLeft, {
      className: gridClasses["filler--pinnedLeft"],
      style: {
        width: leftPinnedWidth
      }
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Main, {}), rightPinnedWidth > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(PinnedRight, {
      className: gridClasses["filler--pinnedRight"],
      style: {
        width: rightPinnedWidth + (hasScrollY ? scrollbarSize : 0)
      }
    })]
  });
}
__name(GridVirtualScrollerFiller, "GridVirtualScrollerFiller");
const Memoized$2 = fastMemo(GridVirtualScrollerFiller);
const _excluded$O = ["className"];
const useUtilityClasses$A = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["virtualScrollerRenderZone"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$A");
const VirtualScrollerRenderZoneRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "VirtualScrollerRenderZone",
  overridesResolver: (props, styles2) => styles2.virtualScrollerRenderZone
})({
  position: "absolute",
  display: "flex",
  // Prevents margin collapsing when using `getRowSpacing`
  flexDirection: "column"
});
const GridVirtualScrollerRenderZone = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridVirtualScrollerRenderZone2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$O);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$A(rootProps);
  const offsetTop = useGridSelector(apiRef, () => {
    const renderContext = gridRenderContextSelector(apiRef);
    const rowsMeta = gridRowsMetaSelector(apiRef.current.state);
    return rowsMeta.positions[renderContext.firstRowIndex] ?? 0;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualScrollerRenderZoneRoot, _extends$4({
    ref,
    className: clsx(classes2.root, className),
    ownerState: rootProps,
    style: {
      transform: `translate3d(0, ${offsetTop}px, 0)`
    }
  }, other));
}, "GridVirtualScrollerRenderZone"));
const DEFAULT_GRID_AUTOSIZE_OPTIONS = {
  includeHeaders: true,
  includeOutliers: false,
  outliersFactor: 1.5,
  expand: false
};
const gridEditRowsStateSelector = /* @__PURE__ */ __name((state) => state.editRows, "gridEditRowsStateSelector");
const gridPreferencePanelStateSelector = /* @__PURE__ */ __name((state) => state.preferencePanel, "gridPreferencePanelStateSelector");
var GridPreferencePanelsValue = /* @__PURE__ */ function(GridPreferencePanelsValue2) {
  GridPreferencePanelsValue2["filters"] = "filters";
  GridPreferencePanelsValue2["columns"] = "columns";
  return GridPreferencePanelsValue2;
}(GridPreferencePanelsValue || {});
const useUtilityClasses$z = /* @__PURE__ */ __name((ownerState, position2) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["scrollbar", `scrollbar--${position2}`],
    content: ["scrollbarContent"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$z");
const Scrollbar = styled$1("div")({
  position: "absolute",
  display: "inline-block",
  zIndex: 6,
  // In macOS Safari and Gnome Web, scrollbars are overlaid and don't affect the layout. So we consider
  // their size to be 0px throughout all the calculations, but the floating scrollbar container does need
  // to appear and have a real size. We set it to 14px because it seems like an acceptable value and we
  // don't have a method to find the required size for scrollbars on those platforms.
  "--size": "calc(max(var(--DataGrid-scrollbarSize), 14px))"
});
const ScrollbarVertical = styled$1(Scrollbar)({
  width: "var(--size)",
  height: "calc(var(--DataGrid-hasScrollY) * (100% - var(--DataGrid-topContainerHeight) - var(--DataGrid-bottomContainerHeight) - var(--DataGrid-hasScrollX) * var(--DataGrid-scrollbarSize)))",
  overflowY: "auto",
  overflowX: "hidden",
  // Disable focus-visible style, it's a scrollbar.
  outline: 0,
  "& > div": {
    width: "var(--size)"
  },
  top: "var(--DataGrid-topContainerHeight)",
  right: "0px"
});
const ScrollbarHorizontal = styled$1(Scrollbar)({
  width: "100%",
  height: "var(--size)",
  overflowY: "hidden",
  overflowX: "auto",
  // Disable focus-visible style, it's a scrollbar.
  outline: 0,
  "& > div": {
    height: "var(--size)"
  },
  bottom: "0px"
});
const GridVirtualScrollbar = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridVirtualScrollbar2(props, ref) {
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const isLocked = reactExports.useRef(false);
  const lastPosition = reactExports.useRef(0);
  const scrollbarRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const classes2 = useUtilityClasses$z(rootProps, props.position);
  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);
  const propertyDimension = props.position === "vertical" ? "height" : "width";
  const propertyScroll = props.position === "vertical" ? "scrollTop" : "scrollLeft";
  const hasScroll = props.position === "vertical" ? dimensions.hasScrollX : dimensions.hasScrollY;
  const contentSize = dimensions.minimumSize[propertyDimension] + (hasScroll ? dimensions.scrollbarSize : 0);
  const scrollbarSize = props.position === "vertical" ? dimensions.viewportInnerSize.height : dimensions.viewportOuterSize.width;
  const scrollbarInnerSize = scrollbarSize * (contentSize / dimensions.viewportOuterSize[propertyDimension]);
  const onScrollerScroll = useEventCallback(() => {
    const scroller = apiRef.current.virtualScrollerRef.current;
    const scrollbar = scrollbarRef.current;
    if (!scrollbar) {
      return;
    }
    if (scroller[propertyScroll] === lastPosition.current) {
      return;
    }
    lastPosition.current = scroller[propertyScroll];
    if (isLocked.current) {
      isLocked.current = false;
      return;
    }
    isLocked.current = true;
    const value = scroller[propertyScroll] / contentSize;
    scrollbar[propertyScroll] = value * scrollbarInnerSize;
  });
  const onScrollbarScroll = useEventCallback(() => {
    const scroller = apiRef.current.virtualScrollerRef.current;
    const scrollbar = scrollbarRef.current;
    if (!scrollbar) {
      return;
    }
    if (isLocked.current) {
      isLocked.current = false;
      return;
    }
    isLocked.current = true;
    const value = scrollbar[propertyScroll] / scrollbarInnerSize;
    scroller[propertyScroll] = value * contentSize;
  });
  useOnMount(() => {
    const scroller = apiRef.current.virtualScrollerRef.current;
    const scrollbar = scrollbarRef.current;
    scroller.addEventListener("scroll", onScrollerScroll, {
      capture: true
    });
    scrollbar.addEventListener("scroll", onScrollbarScroll, {
      capture: true
    });
    return () => {
      scroller.removeEventListener("scroll", onScrollerScroll, {
        capture: true
      });
      scrollbar.removeEventListener("scroll", onScrollbarScroll, {
        capture: true
      });
    };
  });
  reactExports.useEffect(() => {
    const content = contentRef.current;
    content.style.setProperty(propertyDimension, `${scrollbarInnerSize}px`);
  }, [scrollbarInnerSize, propertyDimension]);
  const Container2 = props.position === "vertical" ? ScrollbarVertical : ScrollbarHorizontal;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container2, {
    ref: useForkRef(ref, scrollbarRef),
    className: classes2.root,
    style: props.position === "vertical" && rootProps.unstable_listView ? {
      height: "100%",
      top: 0
    } : void 0,
    tabIndex: -1,
    "aria-hidden": "true",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      ref: contentRef,
      className: classes2.content
    })
  });
}, "GridVirtualScrollbar"));
const useUtilityClasses$y = /* @__PURE__ */ __name((ownerState, dimensions, loadingOverlayVariant) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["main", dimensions.rightPinnedWidth > 0 && "main--hasPinnedRight", loadingOverlayVariant === "skeleton" && "main--hasSkeletonLoadingOverlay"],
    scroller: ["virtualScroller", dimensions.hasScrollX && "virtualScroller--hasScrollX"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$y");
const Scroller$2 = styled$1("div", {
  name: "MuiDataGrid",
  slot: "VirtualScroller",
  overridesResolver: (props, styles2) => styles2.virtualScroller
})({
  position: "relative",
  height: "100%",
  flexGrow: 1,
  overflow: "scroll",
  scrollbarWidth: "none",
  display: "flex",
  flexDirection: "column",
  "&::-webkit-scrollbar": {
    display: "none"
    /* Safari and Chrome */
  },
  "@media print": {
    overflow: "hidden"
  },
  // See https://github.com/mui/mui-x/issues/10547
  zIndex: 0
});
function GridVirtualScroller(props) {
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);
  const overlaysProps = useGridOverlays();
  const classes2 = useUtilityClasses$y(rootProps, dimensions, overlaysProps.loadingOverlayVariant);
  const virtualScroller = useGridVirtualScroller();
  const {
    getContainerProps,
    getScrollerProps,
    getContentProps,
    getRenderZoneProps,
    getScrollbarVerticalProps,
    getScrollbarHorizontalProps,
    getRows
  } = virtualScroller;
  const rows = getRows();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridMainContainer, _extends$4({
    className: classes2.root
  }, getContainerProps(), {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridScrollArea, {
      scrollDirection: "left"
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(GridScrollArea, {
      scrollDirection: "right"
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs(Scroller$2, _extends$4({
      className: classes2.scroller
    }, getScrollerProps(), {
      ownerState: rootProps,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(GridTopContainer, {
        children: [!rootProps.unstable_listView && /* @__PURE__ */ jsxRuntimeExports.jsx(MemoizedGridHeaders, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.pinnedRows, {
          position: "top",
          virtualScroller
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlays, _extends$4({}, overlaysProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(GridVirtualScrollerContent, _extends$4({}, getContentProps(), {
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GridVirtualScrollerRenderZone, _extends$4({}, getRenderZoneProps(), {
          children: [rows, /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.detailPanels, {
            virtualScroller
          })]
        }))
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(Memoized$2, {
        rowsLength: rows.length
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(GridBottomContainer, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.pinnedRows, {
          position: "bottom",
          virtualScroller
        })
      })]
    })), dimensions.hasScrollY && /* @__PURE__ */ jsxRuntimeExports.jsx(GridVirtualScrollbar, _extends$4({
      position: "vertical"
    }, getScrollbarVerticalProps())), dimensions.hasScrollX && !rootProps.unstable_listView && /* @__PURE__ */ jsxRuntimeExports.jsx(GridVirtualScrollbar, _extends$4({
      position: "horizontal"
    }, getScrollbarHorizontalProps())), props.children]
  }));
}
__name(GridVirtualScroller, "GridVirtualScroller");
function GridFooterPlaceholder() {
  var _a2;
  const rootProps = useGridRootProps();
  if (rootProps.hideFooter) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.footer, _extends$4(
    {},
    (_a2 = rootProps.slotProps) == null ? void 0 : _a2.footer
    /* FIXME: typing error */
  ));
}
__name(GridFooterPlaceholder, "GridFooterPlaceholder");
let cachedSupportsPreventScroll;
function doesSupportPreventScroll() {
  if (cachedSupportsPreventScroll === void 0) {
    document.createElement("div").focus({
      get preventScroll() {
        cachedSupportsPreventScroll = true;
        return false;
      }
    });
  }
  return cachedSupportsPreventScroll;
}
__name(doesSupportPreventScroll, "doesSupportPreventScroll");
function isOverflown(element) {
  return element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
}
__name(isOverflown, "isOverflown");
function findParentElementFromClassName(elem, className) {
  return elem.closest(`.${className}`);
}
__name(findParentElementFromClassName, "findParentElementFromClassName");
function escapeOperandAttributeSelector(operand) {
  return operand.replace(/["\\]/g, "\\$&");
}
__name(escapeOperandAttributeSelector, "escapeOperandAttributeSelector");
function getGridColumnHeaderElement(root2, field) {
  return root2.querySelector(`[role="columnheader"][data-field="${escapeOperandAttributeSelector(field)}"]`);
}
__name(getGridColumnHeaderElement, "getGridColumnHeaderElement");
function getGridRowElementSelector(id2) {
  return `.${gridClasses.row}[data-id="${escapeOperandAttributeSelector(String(id2))}"]`;
}
__name(getGridRowElementSelector, "getGridRowElementSelector");
function getGridRowElement(root2, id2) {
  return root2.querySelector(getGridRowElementSelector(id2));
}
__name(getGridRowElement, "getGridRowElement");
function getGridCellElement(root2, {
  id: id2,
  field
}) {
  const rowSelector = getGridRowElementSelector(id2);
  const cellSelector = `.${gridClasses.cell}[data-field="${escapeOperandAttributeSelector(field)}"]`;
  const selector = `${rowSelector} ${cellSelector}`;
  return root2.querySelector(selector);
}
__name(getGridCellElement, "getGridCellElement");
function isEventTargetInPortal(event) {
  if (
    // The target is not an element when triggered by a Select inside the cell
    // See https://github.com/mui/material-ui/issues/10534
    event.target.nodeType === 1 && !event.currentTarget.contains(event.target)
  ) {
    return true;
  }
  return false;
}
__name(isEventTargetInPortal, "isEventTargetInPortal");
function getFieldFromHeaderElem(colCellEl) {
  return colCellEl.getAttribute("data-field");
}
__name(getFieldFromHeaderElem, "getFieldFromHeaderElem");
function findHeaderElementFromField(elem, field) {
  return elem.querySelector(`[data-field="${escapeOperandAttributeSelector(field)}"]`);
}
__name(findHeaderElementFromField, "findHeaderElementFromField");
function getFieldsFromGroupHeaderElem(colCellEl) {
  return colCellEl.getAttribute("data-fields").slice(2, -2).split("-|-");
}
__name(getFieldsFromGroupHeaderElem, "getFieldsFromGroupHeaderElem");
function findGroupHeaderElementsFromField(elem, field) {
  return Array.from(elem.querySelectorAll(`[data-fields*="|-${escapeOperandAttributeSelector(field)}-|"]`) ?? []);
}
__name(findGroupHeaderElementsFromField, "findGroupHeaderElementsFromField");
function findGridCellElementsFromCol(col, api2) {
  var _a2;
  const root2 = findParentElementFromClassName(col, gridClasses.root);
  if (!root2) {
    throw new Error("MUI X: The root element is not found.");
  }
  const ariaColIndex = col.getAttribute("aria-colindex");
  if (!ariaColIndex) {
    return [];
  }
  const colIndex = Number(ariaColIndex) - 1;
  const cells = [];
  if (!((_a2 = api2.virtualScrollerRef) == null ? void 0 : _a2.current)) {
    return [];
  }
  queryRows(api2).forEach((rowElement) => {
    const rowId = rowElement.getAttribute("data-id");
    if (!rowId) {
      return;
    }
    let columnIndex = colIndex;
    const cellColSpanInfo = api2.unstable_getCellColSpanInfo(rowId, colIndex);
    if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {
      columnIndex = cellColSpanInfo.leftVisibleCellIndex;
    }
    const cell = rowElement.querySelector(`[data-colindex="${columnIndex}"]`);
    if (cell) {
      cells.push(cell);
    }
  });
  return cells;
}
__name(findGridCellElementsFromCol, "findGridCellElementsFromCol");
function findGridElement(api2, klass) {
  return api2.rootElementRef.current.querySelector(`.${gridClasses[klass]}`);
}
__name(findGridElement, "findGridElement");
const findPinnedCells = /* @__PURE__ */ __name(({
  api: api2,
  colIndex,
  position: position2,
  filterFn
}) => {
  if (colIndex === null) {
    return [];
  }
  const cells = [];
  queryRows(api2).forEach((rowElement) => {
    const rowId = rowElement.getAttribute("data-id");
    if (!rowId) {
      return;
    }
    rowElement.querySelectorAll(`.${gridClasses[position2 === "left" ? "cell--pinnedLeft" : "cell--pinnedRight"]}`).forEach((cell) => {
      const currentColIndex = parseCellColIndex(cell);
      if (currentColIndex !== null && filterFn(currentColIndex)) {
        cells.push(cell);
      }
    });
  });
  return cells;
}, "findPinnedCells");
function findLeftPinnedCellsAfterCol(api2, col, isRtl) {
  const colIndex = parseCellColIndex(col);
  return findPinnedCells({
    api: api2,
    colIndex,
    position: isRtl ? "right" : "left",
    filterFn: (index2) => isRtl ? index2 < colIndex : index2 > colIndex
  });
}
__name(findLeftPinnedCellsAfterCol, "findLeftPinnedCellsAfterCol");
function findRightPinnedCellsBeforeCol(api2, col, isRtl) {
  const colIndex = parseCellColIndex(col);
  return findPinnedCells({
    api: api2,
    colIndex,
    position: isRtl ? "left" : "right",
    filterFn: (index2) => isRtl ? index2 > colIndex : index2 < colIndex
  });
}
__name(findRightPinnedCellsBeforeCol, "findRightPinnedCellsBeforeCol");
const findPinnedHeaders = /* @__PURE__ */ __name(({
  api: api2,
  colIndex,
  position: position2,
  filterFn
}) => {
  var _a2;
  if (!((_a2 = api2.columnHeadersContainerRef) == null ? void 0 : _a2.current)) {
    return [];
  }
  if (colIndex === null) {
    return [];
  }
  const elements = [];
  api2.columnHeadersContainerRef.current.querySelectorAll(`.${gridClasses[position2 === "left" ? "columnHeader--pinnedLeft" : "columnHeader--pinnedRight"]}`).forEach((element) => {
    const currentColIndex = parseCellColIndex(element);
    if (currentColIndex !== null && filterFn(currentColIndex)) {
      elements.push(element);
    }
  });
  return elements;
}, "findPinnedHeaders");
function findLeftPinnedHeadersAfterCol(api2, col, isRtl) {
  const colIndex = parseCellColIndex(col);
  return findPinnedHeaders({
    api: api2,
    position: isRtl ? "right" : "left",
    colIndex,
    filterFn: (index2) => isRtl ? index2 < colIndex : index2 > colIndex
  });
}
__name(findLeftPinnedHeadersAfterCol, "findLeftPinnedHeadersAfterCol");
function findRightPinnedHeadersBeforeCol(api2, col, isRtl) {
  const colIndex = parseCellColIndex(col);
  return findPinnedHeaders({
    api: api2,
    position: isRtl ? "left" : "right",
    colIndex,
    filterFn: (index2) => isRtl ? index2 > colIndex : index2 < colIndex
  });
}
__name(findRightPinnedHeadersBeforeCol, "findRightPinnedHeadersBeforeCol");
function findGridHeader(api2, field) {
  const headers = api2.columnHeadersContainerRef.current;
  return headers.querySelector(`:scope > div > [data-field="${escapeOperandAttributeSelector(field)}"][role="columnheader"]`);
}
__name(findGridHeader, "findGridHeader");
function findGridCells(api2, field) {
  const container = api2.virtualScrollerRef.current;
  return Array.from(container.querySelectorAll(`:scope > div > div > div > [data-field="${escapeOperandAttributeSelector(field)}"][role="gridcell"]`));
}
__name(findGridCells, "findGridCells");
function queryRows(api2) {
  return api2.virtualScrollerRef.current.querySelectorAll(
    // Use > to ignore rows from nested Data Grids (for example in detail panel)
    `:scope > div > div > .${gridClasses.row}`
  );
}
__name(queryRows, "queryRows");
function parseCellColIndex(col) {
  const ariaColIndex = col.getAttribute("aria-colindex");
  if (!ariaColIndex) {
    return null;
  }
  return Number(ariaColIndex) - 1;
}
__name(parseCellColIndex, "parseCellColIndex");
const _MissingRowIdError = class _MissingRowIdError extends Error {
};
__name(_MissingRowIdError, "MissingRowIdError");
let MissingRowIdError = _MissingRowIdError;
function useGridParamsApi(apiRef, props) {
  const getColumnHeaderParams = reactExports.useCallback((field) => ({
    field,
    colDef: apiRef.current.getColumn(field)
  }), [apiRef]);
  const getRowParams = reactExports.useCallback((id2) => {
    const row = apiRef.current.getRow(id2);
    if (!row) {
      throw new MissingRowIdError(`No row with id #${id2} found`);
    }
    const params = {
      id: id2,
      columns: apiRef.current.getAllColumns(),
      row
    };
    return params;
  }, [apiRef]);
  const getCellParams = reactExports.useCallback((id2, field) => {
    const colDef = props.unstable_listView ? gridListColumnSelector(apiRef.current.state) : apiRef.current.getColumn(field);
    const row = apiRef.current.getRow(id2);
    const rowNode = apiRef.current.getRowNode(id2);
    if (!row || !rowNode) {
      throw new MissingRowIdError(`No row with id #${id2} found`);
    }
    const rawValue = row[field];
    const value = (colDef == null ? void 0 : colDef.valueGetter) ? colDef.valueGetter(rawValue, row, colDef, apiRef) : rawValue;
    const cellFocus = gridFocusCellSelector(apiRef);
    const cellTabIndex = gridTabIndexCellSelector(apiRef);
    const params = {
      id: id2,
      field,
      row,
      rowNode,
      colDef,
      cellMode: apiRef.current.getCellMode(id2, field),
      hasFocus: cellFocus !== null && cellFocus.field === field && cellFocus.id === id2,
      tabIndex: cellTabIndex && cellTabIndex.field === field && cellTabIndex.id === id2 ? 0 : -1,
      value,
      formattedValue: value,
      isEditable: false,
      api: {}
    };
    if (colDef && colDef.valueFormatter) {
      params.formattedValue = colDef.valueFormatter(value, row, colDef, apiRef);
    }
    params.isEditable = colDef && apiRef.current.isCellEditable(params);
    return params;
  }, [apiRef, props.unstable_listView]);
  const getCellValue2 = reactExports.useCallback((id2, field) => {
    const colDef = apiRef.current.getColumn(field);
    const row = apiRef.current.getRow(id2);
    if (!row) {
      throw new MissingRowIdError(`No row with id #${id2} found`);
    }
    if (!colDef || !colDef.valueGetter) {
      return row[field];
    }
    return colDef.valueGetter(row[colDef.field], row, colDef, apiRef);
  }, [apiRef]);
  const getRowValue = reactExports.useCallback((row, colDef) => {
    const field = colDef.field;
    if (!colDef || !colDef.valueGetter) {
      return row[field];
    }
    const value = row[colDef.field];
    return colDef.valueGetter(value, row, colDef, apiRef);
  }, [apiRef]);
  const getRowFormattedValue = reactExports.useCallback((row, colDef) => {
    const value = getRowValue(row, colDef);
    if (!colDef || !colDef.valueFormatter) {
      return value;
    }
    return colDef.valueFormatter(value, row, colDef, apiRef);
  }, [apiRef, getRowValue]);
  const getColumnHeaderElement = reactExports.useCallback((field) => {
    if (!apiRef.current.rootElementRef.current) {
      return null;
    }
    return getGridColumnHeaderElement(apiRef.current.rootElementRef.current, field);
  }, [apiRef]);
  const getRowElement = reactExports.useCallback((id2) => {
    if (!apiRef.current.rootElementRef.current) {
      return null;
    }
    return getGridRowElement(apiRef.current.rootElementRef.current, id2);
  }, [apiRef]);
  const getCellElement = reactExports.useCallback((id2, field) => {
    if (!apiRef.current.rootElementRef.current) {
      return null;
    }
    return getGridCellElement(apiRef.current.rootElementRef.current, {
      id: id2,
      field
    });
  }, [apiRef]);
  const paramsApi = {
    getCellValue: getCellValue2,
    getCellParams,
    getCellElement,
    getRowValue,
    getRowFormattedValue,
    getRowParams,
    getRowElement,
    getColumnHeaderParams,
    getColumnHeaderElement
  };
  useGridApiMethod(apiRef, paramsApi, "public");
}
__name(useGridParamsApi, "useGridParamsApi");
const shouldCellShowRightBorder = /* @__PURE__ */ __name((pinnedPosition, indexInSection, sectionLength, showCellVerticalBorderRootProp, gridHasFiller) => {
  const isSectionLastCell = indexInSection === sectionLength - 1;
  if (pinnedPosition === GridPinnedColumnPosition.LEFT && isSectionLastCell) {
    return true;
  }
  if (showCellVerticalBorderRootProp) {
    if (pinnedPosition === GridPinnedColumnPosition.LEFT) {
      return true;
    }
    if (pinnedPosition === GridPinnedColumnPosition.RIGHT) {
      return !isSectionLastCell;
    }
    return !isSectionLastCell || gridHasFiller;
  }
  return false;
}, "shouldCellShowRightBorder");
const shouldCellShowLeftBorder = /* @__PURE__ */ __name((pinnedPosition, indexInSection) => {
  return pinnedPosition === GridPinnedColumnPosition.RIGHT && indexInSection === 0;
}, "shouldCellShowLeftBorder");
const _excluded$N = ["column", "rowId", "editCellState", "align", "children", "colIndex", "width", "className", "style", "colSpan", "disableDragEvents", "isNotVisible", "pinnedOffset", "pinnedPosition", "sectionIndex", "sectionLength", "gridHasFiller", "onClick", "onDoubleClick", "onMouseDown", "onMouseUp", "onMouseOver", "onKeyDown", "onKeyUp", "onDragEnter", "onDragOver"], _excluded2$6 = ["changeReason", "unstable_updateValueOnRender"];
let PinnedPosition = /* @__PURE__ */ function(PinnedPosition2) {
  PinnedPosition2[PinnedPosition2["NONE"] = 0] = "NONE";
  PinnedPosition2[PinnedPosition2["LEFT"] = 1] = "LEFT";
  PinnedPosition2[PinnedPosition2["RIGHT"] = 2] = "RIGHT";
  PinnedPosition2[PinnedPosition2["VIRTUAL"] = 3] = "VIRTUAL";
  return PinnedPosition2;
}({});
const gridPinnedColumnPositionLookup = {
  [PinnedPosition.LEFT]: GridPinnedColumnPosition.LEFT,
  [PinnedPosition.RIGHT]: GridPinnedColumnPosition.RIGHT,
  [PinnedPosition.NONE]: void 0,
  [PinnedPosition.VIRTUAL]: void 0
};
const EMPTY_CELL_PARAMS = {
  id: -1,
  field: "__unset__",
  row: {},
  rowNode: {
    id: -1,
    depth: 0,
    type: "leaf",
    parent: -1,
    groupingKey: null
  },
  colDef: {
    type: "string",
    field: "__unset__",
    computedWidth: 0
  },
  cellMode: GridCellModes.View,
  hasFocus: false,
  tabIndex: -1,
  value: null,
  formattedValue: "__unset__",
  isEditable: false,
  api: {}
};
const useUtilityClasses$x = /* @__PURE__ */ __name((ownerState) => {
  const {
    align,
    showLeftBorder,
    showRightBorder,
    pinnedPosition,
    isEditable,
    isSelected,
    isSelectionMode,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["cell", `cell--text${capitalize$1(align)}`, isSelected && "selected", isEditable && "cell--editable", showLeftBorder && "cell--withLeftBorder", showRightBorder && "cell--withRightBorder", pinnedPosition === PinnedPosition.LEFT && "cell--pinnedLeft", pinnedPosition === PinnedPosition.RIGHT && "cell--pinnedRight", isSelectionMode && !isEditable && "cell--selectionMode"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$x");
const GridCell = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridCell2(props, ref) {
  var _a2, _b2, _c2;
  const {
    column: column2,
    rowId,
    editCellState,
    align,
    colIndex,
    width: width2,
    className,
    style: styleProp,
    colSpan,
    disableDragEvents,
    isNotVisible,
    pinnedOffset,
    pinnedPosition,
    sectionIndex,
    sectionLength,
    gridHasFiller,
    onClick,
    onDoubleClick,
    onMouseDown,
    onMouseUp,
    onMouseOver,
    onKeyDown,
    onKeyUp,
    onDragEnter,
    onDragOver
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$N);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const isRtl = useRtl();
  const field = column2.field;
  const cellParams = useGridSelector(apiRef, () => {
    try {
      const result = apiRef.current.getCellParams(rowId, field);
      result.api = apiRef.current;
      return result;
    } catch (error) {
      if (error instanceof MissingRowIdError) {
        return EMPTY_CELL_PARAMS;
      }
      throw error;
    }
  }, objectShallowCompare);
  const isSelected = useGridSelector(apiRef, () => apiRef.current.unstable_applyPipeProcessors("isCellSelected", false, {
    id: rowId,
    field
  }));
  const hiddenCells = useGridSelector(apiRef, gridRowSpanningHiddenCellsSelector);
  const spannedCells = useGridSelector(apiRef, gridRowSpanningSpannedCellsSelector);
  const {
    cellMode,
    hasFocus,
    isEditable = false,
    value
  } = cellParams;
  const canManageOwnFocus = column2.type === "actions" && ((_a2 = column2.getActions) == null ? void 0 : _a2.call(column2, apiRef.current.getRowParams(rowId)).some((action) => !action.props.disabled));
  const tabIndex = (cellMode === "view" || !isEditable) && !canManageOwnFocus ? cellParams.tabIndex : -1;
  const {
    classes: rootClasses,
    getCellClassName
  } = rootProps;
  const pipesClassName = useGridSelector(apiRef, () => apiRef.current.unstable_applyPipeProcessors("cellClassName", [], {
    id: rowId,
    field
  }).filter(Boolean).join(" "));
  const classNames = [pipesClassName];
  if (column2.cellClassName) {
    classNames.push(typeof column2.cellClassName === "function" ? column2.cellClassName(cellParams) : column2.cellClassName);
  }
  if (column2.display === "flex") {
    classNames.push(gridClasses["cell--flex"]);
  }
  if (getCellClassName) {
    classNames.push(getCellClassName(cellParams));
  }
  const valueToRender = cellParams.formattedValue ?? value;
  const cellRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, cellRef);
  const focusElementRef = reactExports.useRef(null);
  const isSelectionMode = rootProps.cellSelection ?? false;
  const position2 = gridPinnedColumnPositionLookup[pinnedPosition];
  const showLeftBorder = shouldCellShowLeftBorder(position2, sectionIndex);
  const showRightBorder = shouldCellShowRightBorder(position2, sectionIndex, sectionLength, rootProps.showCellVerticalBorder, gridHasFiller);
  const ownerState = {
    align,
    showLeftBorder,
    showRightBorder,
    isEditable,
    classes: rootProps.classes,
    pinnedPosition,
    isSelected,
    isSelectionMode
  };
  const classes2 = useUtilityClasses$x(ownerState);
  const publishMouseUp = reactExports.useCallback((eventName) => (event) => {
    const params = apiRef.current.getCellParams(rowId, field || "");
    apiRef.current.publishEvent(eventName, params, event);
    if (onMouseUp) {
      onMouseUp(event);
    }
  }, [apiRef, field, onMouseUp, rowId]);
  const publishMouseDown = reactExports.useCallback((eventName) => (event) => {
    const params = apiRef.current.getCellParams(rowId, field || "");
    apiRef.current.publishEvent(eventName, params, event);
    if (onMouseDown) {
      onMouseDown(event);
    }
  }, [apiRef, field, onMouseDown, rowId]);
  const publish2 = reactExports.useCallback((eventName, propHandler) => (event) => {
    if (!apiRef.current.getRow(rowId)) {
      return;
    }
    const params = apiRef.current.getCellParams(rowId, field || "");
    apiRef.current.publishEvent(eventName, params, event);
    if (propHandler) {
      propHandler(event);
    }
  }, [apiRef, field, rowId]);
  const isCellRowSpanned = ((_b2 = hiddenCells[rowId]) == null ? void 0 : _b2[field]) ?? false;
  const rowSpan = ((_c2 = spannedCells[rowId]) == null ? void 0 : _c2[field]) ?? 1;
  const style2 = reactExports.useMemo(() => {
    if (isNotVisible) {
      return {
        padding: 0,
        opacity: 0,
        width: 0,
        border: 0
      };
    }
    const cellStyle = _extends$4({
      "--width": `${width2}px`
    }, styleProp);
    const isLeftPinned = pinnedPosition === PinnedPosition.LEFT;
    const isRightPinned = pinnedPosition === PinnedPosition.RIGHT;
    if (isLeftPinned || isRightPinned) {
      let side = isLeftPinned ? "left" : "right";
      if (isRtl) {
        side = isLeftPinned ? "right" : "left";
      }
      cellStyle[side] = pinnedOffset;
    }
    if (rowSpan > 1) {
      cellStyle.height = `calc(var(--height) * ${rowSpan})`;
      cellStyle.zIndex = 5;
    }
    return cellStyle;
  }, [width2, isNotVisible, styleProp, pinnedOffset, pinnedPosition, isRtl, rowSpan]);
  reactExports.useEffect(() => {
    if (!hasFocus || cellMode === GridCellModes.Edit) {
      return;
    }
    const doc = ownerDocument(apiRef.current.rootElementRef.current);
    if (cellRef.current && !cellRef.current.contains(doc.activeElement)) {
      const focusableElement = cellRef.current.querySelector('[tabindex="0"]');
      const elementToFocus = focusElementRef.current || focusableElement || cellRef.current;
      if (doesSupportPreventScroll()) {
        elementToFocus.focus({
          preventScroll: true
        });
      } else {
        const scrollPosition = apiRef.current.getScrollPosition();
        elementToFocus.focus();
        apiRef.current.scroll(scrollPosition);
      }
    }
  }, [hasFocus, cellMode, apiRef]);
  if (isCellRowSpanned) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      "data-colindex": colIndex,
      role: "presentation",
      style: _extends$4({
        width: "var(--width)"
      }, style2)
    });
  }
  if (cellParams === EMPTY_CELL_PARAMS) {
    return null;
  }
  let handleFocus = other.onFocus;
  let children;
  let title;
  if (editCellState === null && column2.renderCell) {
    children = column2.renderCell(cellParams);
  }
  if (editCellState !== null && column2.renderEditCell) {
    const updatedRow = apiRef.current.getRowWithUpdatedValues(rowId, column2.field);
    const editCellStateRest = _objectWithoutPropertiesLoose$1(editCellState, _excluded2$6);
    const formattedValue = column2.valueFormatter ? column2.valueFormatter(editCellState.value, updatedRow, column2, apiRef) : cellParams.formattedValue;
    const params = _extends$4({}, cellParams, {
      row: updatedRow,
      formattedValue
    }, editCellStateRest);
    children = column2.renderEditCell(params);
    classNames.push(gridClasses["cell--editing"]);
    classNames.push(rootClasses == null ? void 0 : rootClasses["cell--editing"]);
  }
  if (children === void 0) {
    const valueString = valueToRender == null ? void 0 : valueToRender.toString();
    children = valueString;
    title = valueString;
  }
  if (/* @__PURE__ */ reactExports.isValidElement(children) && canManageOwnFocus) {
    children = /* @__PURE__ */ reactExports.cloneElement(children, {
      focusElementRef
    });
  }
  const draggableEventHandlers = disableDragEvents ? null : {
    onDragEnter: publish2("cellDragEnter", onDragEnter),
    onDragOver: publish2("cellDragOver", onDragOver)
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends$4({
    ref: handleRef,
    className: clsx(classes2.root, classNames, className),
    role: "gridcell",
    "data-field": field,
    "data-colindex": colIndex,
    "aria-colindex": colIndex + 1,
    "aria-colspan": colSpan,
    "aria-rowspan": rowSpan,
    style: style2,
    title,
    tabIndex,
    onClick: publish2("cellClick", onClick),
    onDoubleClick: publish2("cellDoubleClick", onDoubleClick),
    onMouseOver: publish2("cellMouseOver", onMouseOver),
    onMouseDown: publishMouseDown("cellMouseDown"),
    onMouseUp: publishMouseUp("cellMouseUp"),
    onKeyDown: publish2("cellKeyDown", onKeyDown),
    onKeyUp: publish2("cellKeyUp", onKeyUp)
  }, draggableEventHandlers, other, {
    onFocus: handleFocus,
    children
  }));
}, "GridCell2"));
const MemoizedGridCell = fastMemo(GridCell);
const _excluded$M = ["field", "type", "align", "width", "height", "empty", "style", "className"];
const CIRCULAR_CONTENT_SIZE = "1.3em";
const CONTENT_HEIGHT = "1.2em";
const DEFAULT_CONTENT_WIDTH_RANGE = [40, 80];
const CONTENT_WIDTH_RANGE_BY_TYPE = {
  number: [40, 60],
  string: [40, 80],
  date: [40, 60],
  dateTime: [60, 80],
  singleSelect: [40, 80]
};
const useUtilityClasses$w = /* @__PURE__ */ __name((ownerState) => {
  const {
    align,
    classes: classes2,
    empty: empty2
  } = ownerState;
  const slots = {
    root: ["cell", "cellSkeleton", `cell--text${align ? capitalize$1(align) : "Left"}`, empty2 && "cellEmpty"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$w");
const randomNumberGenerator = createRandomNumberGenerator(12345);
function GridSkeletonCell(props) {
  const {
    field,
    type,
    align,
    width: width2,
    height: height2,
    empty: empty2 = false,
    style: style2,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$M);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes,
    align,
    empty: empty2
  };
  const classes2 = useUtilityClasses$w(ownerState);
  const skeletonProps = reactExports.useMemo(() => {
    const isCircularContent = type === "boolean" || type === "actions";
    if (isCircularContent) {
      return {
        variant: "circular",
        width: CIRCULAR_CONTENT_SIZE,
        height: CIRCULAR_CONTENT_SIZE
      };
    }
    const [min2, max2] = type ? CONTENT_WIDTH_RANGE_BY_TYPE[type] ?? DEFAULT_CONTENT_WIDTH_RANGE : DEFAULT_CONTENT_WIDTH_RANGE;
    return {
      variant: "text",
      width: `${Math.round(randomNumberGenerator(min2, max2))}%`,
      height: CONTENT_HEIGHT
    };
  }, [type]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends$4({
    "data-field": field,
    className: clsx(classes2.root, className),
    style: _extends$4({
      height: height2,
      maxWidth: width2,
      minWidth: width2
    }, style2)
  }, other, {
    children: !empty2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, _extends$4({}, skeletonProps))
  }));
}
__name(GridSkeletonCell, "GridSkeletonCell");
const Memoized$1 = fastMemo(GridSkeletonCell);
function getBorderColor(theme2) {
  if (theme2.vars) {
    return theme2.vars.palette.TableCell.border;
  }
  if (theme2.palette.mode === "light") {
    return lighten$1(alpha$2(theme2.palette.divider, 1), 0.88);
  }
  return darken$1(alpha$2(theme2.palette.divider, 1), 0.68);
}
__name(getBorderColor, "getBorderColor");
const columnHeaderStyles = {
  [`& .${gridClasses.iconButtonContainer}`]: {
    visibility: "visible",
    width: "auto"
  },
  [`& .${gridClasses.menuIcon}`]: {
    width: "auto",
    visibility: "visible"
  }
};
const columnSeparatorTargetSize = 10;
const columnSeparatorOffset = -5;
const focusOutlineWidth = 1;
const separatorIconDragStyles = {
  width: 3,
  rx: 1.5,
  x: 10.5
};
const ignoreSsrWarning = "/* emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason */";
const GridRootStyles = styled("div", {
  name: "MuiDataGrid",
  slot: "Root",
  overridesResolver: (props, styles2) => [{
    [`&.${gridClasses.autoHeight}`]: styles2.autoHeight
  }, {
    [`&.${gridClasses.aggregationColumnHeader}`]: styles2.aggregationColumnHeader
  }, {
    [`&.${gridClasses["aggregationColumnHeader--alignLeft"]}`]: styles2["aggregationColumnHeader--alignLeft"]
  }, {
    [`&.${gridClasses["aggregationColumnHeader--alignCenter"]}`]: styles2["aggregationColumnHeader--alignCenter"]
  }, {
    [`&.${gridClasses["aggregationColumnHeader--alignRight"]}`]: styles2["aggregationColumnHeader--alignRight"]
  }, {
    [`&.${gridClasses.aggregationColumnHeaderLabel}`]: styles2.aggregationColumnHeaderLabel
  }, {
    [`&.${gridClasses["root--disableUserSelection"]} .${gridClasses.cell}`]: styles2["root--disableUserSelection"]
  }, {
    [`&.${gridClasses.autosizing}`]: styles2.autosizing
  }, {
    [`& .${gridClasses.editBooleanCell}`]: styles2.editBooleanCell
  }, {
    [`& .${gridClasses.cell}`]: styles2.cell
  }, {
    [`& .${gridClasses["cell--editing"]}`]: styles2["cell--editing"]
  }, {
    [`& .${gridClasses["cell--textCenter"]}`]: styles2["cell--textCenter"]
  }, {
    [`& .${gridClasses["cell--textLeft"]}`]: styles2["cell--textLeft"]
  }, {
    [`& .${gridClasses["cell--textRight"]}`]: styles2["cell--textRight"]
  }, {
    [`& .${gridClasses["cell--rangeTop"]}`]: styles2["cell--rangeTop"]
  }, {
    [`& .${gridClasses["cell--rangeBottom"]}`]: styles2["cell--rangeBottom"]
  }, {
    [`& .${gridClasses["cell--rangeLeft"]}`]: styles2["cell--rangeLeft"]
  }, {
    [`& .${gridClasses["cell--rangeRight"]}`]: styles2["cell--rangeRight"]
  }, {
    [`& .${gridClasses["cell--withRightBorder"]}`]: styles2["cell--withRightBorder"]
  }, {
    [`& .${gridClasses.cellCheckbox}`]: styles2.cellCheckbox
  }, {
    [`& .${gridClasses.cellSkeleton}`]: styles2.cellSkeleton
  }, {
    [`& .${gridClasses.checkboxInput}`]: styles2.checkboxInput
  }, {
    [`& .${gridClasses["columnHeader--alignCenter"]}`]: styles2["columnHeader--alignCenter"]
  }, {
    [`& .${gridClasses["columnHeader--alignLeft"]}`]: styles2["columnHeader--alignLeft"]
  }, {
    [`& .${gridClasses["columnHeader--alignRight"]}`]: styles2["columnHeader--alignRight"]
  }, {
    [`& .${gridClasses["columnHeader--dragging"]}`]: styles2["columnHeader--dragging"]
  }, {
    [`& .${gridClasses["columnHeader--moving"]}`]: styles2["columnHeader--moving"]
  }, {
    [`& .${gridClasses["columnHeader--numeric"]}`]: styles2["columnHeader--numeric"]
  }, {
    [`& .${gridClasses["columnHeader--sortable"]}`]: styles2["columnHeader--sortable"]
  }, {
    [`& .${gridClasses["columnHeader--sorted"]}`]: styles2["columnHeader--sorted"]
  }, {
    [`& .${gridClasses["columnHeader--withRightBorder"]}`]: styles2["columnHeader--withRightBorder"]
  }, {
    [`& .${gridClasses.columnHeader}`]: styles2.columnHeader
  }, {
    [`& .${gridClasses.headerFilterRow}`]: styles2.headerFilterRow
  }, {
    [`& .${gridClasses.columnHeaderCheckbox}`]: styles2.columnHeaderCheckbox
  }, {
    [`& .${gridClasses.columnHeaderDraggableContainer}`]: styles2.columnHeaderDraggableContainer
  }, {
    [`& .${gridClasses.columnHeaderTitleContainer}`]: styles2.columnHeaderTitleContainer
  }, {
    [`& .${gridClasses["columnSeparator--resizable"]}`]: styles2["columnSeparator--resizable"]
  }, {
    [`& .${gridClasses["columnSeparator--resizing"]}`]: styles2["columnSeparator--resizing"]
  }, {
    [`& .${gridClasses.columnSeparator}`]: styles2.columnSeparator
  }, {
    [`& .${gridClasses.filterIcon}`]: styles2.filterIcon
  }, {
    [`& .${gridClasses.iconSeparator}`]: styles2.iconSeparator
  }, {
    [`& .${gridClasses.menuIcon}`]: styles2.menuIcon
  }, {
    [`& .${gridClasses.menuIconButton}`]: styles2.menuIconButton
  }, {
    [`& .${gridClasses.menuOpen}`]: styles2.menuOpen
  }, {
    [`& .${gridClasses.menuList}`]: styles2.menuList
  }, {
    [`& .${gridClasses["row--editable"]}`]: styles2["row--editable"]
  }, {
    [`& .${gridClasses["row--editing"]}`]: styles2["row--editing"]
  }, {
    [`& .${gridClasses["row--dragging"]}`]: styles2["row--dragging"]
  }, {
    [`& .${gridClasses.row}`]: styles2.row
  }, {
    [`& .${gridClasses.rowReorderCellPlaceholder}`]: styles2.rowReorderCellPlaceholder
  }, {
    [`& .${gridClasses.rowReorderCell}`]: styles2.rowReorderCell
  }, {
    [`& .${gridClasses["rowReorderCell--draggable"]}`]: styles2["rowReorderCell--draggable"]
  }, {
    [`& .${gridClasses.sortIcon}`]: styles2.sortIcon
  }, {
    [`& .${gridClasses.withBorderColor}`]: styles2.withBorderColor
  }, {
    [`& .${gridClasses.treeDataGroupingCell}`]: styles2.treeDataGroupingCell
  }, {
    [`& .${gridClasses.treeDataGroupingCellToggle}`]: styles2.treeDataGroupingCellToggle
  }, {
    [`& .${gridClasses.treeDataGroupingCellLoadingContainer}`]: styles2.treeDataGroupingCellLoadingContainer
  }, {
    [`& .${gridClasses.groupingCriteriaCellLoadingContainer}`]: styles2.groupingCriteriaCellLoadingContainer
  }, {
    [`& .${gridClasses.detailPanelToggleCell}`]: styles2.detailPanelToggleCell
  }, {
    [`& .${gridClasses["detailPanelToggleCell--expanded"]}`]: styles2["detailPanelToggleCell--expanded"]
  }, styles2.root]
})(({
  theme: t2
}) => {
  var _a2, _b2;
  const apiRef = useGridPrivateApiContext();
  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);
  const borderColor2 = getBorderColor(t2);
  const radius = t2.shape.borderRadius;
  const containerBackground = t2.vars ? t2.vars.palette.background.default : ((_a2 = t2.mixins.MuiDataGrid) == null ? void 0 : _a2.containerBackground) ?? t2.palette.background.default;
  const pinnedBackground = ((_b2 = t2.mixins.MuiDataGrid) == null ? void 0 : _b2.pinnedBackground) ?? containerBackground;
  const overlayBackground = t2.vars ? `rgba(${t2.vars.palette.background.defaultChannel} / ${t2.vars.palette.action.disabledOpacity})` : alpha$2(t2.palette.background.default, t2.palette.action.disabledOpacity);
  const hoverOpacity = (t2.vars || t2).palette.action.hoverOpacity;
  const hoverColor = (t2.vars || t2).palette.action.hover;
  const selectedOpacity = (t2.vars || t2).palette.action.selectedOpacity;
  const selectedHoverOpacity = t2.vars ? `calc(${hoverOpacity} + ${selectedOpacity})` : hoverOpacity + selectedOpacity;
  const selectedBackground = t2.vars ? `rgba(${t2.vars.palette.primary.mainChannel} / ${selectedOpacity})` : alpha$2(t2.palette.primary.main, selectedOpacity);
  const selectedHoverBackground = t2.vars ? `rgba(${t2.vars.palette.primary.mainChannel} / ${selectedHoverOpacity})` : alpha$2(t2.palette.primary.main, selectedHoverOpacity);
  const blendFn = t2.vars ? blendCssVars : blend;
  const getPinnedBackgroundStyles = /* @__PURE__ */ __name((backgroundColor2) => ({
    [`& .${gridClasses["cell--pinnedLeft"]}, & .${gridClasses["cell--pinnedRight"]}`]: {
      backgroundColor: backgroundColor2,
      "&.Mui-selected": {
        backgroundColor: blendFn(backgroundColor2, selectedBackground, selectedOpacity),
        "&:hover": {
          backgroundColor: blendFn(backgroundColor2, selectedBackground, selectedHoverOpacity)
        }
      }
    }
  }), "getPinnedBackgroundStyles");
  const pinnedBackgroundColor = blendFn(pinnedBackground, hoverColor, hoverOpacity);
  const pinnedHoverStyles = getPinnedBackgroundStyles(pinnedBackgroundColor);
  const pinnedSelectedBackgroundColor = blendFn(pinnedBackground, selectedBackground, selectedOpacity);
  const pinnedSelectedStyles = getPinnedBackgroundStyles(pinnedSelectedBackgroundColor);
  const pinnedSelectedHoverBackgroundColor = blendFn(pinnedBackground, selectedHoverBackground, selectedHoverOpacity);
  const pinnedSelectedHoverStyles = getPinnedBackgroundStyles(pinnedSelectedHoverBackgroundColor);
  const selectedStyles = {
    backgroundColor: selectedBackground,
    "&:hover": {
      backgroundColor: selectedHoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: selectedBackground
      }
    }
  };
  const gridStyle = _extends$4({
    "--unstable_DataGrid-radius": typeof radius === "number" ? `${radius}px` : radius,
    "--unstable_DataGrid-headWeight": t2.typography.fontWeightMedium,
    "--unstable_DataGrid-overlayBackground": overlayBackground,
    "--DataGrid-containerBackground": containerBackground,
    "--DataGrid-pinnedBackground": pinnedBackground,
    "--DataGrid-rowBorderColor": borderColor2,
    "--DataGrid-cellOffsetMultiplier": 2,
    "--DataGrid-width": "0px",
    "--DataGrid-hasScrollX": "0",
    "--DataGrid-hasScrollY": "0",
    "--DataGrid-scrollbarSize": "10px",
    "--DataGrid-rowWidth": "0px",
    "--DataGrid-columnsTotalWidth": "0px",
    "--DataGrid-leftPinnedWidth": "0px",
    "--DataGrid-rightPinnedWidth": "0px",
    "--DataGrid-headerHeight": "0px",
    "--DataGrid-headersTotalHeight": "0px",
    "--DataGrid-topContainerHeight": "0px",
    "--DataGrid-bottomContainerHeight": "0px",
    flex: 1,
    boxSizing: "border-box",
    position: "relative",
    borderWidth: "1px",
    borderStyle: "solid",
    borderColor: borderColor2,
    borderRadius: "var(--unstable_DataGrid-radius)",
    color: (t2.vars || t2).palette.text.primary
  }, t2.typography.body2, {
    outline: "none",
    height: "100%",
    display: "flex",
    minWidth: 0,
    // See https://github.com/mui/mui-x/issues/8547
    minHeight: 0,
    flexDirection: "column",
    overflow: "hidden",
    overflowAnchor: "none",
    // Keep the same scrolling position
    [`.${gridClasses.main} > *:first-child${ignoreSsrWarning}`]: {
      borderTopLeftRadius: "var(--unstable_DataGrid-radius)",
      borderTopRightRadius: "var(--unstable_DataGrid-radius)"
    },
    [`&.${gridClasses.autoHeight}`]: {
      height: "auto"
    },
    [`&.${gridClasses.autosizing}`]: {
      [`& .${gridClasses.columnHeaderTitleContainerContent} > *`]: {
        overflow: "visible !important"
      },
      "@media (hover: hover)": {
        [`& .${gridClasses.iconButtonContainer}`]: {
          width: "0 !important",
          visibility: "hidden !important"
        },
        [`& .${gridClasses.menuIcon}`]: {
          width: "0 !important",
          visibility: "hidden !important"
        }
      },
      [`& .${gridClasses.cell}`]: {
        overflow: "visible !important",
        whiteSpace: "nowrap",
        minWidth: "max-content !important",
        maxWidth: "max-content !important"
      },
      [`& .${gridClasses.groupingCriteriaCell}`]: {
        width: "unset"
      },
      [`& .${gridClasses.treeDataGroupingCell}`]: {
        width: "unset"
      }
    },
    [`& .${gridClasses.columnHeader}, & .${gridClasses.cell}`]: {
      WebkitTapHighlightColor: "transparent",
      padding: "0 10px",
      boxSizing: "border-box"
    },
    [`& .${gridClasses.columnHeader}:focus-within, & .${gridClasses.cell}:focus-within`]: {
      outline: `solid ${t2.vars ? `rgba(${t2.vars.palette.primary.mainChannel} / 0.5)` : alpha$2(t2.palette.primary.main, 0.5)} ${focusOutlineWidth}px`,
      outlineOffset: focusOutlineWidth * -1
    },
    [`& .${gridClasses.columnHeader}:focus, & .${gridClasses.cell}:focus`]: {
      outline: `solid ${t2.palette.primary.main} ${focusOutlineWidth}px`,
      outlineOffset: focusOutlineWidth * -1
    },
    // Hide the column separator when:
    // - the column is focused and has an outline
    // - the next column is focused and has an outline
    // - the column has a left or right border
    // - the next column is pinned right and has a left border
    [`& .${gridClasses.columnHeader}:focus,
      & .${gridClasses["columnHeader--withLeftBorder"]},
      & .${gridClasses["columnHeader--withRightBorder"]},
      & .${gridClasses["columnHeader--siblingFocused"]},
      & .${gridClasses["virtualScroller--hasScrollX"]} .${gridClasses["columnHeader--lastUnpinned"]},
      & .${gridClasses["virtualScroller--hasScrollX"]} .${gridClasses["columnHeader--last"]}
      `]: {
      [`& .${gridClasses.columnSeparator}`]: {
        opacity: 0
      },
      // Show resizable separators at all times on touch devices
      "@media (hover: none)": {
        [`& .${gridClasses["columnSeparator--resizable"]}`]: {
          opacity: 1
        }
      },
      [`& .${gridClasses["columnSeparator--resizable"]}:hover`]: {
        opacity: 1
      }
    },
    [`&.${gridClasses["root--noToolbar"]} [aria-rowindex="1"] [aria-colindex="1"]`]: {
      borderTopLeftRadius: "calc(var(--unstable_DataGrid-radius) - 1px)"
    },
    [`&.${gridClasses["root--noToolbar"]} [aria-rowindex="1"] .${gridClasses["columnHeader--last"]}`]: {
      borderTopRightRadius: dimensions.hasScrollX && (!dimensions.hasScrollY || dimensions.scrollbarSize === 0) ? "calc(var(--unstable_DataGrid-radius) - 1px)" : void 0
    },
    [`& .${gridClasses.columnHeaderCheckbox}, & .${gridClasses.cellCheckbox}`]: {
      padding: 0,
      justifyContent: "center",
      alignItems: "center"
    },
    [`& .${gridClasses.columnHeader}`]: {
      position: "relative",
      display: "flex",
      alignItems: "center"
    },
    [`& .${gridClasses["virtualScroller--hasScrollX"]} .${gridClasses["columnHeader--last"]}`]: {
      overflow: "hidden"
    },
    [`& .${gridClasses["columnHeader--sorted"]} .${gridClasses.iconButtonContainer}, & .${gridClasses["columnHeader--filtered"]} .${gridClasses.iconButtonContainer}`]: {
      visibility: "visible",
      width: "auto"
    },
    [`& .${gridClasses.columnHeader}:not(.${gridClasses["columnHeader--sorted"]}) .${gridClasses.sortIcon}`]: {
      opacity: 0,
      transition: t2.transitions.create(["opacity"], {
        duration: t2.transitions.duration.shorter
      })
    },
    [`& .${gridClasses.columnHeaderTitleContainer}`]: {
      display: "flex",
      alignItems: "center",
      gap: t2.spacing(0.25),
      minWidth: 0,
      flex: 1,
      whiteSpace: "nowrap",
      overflow: "hidden"
    },
    [`& .${gridClasses.columnHeaderTitleContainerContent}`]: {
      overflow: "hidden",
      display: "flex",
      alignItems: "center"
    },
    [`& .${gridClasses["columnHeader--filledGroup"]} .${gridClasses.columnHeaderTitleContainer}`]: {
      borderBottomWidth: "1px",
      borderBottomStyle: "solid",
      boxSizing: "border-box"
    },
    [`& .${gridClasses.sortIcon}, & .${gridClasses.filterIcon}`]: {
      fontSize: "inherit"
    },
    [`& .${gridClasses["columnHeader--sortable"]}`]: {
      cursor: "pointer"
    },
    [`& .${gridClasses["columnHeader--alignCenter"]} .${gridClasses.columnHeaderTitleContainer}`]: {
      justifyContent: "center"
    },
    [`& .${gridClasses["columnHeader--alignRight"]} .${gridClasses.columnHeaderDraggableContainer}, & .${gridClasses["columnHeader--alignRight"]} .${gridClasses.columnHeaderTitleContainer}`]: {
      flexDirection: "row-reverse"
    },
    [`& .${gridClasses["columnHeader--alignCenter"]} .${gridClasses.menuIcon}`]: {
      marginLeft: "auto"
    },
    [`& .${gridClasses["columnHeader--alignRight"]} .${gridClasses.menuIcon}`]: {
      marginRight: "auto",
      marginLeft: -5
    },
    [`& .${gridClasses["columnHeader--moving"]}`]: {
      backgroundColor: (t2.vars || t2).palette.action.hover
    },
    [`& .${gridClasses["columnHeader--pinnedLeft"]}, & .${gridClasses["columnHeader--pinnedRight"]}`]: {
      position: "sticky",
      zIndex: 4,
      // Should be above the column separator
      background: "var(--DataGrid-pinnedBackground)"
    },
    [`& .${gridClasses.columnSeparator}`]: {
      position: "absolute",
      overflow: "hidden",
      zIndex: 3,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      maxWidth: columnSeparatorTargetSize,
      color: borderColor2
    },
    [`& .${gridClasses.columnHeaders}`]: {
      width: "var(--DataGrid-rowWidth)"
    },
    "@media (hover: hover)": {
      [`& .${gridClasses.columnHeader}:hover`]: columnHeaderStyles,
      [`& .${gridClasses.columnHeader}:not(.${gridClasses["columnHeader--sorted"]}):hover .${gridClasses.sortIcon}`]: {
        opacity: 0.5
      }
    },
    "@media (hover: none)": {
      [`& .${gridClasses.columnHeader}`]: columnHeaderStyles,
      [`& .${gridClasses.columnHeader}:focus,
        & .${gridClasses["columnHeader--siblingFocused"]}`]: {
        [`.${gridClasses["columnSeparator--resizable"]}`]: {
          color: (t2.vars || t2).palette.primary.main
        }
      }
    },
    [`& .${gridClasses["columnSeparator--sideLeft"]}`]: {
      left: columnSeparatorOffset
    },
    [`& .${gridClasses["columnSeparator--sideRight"]}`]: {
      right: columnSeparatorOffset
    },
    [`& .${gridClasses["columnHeader--withRightBorder"]} .${gridClasses["columnSeparator--sideLeft"]}`]: {
      left: columnSeparatorOffset - 0.5
    },
    [`& .${gridClasses["columnHeader--withRightBorder"]} .${gridClasses["columnSeparator--sideRight"]}`]: {
      right: columnSeparatorOffset - 0.5
    },
    [`& .${gridClasses["columnSeparator--resizable"]}`]: {
      cursor: "col-resize",
      touchAction: "none",
      [`&.${gridClasses["columnSeparator--resizing"]}`]: {
        color: (t2.vars || t2).palette.primary.main
      },
      // Always appear as draggable on touch devices
      "@media (hover: none)": {
        [`& .${gridClasses.iconSeparator} rect`]: separatorIconDragStyles
      },
      "@media (hover: hover)": {
        "&:hover": {
          color: (t2.vars || t2).palette.primary.main,
          [`& .${gridClasses.iconSeparator} rect`]: separatorIconDragStyles
        }
      },
      "& svg": {
        pointerEvents: "none"
      }
    },
    [`& .${gridClasses.iconSeparator}`]: {
      color: "inherit",
      transition: t2.transitions.create(["color", "width"], {
        duration: t2.transitions.duration.shortest
      })
    },
    [`& .${gridClasses.menuIcon}`]: {
      width: 0,
      visibility: "hidden",
      fontSize: 20,
      marginRight: -5,
      display: "flex",
      alignItems: "center"
    },
    [`.${gridClasses.menuOpen}`]: {
      visibility: "visible",
      width: "auto"
    },
    [`& .${gridClasses.headerFilterRow}`]: {
      [`& .${gridClasses.columnHeader}`]: {
        boxSizing: "border-box",
        borderBottom: "1px solid var(--DataGrid-rowBorderColor)"
      }
    },
    /* Bottom border of the top-container */
    [`& .${gridClasses["row--borderBottom"]} .${gridClasses.columnHeader},
      & .${gridClasses["row--borderBottom"]} .${gridClasses.filler},
      & .${gridClasses["row--borderBottom"]} .${gridClasses.scrollbarFiller}`]: {
      borderBottom: `1px solid var(--DataGrid-rowBorderColor)`
    },
    [`& .${gridClasses["row--borderBottom"]} .${gridClasses.cell}`]: {
      borderBottom: `1px solid var(--rowBorderColor)`
    },
    /* Row styles */
    [`.${gridClasses.row}`]: {
      display: "flex",
      width: "var(--DataGrid-rowWidth)",
      breakInside: "avoid",
      // Avoid the row to be broken in two different print pages.
      "--rowBorderColor": "var(--DataGrid-rowBorderColor)",
      [`&.${gridClasses["row--firstVisible"]}`]: {
        "--rowBorderColor": "transparent"
      },
      "&:hover": {
        backgroundColor: (t2.vars || t2).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${gridClasses.rowSkeleton}:hover`]: {
        backgroundColor: "transparent"
      },
      "&.Mui-selected": selectedStyles
    },
    [`& .${gridClasses["container--top"]}, & .${gridClasses["container--bottom"]}`]: {
      "[role=row]": {
        background: "var(--DataGrid-containerBackground)"
      }
    },
    /* Cell styles */
    [`& .${gridClasses.cell}`]: {
      flex: "0 0 auto",
      height: "var(--height)",
      width: "var(--width)",
      lineHeight: "calc(var(--height) - 1px)",
      // -1px for the border
      boxSizing: "border-box",
      borderTop: `1px solid var(--rowBorderColor)`,
      overflow: "hidden",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      "&.Mui-selected": selectedStyles
    },
    [`& .${gridClasses["virtualScrollerContent--overflowed"]} .${gridClasses["row--lastVisible"]} .${gridClasses.cell}`]: {
      borderTopColor: "transparent"
    },
    [`& .${gridClasses["pinnedRows--top"]} :first-of-type`]: {
      [`& .${gridClasses.cell}, .${gridClasses.scrollbarFiller}`]: {
        borderTop: "none"
      }
    },
    [`&.${gridClasses["root--disableUserSelection"]} .${gridClasses.cell}`]: {
      userSelect: "none"
    },
    [`& .${gridClasses["row--dynamicHeight"]} > .${gridClasses.cell}`]: {
      whiteSpace: "initial",
      lineHeight: "inherit"
    },
    [`& .${gridClasses.cellEmpty}`]: {
      padding: 0,
      height: "unset"
    },
    [`& .${gridClasses.cell}.${gridClasses["cell--selectionMode"]}`]: {
      cursor: "default"
    },
    [`& .${gridClasses.cell}.${gridClasses["cell--editing"]}`]: {
      padding: 1,
      display: "flex",
      boxShadow: t2.shadows[2],
      backgroundColor: (t2.vars || t2).palette.background.paper,
      "&:focus-within": {
        outline: `${focusOutlineWidth}px solid ${(t2.vars || t2).palette.primary.main}`,
        outlineOffset: focusOutlineWidth * -1
      }
    },
    [`& .${gridClasses["row--editing"]}`]: {
      boxShadow: t2.shadows[2]
    },
    [`& .${gridClasses["row--editing"]} .${gridClasses.cell}`]: {
      boxShadow: t2.shadows[0],
      backgroundColor: (t2.vars || t2).palette.background.paper
    },
    [`& .${gridClasses.editBooleanCell}`]: {
      display: "flex",
      height: "100%",
      width: "100%",
      alignItems: "center",
      justifyContent: "center"
    },
    [`& .${gridClasses.booleanCell}[data-value="true"]`]: {
      color: (t2.vars || t2).palette.text.secondary
    },
    [`& .${gridClasses.booleanCell}[data-value="false"]`]: {
      color: (t2.vars || t2).palette.text.disabled
    },
    [`& .${gridClasses.actionsCell}`]: {
      display: "inline-flex",
      alignItems: "center",
      gridGap: t2.spacing(1)
    },
    [`& .${gridClasses.rowReorderCell}`]: {
      display: "inline-flex",
      flex: 1,
      alignItems: "center",
      justifyContent: "center",
      opacity: (t2.vars || t2).palette.action.disabledOpacity
    },
    [`& .${gridClasses["rowReorderCell--draggable"]}`]: {
      cursor: "move",
      opacity: 1
    },
    [`& .${gridClasses.rowReorderCellContainer}`]: {
      padding: 0,
      display: "flex",
      alignItems: "stretch"
    },
    [`.${gridClasses.withBorderColor}`]: {
      borderColor: borderColor2
    },
    [`& .${gridClasses["cell--withLeftBorder"]}, & .${gridClasses["columnHeader--withLeftBorder"]}`]: {
      borderLeftColor: "var(--DataGrid-rowBorderColor)",
      borderLeftWidth: "1px",
      borderLeftStyle: "solid"
    },
    [`& .${gridClasses["cell--withRightBorder"]}, & .${gridClasses["columnHeader--withRightBorder"]}`]: {
      borderRightColor: "var(--DataGrid-rowBorderColor)",
      borderRightWidth: "1px",
      borderRightStyle: "solid"
    },
    [`& .${gridClasses["cell--flex"]}`]: {
      display: "flex",
      alignItems: "center",
      lineHeight: "inherit"
    },
    [`& .${gridClasses["cell--textLeft"]}`]: {
      textAlign: "left",
      justifyContent: "flex-start"
    },
    [`& .${gridClasses["cell--textRight"]}`]: {
      textAlign: "right",
      justifyContent: "flex-end"
    },
    [`& .${gridClasses["cell--textCenter"]}`]: {
      textAlign: "center",
      justifyContent: "center"
    },
    [`& .${gridClasses["cell--pinnedLeft"]}, & .${gridClasses["cell--pinnedRight"]}`]: {
      position: "sticky",
      zIndex: 3,
      background: "var(--DataGrid-pinnedBackground)",
      "&.Mui-selected": {
        backgroundColor: pinnedSelectedBackgroundColor
      }
    },
    [`& .${gridClasses.virtualScrollerContent} .${gridClasses.row}`]: {
      "&:hover": pinnedHoverStyles,
      "&.Mui-selected": pinnedSelectedStyles,
      "&.Mui-selected:hover": pinnedSelectedHoverStyles
    },
    [`& .${gridClasses.cellOffsetLeft}`]: {
      flex: "0 0 auto",
      display: "inline-block"
    },
    [`& .${gridClasses.cellSkeleton}`]: {
      flex: "0 0 auto",
      height: "100%",
      display: "inline-flex",
      alignItems: "center"
    },
    [`& .${gridClasses.columnHeaderDraggableContainer}`]: {
      display: "flex",
      width: "100%",
      height: "100%"
    },
    [`& .${gridClasses.rowReorderCellPlaceholder}`]: {
      display: "none"
    },
    [`& .${gridClasses["columnHeader--dragging"]}, & .${gridClasses["row--dragging"]}`]: {
      background: (t2.vars || t2).palette.background.paper,
      padding: "0 12px",
      borderRadius: "var(--unstable_DataGrid-radius)",
      opacity: (t2.vars || t2).palette.action.disabledOpacity
    },
    [`& .${gridClasses["row--dragging"]}`]: {
      background: (t2.vars || t2).palette.background.paper,
      padding: "0 12px",
      borderRadius: "var(--unstable_DataGrid-radius)",
      opacity: (t2.vars || t2).palette.action.disabledOpacity,
      [`& .${gridClasses.rowReorderCellPlaceholder}`]: {
        display: "flex"
      }
    },
    [`& .${gridClasses.treeDataGroupingCell}`]: {
      display: "flex",
      alignItems: "center",
      width: "100%"
    },
    [`& .${gridClasses.treeDataGroupingCellToggle}`]: {
      flex: "0 0 28px",
      alignSelf: "stretch",
      marginRight: t2.spacing(2)
    },
    [`& .${gridClasses.treeDataGroupingCellLoadingContainer}, .${gridClasses.groupingCriteriaCellLoadingContainer}`]: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      height: "100%"
    },
    [`& .${gridClasses.groupingCriteriaCell}`]: {
      display: "flex",
      alignItems: "center",
      width: "100%"
    },
    [`& .${gridClasses.groupingCriteriaCellToggle}`]: {
      flex: "0 0 28px",
      alignSelf: "stretch",
      marginRight: t2.spacing(2)
    },
    /* ScrollbarFiller styles */
    [`.${gridClasses.scrollbarFiller}`]: {
      minWidth: "calc(var(--DataGrid-hasScrollY) * var(--DataGrid-scrollbarSize))",
      alignSelf: "stretch",
      [`&.${gridClasses["scrollbarFiller--borderTop"]}`]: {
        borderTop: "1px solid var(--DataGrid-rowBorderColor)"
      },
      [`&.${gridClasses["scrollbarFiller--borderBottom"]}`]: {
        borderBottom: "1px solid var(--DataGrid-rowBorderColor)"
      },
      [`&.${gridClasses["scrollbarFiller--pinnedRight"]}`]: {
        backgroundColor: "var(--DataGrid-pinnedBackground)",
        position: "sticky",
        right: 0
      }
    },
    [`& .${gridClasses.filler}`]: {
      flex: "1 0 auto"
    },
    [`& .${gridClasses["filler--borderBottom"]}`]: {
      borderBottom: "1px solid var(--DataGrid-rowBorderColor)"
    },
    /* Hide grid rows, row filler, and vertical scrollbar when skeleton overlay is visible */
    [`& .${gridClasses["main--hasSkeletonLoadingOverlay"]}`]: {
      [`& .${gridClasses.virtualScrollerContent}`]: {
        // We use visibility hidden so that the virtual scroller content retains its height.
        // Position fixed is used to remove the virtual scroller content from the flow.
        // https://github.com/mui/mui-x/issues/14061
        position: "fixed",
        visibility: "hidden"
      },
      [`& .${gridClasses["scrollbar--vertical"]}, & .${gridClasses.pinnedRows}, & .${gridClasses.virtualScroller} > .${gridClasses.filler}`]: {
        display: "none"
      }
    }
  });
  return gridStyle;
});
function blend(background, overlay, opacity, gamma = 1) {
  const f2 = /* @__PURE__ */ __name((b2, o) => Math.round((b2 ** (1 / gamma) * (1 - opacity) + o ** (1 / gamma) * opacity) ** gamma), "f");
  const backgroundColor2 = decomposeColor$1(background);
  const overlayColor = decomposeColor$1(overlay);
  const rgb = [f2(backgroundColor2.values[0], overlayColor.values[0]), f2(backgroundColor2.values[1], overlayColor.values[1]), f2(backgroundColor2.values[2], overlayColor.values[2])];
  return recomposeColor$1({
    type: "rgb",
    values: rgb
  });
}
__name(blend, "blend");
const removeOpacity = /* @__PURE__ */ __name((color2) => `rgb(from ${color2} r g b / 1)`, "removeOpacity");
function blendCssVars(background, overlay, opacity) {
  return `color-mix(in srgb,${background}, ${removeOpacity(overlay)} calc(${opacity} * 100%))`;
}
__name(blendCssVars, "blendCssVars");
const _excluded$L = ["className"];
const useUtilityClasses$v = /* @__PURE__ */ __name((ownerState, density) => {
  const {
    autoHeight,
    classes: classes2,
    showCellVerticalBorder
  } = ownerState;
  const slots = {
    root: ["root", autoHeight && "autoHeight", `root--density${capitalize$1(density)}`, ownerState.slots.toolbar === null && "root--noToolbar", "withBorderColor", showCellVerticalBorder && "withVerticalBorder"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$v");
const GridRoot$1 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridRoot2(props, ref) {
  const rootProps = useGridRootProps();
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$L);
  const apiRef = useGridPrivateApiContext();
  const density = useGridSelector(apiRef, gridDensitySelector);
  const rootElementRef = apiRef.current.rootElementRef;
  const handleRef = useForkRef(rootElementRef, ref);
  const ownerState = rootProps;
  const classes2 = useUtilityClasses$v(ownerState, density);
  const [mountedState, setMountedState] = reactExports.useState(false);
  useEnhancedEffect(() => {
    setMountedState(true);
  }, []);
  if (!mountedState) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridRootStyles, _extends$4({
    ref: handleRef,
    className: clsx(classes2.root, className),
    ownerState
  }, other));
}, "GridRoot2"));
const _excluded$K = ["className"];
const useUtilityClasses$u = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["footerContainer", "withBorderColor"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$u");
const GridFooterContainerRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "FooterContainer",
  overridesResolver: (props, styles2) => styles2.footerContainer
})({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  minHeight: 52,
  borderTop: "1px solid"
});
const GridFooterContainer = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridFooterContainer2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$K);
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$u(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridFooterContainerRoot, _extends$4({
    ref,
    className: clsx(classes2.root, className),
    ownerState: rootProps
  }, other));
}, "GridFooterContainer2"));
const _excluded$J = ["className"];
const useUtilityClasses$t = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["overlay"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$t");
const GridOverlayRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "Overlay",
  overridesResolver: (_2, styles2) => styles2.overlay
})({
  width: "100%",
  height: "100%",
  display: "flex",
  alignSelf: "center",
  alignItems: "center",
  justifyContent: "center",
  backgroundColor: "var(--unstable_DataGrid-overlayBackground)"
});
const GridOverlay = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridOverlay2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$J);
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$t(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayRoot, _extends$4({
    ref,
    className: clsx(classes2.root, className),
    ownerState: rootProps
  }, other));
}, "GridOverlay2"));
const useUtilityClasses$s = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    open: open2
  } = ownerState;
  const slots = {
    root: ["menuIcon", open2 && "menuOpen"],
    button: ["menuIconButton"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$s");
const ColumnHeaderMenuIcon = /* @__PURE__ */ reactExports.memo((props) => {
  var _a2, _b2;
  const {
    colDef,
    open: open2,
    columnMenuId,
    columnMenuButtonId,
    iconButtonRef
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = _extends$4({}, props, {
    classes: rootProps.classes
  });
  const classes2 = useUtilityClasses$s(ownerState);
  const handleMenuIconClick = reactExports.useCallback((event) => {
    event.preventDefault();
    event.stopPropagation();
    apiRef.current.toggleColumnMenu(colDef.field);
  }, [apiRef, colDef.field]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    className: classes2.root,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTooltip, _extends$4({
      title: apiRef.current.getLocaleText("columnMenuLabel"),
      enterDelay: 1e3
    }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseTooltip, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$4({
        ref: iconButtonRef,
        tabIndex: -1,
        className: classes2.button,
        "aria-label": apiRef.current.getLocaleText("columnMenuLabel"),
        size: "small",
        onClick: handleMenuIconClick,
        "aria-haspopup": "menu",
        "aria-expanded": open2,
        "aria-controls": open2 ? columnMenuId : void 0,
        id: columnMenuButtonId
      }, (_b2 = rootProps.slotProps) == null ? void 0 : _b2.baseIconButton, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuIcon, {
          fontSize: "inherit"
        })
      }))
    }))
  });
});
function GridColumnHeaderMenu({
  columnMenuId,
  columnMenuButtonId,
  ContentComponent,
  contentComponentProps,
  field,
  open: open2,
  target,
  onExited
}) {
  const apiRef = useGridApiContext();
  const colDef = apiRef.current.getColumn(field);
  const hideMenu = useEventCallback((event) => {
    if (event) {
      event.stopPropagation();
      if (target == null ? void 0 : target.contains(event.target)) {
        return;
      }
    }
    apiRef.current.hideColumnMenu();
  });
  if (!target || !colDef) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenu, {
    placement: `bottom-${colDef.align === "right" ? "start" : "end"}`,
    open: open2,
    target,
    onClose: hideMenu,
    onExited,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentComponent, _extends$4({
      colDef,
      hideMenu,
      open: open2,
      id: columnMenuId,
      labelledby: columnMenuButtonId
    }, contentComponentProps))
  });
}
__name(GridColumnHeaderMenu, "GridColumnHeaderMenu");
const _excluded$I = ["className", "aria-label"];
const useUtilityClasses$r = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["columnHeaderTitle"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$r");
const GridColumnHeaderTitleRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "ColumnHeaderTitle",
  overridesResolver: (props, styles2) => styles2.columnHeaderTitle
})({
  textOverflow: "ellipsis",
  overflow: "hidden",
  whiteSpace: "nowrap",
  fontWeight: "var(--unstable_DataGrid-headWeight)",
  lineHeight: "normal"
});
const ColumnHeaderInnerTitle = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function ColumnHeaderInnerTitle2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$I);
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$r(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderTitleRoot, _extends$4({
    ref,
    className: clsx(classes2.root, className),
    ownerState: rootProps
  }, other));
}, "ColumnHeaderInnerTitle2"));
function GridColumnHeaderTitle(props) {
  var _a2;
  const {
    label,
    description
  } = props;
  const rootProps = useGridRootProps();
  const titleRef = reactExports.useRef(null);
  const [tooltip, setTooltip] = reactExports.useState("");
  const handleMouseOver = reactExports.useCallback(() => {
    if (!description && (titleRef == null ? void 0 : titleRef.current)) {
      const isOver = isOverflown(titleRef.current);
      if (isOver) {
        setTooltip(label);
      } else {
        setTooltip("");
      }
    }
  }, [description, label]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTooltip, _extends$4({
    title: description || tooltip
  }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseTooltip, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnHeaderInnerTitle, {
      onMouseOver: handleMouseOver,
      ref: titleRef,
      children: label
    })
  }));
}
__name(GridColumnHeaderTitle, "GridColumnHeaderTitle");
const _excluded$H = ["resizable", "resizing", "height", "side"];
var GridColumnHeaderSeparatorSides = /* @__PURE__ */ function(GridColumnHeaderSeparatorSides2) {
  GridColumnHeaderSeparatorSides2["Left"] = "left";
  GridColumnHeaderSeparatorSides2["Right"] = "right";
  return GridColumnHeaderSeparatorSides2;
}(GridColumnHeaderSeparatorSides || {});
const useUtilityClasses$q = /* @__PURE__ */ __name((ownerState) => {
  const {
    resizable,
    resizing,
    classes: classes2,
    side
  } = ownerState;
  const slots = {
    root: ["columnSeparator", resizable && "columnSeparator--resizable", resizing && "columnSeparator--resizing", side && `columnSeparator--side${capitalize$1(side)}`],
    icon: ["iconSeparator"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$q");
function GridColumnHeaderSeparatorRaw(props) {
  const {
    height: height2,
    side = GridColumnHeaderSeparatorSides.Right
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$H);
  const rootProps = useGridRootProps();
  const ownerState = _extends$4({}, props, {
    side,
    classes: rootProps.classes
  });
  const classes2 = useUtilityClasses$q(ownerState);
  const stopClick = reactExports.useCallback((event) => {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  return (
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends$4({
      className: classes2.root,
      style: {
        minHeight: height2
      }
    }, other, {
      onClick: stopClick,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnResizeIcon, {
        className: classes2.icon
      })
    }))
  );
}
__name(GridColumnHeaderSeparatorRaw, "GridColumnHeaderSeparatorRaw");
const GridColumnHeaderSeparator = /* @__PURE__ */ reactExports.memo(GridColumnHeaderSeparatorRaw);
const _excluded$G = ["classes", "columnMenuOpen", "colIndex", "height", "isResizing", "sortDirection", "hasFocus", "tabIndex", "separatorSide", "isDraggable", "headerComponent", "description", "elementId", "width", "columnMenuIconButton", "columnMenu", "columnTitleIconButtons", "headerClassName", "label", "resizable", "draggableContainerProps", "columnHeaderSeparatorProps", "style"];
const GridGenericColumnHeaderItem = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridGenericColumnHeaderItem2(props, ref) {
  const {
    classes: classes2,
    colIndex,
    height: height2,
    isResizing,
    sortDirection,
    hasFocus,
    tabIndex,
    separatorSide,
    isDraggable,
    headerComponent,
    description,
    width: width2,
    columnMenuIconButton = null,
    columnMenu = null,
    columnTitleIconButtons = null,
    headerClassName,
    label,
    resizable,
    draggableContainerProps,
    columnHeaderSeparatorProps,
    style: style2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$G);
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const headerCellRef = reactExports.useRef(null);
  const handleRef = useForkRef(headerCellRef, ref);
  let ariaSort = "none";
  if (sortDirection != null) {
    ariaSort = sortDirection === "asc" ? "ascending" : "descending";
  }
  reactExports.useLayoutEffect(() => {
    var _a2;
    const columnMenuState = apiRef.current.state.columnMenu;
    if (hasFocus && !columnMenuState.open) {
      const focusableElement = headerCellRef.current.querySelector('[tabindex="0"]');
      const elementToFocus = focusableElement || headerCellRef.current;
      elementToFocus == null ? void 0 : elementToFocus.focus();
      if ((_a2 = apiRef.current.columnHeadersContainerRef) == null ? void 0 : _a2.current) {
        apiRef.current.columnHeadersContainerRef.current.scrollLeft = 0;
      }
    }
  }, [apiRef, hasFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$4({
    ref: handleRef,
    className: clsx(classes2.root, headerClassName),
    style: _extends$4({}, style2, {
      height: height2,
      width: width2
    }),
    role: "columnheader",
    tabIndex,
    "aria-colindex": colIndex + 1,
    "aria-sort": ariaSort
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$4({
      className: classes2.draggableContainer,
      draggable: isDraggable,
      role: "presentation"
    }, draggableContainerProps, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        className: classes2.titleContainer,
        role: "presentation",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: classes2.titleContainerContent,
          children: headerComponent !== void 0 ? headerComponent : /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderTitle, {
            label,
            description,
            columnWidth: width2
          })
        }), columnTitleIconButtons]
      }), columnMenuIconButton]
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderSeparator, _extends$4({
      resizable: !rootProps.disableColumnResize && !!resizable,
      resizing: isResizing,
      height: height2,
      side: separatorSide
    }, columnHeaderSeparatorProps)), columnMenu]
  }));
}, "GridGenericColumnHeaderItem"));
const useUtilityClasses$p = /* @__PURE__ */ __name((ownerState) => {
  const {
    colDef,
    classes: classes2,
    isDragging,
    sortDirection,
    showRightBorder,
    showLeftBorder,
    filterItemsCounter,
    pinnedPosition,
    isLastUnpinned,
    isSiblingFocused
  } = ownerState;
  const isColumnSorted = sortDirection != null;
  const isColumnFiltered = filterItemsCounter != null && filterItemsCounter > 0;
  const isColumnNumeric = colDef.type === "number";
  const slots = {
    root: [
      "columnHeader",
      colDef.headerAlign === "left" && "columnHeader--alignLeft",
      colDef.headerAlign === "center" && "columnHeader--alignCenter",
      colDef.headerAlign === "right" && "columnHeader--alignRight",
      colDef.sortable && "columnHeader--sortable",
      isDragging && "columnHeader--moving",
      isColumnSorted && "columnHeader--sorted",
      isColumnFiltered && "columnHeader--filtered",
      isColumnNumeric && "columnHeader--numeric",
      "withBorderColor",
      showRightBorder && "columnHeader--withRightBorder",
      showLeftBorder && "columnHeader--withLeftBorder",
      pinnedPosition === "left" && "columnHeader--pinnedLeft",
      pinnedPosition === "right" && "columnHeader--pinnedRight",
      // TODO: Remove classes below and restore `:has` selectors when they are supported in jsdom
      // See https://github.com/mui/mui-x/pull/14559
      isLastUnpinned && "columnHeader--lastUnpinned",
      isSiblingFocused && "columnHeader--siblingFocused"
    ],
    draggableContainer: ["columnHeaderDraggableContainer"],
    titleContainer: ["columnHeaderTitleContainer"],
    titleContainerContent: ["columnHeaderTitleContainerContent"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$p");
function GridColumnHeaderItem(props) {
  var _a2, _b2, _c2;
  const {
    colDef,
    columnMenuOpen,
    colIndex,
    headerHeight,
    isResizing,
    isLast,
    sortDirection,
    sortIndex,
    filterItemsCounter,
    hasFocus,
    tabIndex,
    disableReorder,
    separatorSide,
    style: style2,
    pinnedPosition,
    indexInSection,
    sectionLength,
    gridHasFiller
  } = props;
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const headerCellRef = reactExports.useRef(null);
  const columnMenuId = useId();
  const columnMenuButtonId = useId();
  const iconButtonRef = reactExports.useRef(null);
  const [showColumnMenuIcon, setShowColumnMenuIcon] = reactExports.useState(columnMenuOpen);
  const isDraggable = reactExports.useMemo(() => !rootProps.disableColumnReorder && !disableReorder && !colDef.disableReorder, [rootProps.disableColumnReorder, disableReorder, colDef.disableReorder]);
  let headerComponent;
  if (colDef.renderHeader) {
    headerComponent = colDef.renderHeader(apiRef.current.getColumnHeaderParams(colDef.field));
  }
  const showLeftBorder = shouldCellShowLeftBorder(pinnedPosition, indexInSection);
  const showRightBorder = shouldCellShowRightBorder(pinnedPosition, indexInSection, sectionLength, rootProps.showColumnVerticalBorder, gridHasFiller);
  const ownerState = _extends$4({}, props, {
    classes: rootProps.classes,
    showRightBorder,
    showLeftBorder
  });
  const classes2 = useUtilityClasses$p(ownerState);
  const publish2 = reactExports.useCallback((eventName) => (event) => {
    if (isEventTargetInPortal(event)) {
      return;
    }
    apiRef.current.publishEvent(eventName, apiRef.current.getColumnHeaderParams(colDef.field), event);
  }, [apiRef, colDef.field]);
  const mouseEventsHandlers = reactExports.useMemo(() => ({
    onClick: publish2("columnHeaderClick"),
    onContextMenu: publish2("columnHeaderContextMenu"),
    onDoubleClick: publish2("columnHeaderDoubleClick"),
    onMouseOver: publish2("columnHeaderOver"),
    // TODO remove as it's not used
    onMouseOut: publish2("columnHeaderOut"),
    // TODO remove as it's not used
    onMouseEnter: publish2("columnHeaderEnter"),
    // TODO remove as it's not used
    onMouseLeave: publish2("columnHeaderLeave"),
    // TODO remove as it's not used
    onKeyDown: publish2("columnHeaderKeyDown"),
    onFocus: publish2("columnHeaderFocus"),
    onBlur: publish2("columnHeaderBlur")
  }), [publish2]);
  const draggableEventHandlers = reactExports.useMemo(() => isDraggable ? {
    onDragStart: publish2("columnHeaderDragStart"),
    onDragEnter: publish2("columnHeaderDragEnter"),
    onDragOver: publish2("columnHeaderDragOver"),
    onDragEnd: publish2("columnHeaderDragEnd")
  } : {}, [isDraggable, publish2]);
  const columnHeaderSeparatorProps = reactExports.useMemo(() => ({
    onMouseDown: publish2("columnSeparatorMouseDown"),
    onDoubleClick: publish2("columnSeparatorDoubleClick")
  }), [publish2]);
  reactExports.useEffect(() => {
    if (!showColumnMenuIcon) {
      setShowColumnMenuIcon(columnMenuOpen);
    }
  }, [showColumnMenuIcon, columnMenuOpen]);
  const handleExited = reactExports.useCallback(() => {
    setShowColumnMenuIcon(false);
  }, []);
  const columnMenuIconButton = !rootProps.disableColumnMenu && !colDef.disableColumnMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnHeaderMenuIcon, {
    colDef,
    columnMenuId,
    columnMenuButtonId,
    open: showColumnMenuIcon,
    iconButtonRef
  });
  const columnMenu = /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderMenu, {
    columnMenuId,
    columnMenuButtonId,
    field: colDef.field,
    open: columnMenuOpen,
    target: iconButtonRef.current,
    ContentComponent: rootProps.slots.columnMenu,
    contentComponentProps: (_a2 = rootProps.slotProps) == null ? void 0 : _a2.columnMenu,
    onExited: handleExited
  });
  const sortingOrder = colDef.sortingOrder ?? rootProps.sortingOrder;
  const showSortIcon = (colDef.sortable || sortDirection != null) && !colDef.hideSortIcons && !rootProps.disableColumnSorting;
  const columnTitleIconButtons = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [!rootProps.disableColumnFilter && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnHeaderFilterIconButton, _extends$4({
      field: colDef.field,
      counter: filterItemsCounter
    }, (_b2 = rootProps.slotProps) == null ? void 0 : _b2.columnHeaderFilterIconButton)), showSortIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnHeaderSortIcon, _extends$4({
      field: colDef.field,
      direction: sortDirection,
      index: sortIndex,
      sortingOrder,
      disabled: !colDef.sortable
    }, (_c2 = rootProps.slotProps) == null ? void 0 : _c2.columnHeaderSortIcon))]
  });
  reactExports.useLayoutEffect(() => {
    var _a3;
    const columnMenuState = apiRef.current.state.columnMenu;
    if (hasFocus && !columnMenuState.open) {
      const focusableElement = headerCellRef.current.querySelector('[tabindex="0"]');
      const elementToFocus = focusableElement || headerCellRef.current;
      elementToFocus == null ? void 0 : elementToFocus.focus();
      if ((_a3 = apiRef.current.columnHeadersContainerRef) == null ? void 0 : _a3.current) {
        apiRef.current.columnHeadersContainerRef.current.scrollLeft = 0;
      }
    }
  }, [apiRef, hasFocus]);
  const headerClassName = typeof colDef.headerClassName === "function" ? colDef.headerClassName({
    field: colDef.field,
    colDef
  }) : colDef.headerClassName;
  const label = colDef.headerName ?? colDef.field;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridGenericColumnHeaderItem, _extends$4({
    ref: headerCellRef,
    classes: classes2,
    columnMenuOpen,
    colIndex,
    height: headerHeight,
    isResizing,
    sortDirection,
    hasFocus,
    tabIndex,
    separatorSide,
    isDraggable,
    headerComponent,
    description: colDef.description,
    elementId: colDef.field,
    width: colDef.computedWidth,
    columnMenuIconButton,
    columnTitleIconButtons,
    headerClassName: clsx(headerClassName, isLast && gridClasses["columnHeader--last"]),
    label,
    resizable: !rootProps.disableColumnResize && !!colDef.resizable,
    "data-field": colDef.field,
    columnMenu,
    draggableContainerProps: draggableEventHandlers,
    columnHeaderSeparatorProps,
    style: style2
  }, mouseEventsHandlers));
}
__name(GridColumnHeaderItem, "GridColumnHeaderItem");
const Memoized = fastMemo(GridColumnHeaderItem);
const _excluded$F = ["className"];
const useUtilityClasses$o = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["iconButtonContainer"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$o");
const GridIconButtonContainerRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "IconButtonContainer",
  overridesResolver: (props, styles2) => styles2.iconButtonContainer
})(() => ({
  display: "flex",
  visibility: "hidden",
  width: 0
}));
const GridIconButtonContainer = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridIconButtonContainer2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$F);
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$o(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridIconButtonContainerRoot, _extends$4({
    ref,
    className: clsx(classes2.root, className),
    ownerState: rootProps
  }, other));
}, "GridIconButtonContainer"));
const _excluded$E = ["direction", "index", "sortingOrder", "disabled"];
const useUtilityClasses$n = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    icon: ["sortIcon"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$n");
function getIcon(icons, direction, className, sortingOrder) {
  let Icon;
  const iconProps = {};
  if (direction === "asc") {
    Icon = icons.columnSortedAscendingIcon;
  } else if (direction === "desc") {
    Icon = icons.columnSortedDescendingIcon;
  } else {
    Icon = icons.columnUnsortedIcon;
    iconProps.sortingOrder = sortingOrder;
  }
  return Icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, _extends$4({
    fontSize: "small",
    className
  }, iconProps)) : null;
}
__name(getIcon, "getIcon");
function GridColumnHeaderSortIconRaw(props) {
  var _a2;
  const {
    direction,
    index: index2,
    sortingOrder,
    disabled
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$E);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = _extends$4({}, props, {
    classes: rootProps.classes
  });
  const classes2 = useUtilityClasses$n(ownerState);
  const iconElement = getIcon(rootProps.slots, direction, classes2.icon, sortingOrder);
  if (!iconElement) {
    return null;
  }
  const iconButton = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$4({
    tabIndex: -1,
    "aria-label": apiRef.current.getLocaleText("columnHeaderSortIconLabel"),
    title: apiRef.current.getLocaleText("columnHeaderSortIconLabel"),
    size: "small",
    disabled
  }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseIconButton, other, {
    children: iconElement
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridIconButtonContainer, {
    children: [index2 != null && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseBadge, {
      badgeContent: index2,
      color: "default",
      overlap: "circular",
      children: iconButton
    }), index2 == null && iconButton]
  });
}
__name(GridColumnHeaderSortIconRaw, "GridColumnHeaderSortIconRaw");
const GridColumnHeaderSortIcon = /* @__PURE__ */ reactExports.memo(GridColumnHeaderSortIconRaw);
const useUtilityClasses$m = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    icon: ["filterIcon"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$m");
function GridColumnHeaderFilterIconButton(props) {
  var _a2, _b2;
  const {
    counter,
    field,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = _extends$4({}, props, {
    classes: rootProps.classes
  });
  const classes2 = useUtilityClasses$m(ownerState);
  const preferencePanel = useGridSelector(apiRef, gridPreferencePanelStateSelector);
  const labelId = useId();
  const panelId = useId();
  const toggleFilter = reactExports.useCallback((event) => {
    event.preventDefault();
    event.stopPropagation();
    const {
      open: open22,
      openedPanelValue
    } = gridPreferencePanelStateSelector(apiRef.current.state);
    if (open22 && openedPanelValue === GridPreferencePanelsValue.filters) {
      apiRef.current.hideFilterPanel();
    } else {
      apiRef.current.showFilterPanel(void 0, panelId, labelId);
    }
    if (onClick) {
      onClick(apiRef.current.getColumnHeaderParams(field), event);
    }
  }, [apiRef, field, onClick, panelId, labelId]);
  if (!counter) {
    return null;
  }
  const open2 = preferencePanel.open && preferencePanel.labelId === labelId;
  const iconButton = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$4({
    id: labelId,
    onClick: toggleFilter,
    color: "default",
    "aria-label": apiRef.current.getLocaleText("columnHeaderFiltersLabel"),
    size: "small",
    tabIndex: -1,
    "aria-haspopup": "menu",
    "aria-expanded": open2,
    "aria-controls": open2 ? panelId : void 0
  }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseIconButton, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnFilteredIcon, {
      className: classes2.icon,
      fontSize: "small"
    })
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTooltip, _extends$4({
    title: apiRef.current.getLocaleText("columnHeaderFiltersTooltipActive")(counter),
    enterDelay: 1e3
  }, (_b2 = rootProps.slotProps) == null ? void 0 : _b2.baseTooltip, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GridIconButtonContainer, {
      children: [counter > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseBadge, {
        badgeContent: counter,
        color: "default",
        children: iconButton
      }), counter === 1 && iconButton]
    })
  }));
}
__name(GridColumnHeaderFilterIconButton, "GridColumnHeaderFilterIconButton");
const GridArrowUpwardIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"
}), "ArrowUpward");
const GridArrowDownwardIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}), "ArrowDownward");
const GridKeyboardArrowRight = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), "KeyboardArrowRight");
const GridExpandMoreIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMore");
const GridFilterListIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"
}), "FilterList");
const GridFilterAltIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61z"
}), "FilterAlt");
const GridSearchIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
}), "Search");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
}), "Menu");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckCircle");
const GridColumnIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6 5H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"
}), "ColumnIcon");
const GridSeparatorIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("rect", {
  width: "1",
  height: "24",
  x: "11.5",
  rx: "0.5"
}), "Separator");
const GridViewHeadlineIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"
}), "ViewHeadline");
const GridTableRowsIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M21,8H3V4h18V8z M21,10H3v4h18V10z M21,16H3v4h18V16z"
}), "TableRows");
const GridViewStreamIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M4 18h17v-6H4v6zM4 5v6h17V5H4z"
}), "ViewStream");
const GridTripleDotsVerticalIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "TripleDotsVertical");
const GridCloseIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
const GridAddIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
}), "Add");
const GridRemoveIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 13H5v-2h14v2z"
}), "Remove");
const GridLoadIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"
}), "Load");
const GridDragIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "Drag");
const GridSaveAltIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"
}), "SaveAlt");
const GridCheckIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
}), "Check");
const GridMoreVertIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "MoreVert");
const GridVisibilityOffIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"
}), "VisibilityOff");
const GridViewColumnIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("g", {
  children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M14.67,5v14H9.33V5H14.67z M15.67,19H21V5h-5.33V19z M8.33,19V5H3v14H8.33z"
  })
}), "ViewColumn");
const GridClearIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Clear");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"
}), "Delete");
const GridDeleteForeverIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"
}), "Delete");
function isPrintableKey(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
__name(isPrintableKey, "isPrintableKey");
const isNavigationKey = /* @__PURE__ */ __name((key) => key.indexOf("Arrow") === 0 || key.indexOf("Page") === 0 || key === " " || key === "Home" || key === "End", "isNavigationKey");
const isKeyboardEvent = /* @__PURE__ */ __name((event) => !!event.key, "isKeyboardEvent");
const isHideMenuKey = /* @__PURE__ */ __name((key) => key === "Tab" || key === "Escape", "isHideMenuKey");
function isPasteShortcut(event) {
  return (event.ctrlKey || event.metaKey) && // We can't use event.code === 'KeyV' as event.code assumes a QWERTY keyboard layout,
  // for example, it would be another letter on a Dvorak physical keyboard.
  // We can't use event.key === 'v' as event.key is not stable with key modifiers and keyboard layouts,
  // for example, it would be  on a Hebrew keyboard layout.
  // https://github.com/w3c/uievents/issues/377 could be a long-term solution
  String.fromCharCode(event.keyCode) === "V" && !event.shiftKey && !event.altKey;
}
__name(isPasteShortcut, "isPasteShortcut");
function isCopyShortcut(event) {
  return (event.ctrlKey || event.metaKey) && String.fromCharCode(event.keyCode) === "C" && !event.shiftKey && !event.altKey;
}
__name(isCopyShortcut, "isCopyShortcut");
const _excluded$D = ["hideMenu", "colDef", "id", "labelledby", "className", "children", "open"];
const StyledMenuList = styled(MenuList)(() => ({
  minWidth: 248
}));
const GridColumnMenuContainer = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridColumnMenuContainer2(props, ref) {
  const {
    hideMenu,
    id: id2,
    labelledby,
    className,
    children,
    open: open2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$D);
  const handleListKeyDown = reactExports.useCallback((event) => {
    if (event.key === "Tab") {
      event.preventDefault();
    }
    if (isHideMenuKey(event.key)) {
      hideMenu(event);
    }
  }, [hideMenu]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledMenuList, _extends$4({
    id: id2,
    ref,
    className: clsx(gridClasses.menuList, className),
    "aria-labelledby": labelledby,
    onKeyDown: handleListKeyDown,
    autoFocus: open2
  }, other, {
    children
  }));
}, "GridColumnMenuContainer2"));
const _excluded$C = ["displayOrder"];
const useGridColumnMenuSlots = /* @__PURE__ */ __name((props) => {
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const {
    defaultSlots: defaultSlots2,
    defaultSlotProps,
    slots = {},
    slotProps = {},
    hideMenu,
    colDef,
    addDividers = true
  } = props;
  const processedComponents = reactExports.useMemo(() => _extends$4({}, defaultSlots2, slots), [defaultSlots2, slots]);
  const processedSlotProps = reactExports.useMemo(() => {
    if (!slotProps || Object.keys(slotProps).length === 0) {
      return defaultSlotProps;
    }
    const mergedProps = _extends$4({}, slotProps);
    Object.entries(defaultSlotProps).forEach(([key, currentSlotProps]) => {
      mergedProps[key] = _extends$4({}, currentSlotProps, slotProps[key] || {});
    });
    return mergedProps;
  }, [defaultSlotProps, slotProps]);
  const defaultItems = apiRef.current.unstable_applyPipeProcessors("columnMenu", [], props.colDef);
  const userItems = reactExports.useMemo(() => {
    const defaultComponentKeys = Object.keys(defaultSlots2);
    return Object.keys(slots).filter((key) => !defaultComponentKeys.includes(key));
  }, [slots, defaultSlots2]);
  return reactExports.useMemo(() => {
    const uniqueItems = Array.from(/* @__PURE__ */ new Set([...defaultItems, ...userItems]));
    const cleansedItems = uniqueItems.filter((key) => processedComponents[key] != null);
    const sorted = cleansedItems.sort((a, b2) => {
      const leftItemProps = processedSlotProps[a];
      const rightItemProps = processedSlotProps[b2];
      const leftDisplayOrder = Number.isFinite(leftItemProps == null ? void 0 : leftItemProps.displayOrder) ? leftItemProps.displayOrder : 100;
      const rightDisplayOrder = Number.isFinite(rightItemProps == null ? void 0 : rightItemProps.displayOrder) ? rightItemProps.displayOrder : 100;
      return leftDisplayOrder - rightDisplayOrder;
    });
    return sorted.reduce((acc, key, index2) => {
      let itemProps = {
        colDef,
        onClick: hideMenu
      };
      const processedComponentProps = processedSlotProps[key];
      if (processedComponentProps) {
        const customProps = _objectWithoutPropertiesLoose$1(processedComponentProps, _excluded$C);
        itemProps = _extends$4({}, itemProps, customProps);
      }
      return addDividers && index2 !== sorted.length - 1 ? [...acc, [processedComponents[key], itemProps], [rootProps.slots.baseDivider, {}]] : [...acc, [processedComponents[key], itemProps]];
    }, []);
  }, [addDividers, colDef, defaultItems, hideMenu, processedComponents, processedSlotProps, userItems, rootProps.slots.baseDivider]);
}, "useGridColumnMenuSlots");
function GridColumnMenuHideItem(props) {
  const {
    colDef,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
  const columnsWithMenu = visibleColumns.filter((col) => col.disableColumnMenu !== true);
  const disabled = columnsWithMenu.length === 1;
  const toggleColumn = reactExports.useCallback((event) => {
    if (disabled) {
      return;
    }
    apiRef.current.setColumnVisibility(colDef.field, false);
    onClick(event);
  }, [apiRef, colDef.field, onClick, disabled]);
  if (rootProps.disableColumnSelector) {
    return null;
  }
  if (colDef.hideable === false) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, {
    onClick: toggleColumn,
    disabled,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuHideIcon, {
        fontSize: "small"
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, {
      children: apiRef.current.getLocaleText("columnMenuHideColumn")
    })]
  });
}
__name(GridColumnMenuHideItem, "GridColumnMenuHideItem");
function GridColumnMenuManageItem(props) {
  const {
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const showColumns = reactExports.useCallback((event) => {
    onClick(event);
    apiRef.current.showPreferences(GridPreferencePanelsValue.columns);
  }, [apiRef, onClick]);
  if (rootProps.disableColumnSelector) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, {
    onClick: showColumns,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuManageColumnsIcon, {
        fontSize: "small"
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, {
      children: apiRef.current.getLocaleText("columnMenuManageColumns")
    })]
  });
}
__name(GridColumnMenuManageItem, "GridColumnMenuManageItem");
function GridColumnMenuColumnsItem(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnMenuHideItem, _extends$4({}, props)), /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnMenuManageItem, _extends$4({}, props))]
  });
}
__name(GridColumnMenuColumnsItem, "GridColumnMenuColumnsItem");
function GridColumnMenuFilterItem(props) {
  const {
    colDef,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const showFilter = reactExports.useCallback((event) => {
    onClick(event);
    apiRef.current.showFilterPanel(colDef.field);
  }, [apiRef, colDef.field, onClick]);
  if (rootProps.disableColumnFilter || !colDef.filterable) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, {
    onClick: showFilter,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuFilterIcon, {
        fontSize: "small"
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, {
      children: apiRef.current.getLocaleText("columnMenuFilter")
    })]
  });
}
__name(GridColumnMenuFilterItem, "GridColumnMenuFilterItem");
function GridColumnMenuSortItem(props) {
  const {
    colDef,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const sortModel = useGridSelector(apiRef, gridSortModelSelector);
  const rootProps = useGridRootProps();
  const sortDirection = reactExports.useMemo(() => {
    if (!colDef) {
      return null;
    }
    const sortItem = sortModel.find((item) => item.field === colDef.field);
    return sortItem == null ? void 0 : sortItem.sort;
  }, [colDef, sortModel]);
  const sortingOrder = colDef.sortingOrder ?? rootProps.sortingOrder;
  const onSortMenuItemClick = reactExports.useCallback((event) => {
    onClick(event);
    const direction = event.currentTarget.getAttribute("data-value") || null;
    apiRef.current.sortColumn(colDef.field, direction === sortDirection ? null : direction);
  }, [apiRef, colDef, onClick, sortDirection]);
  if (rootProps.disableColumnSorting || !colDef || !colDef.sortable || !sortingOrder.some((item) => !!item)) {
    return null;
  }
  const getLabel = /* @__PURE__ */ __name((key) => {
    const label = apiRef.current.getLocaleText(key);
    return typeof label === "function" ? label(colDef) : label;
  }, "getLabel");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [sortingOrder.includes("asc") && sortDirection !== "asc" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, {
      onClick: onSortMenuItemClick,
      "data-value": "asc",
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuSortAscendingIcon, {
          fontSize: "small"
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, {
        children: getLabel("columnMenuSortAsc")
      })]
    }) : null, sortingOrder.includes("desc") && sortDirection !== "desc" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, {
      onClick: onSortMenuItemClick,
      "data-value": "desc",
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuSortDescendingIcon, {
          fontSize: "small"
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, {
        children: getLabel("columnMenuSortDesc")
      })]
    }) : null, sortingOrder.includes(null) && sortDirection != null ? /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, {
      onClick: onSortMenuItemClick,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, {
        children: apiRef.current.getLocaleText("columnMenuUnsort")
      })]
    }) : null]
  });
}
__name(GridColumnMenuSortItem, "GridColumnMenuSortItem");
const _excluded$B = ["defaultSlots", "defaultSlotProps", "slots", "slotProps"];
const GRID_COLUMN_MENU_SLOTS = {
  columnMenuSortItem: GridColumnMenuSortItem,
  columnMenuFilterItem: GridColumnMenuFilterItem,
  columnMenuColumnsItem: GridColumnMenuColumnsItem
};
const GRID_COLUMN_MENU_SLOT_PROPS = {
  columnMenuSortItem: {
    displayOrder: 10
  },
  columnMenuFilterItem: {
    displayOrder: 20
  },
  columnMenuColumnsItem: {
    displayOrder: 30
  }
};
const GridGenericColumnMenu = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridGenericColumnMenu2(props, ref) {
  const {
    defaultSlots: defaultSlots2,
    defaultSlotProps,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$B);
  const orderedSlots = useGridColumnMenuSlots(_extends$4({}, other, {
    defaultSlots: defaultSlots2,
    defaultSlotProps,
    slots,
    slotProps
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnMenuContainer, _extends$4({
    ref
  }, other, {
    children: orderedSlots.map(([Component, otherProps], index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Component, _extends$4({}, otherProps), index2))
  }));
}, "GridGenericColumnMenu2"));
const GridColumnMenu = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridColumnMenu2(props, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridGenericColumnMenu, _extends$4({}, props, {
    ref,
    defaultSlots: GRID_COLUMN_MENU_SLOTS,
    defaultSlotProps: GRID_COLUMN_MENU_SLOT_PROPS
  }));
}, "GridColumnMenu2"));
const _excluded$A = ["className", "slotProps"];
const useUtilityClasses$l = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["panelWrapper"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$l");
const GridPanelWrapperRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "PanelWrapper",
  overridesResolver: (props, styles2) => styles2.panelWrapper
})({
  display: "flex",
  flexDirection: "column",
  flex: 1,
  "&:focus": {
    outline: 0
  }
});
const isEnabled = /* @__PURE__ */ __name(() => true, "isEnabled");
const GridPanelWrapper = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridPanelWrapper2(props, ref) {
  const {
    className,
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$A);
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$l(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap$1, _extends$4({
    open: true,
    disableEnforceFocus: true,
    isEnabled
  }, slotProps.TrapFocus, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelWrapperRoot, _extends$4({
      ref,
      tabIndex: -1,
      className: clsx(classes2.root, className),
      ownerState: rootProps
    }, other))
  }));
}, "GridPanelWrapper2"));
const checkColumnVisibilityModelsSame = /* @__PURE__ */ __name((a, b2) => {
  const aFalseValues = new Set(Object.keys(a).filter((key) => a[key] === false));
  const bFalseValues = new Set(Object.keys(b2).filter((key) => b2[key] === false));
  if (aFalseValues.size !== bFalseValues.size) {
    return false;
  }
  let result = true;
  aFalseValues.forEach((key) => {
    if (!bFalseValues.has(key)) {
      result = false;
    }
  });
  return result;
}, "checkColumnVisibilityModelsSame");
const defaultSearchPredicate = /* @__PURE__ */ __name((column2, searchValue) => (column2.headerName || column2.field).toLowerCase().indexOf(searchValue) > -1, "defaultSearchPredicate");
const useUtilityClasses$k = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["columnsManagement"],
    header: ["columnsManagementHeader"],
    searchInput: ["columnsManagementSearchInput"],
    footer: ["columnsManagementFooter"],
    row: ["columnsManagementRow"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$k");
const collator$1 = new Intl.Collator();
function GridColumnsManagement(props) {
  var _a2, _b2, _c2, _d2;
  const apiRef = useGridApiContext();
  const searchInputRef = reactExports.useRef(null);
  const columns2 = useGridSelector(apiRef, gridColumnDefinitionsSelector);
  const initialColumnVisibilityModel = useLazyRef(() => gridColumnVisibilityModelSelector(apiRef)).current;
  const columnVisibilityModel = useGridSelector(apiRef, gridColumnVisibilityModelSelector);
  const rootProps = useGridRootProps();
  const [searchValue, setSearchValue] = reactExports.useState("");
  const classes2 = useUtilityClasses$k(rootProps);
  const {
    sort,
    searchPredicate = defaultSearchPredicate,
    autoFocusSearchField = true,
    disableShowHideToggle = false,
    disableResetButton = false,
    toggleAllMode = "all",
    getTogglableColumns,
    searchInputProps
  } = props;
  const isResetDisabled = reactExports.useMemo(() => checkColumnVisibilityModelsSame(columnVisibilityModel, initialColumnVisibilityModel), [columnVisibilityModel, initialColumnVisibilityModel]);
  const sortedColumns = reactExports.useMemo(() => {
    switch (sort) {
      case "asc":
        return [...columns2].sort((a, b2) => collator$1.compare(a.headerName || a.field, b2.headerName || b2.field));
      case "desc":
        return [...columns2].sort((a, b2) => -collator$1.compare(a.headerName || a.field, b2.headerName || b2.field));
      default:
        return columns2;
    }
  }, [columns2, sort]);
  const toggleColumn = /* @__PURE__ */ __name((event) => {
    const {
      name: field
    } = event.target;
    apiRef.current.setColumnVisibility(field, columnVisibilityModel[field] === false);
  }, "toggleColumn");
  const currentColumns = reactExports.useMemo(() => {
    const togglableColumns = getTogglableColumns ? getTogglableColumns(sortedColumns) : null;
    const togglableSortedColumns = togglableColumns ? sortedColumns.filter(({
      field
    }) => togglableColumns.includes(field)) : sortedColumns;
    if (!searchValue) {
      return togglableSortedColumns;
    }
    return togglableSortedColumns.filter((column2) => searchPredicate(column2, searchValue.toLowerCase()));
  }, [sortedColumns, searchValue, searchPredicate, getTogglableColumns]);
  const toggleAllColumns = reactExports.useCallback((isVisible) => {
    const currentModel = gridColumnVisibilityModelSelector(apiRef);
    const newModel = _extends$4({}, currentModel);
    const togglableColumns = getTogglableColumns ? getTogglableColumns(columns2) : null;
    (toggleAllMode === "filteredOnly" ? currentColumns : columns2).forEach((col) => {
      if (col.hideable && (togglableColumns == null || togglableColumns.includes(col.field))) {
        if (isVisible) {
          delete newModel[col.field];
        } else {
          newModel[col.field] = false;
        }
      }
    });
    return apiRef.current.setColumnVisibilityModel(newModel);
  }, [apiRef, columns2, getTogglableColumns, toggleAllMode, currentColumns]);
  const handleSearchValueChange = reactExports.useCallback((event) => {
    setSearchValue(event.target.value);
  }, []);
  const hideableColumns = reactExports.useMemo(() => currentColumns.filter((col) => col.hideable), [currentColumns]);
  const allHideableColumnsVisible = reactExports.useMemo(() => hideableColumns.every((column2) => columnVisibilityModel[column2.field] == null || columnVisibilityModel[column2.field] !== false), [columnVisibilityModel, hideableColumns]);
  const allHideableColumnsHidden = reactExports.useMemo(() => hideableColumns.every((column2) => columnVisibilityModel[column2.field] === false), [columnVisibilityModel, hideableColumns]);
  const firstSwitchRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (autoFocusSearchField) {
      searchInputRef.current.focus();
    } else if (firstSwitchRef.current && typeof firstSwitchRef.current.focus === "function") {
      firstSwitchRef.current.focus();
    }
  }, [autoFocusSearchField]);
  let firstHideableColumnFound = false;
  const isFirstHideableColumn = /* @__PURE__ */ __name((column2) => {
    if (firstHideableColumnFound === false && column2.hideable !== false) {
      firstHideableColumnFound = true;
      return true;
    }
    return false;
  }, "isFirstHideableColumn");
  const handleSearchReset = reactExports.useCallback(() => {
    setSearchValue("");
    searchInputRef.current.focus();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnsManagementHeader, {
      className: classes2.header,
      ownerState: rootProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchInput, _extends$4({
        as: rootProps.slots.baseTextField,
        ownerState: rootProps,
        placeholder: apiRef.current.getLocaleText("columnsManagementSearchTitle"),
        inputRef: searchInputRef,
        className: classes2.searchInput,
        value: searchValue,
        onChange: handleSearchValueChange,
        variant: "outlined",
        size: "small",
        type: "search",
        InputProps: {
          startAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputAdornment, {
            position: "start",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.quickFilterIcon, {})
          }),
          endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$4({
            "aria-label": apiRef.current.getLocaleText("columnsManagementDeleteIconLabel"),
            size: "small",
            sx: [searchValue ? {
              visibility: "visible"
            } : {
              visibility: "hidden"
            }],
            tabIndex: -1,
            onClick: handleSearchReset
          }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseIconButton, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.quickFilterClearIcon, {
              fontSize: "small"
            })
          }))
        },
        inputProps: {
          "aria-label": apiRef.current.getLocaleText("columnsManagementSearchTitle")
        },
        autoComplete: "off",
        fullWidth: true
      }, (_b2 = rootProps.slotProps) == null ? void 0 : _b2.baseTextField, searchInputProps))
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs(GridColumnsManagementBody, {
      className: classes2.root,
      ownerState: rootProps,
      children: [currentColumns.map((column2) => {
        var _a3;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel, {
          className: classes2.row,
          control: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends$4({
            disabled: column2.hideable === false,
            checked: columnVisibilityModel[column2.field] !== false,
            onClick: toggleColumn,
            name: column2.field,
            sx: {
              p: 0.5
            },
            inputRef: isFirstHideableColumn(column2) ? firstSwitchRef : void 0
          }, (_a3 = rootProps.slotProps) == null ? void 0 : _a3.baseCheckbox)),
          label: column2.headerName || column2.field
        }, column2.field);
      }), currentColumns.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnsManagementEmptyText, {
        ownerState: rootProps,
        children: apiRef.current.getLocaleText("columnsManagementNoColumns")
      })]
    }), (!disableShowHideToggle || !disableResetButton) && currentColumns.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(GridColumnsManagementFooter, {
      ownerState: rootProps,
      className: classes2.footer,
      children: [!disableShowHideToggle ? /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel, {
        control: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends$4({
          disabled: hideableColumns.length === 0,
          checked: allHideableColumnsVisible,
          indeterminate: !allHideableColumnsVisible && !allHideableColumnsHidden,
          onClick: () => toggleAllColumns(!allHideableColumnsVisible),
          name: apiRef.current.getLocaleText("columnsManagementShowHideAllText"),
          sx: {
            p: 0.5
          }
        }, (_c2 = rootProps.slotProps) == null ? void 0 : _c2.baseCheckbox)),
        label: apiRef.current.getLocaleText("columnsManagementShowHideAllText")
      }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}), !disableResetButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends$4({
        onClick: () => apiRef.current.setColumnVisibilityModel(initialColumnVisibilityModel),
        disabled: isResetDisabled
      }, (_d2 = rootProps.slotProps) == null ? void 0 : _d2.baseButton, {
        children: apiRef.current.getLocaleText("columnsManagementReset")
      })) : null]
    }) : null]
  });
}
__name(GridColumnsManagement, "GridColumnsManagement");
const GridColumnsManagementBody = styled("div", {
  name: "MuiDataGrid",
  slot: "ColumnsManagement",
  overridesResolver: (props, styles2) => styles2.columnsManagement
})(({
  theme: theme2
}) => ({
  padding: theme2.spacing(0, 3, 1.5),
  display: "flex",
  flexDirection: "column",
  overflow: "auto",
  flex: "1 1",
  maxHeight: 400,
  alignItems: "flex-start"
}));
const GridColumnsManagementHeader = styled("div", {
  name: "MuiDataGrid",
  slot: "ColumnsManagementHeader",
  overridesResolver: (props, styles2) => styles2.columnsManagementHeader
})(({
  theme: theme2
}) => ({
  padding: theme2.spacing(1.5, 3)
}));
const SearchInput = styled(TextField, {
  name: "MuiDataGrid",
  slot: "ColumnsManagementSearchInput",
  overridesResolver: (props, styles2) => styles2.columnsManagementSearchInput
})(({
  theme: theme2
}) => ({
  [`& .${inputBaseClasses.root}`]: {
    padding: theme2.spacing(0, 1.5, 0, 1.5)
  },
  [`& .${inputBaseClasses.input}::-webkit-search-decoration,
  & .${inputBaseClasses.input}::-webkit-search-cancel-button,
  & .${inputBaseClasses.input}::-webkit-search-results-button,
  & .${inputBaseClasses.input}::-webkit-search-results-decoration`]: {
    /* clears the 'X' icon from Chrome */
    display: "none"
  }
}));
const GridColumnsManagementFooter = styled("div", {
  name: "MuiDataGrid",
  slot: "ColumnsManagementFooter",
  overridesResolver: (props, styles2) => styles2.columnsManagementFooter
})(({
  theme: theme2
}) => ({
  padding: theme2.spacing(0.5, 1, 0.5, 3),
  display: "flex",
  justifyContent: "space-between",
  borderTop: `1px solid ${theme2.palette.divider}`
}));
const GridColumnsManagementEmptyText = styled("div")(({
  theme: theme2
}) => ({
  padding: theme2.spacing(0.5, 0),
  color: theme2.palette.grey[500]
}));
function GridColumnsPanel(props) {
  var _a2;
  const rootProps = useGridRootProps();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelWrapper, _extends$4({}, props, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnsManagement, _extends$4({}, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.columnsManagement))
  }));
}
__name(GridColumnsPanel, "GridColumnsPanel");
const _excluded$z = ["children", "className", "classes"];
const gridPanelClasses = generateUtilityClasses$1("MuiDataGrid", ["panel", "paper"]);
const GridPanelRoot = styled(Popper, {
  name: "MuiDataGrid",
  slot: "Panel",
  overridesResolver: (props, styles2) => styles2.panel
})(({
  theme: theme2
}) => ({
  zIndex: theme2.zIndex.modal
}));
const GridPaperRoot = styled(Paper, {
  name: "MuiDataGrid",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})(({
  theme: theme2
}) => ({
  backgroundColor: (theme2.vars || theme2).palette.background.paper,
  minWidth: 300,
  maxHeight: 450,
  display: "flex",
  maxWidth: `calc(100vw - ${theme2.spacing(0.5)})`,
  overflow: "auto"
}));
const GridPanel = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  const {
    children,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$z);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const classes2 = gridPanelClasses;
  const [isPlaced, setIsPlaced] = reactExports.useState(false);
  const handleClickAway = reactExports.useCallback(() => {
    apiRef.current.hidePreferences();
  }, [apiRef]);
  const handleKeyDown2 = reactExports.useCallback((event) => {
    if (event.key === "Escape") {
      apiRef.current.hidePreferences();
    }
  }, [apiRef]);
  const modifiers = reactExports.useMemo(() => [{
    name: "flip",
    enabled: true,
    options: {
      rootBoundary: "document"
    }
  }, {
    name: "isPlaced",
    enabled: true,
    phase: "main",
    fn: () => {
      setIsPlaced(true);
    },
    effect: () => () => {
      setIsPlaced(false);
    }
  }], []);
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  reactExports.useEffect(() => {
    var _a2, _b2;
    const panelAnchor = (_b2 = (_a2 = apiRef.current.rootElementRef) == null ? void 0 : _a2.current) == null ? void 0 : _b2.querySelector('[data-id="gridPanelAnchor"]');
    if (panelAnchor) {
      setAnchorEl(panelAnchor);
    }
  }, [apiRef]);
  if (!anchorEl) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelRoot, _extends$4({
    ref,
    placement: "bottom-start",
    className: clsx(classes2.panel, className),
    ownerState: rootProps,
    anchorEl,
    modifiers
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwayListener, {
      mouseEvent: "onMouseUp",
      onClickAway: handleClickAway,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPaperRoot, {
        className: classes2.paper,
        ownerState: rootProps,
        elevation: 8,
        onKeyDown: handleKeyDown2,
        children: isPlaced && children
      })
    })
  }));
});
const _excluded$y = ["className"];
const useUtilityClasses$j = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["panelContent"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$j");
const GridPanelContentRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "PanelContent",
  overridesResolver: (props, styles2) => styles2.panelContent
})({
  display: "flex",
  flexDirection: "column",
  overflow: "auto",
  flex: "1 1",
  maxHeight: 400
});
function GridPanelContent(props) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$y);
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$j(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelContentRoot, _extends$4({
    className: clsx(classes2.root, className),
    ownerState: rootProps
  }, other));
}
__name(GridPanelContent, "GridPanelContent");
const _excluded$x = ["className"];
const useUtilityClasses$i = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["panelFooter"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$i");
const GridPanelFooterRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "PanelFooter",
  overridesResolver: (props, styles2) => styles2.panelFooter
})(({
  theme: theme2
}) => ({
  padding: theme2.spacing(0.5),
  display: "flex",
  justifyContent: "space-between"
}));
function GridPanelFooter(props) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$x);
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$i(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelFooterRoot, _extends$4({
    className: clsx(classes2.root, className),
    ownerState: rootProps
  }, other));
}
__name(GridPanelFooter, "GridPanelFooter");
const _excluded$w = ["item", "hasMultipleFilters", "deleteFilter", "applyFilterChanges", "showMultiFilterOperators", "disableMultiFilterOperator", "applyMultiFilterOperatorChanges", "focusElementRef", "logicOperators", "columnsSort", "filterColumns", "deleteIconProps", "logicOperatorInputProps", "operatorInputProps", "columnInputProps", "valueInputProps", "readOnly", "children"], _excluded2$5 = ["InputComponentProps"];
const useUtilityClasses$h = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["filterForm"],
    deleteIcon: ["filterFormDeleteIcon"],
    logicOperatorInput: ["filterFormLogicOperatorInput"],
    columnInput: ["filterFormColumnInput"],
    operatorInput: ["filterFormOperatorInput"],
    valueInput: ["filterFormValueInput"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$h");
const GridFilterFormRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "FilterForm",
  overridesResolver: (props, styles2) => styles2.filterForm
})(({
  theme: theme2
}) => ({
  display: "flex",
  padding: theme2.spacing(1)
}));
const FilterFormDeleteIcon = styled("div", {
  name: "MuiDataGrid",
  slot: "FilterFormDeleteIcon",
  overridesResolver: (_2, styles2) => styles2.filterFormDeleteIcon
})(({
  theme: theme2
}) => ({
  flexShrink: 0,
  justifyContent: "flex-end",
  marginRight: theme2.spacing(0.5),
  marginBottom: theme2.spacing(0.2)
}));
const FilterFormLogicOperatorInput = styled("div", {
  name: "MuiDataGrid",
  slot: "FilterFormLogicOperatorInput",
  overridesResolver: (_2, styles2) => styles2.filterFormLogicOperatorInput
})({
  minWidth: 55,
  marginRight: 5,
  justifyContent: "end"
});
const FilterFormColumnInput = styled("div", {
  name: "MuiDataGrid",
  slot: "FilterFormColumnInput",
  overridesResolver: (_2, styles2) => styles2.filterFormColumnInput
})({
  width: 150
});
const FilterFormOperatorInput = styled("div", {
  name: "MuiDataGrid",
  slot: "FilterFormOperatorInput",
  overridesResolver: (_2, styles2) => styles2.filterFormOperatorInput
})({
  width: 150
});
const FilterFormValueInput = styled("div", {
  name: "MuiDataGrid",
  slot: "FilterFormValueInput",
  overridesResolver: (_2, styles2) => styles2.filterFormValueInput
})({
  width: 190
});
const getLogicOperatorLocaleKey = /* @__PURE__ */ __name((logicOperator) => {
  switch (logicOperator) {
    case GridLogicOperator.And:
      return "filterPanelOperatorAnd";
    case GridLogicOperator.Or:
      return "filterPanelOperatorOr";
    default:
      throw new Error("MUI X: Invalid `logicOperator` property in the `GridFilterPanel`.");
  }
}, "getLogicOperatorLocaleKey");
const getColumnLabel = /* @__PURE__ */ __name((col) => col.headerName || col.field, "getColumnLabel");
const collator = new Intl.Collator();
const GridFilterForm = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridFilterForm2(props, ref) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2;
  const {
    item,
    hasMultipleFilters,
    deleteFilter,
    applyFilterChanges,
    showMultiFilterOperators,
    disableMultiFilterOperator,
    applyMultiFilterOperatorChanges,
    focusElementRef,
    logicOperators = [GridLogicOperator.And, GridLogicOperator.Or],
    columnsSort,
    filterColumns,
    deleteIconProps = {},
    logicOperatorInputProps = {},
    operatorInputProps = {},
    columnInputProps = {},
    valueInputProps = {},
    readOnly
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$w);
  const apiRef = useGridApiContext();
  const columnLookup = useGridSelector(apiRef, gridColumnLookupSelector);
  const filterableColumns = useGridSelector(apiRef, gridFilterableColumnDefinitionsSelector);
  const filterModel = useGridSelector(apiRef, gridFilterModelSelector);
  const columnSelectId = useId();
  const columnSelectLabelId = useId();
  const operatorSelectId = useId();
  const operatorSelectLabelId = useId();
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$h(rootProps);
  const valueRef = reactExports.useRef(null);
  const filterSelectorRef = reactExports.useRef(null);
  const multiFilterOperator = filterModel.logicOperator ?? GridLogicOperator.And;
  const hasLogicOperatorColumn = hasMultipleFilters && logicOperators.length > 0;
  const baseFormControlProps = ((_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseFormControl) || {};
  const baseSelectProps = ((_b2 = rootProps.slotProps) == null ? void 0 : _b2.baseSelect) || {};
  const isBaseSelectNative = baseSelectProps.native ?? false;
  const baseInputLabelProps = ((_c2 = rootProps.slotProps) == null ? void 0 : _c2.baseInputLabel) || {};
  const baseSelectOptionProps = ((_d2 = rootProps.slotProps) == null ? void 0 : _d2.baseSelectOption) || {};
  const {
    InputComponentProps
  } = valueInputProps, valueInputPropsOther = _objectWithoutPropertiesLoose$1(valueInputProps, _excluded2$5);
  const {
    filteredColumns,
    selectedField
  } = reactExports.useMemo(() => {
    let itemField = item.field;
    const selectedNonFilterableColumn = columnLookup[item.field].filterable === false ? columnLookup[item.field] : null;
    if (selectedNonFilterableColumn) {
      return {
        filteredColumns: [selectedNonFilterableColumn],
        selectedField: itemField
      };
    }
    if (filterColumns === void 0 || typeof filterColumns !== "function") {
      return {
        filteredColumns: filterableColumns,
        selectedField: itemField
      };
    }
    const filteredFields = filterColumns({
      field: item.field,
      columns: filterableColumns,
      currentFilters: (filterModel == null ? void 0 : filterModel.items) || []
    });
    return {
      filteredColumns: filterableColumns.filter((column2) => {
        const isFieldIncluded = filteredFields.includes(column2.field);
        if (column2.field === item.field && !isFieldIncluded) {
          itemField = void 0;
        }
        return isFieldIncluded;
      }),
      selectedField: itemField
    };
  }, [filterColumns, filterModel == null ? void 0 : filterModel.items, filterableColumns, item.field, columnLookup]);
  const sortedFilteredColumns = reactExports.useMemo(() => {
    switch (columnsSort) {
      case "asc":
        return filteredColumns.sort((a, b2) => collator.compare(getColumnLabel(a), getColumnLabel(b2)));
      case "desc":
        return filteredColumns.sort((a, b2) => -collator.compare(getColumnLabel(a), getColumnLabel(b2)));
      default:
        return filteredColumns;
    }
  }, [filteredColumns, columnsSort]);
  const currentColumn = item.field ? apiRef.current.getColumn(item.field) : null;
  const currentOperator = reactExports.useMemo(() => {
    var _a3;
    if (!item.operator || !currentColumn) {
      return null;
    }
    return (_a3 = currentColumn.filterOperators) == null ? void 0 : _a3.find((operator) => operator.value === item.operator);
  }, [item, currentColumn]);
  const changeColumn = reactExports.useCallback((event) => {
    const field = event.target.value;
    const column2 = apiRef.current.getColumn(field);
    if (column2.field === currentColumn.field) {
      return;
    }
    const newOperator = column2.filterOperators.find((operator) => operator.value === item.operator) || column2.filterOperators[0];
    const eraseFilterValue = !newOperator.InputComponent || newOperator.InputComponent !== (currentOperator == null ? void 0 : currentOperator.InputComponent) || column2.type !== currentColumn.type;
    let filterValue = eraseFilterValue ? void 0 : item.value;
    if (column2.type === "singleSelect" && filterValue !== void 0) {
      const colDef = column2;
      const valueOptions = getValueOptions(colDef);
      if (Array.isArray(filterValue)) {
        filterValue = filterValue.filter((val) => {
          return (
            // Only keep values that are in the new value options
            getValueFromValueOptions(val, valueOptions, colDef == null ? void 0 : colDef.getOptionValue) !== void 0
          );
        });
      } else if (getValueFromValueOptions(item.value, valueOptions, colDef == null ? void 0 : colDef.getOptionValue) === void 0) {
        filterValue = void 0;
      }
    }
    applyFilterChanges(_extends$4({}, item, {
      field,
      operator: newOperator.value,
      value: filterValue
    }));
  }, [apiRef, applyFilterChanges, item, currentColumn, currentOperator]);
  const changeOperator = reactExports.useCallback((event) => {
    const operator = event.target.value;
    const newOperator = currentColumn == null ? void 0 : currentColumn.filterOperators.find((op) => op.value === operator);
    const eraseItemValue = !(newOperator == null ? void 0 : newOperator.InputComponent) || (newOperator == null ? void 0 : newOperator.InputComponent) !== (currentOperator == null ? void 0 : currentOperator.InputComponent);
    applyFilterChanges(_extends$4({}, item, {
      operator,
      value: eraseItemValue ? void 0 : item.value
    }));
  }, [applyFilterChanges, item, currentColumn, currentOperator]);
  const changeLogicOperator = reactExports.useCallback((event) => {
    const logicOperator = event.target.value === GridLogicOperator.And.toString() ? GridLogicOperator.And : GridLogicOperator.Or;
    applyMultiFilterOperatorChanges(logicOperator);
  }, [applyMultiFilterOperatorChanges]);
  const handleDeleteFilter = /* @__PURE__ */ __name(() => {
    deleteFilter(item);
  }, "handleDeleteFilter");
  reactExports.useImperativeHandle(focusElementRef, () => ({
    focus: () => {
      var _a3;
      if (currentOperator == null ? void 0 : currentOperator.InputComponent) {
        (_a3 = valueRef == null ? void 0 : valueRef.current) == null ? void 0 : _a3.focus();
      } else {
        filterSelectorRef.current.focus();
      }
    }
  }), [currentOperator]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridFilterFormRoot, _extends$4({
    ref,
    className: classes2.root,
    "data-id": item.id,
    ownerState: rootProps
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(FilterFormDeleteIcon, _extends$4({
      variant: "standard",
      as: rootProps.slots.baseFormControl
    }, baseFormControlProps, deleteIconProps, {
      className: clsx(classes2.deleteIcon, baseFormControlProps.className, deleteIconProps.className),
      ownerState: rootProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$4({
        "aria-label": apiRef.current.getLocaleText("filterPanelDeleteIconLabel"),
        title: apiRef.current.getLocaleText("filterPanelDeleteIconLabel"),
        onClick: handleDeleteFilter,
        size: "small",
        disabled: readOnly
      }, (_e2 = rootProps.slotProps) == null ? void 0 : _e2.baseIconButton, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.filterPanelDeleteIcon, {
          fontSize: "small"
        })
      }))
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(FilterFormLogicOperatorInput, _extends$4({
      variant: "standard",
      as: rootProps.slots.baseFormControl
    }, baseFormControlProps, logicOperatorInputProps, {
      sx: [hasLogicOperatorColumn ? {
        display: "flex"
      } : {
        display: "none"
      }, showMultiFilterOperators ? {
        visibility: "visible"
      } : {
        visibility: "hidden"
      }, baseFormControlProps.sx, logicOperatorInputProps.sx],
      className: clsx(classes2.logicOperatorInput, baseFormControlProps.className, logicOperatorInputProps.className),
      ownerState: rootProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends$4({
        inputProps: {
          "aria-label": apiRef.current.getLocaleText("filterPanelLogicOperator")
        },
        value: multiFilterOperator ?? "",
        onChange: changeLogicOperator,
        disabled: !!disableMultiFilterOperator || logicOperators.length === 1,
        native: isBaseSelectNative
      }, (_f2 = rootProps.slotProps) == null ? void 0 : _f2.baseSelect, {
        children: logicOperators.map((logicOperator) => /* @__PURE__ */ reactExports.createElement(rootProps.slots.baseSelectOption, _extends$4({}, baseSelectOptionProps, {
          native: isBaseSelectNative,
          key: logicOperator.toString(),
          value: logicOperator.toString()
        }), apiRef.current.getLocaleText(getLogicOperatorLocaleKey(logicOperator))))
      }))
    })), /* @__PURE__ */ jsxRuntimeExports.jsxs(FilterFormColumnInput, _extends$4({
      variant: "standard",
      as: rootProps.slots.baseFormControl
    }, baseFormControlProps, columnInputProps, {
      className: clsx(classes2.columnInput, baseFormControlProps.className, columnInputProps.className),
      ownerState: rootProps,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends$4({}, baseInputLabelProps, {
        htmlFor: columnSelectId,
        id: columnSelectLabelId,
        children: apiRef.current.getLocaleText("filterPanelColumns")
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends$4({
        labelId: columnSelectLabelId,
        id: columnSelectId,
        label: apiRef.current.getLocaleText("filterPanelColumns"),
        value: selectedField ?? "",
        onChange: changeColumn,
        native: isBaseSelectNative,
        disabled: readOnly
      }, (_g2 = rootProps.slotProps) == null ? void 0 : _g2.baseSelect, {
        children: sortedFilteredColumns.map((col) => /* @__PURE__ */ reactExports.createElement(rootProps.slots.baseSelectOption, _extends$4({}, baseSelectOptionProps, {
          native: isBaseSelectNative,
          key: col.field,
          value: col.field
        }), getColumnLabel(col)))
      }))]
    })), /* @__PURE__ */ jsxRuntimeExports.jsxs(FilterFormOperatorInput, _extends$4({
      variant: "standard",
      as: rootProps.slots.baseFormControl
    }, baseFormControlProps, operatorInputProps, {
      className: clsx(classes2.operatorInput, baseFormControlProps.className, operatorInputProps.className),
      ownerState: rootProps,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends$4({}, baseInputLabelProps, {
        htmlFor: operatorSelectId,
        id: operatorSelectLabelId,
        children: apiRef.current.getLocaleText("filterPanelOperator")
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends$4({
        labelId: operatorSelectLabelId,
        label: apiRef.current.getLocaleText("filterPanelOperator"),
        id: operatorSelectId,
        value: item.operator,
        onChange: changeOperator,
        native: isBaseSelectNative,
        inputRef: filterSelectorRef,
        disabled: readOnly
      }, (_h2 = rootProps.slotProps) == null ? void 0 : _h2.baseSelect, {
        children: (_i2 = currentColumn == null ? void 0 : currentColumn.filterOperators) == null ? void 0 : _i2.map((operator) => /* @__PURE__ */ reactExports.createElement(rootProps.slots.baseSelectOption, _extends$4({}, baseSelectOptionProps, {
          native: isBaseSelectNative,
          key: operator.value,
          value: operator.value
        }), operator.label || apiRef.current.getLocaleText(`filterOperator${capitalize$1(operator.value)}`)))
      }))]
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(FilterFormValueInput, _extends$4({
      variant: "standard",
      as: rootProps.slots.baseFormControl
    }, baseFormControlProps, valueInputPropsOther, {
      className: clsx(classes2.valueInput, baseFormControlProps.className, valueInputPropsOther.className),
      ownerState: rootProps,
      children: (currentOperator == null ? void 0 : currentOperator.InputComponent) ? /* @__PURE__ */ jsxRuntimeExports.jsx(currentOperator.InputComponent, _extends$4({
        apiRef,
        item,
        applyValue: applyFilterChanges,
        focusElementRef: valueRef,
        disabled: readOnly
      }, currentOperator.InputComponentProps, InputComponentProps), item.field) : null
    }))]
  }));
}, "GridFilterForm2"));
const _excluded$v = ["logicOperators", "columnsSort", "filterFormProps", "getColumnForNewFilter", "children", "disableAddFilterButton", "disableRemoveAllButton"];
const getGridFilter = /* @__PURE__ */ __name((col) => ({
  field: col.field,
  operator: col.filterOperators[0].value,
  id: Math.round(Math.random() * 1e5)
}), "getGridFilter");
const GridFilterPanel = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridFilterPanel2(props, ref) {
  var _a2, _b2;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const filterModel = useGridSelector(apiRef, gridFilterModelSelector);
  const filterableColumns = useGridSelector(apiRef, gridFilterableColumnDefinitionsSelector);
  const filterableColumnsLookup = useGridSelector(apiRef, gridFilterableColumnLookupSelector);
  const lastFilterRef = reactExports.useRef(null);
  const placeholderFilter = reactExports.useRef(null);
  const {
    logicOperators = [GridLogicOperator.And, GridLogicOperator.Or],
    columnsSort,
    filterFormProps,
    getColumnForNewFilter,
    disableAddFilterButton = false,
    disableRemoveAllButton = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$v);
  const applyFilter = apiRef.current.upsertFilterItem;
  const applyFilterLogicOperator = reactExports.useCallback((operator) => {
    apiRef.current.setFilterLogicOperator(operator);
  }, [apiRef]);
  const getDefaultFilter = reactExports.useCallback(() => {
    let nextColumnWithOperator;
    if (getColumnForNewFilter && typeof getColumnForNewFilter === "function") {
      const nextFieldName = getColumnForNewFilter({
        currentFilters: (filterModel == null ? void 0 : filterModel.items) || [],
        columns: filterableColumns
      });
      if (nextFieldName === null) {
        return null;
      }
      nextColumnWithOperator = filterableColumns.find(({
        field
      }) => field === nextFieldName);
    } else {
      nextColumnWithOperator = filterableColumns.find((colDef) => {
        var _a3;
        return (_a3 = colDef.filterOperators) == null ? void 0 : _a3.length;
      });
    }
    if (!nextColumnWithOperator) {
      return null;
    }
    return getGridFilter(nextColumnWithOperator);
  }, [filterModel == null ? void 0 : filterModel.items, filterableColumns, getColumnForNewFilter]);
  const getNewFilter = reactExports.useCallback(() => {
    if (getColumnForNewFilter === void 0 || typeof getColumnForNewFilter !== "function") {
      return getDefaultFilter();
    }
    const currentFilters = filterModel.items.length ? filterModel.items : [getDefaultFilter()].filter(Boolean);
    const nextColumnFieldName = getColumnForNewFilter({
      currentFilters,
      columns: filterableColumns
    });
    if (nextColumnFieldName === null) {
      return null;
    }
    const nextColumnWithOperator = filterableColumns.find(({
      field
    }) => field === nextColumnFieldName);
    if (!nextColumnWithOperator) {
      return null;
    }
    return getGridFilter(nextColumnWithOperator);
  }, [filterModel.items, filterableColumns, getColumnForNewFilter, getDefaultFilter]);
  const items = reactExports.useMemo(() => {
    if (filterModel.items.length) {
      return filterModel.items;
    }
    if (!placeholderFilter.current) {
      placeholderFilter.current = getDefaultFilter();
    }
    return placeholderFilter.current ? [placeholderFilter.current] : [];
  }, [filterModel.items, getDefaultFilter]);
  const hasMultipleFilters = items.length > 1;
  const {
    readOnlyFilters,
    validFilters
  } = reactExports.useMemo(() => items.reduce((acc, item) => {
    if (filterableColumnsLookup[item.field]) {
      acc.validFilters.push(item);
    } else {
      acc.readOnlyFilters.push(item);
    }
    return acc;
  }, {
    readOnlyFilters: [],
    validFilters: []
  }), [items, filterableColumnsLookup]);
  const addNewFilter = reactExports.useCallback(() => {
    const newFilter = getNewFilter();
    if (!newFilter) {
      return;
    }
    apiRef.current.upsertFilterItems([...items, newFilter]);
  }, [apiRef, getNewFilter, items]);
  const deleteFilter = reactExports.useCallback((item) => {
    const shouldCloseFilterPanel = validFilters.length === 1;
    apiRef.current.deleteFilterItem(item);
    if (shouldCloseFilterPanel) {
      apiRef.current.hideFilterPanel();
    }
  }, [apiRef, validFilters.length]);
  const handleRemoveAll = reactExports.useCallback(() => {
    if (validFilters.length === 1 && validFilters[0].value === void 0) {
      apiRef.current.deleteFilterItem(validFilters[0]);
      return apiRef.current.hideFilterPanel();
    }
    return apiRef.current.setFilterModel(_extends$4({}, filterModel, {
      items: readOnlyFilters
    }), "removeAllFilterItems");
  }, [apiRef, readOnlyFilters, filterModel, validFilters]);
  reactExports.useEffect(() => {
    if (logicOperators.length > 0 && filterModel.logicOperator && !logicOperators.includes(filterModel.logicOperator)) {
      applyFilterLogicOperator(logicOperators[0]);
    }
  }, [logicOperators, applyFilterLogicOperator, filterModel.logicOperator]);
  reactExports.useEffect(() => {
    if (validFilters.length > 0) {
      lastFilterRef.current.focus();
    }
  }, [validFilters.length]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelWrapper, _extends$4({
    ref
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelContent, {
      children: [readOnlyFilters.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridFilterForm, _extends$4({
        item,
        applyFilterChanges: applyFilter,
        deleteFilter,
        hasMultipleFilters,
        showMultiFilterOperators: index2 > 0,
        disableMultiFilterOperator: index2 !== 1,
        applyMultiFilterOperatorChanges: applyFilterLogicOperator,
        focusElementRef: null,
        readOnly: true,
        logicOperators,
        columnsSort
      }, filterFormProps), item.id == null ? index2 : item.id)), validFilters.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridFilterForm, _extends$4({
        item,
        applyFilterChanges: applyFilter,
        deleteFilter,
        hasMultipleFilters,
        showMultiFilterOperators: readOnlyFilters.length + index2 > 0,
        disableMultiFilterOperator: readOnlyFilters.length + index2 !== 1,
        applyMultiFilterOperatorChanges: applyFilterLogicOperator,
        focusElementRef: index2 === validFilters.length - 1 ? lastFilterRef : null,
        logicOperators,
        columnsSort
      }, filterFormProps), item.id == null ? index2 + readOnlyFilters.length : item.id))]
    }), !rootProps.disableMultipleColumnsFiltering && !(disableAddFilterButton && disableRemoveAllButton) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelFooter, {
      children: [!disableAddFilterButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends$4({
        onClick: addNewFilter,
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.filterPanelAddIcon, {})
      }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.baseButton, {
        children: apiRef.current.getLocaleText("filterPanelAddFilter")
      })) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}), !disableRemoveAllButton && validFilters.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends$4({
        onClick: handleRemoveAll,
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.filterPanelRemoveAllIcon, {})
      }, (_b2 = rootProps.slotProps) == null ? void 0 : _b2.baseButton, {
        children: apiRef.current.getLocaleText("filterPanelRemoveAll")
      })) : null]
    }) : null]
  }));
}, "GridFilterPanel2"));
const _excluded$u = ["hideMenu", "options"], _excluded2$4 = ["hideMenu", "options"];
function GridCsvExportMenuItem(props) {
  const apiRef = useGridApiContext();
  const {
    hideMenu,
    options
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$u);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, _extends$4({
    onClick: () => {
      apiRef.current.exportDataAsCsv(options);
      hideMenu == null ? void 0 : hideMenu();
    }
  }, other, {
    children: apiRef.current.getLocaleText("toolbarExportCSV")
  }));
}
__name(GridCsvExportMenuItem, "GridCsvExportMenuItem");
function GridPrintExportMenuItem(props) {
  const apiRef = useGridApiContext();
  const {
    hideMenu,
    options
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded2$4);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, _extends$4({
    onClick: () => {
      apiRef.current.exportDataAsPrint(options);
      hideMenu == null ? void 0 : hideMenu();
    }
  }, other, {
    children: apiRef.current.getLocaleText("toolbarExportPrint")
  }));
}
__name(GridPrintExportMenuItem, "GridPrintExportMenuItem");
const _excluded$t = ["className", "selectedRowCount"];
const useUtilityClasses$g = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["selectedRowCount"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$g");
const GridSelectedRowCountRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "SelectedRowCount",
  overridesResolver: (props, styles2) => styles2.selectedRowCount
})(({
  theme: theme2
}) => ({
  alignItems: "center",
  display: "flex",
  margin: theme2.spacing(0, 2),
  visibility: "hidden",
  width: 0,
  height: 0,
  [theme2.breakpoints.up("sm")]: {
    visibility: "visible",
    width: "auto",
    height: "auto"
  }
}));
const GridSelectedRowCount = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridSelectedRowCount2(props, ref) {
  const {
    className,
    selectedRowCount
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$t);
  const apiRef = useGridApiContext();
  const ownerState = useGridRootProps();
  const classes2 = useUtilityClasses$g(ownerState);
  const rowSelectedText = apiRef.current.getLocaleText("footerRowSelected")(selectedRowCount);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridSelectedRowCountRoot, _extends$4({
    ref,
    className: clsx(classes2.root, className),
    ownerState
  }, other, {
    children: rowSelectedText
  }));
}, "GridSelectedRowCount2"));
const GridFooter = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridFooter2(props, ref) {
  var _a2, _b2;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const totalTopLevelRowCount = useGridSelector(apiRef, gridTopLevelRowCountSelector);
  const selectedRowCount = useGridSelector(apiRef, selectedGridRowsCountSelector);
  const visibleTopLevelRowCount = useGridSelector(apiRef, gridFilteredTopLevelRowCountSelector);
  const selectedRowCountElement = !rootProps.hideFooterSelectedRowCount && selectedRowCount > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(GridSelectedRowCount, {
    selectedRowCount
  }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", {});
  const rowCountElement = !rootProps.hideFooterRowCount && !rootProps.pagination ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.footerRowCount, _extends$4({}, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.footerRowCount, {
    rowCount: totalTopLevelRowCount,
    visibleRowCount: visibleTopLevelRowCount
  })) : null;
  const paginationElement = rootProps.pagination && !rootProps.hideFooterPagination && rootProps.slots.pagination && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.pagination, _extends$4({}, (_b2 = rootProps.slotProps) == null ? void 0 : _b2.pagination));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridFooterContainer, _extends$4({
    ref
  }, props, {
    children: [selectedRowCountElement, rowCountElement, paginationElement]
  }));
}, "GridFooter2"));
function GridPreferencesPanel() {
  var _a2, _b2;
  const apiRef = useGridApiContext();
  const columns2 = useGridSelector(apiRef, gridColumnDefinitionsSelector);
  const rootProps = useGridRootProps();
  const preferencePanelState = useGridSelector(apiRef, gridPreferencePanelStateSelector);
  const panelContent = apiRef.current.unstable_applyPipeProcessors("preferencePanel", null, preferencePanelState.openedPanelValue ?? GridPreferencePanelsValue.filters);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.panel, _extends$4({
    as: rootProps.slots.basePopper,
    open: columns2.length > 0 && preferencePanelState.open,
    id: preferencePanelState.panelId,
    "aria-labelledby": preferencePanelState.labelId
  }, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.panel, (_b2 = rootProps.slotProps) == null ? void 0 : _b2.basePopper, {
    children: panelContent
  }));
}
__name(GridPreferencesPanel, "GridPreferencesPanel");
function GridHeader() {
  var _a2;
  const rootProps = useGridRootProps();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridPreferencesPanel, {}), rootProps.slots.toolbar && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.toolbar, _extends$4({}, (_a2 = rootProps.slotProps) == null ? void 0 : _a2.toolbar))]
  });
}
__name(GridHeader, "GridHeader");
const getPinnedCellOffset = /* @__PURE__ */ __name((pinnedPosition, computedWidth, columnIndex, columnPositions, dimensions) => {
  const scrollbarWidth = dimensions.hasScrollY ? dimensions.scrollbarSize : 0;
  let pinnedOffset;
  switch (pinnedPosition) {
    case GridPinnedColumnPosition.LEFT:
      pinnedOffset = columnPositions[columnIndex];
      break;
    case GridPinnedColumnPosition.RIGHT:
      pinnedOffset = dimensions.columnsTotalWidth - columnPositions[columnIndex] - computedWidth + scrollbarWidth;
      break;
    default:
      pinnedOffset = 0;
      break;
  }
  return pinnedOffset;
}, "getPinnedCellOffset");
const classes = {
  root: gridClasses.scrollbarFiller,
  header: gridClasses["scrollbarFiller--header"],
  borderTop: gridClasses["scrollbarFiller--borderTop"],
  borderBottom: gridClasses["scrollbarFiller--borderBottom"],
  pinnedRight: gridClasses["scrollbarFiller--pinnedRight"]
};
function GridScrollbarFillerCell({
  header,
  borderTop: borderTop2 = true,
  borderBottom: borderBottom2,
  pinnedRight
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    role: "presentation",
    className: clsx(classes.root, header && classes.header, borderTop2 && classes.borderTop, borderBottom2 && classes.borderBottom, pinnedRight && classes.pinnedRight)
  });
}
__name(GridScrollbarFillerCell, "GridScrollbarFillerCell");
const SkeletonOverlay = styled$1("div", {
  name: "MuiDataGrid",
  slot: "SkeletonLoadingOverlay",
  overridesResolver: (props, styles2) => styles2.skeletonLoadingOverlay
})({
  minWidth: "100%",
  width: "max-content",
  // prevents overflow: clip; cutting off the x axis
  height: "100%",
  overflow: "clip"
  // y axis is hidden while the x axis is allowed to overflow
});
const useUtilityClasses$f = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["skeletonLoadingOverlay"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$f");
const getColIndex = /* @__PURE__ */ __name((el2) => parseInt(el2.getAttribute("data-colindex"), 10), "getColIndex");
const GridSkeletonLoadingOverlay = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridSkeletonLoadingOverlay2(props, forwardedRef) {
  const rootProps = useGridRootProps();
  const {
    slots
  } = rootProps;
  const classes2 = useUtilityClasses$f({
    classes: rootProps.classes
  });
  const ref = reactExports.useRef(null);
  const handleRef = useForkRef(ref, forwardedRef);
  const apiRef = useGridApiContext();
  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);
  const viewportHeight = (dimensions == null ? void 0 : dimensions.viewportInnerSize.height) ?? 0;
  const skeletonRowsCount = Math.ceil(viewportHeight / dimensions.rowHeight);
  const totalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);
  const positions = useGridSelector(apiRef, gridColumnPositionsSelector);
  const inViewportCount = reactExports.useMemo(() => positions.filter((value) => value <= totalWidth).length, [totalWidth, positions]);
  const allVisibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const columns2 = reactExports.useMemo(() => allVisibleColumns.slice(0, inViewportCount), [allVisibleColumns, inViewportCount]);
  const pinnedColumns = useGridSelector(apiRef, gridVisiblePinnedColumnDefinitionsSelector);
  const getPinnedStyle = reactExports.useCallback((computedWidth, index2, position2) => {
    const pinnedOffset = getPinnedCellOffset(position2, computedWidth, index2, positions, dimensions);
    return {
      [position2]: pinnedOffset
    };
  }, [dimensions, positions]);
  const getPinnedPosition = reactExports.useCallback((field) => {
    if (pinnedColumns.left.findIndex((col) => col.field === field) !== -1) {
      return GridPinnedColumnPosition.LEFT;
    }
    if (pinnedColumns.right.findIndex((col) => col.field === field) !== -1) {
      return GridPinnedColumnPosition.RIGHT;
    }
    return void 0;
  }, [pinnedColumns.left, pinnedColumns.right]);
  const children = reactExports.useMemo(() => {
    const array = [];
    for (let i = 0; i < skeletonRowsCount; i += 1) {
      const rowCells = [];
      for (let colIndex = 0; colIndex < columns2.length; colIndex += 1) {
        const column2 = columns2[colIndex];
        const pinnedPosition = getPinnedPosition(column2.field);
        const isPinnedLeft = pinnedPosition === GridPinnedColumnPosition.LEFT;
        const isPinnedRight = pinnedPosition === GridPinnedColumnPosition.RIGHT;
        const sectionLength = pinnedPosition ? pinnedColumns[pinnedPosition].length : columns2.length - pinnedColumns.left.length - pinnedColumns.right.length;
        const sectionIndex = pinnedPosition ? pinnedColumns[pinnedPosition].findIndex((col) => col.field === column2.field) : colIndex - pinnedColumns.left.length;
        const pinnedStyle = pinnedPosition && getPinnedStyle(column2.computedWidth, colIndex, pinnedPosition);
        const gridHasFiller = dimensions.columnsTotalWidth < dimensions.viewportOuterSize.width;
        const showRightBorder = shouldCellShowRightBorder(pinnedPosition, sectionIndex, sectionLength, rootProps.showCellVerticalBorder, gridHasFiller);
        const showLeftBorder = shouldCellShowLeftBorder(pinnedPosition, sectionIndex);
        const isLastColumn = colIndex === columns2.length - 1;
        const isFirstPinnedRight = isPinnedRight && sectionIndex === 0;
        const hasFillerBefore = isFirstPinnedRight && gridHasFiller;
        const hasFillerAfter = isLastColumn && !isFirstPinnedRight && gridHasFiller;
        const expandedWidth = dimensions.viewportOuterSize.width - dimensions.columnsTotalWidth;
        const emptyCellWidth = Math.max(0, expandedWidth);
        const emptyCell = /* @__PURE__ */ jsxRuntimeExports.jsx(slots.skeletonCell, {
          width: emptyCellWidth,
          empty: true
        }, `skeleton-filler-column-${i}`);
        const scrollbarWidth = dimensions.hasScrollY ? dimensions.scrollbarSize : 0;
        const hasScrollbarFiller = isLastColumn && scrollbarWidth !== 0;
        if (hasFillerBefore) {
          rowCells.push(emptyCell);
        }
        rowCells.push(/* @__PURE__ */ jsxRuntimeExports.jsx(slots.skeletonCell, {
          field: column2.field,
          type: column2.type,
          align: column2.align,
          width: "var(--width)",
          height: dimensions.rowHeight,
          "data-colindex": colIndex,
          className: clsx(isPinnedLeft && gridClasses["cell--pinnedLeft"], isPinnedRight && gridClasses["cell--pinnedRight"], showRightBorder && gridClasses["cell--withRightBorder"], showLeftBorder && gridClasses["cell--withLeftBorder"]),
          style: _extends$4({
            "--width": `${column2.computedWidth}px`
          }, pinnedStyle)
        }, `skeleton-column-${i}-${column2.field}`));
        if (hasFillerAfter) {
          rowCells.push(emptyCell);
        }
        if (hasScrollbarFiller) {
          rowCells.push(/* @__PURE__ */ jsxRuntimeExports.jsx(GridScrollbarFillerCell, {
            pinnedRight: pinnedColumns.right.length > 0
          }, `skeleton-scrollbar-filler-${i}`));
        }
      }
      array.push(/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        className: clsx(gridClasses.row, gridClasses.rowSkeleton, i === 0 && gridClasses["row--firstVisible"]),
        children: rowCells
      }, `skeleton-row-${i}`));
    }
    return array;
  }, [slots, columns2, pinnedColumns, skeletonRowsCount, rootProps.showCellVerticalBorder, dimensions.columnsTotalWidth, dimensions.viewportOuterSize.width, dimensions.rowHeight, dimensions.hasScrollY, dimensions.scrollbarSize, getPinnedPosition, getPinnedStyle]);
  const handleColumnResize = /* @__PURE__ */ __name((params) => {
    var _a2, _b2, _c2;
    const {
      colDef,
      width: width2
    } = params;
    const cells = (_a2 = ref.current) == null ? void 0 : _a2.querySelectorAll(`[data-field="${escapeOperandAttributeSelector(colDef.field)}"]`);
    if (!cells) {
      throw new Error("MUI X: Expected skeleton cells to be defined with `data-field` attribute.");
    }
    const resizedColIndex = columns2.findIndex((col) => col.field === colDef.field);
    const pinnedPosition = getPinnedPosition(colDef.field);
    const isPinnedLeft = pinnedPosition === GridPinnedColumnPosition.LEFT;
    const isPinnedRight = pinnedPosition === GridPinnedColumnPosition.RIGHT;
    const currentWidth = getComputedStyle(cells[0]).getPropertyValue("--width");
    const delta = parseInt(currentWidth, 10) - width2;
    if (cells) {
      cells.forEach((element) => {
        element.style.setProperty("--width", `${width2}px`);
      });
    }
    if (isPinnedLeft) {
      const pinnedCells = (_b2 = ref.current) == null ? void 0 : _b2.querySelectorAll(`.${gridClasses["cell--pinnedLeft"]}`);
      pinnedCells == null ? void 0 : pinnedCells.forEach((element) => {
        const colIndex = getColIndex(element);
        if (colIndex > resizedColIndex) {
          element.style.left = `${parseInt(getComputedStyle(element).left, 10) - delta}px`;
        }
      });
    }
    if (isPinnedRight) {
      const pinnedCells = (_c2 = ref.current) == null ? void 0 : _c2.querySelectorAll(`.${gridClasses["cell--pinnedRight"]}`);
      pinnedCells == null ? void 0 : pinnedCells.forEach((element) => {
        const colIndex = getColIndex(element);
        if (colIndex < resizedColIndex) {
          element.style.right = `${parseInt(getComputedStyle(element).right, 10) + delta}px`;
        }
      });
    }
  }, "handleColumnResize");
  useGridApiEventHandler(apiRef, "columnResize", handleColumnResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonOverlay, _extends$4({
    className: classes2.root,
    ref: handleRef
  }, props, {
    children
  }));
}, "GridSkeletonLoadingOverlay"));
const _excluded$s = ["variant", "noRowsVariant", "style"];
const LOADING_VARIANTS = {
  "circular-progress": {
    component: CircularProgress,
    style: {}
  },
  "linear-progress": {
    component: LinearProgress,
    style: {
      display: "block"
    }
  },
  skeleton: {
    component: GridSkeletonLoadingOverlay,
    style: {
      display: "block"
    }
  }
};
const GridLoadingOverlay = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridLoadingOverlay2(props, ref) {
  const {
    variant = "circular-progress",
    noRowsVariant = "circular-progress",
    style: style2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$s);
  const apiRef = useGridApiContext();
  const rowsCount = useGridSelector(apiRef, gridRowCountSelector);
  const activeVariant = LOADING_VARIANTS[rowsCount === 0 ? noRowsVariant : variant];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlay, _extends$4({
    ref,
    style: _extends$4({}, activeVariant.style, style2)
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(activeVariant.component, {})
  }));
}, "GridLoadingOverlay2"));
const GridNoRowsOverlay = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridNoRowsOverlay2(props, ref) {
  const apiRef = useGridApiContext();
  const noRowsLabel = apiRef.current.getLocaleText("noRowsLabel");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlay, _extends$4({
    ref
  }, props, {
    children: noRowsLabel
  }));
}, "GridNoRowsOverlay2"));
const GridPaginationRoot = styled(TablePagination)(({
  theme: theme2
}) => ({
  maxHeight: "calc(100% + 1px)",
  // border width
  flexGrow: 1,
  [`& .${tablePaginationClasses.selectLabel}`]: {
    display: "none",
    [theme2.breakpoints.up("sm")]: {
      display: "block"
    }
  },
  [`& .${tablePaginationClasses.input}`]: {
    display: "none",
    [theme2.breakpoints.up("sm")]: {
      display: "inline-flex"
    }
  }
}));
const wrapLabelDisplayedRows = /* @__PURE__ */ __name((labelDisplayedRows, estimated) => {
  return ({
    from: from2,
    to,
    count,
    page
  }) => labelDisplayedRows({
    from: from2,
    to,
    count,
    page,
    estimated
  });
}, "wrapLabelDisplayedRows");
const defaultLabelDisplayedRows = /* @__PURE__ */ __name(({
  from: from2,
  to,
  count,
  estimated
}) => {
  if (!estimated) {
    return `${from2}${to} of ${count !== -1 ? count : `more than ${to}`}`;
  }
  return `${from2}${to} of ${count !== -1 ? count : `more than ${estimated > to ? estimated : to}`}`;
}, "defaultLabelDisplayedRows");
const GridPagination = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridPagination2(props, ref) {
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const paginationModel = useGridSelector(apiRef, gridPaginationModelSelector);
  const rowCount = useGridSelector(apiRef, gridPaginationRowCountSelector);
  const pageCount = useGridSelector(apiRef, gridPageCountSelector);
  const {
    paginationMode,
    loading,
    estimatedRowCount
  } = rootProps;
  const computedProps = reactExports.useMemo(() => {
    if (rowCount === -1 && paginationMode === "server" && loading) {
      return {
        backIconButtonProps: {
          disabled: true
        },
        nextIconButtonProps: {
          disabled: true
        }
      };
    }
    return {};
  }, [loading, paginationMode, rowCount]);
  const lastPage = reactExports.useMemo(() => Math.max(0, pageCount - 1), [pageCount]);
  const computedPage = reactExports.useMemo(() => {
    if (rowCount === -1) {
      return paginationModel.page;
    }
    return paginationModel.page <= lastPage ? paginationModel.page : lastPage;
  }, [lastPage, paginationModel.page, rowCount]);
  const handlePageSizeChange = reactExports.useCallback((event) => {
    const pageSize2 = Number(event.target.value);
    apiRef.current.setPageSize(pageSize2);
  }, [apiRef]);
  const handlePageChange = reactExports.useCallback((_2, page) => {
    apiRef.current.setPage(page);
  }, [apiRef]);
  const isPageSizeIncludedInPageSizeOptions = /* @__PURE__ */ __name((pageSize2) => {
    for (let i = 0; i < rootProps.pageSizeOptions.length; i += 1) {
      const option = rootProps.pageSizeOptions[i];
      if (typeof option === "number") {
        if (option === pageSize2) {
          return true;
        }
      } else if (option.value === pageSize2) {
        return true;
      }
    }
    return false;
  }, "isPageSizeIncludedInPageSizeOptions");
  const pageSizeOptions = isPageSizeIncludedInPageSizeOptions(paginationModel.pageSize) ? rootProps.pageSizeOptions : [];
  const locales = apiRef.current.getLocaleText("MuiTablePagination");
  const wrappedLabelDisplayedRows = wrapLabelDisplayedRows(locales.labelDisplayedRows || defaultLabelDisplayedRows, estimatedRowCount);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPaginationRoot, _extends$4({
    ref,
    component: "div",
    count: rowCount,
    page: computedPage,
    rowsPerPageOptions: pageSizeOptions,
    rowsPerPage: paginationModel.pageSize,
    onPageChange: handlePageChange,
    onRowsPerPageChange: handlePageSizeChange
  }, computedProps, locales, {
    labelDisplayedRows: wrappedLabelDisplayedRows
  }, props));
}, "GridPagination2"));
const _excluded$r = ["className", "rowCount", "visibleRowCount"];
const useUtilityClasses$e = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["rowCount"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$e");
const GridRowCountRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "RowCount",
  overridesResolver: (props, styles2) => styles2.rowCount
})(({
  theme: theme2
}) => ({
  alignItems: "center",
  display: "flex",
  margin: theme2.spacing(0, 2)
}));
const GridRowCount = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridRowCount2(props, ref) {
  const {
    className,
    rowCount,
    visibleRowCount
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$r);
  const apiRef = useGridApiContext();
  const ownerState = useGridRootProps();
  const classes2 = useUtilityClasses$e(ownerState);
  if (rowCount === 0) {
    return null;
  }
  const text = visibleRowCount < rowCount ? apiRef.current.getLocaleText("footerTotalVisibleRows")(visibleRowCount, rowCount) : rowCount.toLocaleString();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridRowCountRoot, _extends$4({
    ref,
    className: clsx(classes2.root, className),
    ownerState
  }, other, {
    children: [apiRef.current.getLocaleText("footerTotalRows"), " ", text]
  }));
}, "GridRowCount2"));
function composeGridClasses(classes2, slots) {
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}
__name(composeGridClasses, "composeGridClasses");
const _excluded$q = ["selected", "rowId", "row", "index", "style", "rowHeight", "className", "visibleColumns", "pinnedColumns", "offsetTop", "offsetLeft", "dimensions", "renderContext", "focusedColumnIndex", "isFirstVisible", "isLastVisible", "isNotVisible", "showBottomBorder", "tabbableCell", "onClick", "onDoubleClick", "onMouseEnter", "onMouseLeave", "onMouseOut", "onMouseOver"];
function EmptyCell({
  width: width2
}) {
  if (!width2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    role: "presentation",
    className: clsx(gridClasses.cell, gridClasses.cellEmpty),
    style: {
      "--width": `${width2}px`
    }
  });
}
__name(EmptyCell, "EmptyCell");
const GridRow = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridRow2(props, refProp) {
  var _a2;
  const {
    selected,
    rowId,
    row,
    index: index2,
    style: styleProp,
    rowHeight,
    className,
    visibleColumns,
    pinnedColumns,
    offsetLeft,
    dimensions,
    renderContext,
    focusedColumnIndex,
    isFirstVisible,
    isLastVisible,
    isNotVisible,
    showBottomBorder,
    onClick,
    onDoubleClick,
    onMouseEnter,
    onMouseLeave,
    onMouseOut,
    onMouseOver
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$q);
  const apiRef = useGridPrivateApiContext();
  const configuration2 = useGridConfiguration();
  const ref = reactExports.useRef(null);
  const rootProps = useGridRootProps();
  const currentPage = useGridVisibleRows(apiRef, rootProps);
  const sortModel = useGridSelector(apiRef, gridSortModelSelector);
  const treeDepth = useGridSelector(apiRef, gridRowMaximumTreeDepthSelector);
  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);
  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);
  const handleRef = useForkRef(ref, refProp);
  const rowNode = apiRef.current.getRowNode(rowId);
  const scrollbarWidth = dimensions.hasScrollY ? dimensions.scrollbarSize : 0;
  const gridHasFiller = dimensions.columnsTotalWidth < dimensions.viewportOuterSize.width;
  const editing = apiRef.current.getRowMode(rowId) === GridRowModes.Edit;
  const editable = rootProps.editMode === GridEditModes.Row;
  const hasFocusCell = focusedColumnIndex !== void 0;
  const hasVirtualFocusCellLeft = hasFocusCell && focusedColumnIndex >= pinnedColumns.left.length && focusedColumnIndex < renderContext.firstColumnIndex;
  const hasVirtualFocusCellRight = hasFocusCell && focusedColumnIndex < visibleColumns.length - pinnedColumns.right.length && focusedColumnIndex >= renderContext.lastColumnIndex;
  const classes2 = composeGridClasses(rootProps.classes, {
    root: ["row", selected && "selected", editable && "row--editable", editing && "row--editing", isFirstVisible && "row--firstVisible", isLastVisible && "row--lastVisible", showBottomBorder && "row--borderBottom", rowHeight === "auto" && "row--dynamicHeight"]
  });
  const getRowAriaAttributes = configuration2.hooks.useGridRowAriaAttributes();
  reactExports.useLayoutEffect(() => {
    if (currentPage.range) {
      const rowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(rowId);
      if (rowIndex !== void 0) {
        apiRef.current.unstable_setLastMeasuredRowIndex(rowIndex);
      }
    }
    if (ref.current && rowHeight === "auto") {
      return apiRef.current.observeRowHeight(ref.current, rowId);
    }
    return void 0;
  }, [apiRef, currentPage.range, rowHeight, rowId]);
  const publish2 = reactExports.useCallback((eventName, propHandler) => (event) => {
    if (isEventTargetInPortal(event)) {
      return;
    }
    if (!apiRef.current.getRow(rowId)) {
      return;
    }
    apiRef.current.publishEvent(eventName, apiRef.current.getRowParams(rowId), event);
    if (propHandler) {
      propHandler(event);
    }
  }, [apiRef, rowId]);
  const publishClick = reactExports.useCallback((event) => {
    const cell = findParentElementFromClassName(event.target, gridClasses.cell);
    const field = cell == null ? void 0 : cell.getAttribute("data-field");
    if (field) {
      if (field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {
        return;
      }
      if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
        return;
      }
      if (field === "__reorder__") {
        return;
      }
      if (apiRef.current.getCellMode(rowId, field) === GridCellModes.Edit) {
        return;
      }
      const column2 = apiRef.current.getColumn(field);
      if ((column2 == null ? void 0 : column2.type) === GRID_ACTIONS_COLUMN_TYPE) {
        return;
      }
    }
    publish2("rowClick", onClick)(event);
  }, [apiRef, onClick, publish2, rowId]);
  const {
    slots,
    slotProps,
    disableColumnReorder
  } = rootProps;
  const rowReordering = rootProps.rowReordering;
  const heightEntry = useGridSelector(apiRef, () => _extends$4({}, apiRef.current.getRowHeightEntry(rowId)), objectShallowCompare);
  const style2 = reactExports.useMemo(() => {
    if (isNotVisible) {
      return {
        opacity: 0,
        width: 0,
        height: 0
      };
    }
    const rowStyle = _extends$4({}, styleProp, {
      maxHeight: rowHeight === "auto" ? "none" : rowHeight,
      // max-height doesn't support "auto"
      minHeight: rowHeight,
      "--height": typeof rowHeight === "number" ? `${rowHeight}px` : rowHeight
    });
    if (heightEntry.spacingTop) {
      const property = rootProps.rowSpacingType === "border" ? "borderTopWidth" : "marginTop";
      rowStyle[property] = heightEntry.spacingTop;
    }
    if (heightEntry.spacingBottom) {
      const property = rootProps.rowSpacingType === "border" ? "borderBottomWidth" : "marginBottom";
      let propertyValue = rowStyle[property];
      if (typeof propertyValue !== "number") {
        propertyValue = parseInt(propertyValue || "0", 10);
      }
      propertyValue += heightEntry.spacingBottom;
      rowStyle[property] = propertyValue;
    }
    return rowStyle;
  }, [isNotVisible, rowHeight, styleProp, heightEntry, rootProps.rowSpacingType]);
  const rowClassNames = apiRef.current.unstable_applyPipeProcessors("rowClassName", [], rowId);
  const ariaAttributes = rowNode ? getRowAriaAttributes(rowNode, index2) : void 0;
  if (typeof rootProps.getRowClassName === "function") {
    const indexRelativeToCurrentPage = index2 - (((_a2 = currentPage.range) == null ? void 0 : _a2.firstRowIndex) || 0);
    const rowParams = _extends$4({}, apiRef.current.getRowParams(rowId), {
      isFirstVisible: indexRelativeToCurrentPage === 0,
      isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,
      indexRelativeToCurrentPage
    });
    rowClassNames.push(rootProps.getRowClassName(rowParams));
  }
  const getCell = /* @__PURE__ */ __name((column2, indexInSection, indexRelativeToAllColumns, sectionLength, pinnedPosition = PinnedPosition.NONE) => {
    var _a3;
    const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, indexRelativeToAllColumns);
    if (cellColSpanInfo == null ? void 0 : cellColSpanInfo.spannedByColSpan) {
      return null;
    }
    const width2 = (cellColSpanInfo == null ? void 0 : cellColSpanInfo.cellProps.width) ?? column2.computedWidth;
    const colSpan = (cellColSpanInfo == null ? void 0 : cellColSpanInfo.cellProps.colSpan) ?? 1;
    const pinnedOffset = getPinnedCellOffset(gridPinnedColumnPositionLookup[pinnedPosition], column2.computedWidth, indexRelativeToAllColumns, columnPositions, dimensions);
    if ((rowNode == null ? void 0 : rowNode.type) === "skeletonRow") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(slots.skeletonCell, {
        type: column2.type,
        width: width2,
        height: rowHeight,
        field: column2.field,
        align: column2.align
      }, column2.field);
    }
    const editCellState = ((_a3 = editRowsState[rowId]) == null ? void 0 : _a3[column2.field]) ?? null;
    const isReorderCell = column2.field === "__reorder__";
    const isEditingRows = Object.keys(editRowsState).length > 0;
    const canReorderColumn = !(disableColumnReorder || column2.disableReorder);
    const canReorderRow = rowReordering && !sortModel.length && treeDepth <= 1 && !isEditingRows;
    const disableDragEvents = !(canReorderColumn || isReorderCell && canReorderRow);
    const cellIsNotVisible = pinnedPosition === PinnedPosition.VIRTUAL;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(slots.cell, _extends$4({
      column: column2,
      width: width2,
      rowId,
      align: column2.align || "left",
      colIndex: indexRelativeToAllColumns,
      colSpan,
      disableDragEvents,
      editCellState,
      isNotVisible: cellIsNotVisible,
      pinnedOffset,
      pinnedPosition,
      sectionIndex: indexInSection,
      sectionLength,
      gridHasFiller
    }, slotProps == null ? void 0 : slotProps.cell), column2.field);
  }, "getCell");
  if (!rowNode) {
    return null;
  }
  const leftCells = pinnedColumns.left.map((column2, i) => {
    const indexRelativeToAllColumns = i;
    return getCell(column2, i, indexRelativeToAllColumns, pinnedColumns.left.length, PinnedPosition.LEFT);
  });
  const rightCells = pinnedColumns.right.map((column2, i) => {
    const indexRelativeToAllColumns = visibleColumns.length - pinnedColumns.right.length + i;
    return getCell(column2, i, indexRelativeToAllColumns, pinnedColumns.right.length, PinnedPosition.RIGHT);
  });
  const middleColumnsLength = visibleColumns.length - pinnedColumns.left.length - pinnedColumns.right.length;
  const cells = [];
  if (hasVirtualFocusCellLeft) {
    cells.push(getCell(visibleColumns[focusedColumnIndex], focusedColumnIndex - pinnedColumns.left.length, focusedColumnIndex, middleColumnsLength, PinnedPosition.VIRTUAL));
  }
  for (let i = renderContext.firstColumnIndex; i < renderContext.lastColumnIndex; i += 1) {
    const column2 = visibleColumns[i];
    const indexInSection = i - pinnedColumns.left.length;
    if (!column2) {
      continue;
    }
    cells.push(getCell(column2, indexInSection, i, middleColumnsLength));
  }
  if (hasVirtualFocusCellRight) {
    cells.push(getCell(visibleColumns[focusedColumnIndex], focusedColumnIndex - pinnedColumns.left.length, focusedColumnIndex, middleColumnsLength, PinnedPosition.VIRTUAL));
  }
  const eventHandlers = row ? {
    onClick: publishClick,
    onDoubleClick: publish2("rowDoubleClick", onDoubleClick),
    onMouseEnter: publish2("rowMouseEnter", onMouseEnter),
    onMouseLeave: publish2("rowMouseLeave", onMouseLeave),
    onMouseOut: publish2("rowMouseOut", onMouseOut),
    onMouseOver: publish2("rowMouseOver", onMouseOver)
  } : null;
  const expandedWidth = dimensions.viewportOuterSize.width - dimensions.columnsTotalWidth - scrollbarWidth;
  const emptyCellWidth = Math.max(0, expandedWidth);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$4({
    ref: handleRef,
    "data-id": rowId,
    "data-rowindex": index2,
    role: "row",
    className: clsx(...rowClassNames, classes2.root, className),
    style: style2
  }, ariaAttributes, eventHandlers, other, {
    children: [leftCells, /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      role: "presentation",
      className: gridClasses.cellOffsetLeft,
      style: {
        width: offsetLeft
      }
    }), cells, emptyCellWidth > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyCell, {
      width: emptyCellWidth
    }), rightCells.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      role: "presentation",
      className: gridClasses.filler
    }), rightCells, scrollbarWidth !== 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(GridScrollbarFillerCell, {
      pinnedRight: pinnedColumns.right.length > 0
    })]
  }));
}, "GridRow2"));
const MemoizedGridRow = fastMemo(GridRow);
const useGridAriaAttributes = /* @__PURE__ */ __name(() => {
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const accessibleRowCount = useGridSelector(apiRef, gridExpandedRowCountSelector);
  const headerGroupingMaxDepth = useGridSelector(apiRef, gridColumnGroupsHeaderMaxDepthSelector);
  const pinnedRowsCount = useGridSelector(apiRef, gridPinnedRowsCountSelector);
  return {
    role: "grid",
    "aria-colcount": visibleColumns.length,
    "aria-rowcount": headerGroupingMaxDepth + 1 + pinnedRowsCount + accessibleRowCount,
    "aria-multiselectable": isMultipleRowSelectionEnabled(rootProps)
  };
}, "useGridAriaAttributes");
const useGridRowAriaAttributes = /* @__PURE__ */ __name(() => {
  const apiRef = useGridPrivateApiContext();
  const selectedIdsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);
  const headerGroupingMaxDepth = useGridSelector(apiRef, gridColumnGroupsHeaderMaxDepthSelector);
  return reactExports.useCallback((rowNode, index2) => {
    const ariaAttributes = {};
    const ariaRowIndex = index2 + headerGroupingMaxDepth + 2;
    ariaAttributes["aria-rowindex"] = ariaRowIndex;
    if (apiRef.current.isRowSelectable(rowNode.id)) {
      ariaAttributes["aria-selected"] = selectedIdsLookup[rowNode.id] !== void 0;
    }
    return ariaAttributes;
  }, [apiRef, selectedIdsLookup, headerGroupingMaxDepth]);
}, "useGridRowAriaAttributes");
function GridContextProvider({
  privateApiRef,
  configuration: configuration2,
  props,
  children
}) {
  const apiRef = reactExports.useRef(privateApiRef.current.getPublicApi());
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridConfigurationContext.Provider, {
    value: configuration2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridRootPropsContext.Provider, {
      value: props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPrivateApiContext.Provider, {
        value: privateApiRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridApiContext.Provider, {
          value: apiRef,
          children
        })
      })
    })
  });
}
__name(GridContextProvider, "GridContextProvider");
const useGridRefs = /* @__PURE__ */ __name((apiRef) => {
  const rootElementRef = reactExports.useRef(null);
  const mainElementRef = reactExports.useRef(null);
  const virtualScrollerRef = reactExports.useRef(null);
  const virtualScrollbarVerticalRef = reactExports.useRef(null);
  const virtualScrollbarHorizontalRef = reactExports.useRef(null);
  const columnHeadersContainerRef = reactExports.useRef(null);
  apiRef.current.register("public", {
    rootElementRef
  });
  apiRef.current.register("private", {
    mainElementRef,
    virtualScrollerRef,
    virtualScrollbarVerticalRef,
    virtualScrollbarHorizontalRef,
    columnHeadersContainerRef
  });
}, "useGridRefs");
const useGridIsRtl = /* @__PURE__ */ __name((apiRef) => {
  const isRtl = useRtl();
  if (apiRef.current.state.isRtl === void 0) {
    apiRef.current.state.isRtl = isRtl;
  }
  const isFirstEffect = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstEffect.current) {
      isFirstEffect.current = false;
    } else {
      apiRef.current.setState((state) => _extends$4({}, state, {
        isRtl
      }));
    }
  }, [apiRef, isRtl]);
}, "useGridIsRtl");
const forceDebug = localStorageAvailable() && window.localStorage.getItem("DEBUG") != null;
const noop$4 = /* @__PURE__ */ __name(() => {
}, "noop$4");
const noopLogger = {
  debug: noop$4,
  info: noop$4,
  warn: noop$4,
  error: noop$4
};
const LOG_LEVELS = ["debug", "info", "warn", "error"];
function getAppender(name, logLevel, appender = console) {
  const minLogLevelIdx = LOG_LEVELS.indexOf(logLevel);
  if (minLogLevelIdx === -1) {
    throw new Error(`MUI X: Log level ${logLevel} not recognized.`);
  }
  const logger = LOG_LEVELS.reduce((loggerObj, method, idx) => {
    if (idx >= minLogLevelIdx) {
      loggerObj[method] = (...args) => {
        const [message, ...other] = args;
        appender[method](`MUI X: ${name} - ${message}`, ...other);
      };
    } else {
      loggerObj[method] = noop$4;
    }
    return loggerObj;
  }, {});
  return logger;
}
__name(getAppender, "getAppender");
const useGridLoggerFactory = /* @__PURE__ */ __name((apiRef, props) => {
  const getLogger = reactExports.useCallback((name) => {
    if (forceDebug) {
      return getAppender(name, "debug", props.logger);
    }
    if (!props.logLevel) {
      return noopLogger;
    }
    return getAppender(name, props.logLevel.toString(), props.logger);
  }, [props.logLevel, props.logger]);
  useGridApiMethod(apiRef, {
    getLogger
  }, "private");
}, "useGridLoggerFactory");
const _EventManager = class _EventManager {
  constructor() {
    this.maxListeners = 20;
    this.warnOnce = false;
    this.events = {};
  }
  on(eventName, listener, options = {}) {
    let collection = this.events[eventName];
    if (!collection) {
      collection = {
        highPriority: /* @__PURE__ */ new Map(),
        regular: /* @__PURE__ */ new Map()
      };
      this.events[eventName] = collection;
    }
    if (options.isFirst) {
      collection.highPriority.set(listener, true);
    } else {
      collection.regular.set(listener, true);
    }
  }
  removeListener(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName].regular.delete(listener);
      this.events[eventName].highPriority.delete(listener);
    }
  }
  removeAllListeners() {
    this.events = {};
  }
  emit(eventName, ...args) {
    const collection = this.events[eventName];
    if (!collection) {
      return;
    }
    const highPriorityListeners = Array.from(collection.highPriority.keys());
    const regularListeners = Array.from(collection.regular.keys());
    for (let i = highPriorityListeners.length - 1; i >= 0; i -= 1) {
      const listener = highPriorityListeners[i];
      if (collection.highPriority.has(listener)) {
        listener.apply(this, args);
      }
    }
    for (let i = 0; i < regularListeners.length; i += 1) {
      const listener = regularListeners[i];
      if (collection.regular.has(listener)) {
        listener.apply(this, args);
      }
    }
  }
  once(eventName, listener) {
    const that = this;
    this.on(eventName, /* @__PURE__ */ __name(function oneTimeListener(...args) {
      that.removeListener(eventName, oneTimeListener);
      listener.apply(that, args);
    }, "oneTimeListener"));
  }
};
__name(_EventManager, "EventManager");
let EventManager = _EventManager;
const _Store = class _Store {
  static create(value) {
    return new _Store(value);
  }
  constructor(_value) {
    this.value = void 0;
    this.listeners = void 0;
    this.subscribe = (fn2) => {
      this.listeners.add(fn2);
      return () => {
        this.listeners.delete(fn2);
      };
    };
    this.getSnapshot = () => {
      return this.value;
    };
    this.update = (value) => {
      this.value = value;
      this.listeners.forEach((l2) => l2(value));
    };
    this.value = _value;
    this.listeners = /* @__PURE__ */ new Set();
  }
};
__name(_Store, "Store");
let Store = _Store;
const SYMBOL_API_PRIVATE = Symbol("mui.api_private");
const isSyntheticEvent = /* @__PURE__ */ __name((event) => {
  return event.isPropagationStopped !== void 0;
}, "isSyntheticEvent");
let globalId = 0;
function createPrivateAPI(publicApiRef) {
  var _a2;
  const existingPrivateApi = (_a2 = publicApiRef.current) == null ? void 0 : _a2[SYMBOL_API_PRIVATE];
  if (existingPrivateApi) {
    return existingPrivateApi;
  }
  const state = {};
  const privateApi = {
    state,
    store: Store.create(state),
    instanceId: {
      id: globalId
    }
  };
  globalId += 1;
  privateApi.getPublicApi = () => publicApiRef.current;
  privateApi.register = (visibility, methods) => {
    Object.keys(methods).forEach((methodName) => {
      const method = methods[methodName];
      const currentPrivateMethod = privateApi[methodName];
      if ((currentPrivateMethod == null ? void 0 : currentPrivateMethod.spying) === true) {
        currentPrivateMethod.target = method;
      } else {
        privateApi[methodName] = method;
      }
      if (visibility === "public") {
        const publicApi = publicApiRef.current;
        const currentPublicMethod = publicApi[methodName];
        if ((currentPublicMethod == null ? void 0 : currentPublicMethod.spying) === true) {
          currentPublicMethod.target = method;
        } else {
          publicApi[methodName] = method;
        }
      }
    });
  };
  privateApi.register("private", {
    caches: {},
    eventManager: new EventManager()
  });
  return privateApi;
}
__name(createPrivateAPI, "createPrivateAPI");
function createPublicAPI(privateApiRef) {
  const publicApi = {
    get state() {
      return privateApiRef.current.state;
    },
    get store() {
      return privateApiRef.current.store;
    },
    get instanceId() {
      return privateApiRef.current.instanceId;
    },
    [SYMBOL_API_PRIVATE]: privateApiRef.current
  };
  return publicApi;
}
__name(createPublicAPI, "createPublicAPI");
function useGridApiInitialization(inputApiRef, props) {
  var _a2;
  const publicApiRef = reactExports.useRef();
  const privateApiRef = reactExports.useRef();
  if (!privateApiRef.current) {
    privateApiRef.current = createPrivateAPI(publicApiRef);
  }
  if (!publicApiRef.current) {
    publicApiRef.current = createPublicAPI(privateApiRef);
  }
  const publishEvent = reactExports.useCallback((...args) => {
    const [name, params, event = {}] = args;
    event.defaultMuiPrevented = false;
    if (isSyntheticEvent(event) && event.isPropagationStopped()) {
      return;
    }
    const details = props.signature === GridSignature.DataGridPro || props.signature === GridSignature.DataGridPremium ? {
      api: privateApiRef.current.getPublicApi()
    } : {};
    privateApiRef.current.eventManager.emit(name, params, event, details);
  }, [privateApiRef, props.signature]);
  const subscribeEvent = reactExports.useCallback((event, handler, options) => {
    privateApiRef.current.eventManager.on(event, handler, options);
    const api2 = privateApiRef.current;
    return () => {
      api2.eventManager.removeListener(event, handler);
    };
  }, [privateApiRef]);
  useGridApiMethod(privateApiRef, {
    subscribeEvent,
    publishEvent
  }, "public");
  if (inputApiRef && !((_a2 = inputApiRef.current) == null ? void 0 : _a2.state)) {
    inputApiRef.current = publicApiRef.current;
  }
  reactExports.useImperativeHandle(inputApiRef, () => publicApiRef.current, [publicApiRef]);
  reactExports.useEffect(() => {
    const api2 = privateApiRef.current;
    return () => {
      api2.publishEvent("unmount");
    };
  }, [privateApiRef]);
  return privateApiRef;
}
__name(useGridApiInitialization, "useGridApiInitialization");
const useGridLocaleText = /* @__PURE__ */ __name((apiRef, props) => {
  const getLocaleText = reactExports.useCallback((key) => {
    if (props.localeText[key] == null) {
      throw new Error(`Missing translation for key ${key}.`);
    }
    return props.localeText[key];
  }, [props.localeText]);
  apiRef.current.register("public", {
    getLocaleText
  });
}, "useGridLocaleText");
const useGridPipeProcessing = /* @__PURE__ */ __name((apiRef) => {
  const cache2 = reactExports.useRef({});
  const isRunning = reactExports.useRef(false);
  const runAppliers = reactExports.useCallback((groupCache) => {
    if (isRunning.current || !groupCache) {
      return;
    }
    isRunning.current = true;
    Object.values(groupCache.appliers).forEach((callback) => {
      callback();
    });
    isRunning.current = false;
  }, []);
  const registerPipeProcessor = reactExports.useCallback((group, id2, processor) => {
    if (!cache2.current[group]) {
      cache2.current[group] = {
        processors: /* @__PURE__ */ new Map(),
        processorsAsArray: [],
        appliers: {}
      };
    }
    const groupCache = cache2.current[group];
    const oldProcessor = groupCache.processors.get(id2);
    if (oldProcessor !== processor) {
      groupCache.processors.set(id2, processor);
      groupCache.processorsAsArray = Array.from(cache2.current[group].processors.values());
      runAppliers(groupCache);
    }
    return () => {
      cache2.current[group].processors.delete(id2);
      cache2.current[group].processorsAsArray = Array.from(cache2.current[group].processors.values());
    };
  }, [runAppliers]);
  const registerPipeApplier = reactExports.useCallback((group, id2, applier) => {
    if (!cache2.current[group]) {
      cache2.current[group] = {
        processors: /* @__PURE__ */ new Map(),
        processorsAsArray: [],
        appliers: {}
      };
    }
    cache2.current[group].appliers[id2] = applier;
    return () => {
      const _appliers = cache2.current[group].appliers, otherAppliers = _objectWithoutPropertiesLoose$1(_appliers, [id2].map(toPropertyKey));
      cache2.current[group].appliers = otherAppliers;
    };
  }, []);
  const requestPipeProcessorsApplication = reactExports.useCallback((group) => {
    runAppliers(cache2.current[group]);
  }, [runAppliers]);
  const applyPipeProcessors = reactExports.useCallback((...args) => {
    const [group, value, context] = args;
    if (!cache2.current[group]) {
      return value;
    }
    const processors = cache2.current[group].processorsAsArray;
    let result = value;
    for (let i = 0; i < processors.length; i += 1) {
      result = processors[i](result, context);
    }
    return result;
  }, []);
  const preProcessingPrivateApi = {
    registerPipeProcessor,
    registerPipeApplier,
    requestPipeProcessorsApplication
  };
  const preProcessingPublicApi = {
    unstable_applyPipeProcessors: applyPipeProcessors
  };
  useGridApiMethod(apiRef, preProcessingPrivateApi, "private");
  useGridApiMethod(apiRef, preProcessingPublicApi, "public");
}, "useGridPipeProcessing");
const useGridRegisterPipeProcessor = /* @__PURE__ */ __name((apiRef, group, callback) => {
  const cleanup = reactExports.useRef();
  const id2 = reactExports.useRef(`mui-${Math.round(Math.random() * 1e9)}`);
  const registerPreProcessor = reactExports.useCallback(() => {
    cleanup.current = apiRef.current.registerPipeProcessor(group, id2.current, callback);
  }, [apiRef, callback, group]);
  useFirstRender(() => {
    registerPreProcessor();
  });
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      registerPreProcessor();
    }
    return () => {
      if (cleanup.current) {
        cleanup.current();
        cleanup.current = null;
      }
    };
  }, [registerPreProcessor]);
}, "useGridRegisterPipeProcessor");
const useGridRegisterPipeApplier = /* @__PURE__ */ __name((apiRef, group, callback) => {
  const cleanup = reactExports.useRef();
  const id2 = reactExports.useRef(`mui-${Math.round(Math.random() * 1e9)}`);
  const registerPreProcessor = reactExports.useCallback(() => {
    cleanup.current = apiRef.current.registerPipeApplier(group, id2.current, callback);
  }, [apiRef, callback, group]);
  useFirstRender(() => {
    registerPreProcessor();
  });
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      registerPreProcessor();
    }
    return () => {
      if (cleanup.current) {
        cleanup.current();
        cleanup.current = null;
      }
    };
  }, [registerPreProcessor]);
}, "useGridRegisterPipeApplier");
const useGridRegisterStrategyProcessor = /* @__PURE__ */ __name((apiRef, strategyName, group, processor) => {
  const registerPreProcessor = reactExports.useCallback(() => {
    apiRef.current.registerStrategyProcessor(strategyName, group, processor);
  }, [apiRef, processor, group, strategyName]);
  useFirstRender(() => {
    registerPreProcessor();
  });
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      registerPreProcessor();
    }
  }, [registerPreProcessor]);
}, "useGridRegisterStrategyProcessor");
const GRID_DEFAULT_STRATEGY = "none";
const GRID_STRATEGIES_PROCESSORS = {
  rowTreeCreation: "rowTree",
  filtering: "rowTree",
  sorting: "rowTree",
  visibleRowsLookupCreation: "rowTree"
};
const useGridStrategyProcessing = /* @__PURE__ */ __name((apiRef) => {
  const availableStrategies = reactExports.useRef(/* @__PURE__ */ new Map());
  const strategiesCache = reactExports.useRef({});
  const registerStrategyProcessor = reactExports.useCallback((strategyName, processorName, processor) => {
    const cleanup = /* @__PURE__ */ __name(() => {
      const _ref = strategiesCache.current[processorName], otherProcessors = _objectWithoutPropertiesLoose$1(_ref, [strategyName].map(toPropertyKey));
      strategiesCache.current[processorName] = otherProcessors;
    }, "cleanup");
    if (!strategiesCache.current[processorName]) {
      strategiesCache.current[processorName] = {};
    }
    const groupPreProcessors = strategiesCache.current[processorName];
    const previousProcessor = groupPreProcessors[strategyName];
    groupPreProcessors[strategyName] = processor;
    if (!previousProcessor || previousProcessor === processor) {
      return cleanup;
    }
    if (strategyName === apiRef.current.getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName])) {
      apiRef.current.publishEvent("activeStrategyProcessorChange", processorName);
    }
    return cleanup;
  }, [apiRef]);
  const applyStrategyProcessor = reactExports.useCallback((processorName, params) => {
    const activeStrategy = apiRef.current.getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName]);
    if (activeStrategy == null) {
      throw new Error("Can't apply a strategy processor before defining an active strategy");
    }
    const groupCache = strategiesCache.current[processorName];
    if (!groupCache || !groupCache[activeStrategy]) {
      throw new Error(`No processor found for processor "${processorName}" on strategy "${activeStrategy}"`);
    }
    const processor = groupCache[activeStrategy];
    return processor(params);
  }, [apiRef]);
  const getActiveStrategy = reactExports.useCallback((strategyGroup) => {
    const strategyEntries = Array.from(availableStrategies.current.entries());
    const availableStrategyEntry = strategyEntries.find(([, strategy]) => {
      if (strategy.group !== strategyGroup) {
        return false;
      }
      return strategy.isAvailable();
    });
    return (availableStrategyEntry == null ? void 0 : availableStrategyEntry[0]) ?? GRID_DEFAULT_STRATEGY;
  }, []);
  const setStrategyAvailability = reactExports.useCallback((strategyGroup, strategyName, isAvailable) => {
    availableStrategies.current.set(strategyName, {
      group: strategyGroup,
      isAvailable
    });
    apiRef.current.publishEvent("strategyAvailabilityChange");
  }, [apiRef]);
  const strategyProcessingApi = {
    registerStrategyProcessor,
    applyStrategyProcessor,
    getActiveStrategy,
    setStrategyAvailability
  };
  useGridApiMethod(apiRef, strategyProcessingApi, "private");
}, "useGridStrategyProcessing");
const useGridStateInitialization = /* @__PURE__ */ __name((apiRef) => {
  const controlStateMapRef = reactExports.useRef({});
  const [, rawForceUpdate] = reactExports.useState();
  const registerControlState = reactExports.useCallback((controlStateItem) => {
    controlStateMapRef.current[controlStateItem.stateId] = controlStateItem;
  }, []);
  const setState = reactExports.useCallback((state, reason) => {
    let newState;
    if (isFunction$1(state)) {
      newState = state(apiRef.current.state);
    } else {
      newState = state;
    }
    if (apiRef.current.state === newState) {
      return false;
    }
    let ignoreSetState = false;
    const updatedControlStateIds = [];
    Object.keys(controlStateMapRef.current).forEach((stateId) => {
      const controlState = controlStateMapRef.current[stateId];
      const oldSubState = controlState.stateSelector(apiRef.current.state, apiRef.current.instanceId);
      const newSubState = controlState.stateSelector(newState, apiRef.current.instanceId);
      if (newSubState === oldSubState) {
        return;
      }
      updatedControlStateIds.push({
        stateId: controlState.stateId,
        hasPropChanged: newSubState !== controlState.propModel
      });
      if (controlState.propModel !== void 0 && newSubState !== controlState.propModel) {
        ignoreSetState = true;
      }
    });
    if (updatedControlStateIds.length > 1) {
      throw new Error(`You're not allowed to update several sub-state in one transaction. You already updated ${updatedControlStateIds[0].stateId}, therefore, you're not allowed to update ${updatedControlStateIds.map((el2) => el2.stateId).join(", ")} in the same transaction.`);
    }
    if (!ignoreSetState) {
      apiRef.current.state = newState;
      apiRef.current.publishEvent("stateChange", newState);
      apiRef.current.store.update(newState);
    }
    if (updatedControlStateIds.length === 1) {
      const {
        stateId,
        hasPropChanged
      } = updatedControlStateIds[0];
      const controlState = controlStateMapRef.current[stateId];
      const model = controlState.stateSelector(newState, apiRef.current.instanceId);
      if (controlState.propOnChange && hasPropChanged) {
        controlState.propOnChange(model, {
          reason,
          api: apiRef.current
        });
      }
      if (!ignoreSetState) {
        apiRef.current.publishEvent(controlState.changeEvent, model, {
          reason
        });
      }
    }
    return !ignoreSetState;
  }, [apiRef]);
  const updateControlState = reactExports.useCallback((key, state, reason) => {
    return apiRef.current.setState((previousState) => {
      return _extends$4({}, previousState, {
        [key]: state(previousState[key])
      });
    }, reason);
  }, [apiRef]);
  const forceUpdate = reactExports.useCallback(() => rawForceUpdate(() => apiRef.current.state), [apiRef]);
  const publicStateApi = {
    setState,
    forceUpdate
  };
  const privateStateApi = {
    updateControlState,
    registerControlState
  };
  useGridApiMethod(apiRef, publicStateApi, "public");
  useGridApiMethod(apiRef, privateStateApi, "private");
}, "useGridStateInitialization");
const useGridInitialization = /* @__PURE__ */ __name((inputApiRef, props) => {
  const privateApiRef = useGridApiInitialization(inputApiRef, props);
  useGridRefs(privateApiRef);
  useGridIsRtl(privateApiRef);
  useGridLoggerFactory(privateApiRef, props);
  useGridStateInitialization(privateApiRef);
  useGridPipeProcessing(privateApiRef);
  useGridStrategyProcessing(privateApiRef);
  useGridLocaleText(privateApiRef, props);
  privateApiRef.current.register("private", {
    rootProps: props
  });
  return privateApiRef;
}, "useGridInitialization");
const useGridInitializeState = /* @__PURE__ */ __name((initializer, privateApiRef, props) => {
  const isInitialized = reactExports.useRef(false);
  if (!isInitialized.current) {
    privateApiRef.current.state = initializer(privateApiRef.current.state, props, privateApiRef);
    isInitialized.current = true;
  }
}, "useGridInitializeState");
function sanitizeCellValue(value, csvOptions) {
  if (value === null || value === void 0) {
    return "";
  }
  const valueStr = typeof value === "string" ? value : `${value}`;
  if (csvOptions.shouldAppendQuotes || csvOptions.escapeFormulas) {
    const escapedValue = valueStr.replace(/"/g, '""');
    if (csvOptions.escapeFormulas) {
      if (["=", "+", "-", "@", "	", "\r"].includes(escapedValue[0])) {
        return `"'${escapedValue}"`;
      }
    }
    if ([csvOptions.delimiter, "\n", "\r", '"'].some((delimiter2) => valueStr.includes(delimiter2))) {
      return `"${escapedValue}"`;
    }
    return escapedValue;
  }
  return valueStr;
}
__name(sanitizeCellValue, "sanitizeCellValue");
const serializeCellValue = /* @__PURE__ */ __name((cellParams, options) => {
  var _a2, _b2;
  const {
    csvOptions,
    ignoreValueFormatter
  } = options;
  let value;
  if (ignoreValueFormatter) {
    const columnType = cellParams.colDef.type;
    if (columnType === "number") {
      value = String(cellParams.value);
    } else if (columnType === "date" || columnType === "dateTime") {
      value = (_a2 = cellParams.value) == null ? void 0 : _a2.toISOString();
    } else if (typeof ((_b2 = cellParams.value) == null ? void 0 : _b2.toString) === "function") {
      value = cellParams.value.toString();
    } else {
      value = cellParams.value;
    }
  } else {
    value = cellParams.formattedValue;
  }
  return sanitizeCellValue(value, csvOptions);
}, "serializeCellValue");
const _CSVRow = class _CSVRow {
  constructor(options) {
    this.options = void 0;
    this.rowString = "";
    this.isEmpty = true;
    this.options = options;
  }
  addValue(value) {
    if (!this.isEmpty) {
      this.rowString += this.options.csvOptions.delimiter;
    }
    if (typeof this.options.sanitizeCellValue === "function") {
      this.rowString += this.options.sanitizeCellValue(value, this.options.csvOptions);
    } else {
      this.rowString += value;
    }
    this.isEmpty = false;
  }
  getRowString() {
    return this.rowString;
  }
};
__name(_CSVRow, "CSVRow");
let CSVRow = _CSVRow;
const serializeRow = /* @__PURE__ */ __name(({
  id: id2,
  columns: columns2,
  getCellParams,
  csvOptions,
  ignoreValueFormatter
}) => {
  const row = new CSVRow({
    csvOptions
  });
  columns2.forEach((column2) => {
    const cellParams = getCellParams(id2, column2.field);
    row.addValue(serializeCellValue(cellParams, {
      ignoreValueFormatter,
      csvOptions
    }));
  });
  return row.getRowString();
}, "serializeRow");
function buildCSV(options) {
  const {
    columns: columns2,
    rowIds,
    csvOptions,
    ignoreValueFormatter,
    apiRef
  } = options;
  const CSVBody = rowIds.reduce((acc, id2) => `${acc}${serializeRow({
    id: id2,
    columns: columns2,
    getCellParams: apiRef.current.getCellParams,
    ignoreValueFormatter,
    csvOptions
  })}\r
`, "").trim();
  if (!csvOptions.includeHeaders) {
    return CSVBody;
  }
  const filteredColumns = columns2.filter((column2) => column2.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field);
  const headerRows = [];
  if (csvOptions.includeColumnGroupsHeaders) {
    const columnGroupLookup = apiRef.current.getAllGroupDetails();
    let maxColumnGroupsDepth = 0;
    const columnGroupPathsLookup = filteredColumns.reduce((acc, column2) => {
      const columnGroupPath = apiRef.current.getColumnGroupPath(column2.field);
      acc[column2.field] = columnGroupPath;
      maxColumnGroupsDepth = Math.max(maxColumnGroupsDepth, columnGroupPath.length);
      return acc;
    }, {});
    for (let i = 0; i < maxColumnGroupsDepth; i += 1) {
      const headerGroupRow = new CSVRow({
        csvOptions,
        sanitizeCellValue
      });
      headerRows.push(headerGroupRow);
      filteredColumns.forEach((column2) => {
        const columnGroupId = (columnGroupPathsLookup[column2.field] || [])[i];
        const columnGroup = columnGroupLookup[columnGroupId];
        headerGroupRow.addValue(columnGroup ? columnGroup.headerName || columnGroup.groupId : "");
      });
    }
  }
  const mainHeaderRow = new CSVRow({
    csvOptions,
    sanitizeCellValue
  });
  filteredColumns.forEach((column2) => {
    mainHeaderRow.addValue(column2.headerName || column2.field);
  });
  headerRows.push(mainHeaderRow);
  const CSVHead = `${headerRows.map((row) => row.getRowString()).join("\r\n")}\r
`;
  return `${CSVHead}${CSVBody}`.trim();
}
__name(buildCSV, "buildCSV");
function writeToClipboardPolyfill(data) {
  const span = document.createElement("span");
  span.style.whiteSpace = "pre";
  span.style.userSelect = "all";
  span.style.opacity = "0px";
  span.textContent = data;
  document.body.appendChild(span);
  const range2 = document.createRange();
  range2.selectNode(span);
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range2);
  try {
    document.execCommand("copy");
  } finally {
    document.body.removeChild(span);
  }
}
__name(writeToClipboardPolyfill, "writeToClipboardPolyfill");
function copyToClipboard(data) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(data).catch(() => {
      writeToClipboardPolyfill(data);
    });
  } else {
    writeToClipboardPolyfill(data);
  }
}
__name(copyToClipboard, "copyToClipboard");
function hasNativeSelection(element) {
  var _a2;
  if ((_a2 = window.getSelection()) == null ? void 0 : _a2.toString()) {
    return true;
  }
  if (element && (element.selectionEnd || 0) - (element.selectionStart || 0) > 0) {
    return true;
  }
  return false;
}
__name(hasNativeSelection, "hasNativeSelection");
const useGridClipboard = /* @__PURE__ */ __name((apiRef, props) => {
  const ignoreValueFormatterProp = props.ignoreValueFormatterDuringExport;
  const ignoreValueFormatter = (typeof ignoreValueFormatterProp === "object" ? ignoreValueFormatterProp == null ? void 0 : ignoreValueFormatterProp.clipboardExport : ignoreValueFormatterProp) || false;
  const clipboardCopyCellDelimiter = props.clipboardCopyCellDelimiter;
  const handleCopy = reactExports.useCallback((event) => {
    if (!isCopyShortcut(event)) {
      return;
    }
    if (hasNativeSelection(event.target)) {
      return;
    }
    let textToCopy = "";
    const selectedRows = apiRef.current.getSelectedRows();
    if (selectedRows.size > 0) {
      textToCopy = apiRef.current.getDataAsCsv({
        includeHeaders: false,
        delimiter: clipboardCopyCellDelimiter,
        shouldAppendQuotes: false,
        escapeFormulas: false
      });
    } else {
      const focusedCell = gridFocusCellSelector(apiRef);
      if (focusedCell) {
        const cellParams = apiRef.current.getCellParams(focusedCell.id, focusedCell.field);
        textToCopy = serializeCellValue(cellParams, {
          csvOptions: {
            delimiter: clipboardCopyCellDelimiter,
            shouldAppendQuotes: false,
            escapeFormulas: false
          },
          ignoreValueFormatter
        });
      }
    }
    textToCopy = apiRef.current.unstable_applyPipeProcessors("clipboardCopy", textToCopy);
    if (textToCopy) {
      copyToClipboard(textToCopy);
      apiRef.current.publishEvent("clipboardCopy", textToCopy);
    }
  }, [apiRef, ignoreValueFormatter, clipboardCopyCellDelimiter]);
  useGridNativeEventListener(apiRef, apiRef.current.rootElementRef, "keydown", handleCopy);
  useGridApiOptionHandler(apiRef, "clipboardCopy", props.onClipboardCopy);
}, "useGridClipboard");
const columnMenuStateInitializer = /* @__PURE__ */ __name((state) => _extends$4({}, state, {
  columnMenu: {
    open: false
  }
}), "columnMenuStateInitializer");
const useGridColumnMenu = /* @__PURE__ */ __name((apiRef) => {
  const logger = useGridLogger(apiRef, "useGridColumnMenu");
  const showColumnMenu = reactExports.useCallback((field) => {
    const columnMenuState = gridColumnMenuSelector(apiRef.current.state);
    const newState = {
      open: true,
      field
    };
    const shouldUpdate = newState.open !== columnMenuState.open || newState.field !== columnMenuState.field;
    if (shouldUpdate) {
      apiRef.current.setState((state) => {
        if (state.columnMenu.open && state.columnMenu.field === field) {
          return state;
        }
        logger.debug("Opening Column Menu");
        return _extends$4({}, state, {
          columnMenu: {
            open: true,
            field
          }
        });
      });
      apiRef.current.hidePreferences();
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger]);
  const hideColumnMenu = reactExports.useCallback(() => {
    const columnMenuState = gridColumnMenuSelector(apiRef.current.state);
    if (columnMenuState.field) {
      const columnLookup = gridColumnLookupSelector(apiRef);
      const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef);
      const orderedFields = gridColumnFieldsSelector(apiRef);
      let fieldToFocus = columnMenuState.field;
      if (!columnLookup[fieldToFocus]) {
        fieldToFocus = orderedFields[0];
      }
      if (columnVisibilityModel[fieldToFocus] === false) {
        const visibleOrderedFields = orderedFields.filter((field) => {
          if (field === fieldToFocus) {
            return true;
          }
          return columnVisibilityModel[field] !== false;
        });
        const fieldIndex = visibleOrderedFields.indexOf(fieldToFocus);
        fieldToFocus = visibleOrderedFields[fieldIndex + 1] || visibleOrderedFields[fieldIndex - 1];
      }
      apiRef.current.setColumnHeaderFocus(fieldToFocus);
    }
    const newState = {
      open: false,
      field: void 0
    };
    const shouldUpdate = newState.open !== columnMenuState.open || newState.field !== columnMenuState.field;
    if (shouldUpdate) {
      apiRef.current.setState((state) => {
        logger.debug("Hiding Column Menu");
        return _extends$4({}, state, {
          columnMenu: newState
        });
      });
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger]);
  const toggleColumnMenu = reactExports.useCallback((field) => {
    logger.debug("Toggle Column Menu");
    const columnMenu = gridColumnMenuSelector(apiRef.current.state);
    if (!columnMenu.open || columnMenu.field !== field) {
      showColumnMenu(field);
    } else {
      hideColumnMenu();
    }
  }, [apiRef, logger, showColumnMenu, hideColumnMenu]);
  const columnMenuApi = {
    showColumnMenu,
    hideColumnMenu,
    toggleColumnMenu
  };
  useGridApiMethod(apiRef, columnMenuApi, "public");
  useGridApiEventHandler(apiRef, "columnResizeStart", hideColumnMenu);
  useGridApiEventHandler(apiRef, "virtualScrollerWheel", apiRef.current.hideColumnMenu);
  useGridApiEventHandler(apiRef, "virtualScrollerTouchMove", apiRef.current.hideColumnMenu);
}, "useGridColumnMenu");
const columnsStateInitializer = /* @__PURE__ */ __name((state, props, apiRef) => {
  var _a2, _b2, _c2;
  const columnsState = createColumnsState({
    apiRef,
    columnsToUpsert: props.columns,
    initialState: (_a2 = props.initialState) == null ? void 0 : _a2.columns,
    columnVisibilityModel: props.columnVisibilityModel ?? ((_c2 = (_b2 = props.initialState) == null ? void 0 : _b2.columns) == null ? void 0 : _c2.columnVisibilityModel) ?? {},
    keepOnlyColumnsToUpsert: true
  });
  return _extends$4({}, state, {
    columns: columnsState,
    // In pro/premium, this part of the state is defined. We give it an empty but defined value
    // for the community version.
    pinnedColumns: state.pinnedColumns ?? EMPTY_PINNED_COLUMN_FIELDS
  });
}, "columnsStateInitializer");
function useGridColumns(apiRef, props) {
  var _a2, _b2;
  const logger = useGridLogger(apiRef, "useGridColumns");
  const previousColumnsProp = reactExports.useRef(props.columns);
  apiRef.current.registerControlState({
    stateId: "visibleColumns",
    propModel: props.columnVisibilityModel,
    propOnChange: props.onColumnVisibilityModelChange,
    stateSelector: gridColumnVisibilityModelSelector,
    changeEvent: "columnVisibilityModelChange"
  });
  const setGridColumnsState = reactExports.useCallback((columnsState) => {
    var _a3, _b3;
    logger.debug("Updating columns state.");
    apiRef.current.setState(mergeColumnsState(columnsState));
    apiRef.current.publishEvent("columnsChange", columnsState.orderedFields);
    (_b3 = (_a3 = apiRef.current).updateRenderContext) == null ? void 0 : _b3.call(_a3);
    apiRef.current.forceUpdate();
  }, [logger, apiRef]);
  const getColumn = reactExports.useCallback((field) => gridColumnLookupSelector(apiRef)[field], [apiRef]);
  const getAllColumns = reactExports.useCallback(() => gridColumnDefinitionsSelector(apiRef), [apiRef]);
  const getVisibleColumns = reactExports.useCallback(() => gridVisibleColumnDefinitionsSelector(apiRef), [apiRef]);
  const getColumnIndex = reactExports.useCallback((field, useVisibleColumns = true) => {
    const columns2 = useVisibleColumns ? gridVisibleColumnDefinitionsSelector(apiRef) : gridColumnDefinitionsSelector(apiRef);
    return columns2.findIndex((col) => col.field === field);
  }, [apiRef]);
  const getColumnPosition = reactExports.useCallback((field) => {
    const index2 = getColumnIndex(field);
    return gridColumnPositionsSelector(apiRef)[index2];
  }, [apiRef, getColumnIndex]);
  const setColumnVisibilityModel = reactExports.useCallback((model) => {
    var _a3, _b3;
    const currentModel = gridColumnVisibilityModelSelector(apiRef);
    if (currentModel !== model) {
      apiRef.current.setState((state) => _extends$4({}, state, {
        columns: createColumnsState({
          apiRef,
          columnsToUpsert: [],
          initialState: void 0,
          columnVisibilityModel: model,
          keepOnlyColumnsToUpsert: false
        })
      }));
      (_b3 = (_a3 = apiRef.current).updateRenderContext) == null ? void 0 : _b3.call(_a3);
      apiRef.current.forceUpdate();
    }
  }, [apiRef]);
  const updateColumns = reactExports.useCallback((columns2) => {
    const columnsState = createColumnsState({
      apiRef,
      columnsToUpsert: columns2,
      initialState: void 0,
      keepOnlyColumnsToUpsert: false
    });
    setGridColumnsState(columnsState);
  }, [apiRef, setGridColumnsState]);
  const setColumnVisibility = reactExports.useCallback((field, isVisible) => {
    const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef);
    const isCurrentlyVisible = columnVisibilityModel[field] ?? true;
    if (isVisible !== isCurrentlyVisible) {
      const newModel = _extends$4({}, columnVisibilityModel, {
        [field]: isVisible
      });
      apiRef.current.setColumnVisibilityModel(newModel);
    }
  }, [apiRef]);
  const getColumnIndexRelativeToVisibleColumns = reactExports.useCallback((field) => {
    const allColumns = gridColumnFieldsSelector(apiRef);
    return allColumns.findIndex((col) => col === field);
  }, [apiRef]);
  const setColumnIndex = reactExports.useCallback((field, targetIndexPosition) => {
    const allColumns = gridColumnFieldsSelector(apiRef);
    const oldIndexPosition = getColumnIndexRelativeToVisibleColumns(field);
    if (oldIndexPosition === targetIndexPosition) {
      return;
    }
    logger.debug(`Moving column ${field} to index ${targetIndexPosition}`);
    const updatedColumns = [...allColumns];
    const fieldRemoved = updatedColumns.splice(oldIndexPosition, 1)[0];
    updatedColumns.splice(targetIndexPosition, 0, fieldRemoved);
    setGridColumnsState(_extends$4({}, gridColumnsStateSelector(apiRef.current.state), {
      orderedFields: updatedColumns
    }));
    const params = {
      column: apiRef.current.getColumn(field),
      targetIndex: apiRef.current.getColumnIndexRelativeToVisibleColumns(field),
      oldIndex: oldIndexPosition
    };
    apiRef.current.publishEvent("columnIndexChange", params);
  }, [apiRef, logger, setGridColumnsState, getColumnIndexRelativeToVisibleColumns]);
  const setColumnWidth = reactExports.useCallback((field, width2) => {
    logger.debug(`Updating column ${field} width to ${width2}`);
    const columnsState = gridColumnsStateSelector(apiRef.current.state);
    const column2 = columnsState.lookup[field];
    const newColumn = _extends$4({}, column2, {
      width: width2,
      hasBeenResized: true
    });
    setGridColumnsState(hydrateColumnsWidth(_extends$4({}, columnsState, {
      lookup: _extends$4({}, columnsState.lookup, {
        [field]: newColumn
      })
    }), apiRef.current.getRootDimensions()));
    apiRef.current.publishEvent("columnWidthChange", {
      element: apiRef.current.getColumnHeaderElement(field),
      colDef: newColumn,
      width: width2
    });
  }, [apiRef, logger, setGridColumnsState]);
  const columnApi = {
    getColumn,
    getAllColumns,
    getColumnIndex,
    getColumnPosition,
    getVisibleColumns,
    getColumnIndexRelativeToVisibleColumns,
    updateColumns,
    setColumnVisibilityModel,
    setColumnVisibility,
    setColumnWidth
  };
  const columnReorderApi = {
    setColumnIndex
  };
  useGridApiMethod(apiRef, columnApi, "public");
  useGridApiMethod(apiRef, columnReorderApi, props.signature === GridSignature.DataGrid ? "private" : "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _a3, _b3;
    const columnsStateToExport = {};
    const columnVisibilityModelToExport = gridColumnVisibilityModelSelector(apiRef);
    const shouldExportColumnVisibilityModel = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the model is controlled
      props.columnVisibilityModel != null || // Always export if the model has been initialized
      // TODO v6 Do a nullish check instead to export even if the initial model equals "{}"
      Object.keys(((_b3 = (_a3 = props.initialState) == null ? void 0 : _a3.columns) == null ? void 0 : _b3.columnVisibilityModel) ?? {}).length > 0 || // Always export if the model is not empty
      Object.keys(columnVisibilityModelToExport).length > 0
    );
    if (shouldExportColumnVisibilityModel) {
      columnsStateToExport.columnVisibilityModel = columnVisibilityModelToExport;
    }
    columnsStateToExport.orderedFields = gridColumnFieldsSelector(apiRef);
    const columns2 = gridColumnDefinitionsSelector(apiRef);
    const dimensions = {};
    columns2.forEach((colDef) => {
      if (colDef.hasBeenResized) {
        const colDefDimensions = {};
        COLUMNS_DIMENSION_PROPERTIES.forEach((propertyName) => {
          let propertyValue = colDef[propertyName];
          if (propertyValue === Infinity) {
            propertyValue = -1;
          }
          colDefDimensions[propertyName] = propertyValue;
        });
        dimensions[colDef.field] = colDefDimensions;
      }
    });
    if (Object.keys(dimensions).length > 0) {
      columnsStateToExport.dimensions = dimensions;
    }
    return _extends$4({}, prevState, {
      columns: columnsStateToExport
    });
  }, [apiRef, props.columnVisibilityModel, (_a2 = props.initialState) == null ? void 0 : _a2.columns]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _a3;
    const columnVisibilityModelToImport = (_a3 = context.stateToRestore.columns) == null ? void 0 : _a3.columnVisibilityModel;
    const initialState2 = context.stateToRestore.columns;
    if (columnVisibilityModelToImport == null && initialState2 == null) {
      return params;
    }
    const columnsState = createColumnsState({
      apiRef,
      columnsToUpsert: [],
      initialState: initialState2,
      columnVisibilityModel: columnVisibilityModelToImport,
      keepOnlyColumnsToUpsert: false
    });
    apiRef.current.setState(mergeColumnsState(columnsState));
    if (initialState2 != null) {
      apiRef.current.publishEvent("columnsChange", columnsState.orderedFields);
    }
    return params;
  }, [apiRef]);
  const preferencePanelPreProcessing = reactExports.useCallback((initialValue, value) => {
    var _a3;
    if (value === GridPreferencePanelsValue.columns) {
      const ColumnsPanel = props.slots.columnsPanel;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnsPanel, _extends$4({}, (_a3 = props.slotProps) == null ? void 0 : _a3.columnsPanel));
    }
    return initialValue;
  }, [props.slots.columnsPanel, (_b2 = props.slotProps) == null ? void 0 : _b2.columnsPanel]);
  const addColumnMenuItems = reactExports.useCallback((columnMenuItems) => {
    if (props.disableColumnSelector) {
      return columnMenuItems;
    }
    return [...columnMenuItems, "columnMenuColumnsItem"];
  }, [props.disableColumnSelector]);
  useGridRegisterPipeProcessor(apiRef, "columnMenu", addColumnMenuItems);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  useGridRegisterPipeProcessor(apiRef, "preferencePanel", preferencePanelPreProcessing);
  const prevInnerWidth = reactExports.useRef(null);
  const handleGridSizeChange = /* @__PURE__ */ __name((viewportInnerSize) => {
    if (prevInnerWidth.current !== viewportInnerSize.width) {
      prevInnerWidth.current = viewportInnerSize.width;
      setGridColumnsState(hydrateColumnsWidth(gridColumnsStateSelector(apiRef.current.state), apiRef.current.getRootDimensions()));
    }
  }, "handleGridSizeChange");
  useGridApiEventHandler(apiRef, "viewportInnerSizeChange", handleGridSizeChange);
  const hydrateColumns = reactExports.useCallback(() => {
    logger.info(`Columns pipe processing have changed, regenerating the columns`);
    const columnsState = createColumnsState({
      apiRef,
      columnsToUpsert: [],
      initialState: void 0,
      keepOnlyColumnsToUpsert: false
    });
    setGridColumnsState(columnsState);
  }, [apiRef, logger, setGridColumnsState]);
  useGridRegisterPipeApplier(apiRef, "hydrateColumns", hydrateColumns);
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    logger.info(`GridColumns have changed, new length ${props.columns.length}`);
    if (previousColumnsProp.current === props.columns) {
      return;
    }
    const columnsState = createColumnsState({
      apiRef,
      initialState: void 0,
      // If the user provides a model, we don't want to set it in the state here because it has it's dedicated `useEffect` which calls `setColumnVisibilityModel`
      columnsToUpsert: props.columns,
      keepOnlyColumnsToUpsert: true
    });
    previousColumnsProp.current = props.columns;
    setGridColumnsState(columnsState);
  }, [logger, apiRef, setGridColumnsState, props.columns]);
  reactExports.useEffect(() => {
    if (props.columnVisibilityModel !== void 0) {
      apiRef.current.setColumnVisibilityModel(props.columnVisibilityModel);
    }
  }, [apiRef, logger, props.columnVisibilityModel]);
}
__name(useGridColumns, "useGridColumns");
function mergeColumnsState(columnsState) {
  return (state) => _extends$4({}, state, {
    columns: columnsState
  });
}
__name(mergeColumnsState, "mergeColumnsState");
const densityStateInitializer = /* @__PURE__ */ __name((state, props) => {
  var _a2;
  return _extends$4({}, state, {
    density: ((_a2 = props.initialState) == null ? void 0 : _a2.density) ?? props.density ?? "standard"
  });
}, "densityStateInitializer");
const useGridDensity = /* @__PURE__ */ __name((apiRef, props) => {
  var _a2;
  const logger = useGridLogger(apiRef, "useDensity");
  apiRef.current.registerControlState({
    stateId: "density",
    propModel: props.density,
    propOnChange: props.onDensityChange,
    stateSelector: gridDensitySelector,
    changeEvent: "densityChange"
  });
  const setDensity = useEventCallback((newDensity) => {
    const currentDensity = gridDensitySelector(apiRef.current.state);
    if (currentDensity === newDensity) {
      return;
    }
    logger.debug(`Set grid density to ${newDensity}`);
    apiRef.current.setState((state) => _extends$4({}, state, {
      density: newDensity
    }));
  });
  const densityApi = {
    setDensity
  };
  useGridApiMethod(apiRef, densityApi, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _a3;
    const exportedDensity = gridDensitySelector(apiRef.current.state);
    const shouldExportRowCount = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the `density` is controlled
      props.density != null || // Always export if the `density` has been initialized
      ((_a3 = props.initialState) == null ? void 0 : _a3.density) != null
    );
    if (!shouldExportRowCount) {
      return prevState;
    }
    return _extends$4({}, prevState, {
      density: exportedDensity
    });
  }, [apiRef, props.density, (_a2 = props.initialState) == null ? void 0 : _a2.density]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _a3;
    const restoredDensity = ((_a3 = context.stateToRestore) == null ? void 0 : _a3.density) ? context.stateToRestore.density : gridDensitySelector(apiRef.current.state);
    apiRef.current.setState((state) => _extends$4({}, state, {
      density: restoredDensity
    }));
    return params;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  reactExports.useEffect(() => {
    if (props.density) {
      apiRef.current.setDensity(props.density);
    }
  }, [apiRef, props.density]);
}, "useGridDensity");
function exportAs(blob, extension = "csv", filename = document.title || "untitled") {
  const fullName = `${filename}.${extension}`;
  if ("download" in HTMLAnchorElement.prototype) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = fullName;
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
    });
    return;
  }
  throw new Error("MUI X: exportAs not supported.");
}
__name(exportAs, "exportAs");
const getColumnsToExport = /* @__PURE__ */ __name(({
  apiRef,
  options
}) => {
  const columns2 = gridColumnDefinitionsSelector(apiRef);
  if (options.fields) {
    return options.fields.reduce((currentColumns, field) => {
      const column2 = columns2.find((col) => col.field === field);
      if (column2) {
        currentColumns.push(column2);
      }
      return currentColumns;
    }, []);
  }
  const validColumns = options.allColumns ? columns2 : gridVisibleColumnDefinitionsSelector(apiRef);
  return validColumns.filter((column2) => !column2.disableExport);
}, "getColumnsToExport");
const defaultGetRowsToExport = /* @__PURE__ */ __name(({
  apiRef
}) => {
  var _a2, _b2;
  const filteredSortedRowIds = gridFilteredSortedRowIdsSelector(apiRef);
  const rowTree = gridRowTreeSelector(apiRef);
  const selectedRows = apiRef.current.getSelectedRows();
  const bodyRows = filteredSortedRowIds.filter((id2) => rowTree[id2].type !== "footer");
  const pinnedRows = gridPinnedRowsSelector(apiRef);
  const topPinnedRowsIds = ((_a2 = pinnedRows == null ? void 0 : pinnedRows.top) == null ? void 0 : _a2.map((row) => row.id)) || [];
  const bottomPinnedRowsIds = ((_b2 = pinnedRows == null ? void 0 : pinnedRows.bottom) == null ? void 0 : _b2.map((row) => row.id)) || [];
  bodyRows.unshift(...topPinnedRowsIds);
  bodyRows.push(...bottomPinnedRowsIds);
  if (selectedRows.size > 0) {
    return bodyRows.filter((id2) => selectedRows.has(id2));
  }
  return bodyRows;
}, "defaultGetRowsToExport");
const useGridCsvExport = /* @__PURE__ */ __name((apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridCsvExport");
  const ignoreValueFormatterProp = props.ignoreValueFormatterDuringExport;
  const ignoreValueFormatter = (typeof ignoreValueFormatterProp === "object" ? ignoreValueFormatterProp == null ? void 0 : ignoreValueFormatterProp.csvExport : ignoreValueFormatterProp) || false;
  const getDataAsCsv = reactExports.useCallback((options = {}) => {
    logger.debug(`Get data as CSV`);
    const exportedColumns = getColumnsToExport({
      apiRef,
      options
    });
    const getRowsToExport = options.getRowsToExport ?? defaultGetRowsToExport;
    const exportedRowIds = getRowsToExport({
      apiRef
    });
    return buildCSV({
      columns: exportedColumns,
      rowIds: exportedRowIds,
      csvOptions: {
        delimiter: options.delimiter || ",",
        shouldAppendQuotes: options.shouldAppendQuotes ?? true,
        includeHeaders: options.includeHeaders ?? true,
        includeColumnGroupsHeaders: options.includeColumnGroupsHeaders ?? true,
        escapeFormulas: options.escapeFormulas ?? true
      },
      ignoreValueFormatter,
      apiRef
    });
  }, [logger, apiRef, ignoreValueFormatter]);
  const exportDataAsCsv = reactExports.useCallback((options) => {
    logger.debug(`Export data as CSV`);
    const csv = getDataAsCsv(options);
    const blob = new Blob([(options == null ? void 0 : options.utf8WithBom) ? new Uint8Array([239, 187, 191]) : "", csv], {
      type: "text/csv"
    });
    exportAs(blob, "csv", options == null ? void 0 : options.fileName);
  }, [logger, getDataAsCsv]);
  const csvExportApi = {
    getDataAsCsv,
    exportDataAsCsv
  };
  useGridApiMethod(apiRef, csvExportApi, "public");
  const addExportMenuButtons = reactExports.useCallback((initialValue, options) => {
    var _a2;
    if ((_a2 = options.csvOptions) == null ? void 0 : _a2.disableToolbarButton) {
      return initialValue;
    }
    return [...initialValue, {
      component: /* @__PURE__ */ jsxRuntimeExports.jsx(GridCsvExportMenuItem, {
        options: options.csvOptions
      }),
      componentName: "csvExport"
    }];
  }, []);
  useGridRegisterPipeProcessor(apiRef, "exportMenu", addExportMenuButtons);
}, "useGridCsvExport");
const getDerivedPaginationModel = /* @__PURE__ */ __name((paginationState, signature, paginationModelProp) => {
  let paginationModel = paginationState.paginationModel;
  const rowCount = paginationState.rowCount;
  const pageSize2 = (paginationModelProp == null ? void 0 : paginationModelProp.pageSize) ?? paginationModel.pageSize;
  const page = (paginationModelProp == null ? void 0 : paginationModelProp.page) ?? paginationModel.page;
  const pageCount = getPageCount(rowCount, pageSize2, page);
  if (paginationModelProp && ((paginationModelProp == null ? void 0 : paginationModelProp.page) !== paginationModel.page || (paginationModelProp == null ? void 0 : paginationModelProp.pageSize) !== paginationModel.pageSize)) {
    paginationModel = paginationModelProp;
  }
  const validPage = getValidPage(paginationModel.page, pageCount);
  if (validPage !== paginationModel.page) {
    paginationModel = _extends$4({}, paginationModel, {
      page: validPage
    });
  }
  throwIfPageSizeExceedsTheLimit(paginationModel.pageSize, signature);
  return paginationModel;
}, "getDerivedPaginationModel");
const useGridPaginationModel = /* @__PURE__ */ __name((apiRef, props) => {
  var _a2, _b2;
  const logger = useGridLogger(apiRef, "useGridPaginationModel");
  const densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);
  const rowHeight = Math.floor(props.rowHeight * densityFactor);
  apiRef.current.registerControlState({
    stateId: "paginationModel",
    propModel: props.paginationModel,
    propOnChange: props.onPaginationModelChange,
    stateSelector: gridPaginationModelSelector,
    changeEvent: "paginationModelChange"
  });
  const setPage = reactExports.useCallback((page) => {
    const currentModel = gridPaginationModelSelector(apiRef);
    if (page === currentModel.page) {
      return;
    }
    logger.debug(`Setting page to ${page}`);
    apiRef.current.setPaginationModel({
      page,
      pageSize: currentModel.pageSize
    });
  }, [apiRef, logger]);
  const setPageSize = reactExports.useCallback((pageSize2) => {
    const currentModel = gridPaginationModelSelector(apiRef);
    if (pageSize2 === currentModel.pageSize) {
      return;
    }
    logger.debug(`Setting page size to ${pageSize2}`);
    apiRef.current.setPaginationModel({
      pageSize: pageSize2,
      page: currentModel.page
    });
  }, [apiRef, logger]);
  const setPaginationModel = reactExports.useCallback((paginationModel) => {
    const currentModel = gridPaginationModelSelector(apiRef);
    if (paginationModel === currentModel) {
      return;
    }
    logger.debug("Setting 'paginationModel' to", paginationModel);
    apiRef.current.setState((state) => _extends$4({}, state, {
      pagination: _extends$4({}, state.pagination, {
        paginationModel: getDerivedPaginationModel(state.pagination, props.signature, paginationModel)
      })
    }), "setPaginationModel");
  }, [apiRef, logger, props.signature]);
  const paginationModelApi = {
    setPage,
    setPageSize,
    setPaginationModel
  };
  useGridApiMethod(apiRef, paginationModelApi, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _a3, _b3;
    const paginationModel = gridPaginationModelSelector(apiRef);
    const shouldExportPaginationModel = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the `paginationModel` is controlled
      props.paginationModel != null || // Always export if the `paginationModel` has been initialized
      ((_b3 = (_a3 = props.initialState) == null ? void 0 : _a3.pagination) == null ? void 0 : _b3.paginationModel) != null || // Export if `page` or `pageSize` is not equal to the default value
      paginationModel.page !== 0 && paginationModel.pageSize !== defaultPageSize(props.autoPageSize)
    );
    if (!shouldExportPaginationModel) {
      return prevState;
    }
    return _extends$4({}, prevState, {
      pagination: _extends$4({}, prevState.pagination, {
        paginationModel
      })
    });
  }, [apiRef, props.paginationModel, (_b2 = (_a2 = props.initialState) == null ? void 0 : _a2.pagination) == null ? void 0 : _b2.paginationModel, props.autoPageSize]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _a3, _b3;
    const paginationModel = ((_a3 = context.stateToRestore.pagination) == null ? void 0 : _a3.paginationModel) ? _extends$4({}, getDefaultGridPaginationModel(props.autoPageSize), (_b3 = context.stateToRestore.pagination) == null ? void 0 : _b3.paginationModel) : gridPaginationModelSelector(apiRef);
    apiRef.current.setState((state) => _extends$4({}, state, {
      pagination: _extends$4({}, state.pagination, {
        paginationModel: getDerivedPaginationModel(state.pagination, props.signature, paginationModel)
      })
    }), "stateRestorePreProcessing");
    return params;
  }, [apiRef, props.autoPageSize, props.signature]);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  const handlePaginationModelChange = /* @__PURE__ */ __name(() => {
    var _a3;
    const paginationModel = gridPaginationModelSelector(apiRef);
    if ((_a3 = apiRef.current.virtualScrollerRef) == null ? void 0 : _a3.current) {
      apiRef.current.scrollToIndexes({
        rowIndex: paginationModel.page * paginationModel.pageSize
      });
    }
  }, "handlePaginationModelChange");
  const handleUpdateAutoPageSize = reactExports.useCallback(() => {
    if (!props.autoPageSize) {
      return;
    }
    const dimensions = apiRef.current.getRootDimensions();
    const maximumPageSizeWithoutScrollBar = Math.floor(dimensions.viewportInnerSize.height / rowHeight);
    apiRef.current.setPageSize(maximumPageSizeWithoutScrollBar);
  }, [apiRef, props.autoPageSize, rowHeight]);
  const handleRowCountChange = reactExports.useCallback((newRowCount) => {
    if (newRowCount == null) {
      return;
    }
    const paginationModel = gridPaginationModelSelector(apiRef);
    const pageCount = gridPageCountSelector(apiRef);
    if (paginationModel.page > pageCount - 1) {
      apiRef.current.setPage(Math.max(0, pageCount - 1));
    }
  }, [apiRef]);
  useGridApiEventHandler(apiRef, "viewportInnerSizeChange", handleUpdateAutoPageSize);
  useGridApiEventHandler(apiRef, "paginationModelChange", handlePaginationModelChange);
  useGridApiEventHandler(apiRef, "rowCountChange", handleRowCountChange);
  reactExports.useEffect(() => {
    apiRef.current.setState((state) => _extends$4({}, state, {
      pagination: _extends$4({}, state.pagination, {
        paginationModel: getDerivedPaginationModel(state.pagination, props.signature, props.paginationModel)
      })
    }));
  }, [apiRef, props.paginationModel, props.paginationMode, props.signature]);
  reactExports.useEffect(handleUpdateAutoPageSize, [handleUpdateAutoPageSize]);
}, "useGridPaginationModel");
function raf() {
  return new Promise((resolve) => {
    requestAnimationFrame(() => {
      resolve();
    });
  });
}
__name(raf, "raf");
function buildPrintWindow(title) {
  const iframeEl = document.createElement("iframe");
  iframeEl.style.position = "absolute";
  iframeEl.style.width = "0px";
  iframeEl.style.height = "0px";
  iframeEl.title = title || document.title;
  return iframeEl;
}
__name(buildPrintWindow, "buildPrintWindow");
const useGridPrintExport = /* @__PURE__ */ __name((apiRef, props) => {
  const hasRootReference = apiRef.current.rootElementRef.current !== null;
  const logger = useGridLogger(apiRef, "useGridPrintExport");
  const doc = reactExports.useRef(null);
  const previousGridState = reactExports.useRef(null);
  const previousColumnVisibility = reactExports.useRef({});
  const previousRows = reactExports.useRef([]);
  const previousVirtualizationState = reactExports.useRef();
  reactExports.useEffect(() => {
    doc.current = ownerDocument(apiRef.current.rootElementRef.current);
  }, [apiRef, hasRootReference]);
  const updateGridColumnsForPrint = reactExports.useCallback((fields2, allColumns, includeCheckboxes) => new Promise((resolve) => {
    const exportedColumnFields = getColumnsToExport({
      apiRef,
      options: {
        fields: fields2,
        allColumns
      }
    }).map((column2) => column2.field);
    const columns2 = gridColumnDefinitionsSelector(apiRef);
    const newColumnVisibilityModel = {};
    columns2.forEach((column2) => {
      newColumnVisibilityModel[column2.field] = exportedColumnFields.includes(column2.field);
    });
    if (includeCheckboxes) {
      newColumnVisibilityModel[GRID_CHECKBOX_SELECTION_COL_DEF.field] = true;
    }
    apiRef.current.setColumnVisibilityModel(newColumnVisibilityModel);
    resolve();
  }), [apiRef]);
  const updateGridRowsForPrint = reactExports.useCallback((getRowsToExport) => {
    const rowsToExportIds = getRowsToExport({
      apiRef
    });
    const newRows = rowsToExportIds.reduce((acc, id2) => {
      const row = apiRef.current.getRow(id2);
      if (!row[GRID_ID_AUTOGENERATED]) {
        acc.push(row);
      }
      return acc;
    }, []);
    apiRef.current.setRows(newRows);
  }, [apiRef]);
  const handlePrintWindowLoad = reactExports.useCallback((printWindow, options) => {
    var _a2, _b2, _c2, _d2;
    const normalizeOptions = _extends$4({
      copyStyles: true,
      hideToolbar: false,
      hideFooter: false,
      includeCheckboxes: false
    }, options);
    const printDoc = printWindow.contentDocument;
    if (!printDoc) {
      return;
    }
    const rowsMeta = gridRowsMetaSelector(apiRef.current.state);
    const gridRootElement = apiRef.current.rootElementRef.current;
    const gridClone = gridRootElement.cloneNode(true);
    const gridMain = gridClone.querySelector(`.${gridClasses.main}`);
    gridMain.style.overflow = "visible";
    gridClone.style.contain = "size";
    let gridToolbarElementHeight = ((_a2 = gridRootElement.querySelector(`.${gridClasses.toolbarContainer}`)) == null ? void 0 : _a2.offsetHeight) || 0;
    let gridFooterElementHeight = ((_b2 = gridRootElement.querySelector(`.${gridClasses.footerContainer}`)) == null ? void 0 : _b2.offsetHeight) || 0;
    if (normalizeOptions.hideToolbar) {
      (_c2 = gridClone.querySelector(`.${gridClasses.toolbarContainer}`)) == null ? void 0 : _c2.remove();
      gridToolbarElementHeight = 0;
    }
    if (normalizeOptions.hideFooter) {
      (_d2 = gridClone.querySelector(`.${gridClasses.footerContainer}`)) == null ? void 0 : _d2.remove();
      gridFooterElementHeight = 0;
    }
    const computedTotalHeight = rowsMeta.currentPageTotalHeight + getTotalHeaderHeight(apiRef, props) + gridToolbarElementHeight + gridFooterElementHeight;
    gridClone.style.height = `${computedTotalHeight}px`;
    gridClone.style.boxSizing = "content-box";
    if (!normalizeOptions.hideFooter) {
      const gridFooterElement = gridClone.querySelector(`.${gridClasses.footerContainer}`);
      gridFooterElement.style.position = "absolute";
      gridFooterElement.style.width = "100%";
      gridFooterElement.style.top = `${computedTotalHeight - gridFooterElementHeight}px`;
    }
    const container = document.createElement("div");
    container.appendChild(gridClone);
    printDoc.body.style.marginTop = "0px";
    printDoc.body.innerHTML = container.innerHTML;
    const defaultPageStyle = typeof normalizeOptions.pageStyle === "function" ? normalizeOptions.pageStyle() : normalizeOptions.pageStyle;
    if (typeof defaultPageStyle === "string") {
      const styleElement = printDoc.createElement("style");
      styleElement.appendChild(printDoc.createTextNode(defaultPageStyle));
      printDoc.head.appendChild(styleElement);
    }
    if (normalizeOptions.bodyClassName) {
      printDoc.body.classList.add(...normalizeOptions.bodyClassName.split(" "));
    }
    const stylesheetLoadPromises = [];
    if (normalizeOptions.copyStyles) {
      const rootCandidate = gridRootElement.getRootNode();
      const root2 = rootCandidate.constructor.name === "ShadowRoot" ? rootCandidate : doc.current;
      const headStyleElements = root2.querySelectorAll("style, link[rel='stylesheet']");
      for (let i = 0; i < headStyleElements.length; i += 1) {
        const node2 = headStyleElements[i];
        if (node2.tagName === "STYLE") {
          const newHeadStyleElements = printDoc.createElement(node2.tagName);
          const sheet = node2.sheet;
          if (sheet) {
            let styleCSS = "";
            for (let j = 0; j < sheet.cssRules.length; j += 1) {
              if (typeof sheet.cssRules[j].cssText === "string") {
                styleCSS += `${sheet.cssRules[j].cssText}\r
`;
              }
            }
            newHeadStyleElements.appendChild(printDoc.createTextNode(styleCSS));
            printDoc.head.appendChild(newHeadStyleElements);
          }
        } else if (node2.getAttribute("href")) {
          const newHeadStyleElements = printDoc.createElement(node2.tagName);
          for (let j = 0; j < node2.attributes.length; j += 1) {
            const attr = node2.attributes[j];
            if (attr) {
              newHeadStyleElements.setAttribute(attr.nodeName, attr.nodeValue || "");
            }
          }
          stylesheetLoadPromises.push(new Promise((resolve) => {
            newHeadStyleElements.addEventListener("load", () => resolve());
          }));
          printDoc.head.appendChild(newHeadStyleElements);
        }
      }
    }
    {
      Promise.all(stylesheetLoadPromises).then(() => {
        printWindow.contentWindow.print();
      });
    }
  }, [apiRef, doc, props]);
  const handlePrintWindowAfterPrint = reactExports.useCallback((printWindow) => {
    var _a2, _b2;
    doc.current.body.removeChild(printWindow);
    apiRef.current.restoreState(previousGridState.current || {});
    if (!((_b2 = (_a2 = previousGridState.current) == null ? void 0 : _a2.columns) == null ? void 0 : _b2.columnVisibilityModel)) {
      apiRef.current.setColumnVisibilityModel(previousColumnVisibility.current);
    }
    apiRef.current.setState((state) => _extends$4({}, state, {
      virtualization: previousVirtualizationState.current
    }));
    apiRef.current.setRows(previousRows.current);
    previousGridState.current = null;
    previousColumnVisibility.current = {};
    previousRows.current = [];
  }, [apiRef]);
  const exportDataAsPrint = reactExports.useCallback(async (options) => {
    logger.debug(`Export data as Print`);
    if (!apiRef.current.rootElementRef.current) {
      throw new Error("MUI X: No grid root element available.");
    }
    previousGridState.current = apiRef.current.exportState();
    previousColumnVisibility.current = gridColumnVisibilityModelSelector(apiRef);
    previousRows.current = apiRef.current.getSortedRows().filter((row) => !row[GRID_ID_AUTOGENERATED]);
    if (props.pagination) {
      const visibleRowCount = gridExpandedRowCountSelector(apiRef);
      const paginationModel = {
        page: 0,
        pageSize: visibleRowCount
      };
      apiRef.current.setState((state) => _extends$4({}, state, {
        pagination: _extends$4({}, state.pagination, {
          paginationModel: getDerivedPaginationModel(
            state.pagination,
            // Using signature `DataGridPro` to allow more than 100 rows in the print export
            "DataGridPro",
            paginationModel
          )
        })
      }));
    }
    previousVirtualizationState.current = apiRef.current.state.virtualization;
    apiRef.current.setState((state) => _extends$4({}, state, {
      virtualization: _extends$4({}, state.virtualization, {
        enabled: false,
        enabledForColumns: false
      })
    }));
    await updateGridColumnsForPrint(options == null ? void 0 : options.fields, options == null ? void 0 : options.allColumns, options == null ? void 0 : options.includeCheckboxes);
    updateGridRowsForPrint((options == null ? void 0 : options.getRowsToExport) ?? defaultGetRowsToExport);
    await raf();
    const printWindow = buildPrintWindow(options == null ? void 0 : options.fileName);
    {
      printWindow.onload = () => {
        handlePrintWindowLoad(printWindow, options);
        const mediaQueryList = printWindow.contentWindow.matchMedia("print");
        mediaQueryList.addEventListener("change", (mql) => {
          const isAfterPrint = mql.matches === false;
          if (isAfterPrint) {
            handlePrintWindowAfterPrint(printWindow);
          }
        });
      };
      doc.current.body.appendChild(printWindow);
    }
  }, [props, logger, apiRef, handlePrintWindowLoad, handlePrintWindowAfterPrint, updateGridColumnsForPrint, updateGridRowsForPrint]);
  const printExportApi = {
    exportDataAsPrint
  };
  useGridApiMethod(apiRef, printExportApi, "public");
  const addExportMenuButtons = reactExports.useCallback((initialValue, options) => {
    var _a2;
    if ((_a2 = options.printOptions) == null ? void 0 : _a2.disableToolbarButton) {
      return initialValue;
    }
    return [...initialValue, {
      component: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPrintExportMenuItem, {
        options: options.printOptions
      }),
      componentName: "printExport"
    }];
  }, []);
  useGridRegisterPipeProcessor(apiRef, "exportMenu", addExportMenuButtons);
}, "useGridPrintExport");
const filterStateInitializer = /* @__PURE__ */ __name((state, props, apiRef) => {
  var _a2, _b2;
  const filterModel = props.filterModel ?? ((_b2 = (_a2 = props.initialState) == null ? void 0 : _a2.filter) == null ? void 0 : _b2.filterModel) ?? getDefaultGridFilterModel();
  return _extends$4({}, state, {
    filter: {
      filterModel: sanitizeFilterModel(filterModel, props.disableMultipleColumnsFiltering, apiRef),
      filteredRowsLookup: {},
      filteredChildrenCountLookup: {},
      filteredDescendantCountLookup: {}
    },
    visibleRowsLookup: {}
  });
}, "filterStateInitializer");
const getVisibleRowsLookup = /* @__PURE__ */ __name((params) => {
  return params.filteredRowsLookup;
}, "getVisibleRowsLookup");
function getVisibleRowsLookupState(apiRef, state) {
  return apiRef.current.applyStrategyProcessor("visibleRowsLookupCreation", {
    tree: state.rows.tree,
    filteredRowsLookup: state.filter.filteredRowsLookup
  });
}
__name(getVisibleRowsLookupState, "getVisibleRowsLookupState");
function createMemoizedValues() {
  return lruMemoize(Object.values);
}
__name(createMemoizedValues, "createMemoizedValues");
const useGridFilter = /* @__PURE__ */ __name((apiRef, props) => {
  var _a2, _b2, _c2;
  const logger = useGridLogger(apiRef, "useGridFilter");
  apiRef.current.registerControlState({
    stateId: "filter",
    propModel: props.filterModel,
    propOnChange: props.onFilterModelChange,
    stateSelector: gridFilterModelSelector,
    changeEvent: "filterModelChange"
  });
  const updateFilteredRows = reactExports.useCallback(() => {
    apiRef.current.setState((state) => {
      const filterModel = gridFilterModelSelector(state, apiRef.current.instanceId);
      const filterState = apiRef.current.getFilterState(filterModel);
      const newState = _extends$4({}, state, {
        filter: _extends$4({}, state.filter, filterState)
      });
      const visibleRowsLookupState = getVisibleRowsLookupState(apiRef, newState);
      return _extends$4({}, newState, {
        visibleRowsLookup: visibleRowsLookupState
      });
    });
    apiRef.current.publishEvent("filteredRowsSet");
  }, [apiRef]);
  const addColumnMenuItem = reactExports.useCallback((columnMenuItems, colDef) => {
    if (colDef == null || colDef.filterable === false || props.disableColumnFilter) {
      return columnMenuItems;
    }
    return [...columnMenuItems, "columnMenuFilterItem"];
  }, [props.disableColumnFilter]);
  const applyFilters = reactExports.useCallback(() => {
    updateFilteredRows();
    apiRef.current.forceUpdate();
  }, [apiRef, updateFilteredRows]);
  const upsertFilterItem = reactExports.useCallback((item) => {
    const filterModel = gridFilterModelSelector(apiRef);
    const items = [...filterModel.items];
    const itemIndex = items.findIndex((filterItem) => filterItem.id === item.id);
    if (itemIndex === -1) {
      items.push(item);
    } else {
      items[itemIndex] = item;
    }
    apiRef.current.setFilterModel(_extends$4({}, filterModel, {
      items
    }), "upsertFilterItem");
  }, [apiRef]);
  const upsertFilterItems = reactExports.useCallback((items) => {
    const filterModel = gridFilterModelSelector(apiRef);
    const existingItems = [...filterModel.items];
    items.forEach((item) => {
      const itemIndex = existingItems.findIndex((filterItem) => filterItem.id === item.id);
      if (itemIndex === -1) {
        existingItems.push(item);
      } else {
        existingItems[itemIndex] = item;
      }
    });
    apiRef.current.setFilterModel(_extends$4({}, filterModel, {
      items: existingItems
    }), "upsertFilterItems");
  }, [apiRef]);
  const deleteFilterItem = reactExports.useCallback((itemToDelete) => {
    const filterModel = gridFilterModelSelector(apiRef);
    const items = filterModel.items.filter((item) => item.id !== itemToDelete.id);
    if (items.length === filterModel.items.length) {
      return;
    }
    apiRef.current.setFilterModel(_extends$4({}, filterModel, {
      items
    }), "deleteFilterItem");
  }, [apiRef]);
  const showFilterPanel = reactExports.useCallback((targetColumnField, panelId, labelId) => {
    logger.debug("Displaying filter panel");
    if (targetColumnField) {
      const filterModel = gridFilterModelSelector(apiRef);
      const filterItemsWithValue = filterModel.items.filter((item) => {
        var _a3;
        if (item.value !== void 0) {
          if (Array.isArray(item.value) && item.value.length === 0) {
            return false;
          }
          return true;
        }
        const column2 = apiRef.current.getColumn(item.field);
        const filterOperator = (_a3 = column2.filterOperators) == null ? void 0 : _a3.find((operator) => operator.value === item.operator);
        const requiresFilterValue = typeof (filterOperator == null ? void 0 : filterOperator.requiresFilterValue) === "undefined" ? true : filterOperator == null ? void 0 : filterOperator.requiresFilterValue;
        if (requiresFilterValue) {
          return false;
        }
        return true;
      });
      let newFilterItems;
      const filterItemOnTarget = filterItemsWithValue.find((item) => item.field === targetColumnField);
      const targetColumn = apiRef.current.getColumn(targetColumnField);
      if (filterItemOnTarget) {
        newFilterItems = filterItemsWithValue;
      } else if (props.disableMultipleColumnsFiltering) {
        newFilterItems = [cleanFilterItem({
          field: targetColumnField,
          operator: targetColumn.filterOperators[0].value
        }, apiRef)];
      } else {
        newFilterItems = [...filterItemsWithValue, cleanFilterItem({
          field: targetColumnField,
          operator: targetColumn.filterOperators[0].value
        }, apiRef)];
      }
      apiRef.current.setFilterModel(_extends$4({}, filterModel, {
        items: newFilterItems
      }));
    }
    apiRef.current.showPreferences(GridPreferencePanelsValue.filters, panelId, labelId);
  }, [apiRef, logger, props.disableMultipleColumnsFiltering]);
  const hideFilterPanel = reactExports.useCallback(() => {
    logger.debug("Hiding filter panel");
    apiRef.current.hidePreferences();
  }, [apiRef, logger]);
  const setFilterLogicOperator = reactExports.useCallback((logicOperator) => {
    const filterModel = gridFilterModelSelector(apiRef);
    if (filterModel.logicOperator === logicOperator) {
      return;
    }
    apiRef.current.setFilterModel(_extends$4({}, filterModel, {
      logicOperator
    }), "changeLogicOperator");
  }, [apiRef]);
  const setQuickFilterValues = reactExports.useCallback((values2) => {
    const filterModel = gridFilterModelSelector(apiRef);
    if (isDeepEqual(filterModel.quickFilterValues, values2)) {
      return;
    }
    apiRef.current.setFilterModel(_extends$4({}, filterModel, {
      quickFilterValues: [...values2]
    }));
  }, [apiRef]);
  const setFilterModel = reactExports.useCallback((model, reason) => {
    const currentModel = gridFilterModelSelector(apiRef);
    if (currentModel !== model) {
      logger.debug("Setting filter model");
      apiRef.current.updateControlState("filter", mergeStateWithFilterModel(model, props.disableMultipleColumnsFiltering, apiRef), reason);
      apiRef.current.unstable_applyFilters();
    }
  }, [apiRef, logger, props.disableMultipleColumnsFiltering]);
  const getFilterState = reactExports.useCallback((inputFilterModel) => {
    const filterModel = sanitizeFilterModel(inputFilterModel, props.disableMultipleColumnsFiltering, apiRef);
    const isRowMatchingFilters = props.filterMode === "client" ? buildAggregatedFilterApplier(filterModel, apiRef, props.disableEval) : null;
    const filterResult = apiRef.current.applyStrategyProcessor("filtering", {
      isRowMatchingFilters,
      filterModel: filterModel ?? getDefaultGridFilterModel()
    });
    return _extends$4({}, filterResult, {
      filterModel
    });
  }, [props.disableMultipleColumnsFiltering, props.filterMode, props.disableEval, apiRef]);
  const filterApi = {
    setFilterLogicOperator,
    unstable_applyFilters: applyFilters,
    deleteFilterItem,
    upsertFilterItem,
    upsertFilterItems,
    setFilterModel,
    showFilterPanel,
    hideFilterPanel,
    setQuickFilterValues,
    ignoreDiacritics: props.ignoreDiacritics,
    getFilterState
  };
  useGridApiMethod(apiRef, filterApi, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _a3, _b3;
    const filterModelToExport = gridFilterModelSelector(apiRef);
    const shouldExportFilterModel = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the model is controlled
      props.filterModel != null || // Always export if the model has been initialized
      ((_b3 = (_a3 = props.initialState) == null ? void 0 : _a3.filter) == null ? void 0 : _b3.filterModel) != null || // Export if the model is not equal to the default value
      !isDeepEqual(filterModelToExport, getDefaultGridFilterModel())
    );
    if (!shouldExportFilterModel) {
      return prevState;
    }
    return _extends$4({}, prevState, {
      filter: {
        filterModel: filterModelToExport
      }
    });
  }, [apiRef, props.filterModel, (_b2 = (_a2 = props.initialState) == null ? void 0 : _a2.filter) == null ? void 0 : _b2.filterModel]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _a3;
    const filterModel = (_a3 = context.stateToRestore.filter) == null ? void 0 : _a3.filterModel;
    if (filterModel == null) {
      return params;
    }
    apiRef.current.updateControlState("filter", mergeStateWithFilterModel(filterModel, props.disableMultipleColumnsFiltering, apiRef), "restoreState");
    return _extends$4({}, params, {
      callbacks: [...params.callbacks, apiRef.current.unstable_applyFilters]
    });
  }, [apiRef, props.disableMultipleColumnsFiltering]);
  const preferencePanelPreProcessing = reactExports.useCallback((initialValue, value) => {
    var _a3;
    if (value === GridPreferencePanelsValue.filters) {
      const FilterPanel = props.slots.filterPanel;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FilterPanel, _extends$4({}, (_a3 = props.slotProps) == null ? void 0 : _a3.filterPanel));
    }
    return initialValue;
  }, [props.slots.filterPanel, (_c2 = props.slotProps) == null ? void 0 : _c2.filterPanel]);
  const {
    getRowId
  } = props;
  const getRowsRef = useLazyRef(createMemoizedValues);
  const flatFilteringMethod = reactExports.useCallback((params) => {
    if (props.filterMode !== "client" || !params.isRowMatchingFilters) {
      return {
        filteredRowsLookup: {},
        filteredChildrenCountLookup: {},
        filteredDescendantCountLookup: {}
      };
    }
    const dataRowIdToModelLookup = gridRowsLookupSelector(apiRef);
    const filteredRowsLookup = {};
    const {
      isRowMatchingFilters
    } = params;
    const filterCache = {};
    const result = {
      passingFilterItems: null,
      passingQuickFilterValues: null
    };
    const rows = getRowsRef.current(apiRef.current.state.rows.dataRowIdToModelLookup);
    for (let i = 0; i < rows.length; i += 1) {
      const row = rows[i];
      const id2 = getRowId ? getRowId(row) : row.id;
      isRowMatchingFilters(row, void 0, result);
      const isRowPassing = passFilterLogic([result.passingFilterItems], [result.passingQuickFilterValues], params.filterModel, apiRef, filterCache);
      filteredRowsLookup[id2] = isRowPassing;
    }
    const footerId = "auto-generated-group-footer-root";
    const footer = dataRowIdToModelLookup[footerId];
    if (footer) {
      filteredRowsLookup[footerId] = true;
    }
    return {
      filteredRowsLookup,
      filteredChildrenCountLookup: {},
      filteredDescendantCountLookup: {}
    };
  }, [apiRef, props.filterMode, getRowId, getRowsRef]);
  useGridRegisterPipeProcessor(apiRef, "columnMenu", addColumnMenuItem);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  useGridRegisterPipeProcessor(apiRef, "preferencePanel", preferencePanelPreProcessing);
  useGridRegisterStrategyProcessor(apiRef, GRID_DEFAULT_STRATEGY, "filtering", flatFilteringMethod);
  useGridRegisterStrategyProcessor(apiRef, GRID_DEFAULT_STRATEGY, "visibleRowsLookupCreation", getVisibleRowsLookup);
  const handleColumnsChange = reactExports.useCallback(() => {
    logger.debug("onColUpdated - GridColumns changed, applying filters");
    const filterModel = gridFilterModelSelector(apiRef);
    const columnsLookup = gridColumnLookupSelector(apiRef);
    const newFilterItems = filterModel.items.filter((item) => item.field && columnsLookup[item.field]);
    if (newFilterItems.length < filterModel.items.length) {
      apiRef.current.setFilterModel(_extends$4({}, filterModel, {
        items: newFilterItems
      }));
    }
  }, [apiRef, logger]);
  const handleStrategyProcessorChange = reactExports.useCallback((methodName) => {
    if (methodName === "filtering") {
      apiRef.current.unstable_applyFilters();
    }
  }, [apiRef]);
  const updateVisibleRowsLookupState = reactExports.useCallback(() => {
    apiRef.current.setState((state) => {
      return _extends$4({}, state, {
        visibleRowsLookup: getVisibleRowsLookupState(apiRef, state)
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  useGridApiEventHandler(apiRef, "rowsSet", updateFilteredRows);
  useGridApiEventHandler(apiRef, "columnsChange", handleColumnsChange);
  useGridApiEventHandler(apiRef, "activeStrategyProcessorChange", handleStrategyProcessorChange);
  useGridApiEventHandler(apiRef, "rowExpansionChange", updateVisibleRowsLookupState);
  useGridApiEventHandler(apiRef, "columnVisibilityModelChange", () => {
    const filterModel = gridFilterModelSelector(apiRef);
    if (filterModel.quickFilterValues && shouldQuickFilterExcludeHiddenColumns(filterModel)) {
      apiRef.current.unstable_applyFilters();
    }
  });
  useFirstRender(() => {
    apiRef.current.unstable_applyFilters();
  });
  useEnhancedEffect(() => {
    if (props.filterModel !== void 0) {
      apiRef.current.setFilterModel(props.filterModel);
    }
  }, [apiRef, logger, props.filterModel]);
}, "useGridFilter");
const focusStateInitializer = /* @__PURE__ */ __name((state) => _extends$4({}, state, {
  focus: {
    cell: null,
    columnHeader: null,
    columnHeaderFilter: null,
    columnGroupHeader: null
  },
  tabIndex: {
    cell: null,
    columnHeader: null,
    columnHeaderFilter: null,
    columnGroupHeader: null
  }
}), "focusStateInitializer");
const useGridFocus = /* @__PURE__ */ __name((apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridFocus");
  const lastClickedCell = reactExports.useRef(null);
  const hasRootReference = apiRef.current.rootElementRef.current !== null;
  const publishCellFocusOut = reactExports.useCallback((cell, event) => {
    if (cell) {
      if (apiRef.current.getRow(cell.id)) {
        apiRef.current.publishEvent("cellFocusOut", apiRef.current.getCellParams(cell.id, cell.field), event);
      }
    }
  }, [apiRef]);
  const setCellFocus = reactExports.useCallback((id2, field) => {
    const focusedCell = gridFocusCellSelector(apiRef);
    if ((focusedCell == null ? void 0 : focusedCell.id) === id2 && (focusedCell == null ? void 0 : focusedCell.field) === field) {
      return;
    }
    apiRef.current.setState((state) => {
      logger.debug(`Focusing on cell with id=${id2} and field=${field}`);
      return _extends$4({}, state, {
        tabIndex: {
          cell: {
            id: id2,
            field
          },
          columnHeader: null,
          columnHeaderFilter: null,
          columnGroupHeader: null
        },
        focus: {
          cell: {
            id: id2,
            field
          },
          columnHeader: null,
          columnHeaderFilter: null,
          columnGroupHeader: null
        }
      });
    });
    apiRef.current.forceUpdate();
    if (!apiRef.current.getRow(id2)) {
      return;
    }
    if (focusedCell) {
      publishCellFocusOut(focusedCell, {});
    }
    apiRef.current.publishEvent("cellFocusIn", apiRef.current.getCellParams(id2, field));
  }, [apiRef, logger, publishCellFocusOut]);
  const setColumnHeaderFocus = reactExports.useCallback((field, event = {}) => {
    const cell = gridFocusCellSelector(apiRef);
    publishCellFocusOut(cell, event);
    apiRef.current.setState((state) => {
      logger.debug(`Focusing on column header with colIndex=${field}`);
      return _extends$4({}, state, {
        tabIndex: {
          columnHeader: {
            field
          },
          columnHeaderFilter: null,
          cell: null,
          columnGroupHeader: null
        },
        focus: {
          columnHeader: {
            field
          },
          columnHeaderFilter: null,
          cell: null,
          columnGroupHeader: null
        }
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef, logger, publishCellFocusOut]);
  const setColumnHeaderFilterFocus = reactExports.useCallback((field, event = {}) => {
    const cell = gridFocusCellSelector(apiRef);
    publishCellFocusOut(cell, event);
    apiRef.current.setState((state) => {
      logger.debug(`Focusing on column header filter with colIndex=${field}`);
      return _extends$4({}, state, {
        tabIndex: {
          columnHeader: null,
          columnHeaderFilter: {
            field
          },
          cell: null,
          columnGroupHeader: null
        },
        focus: {
          columnHeader: null,
          columnHeaderFilter: {
            field
          },
          cell: null,
          columnGroupHeader: null
        }
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef, logger, publishCellFocusOut]);
  const setColumnGroupHeaderFocus = reactExports.useCallback((field, depth, event = {}) => {
    const cell = gridFocusCellSelector(apiRef);
    if (cell) {
      apiRef.current.publishEvent("cellFocusOut", apiRef.current.getCellParams(cell.id, cell.field), event);
    }
    apiRef.current.setState((state) => {
      return _extends$4({}, state, {
        tabIndex: {
          columnGroupHeader: {
            field,
            depth
          },
          columnHeader: null,
          columnHeaderFilter: null,
          cell: null
        },
        focus: {
          columnGroupHeader: {
            field,
            depth
          },
          columnHeader: null,
          columnHeaderFilter: null,
          cell: null
        }
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const getColumnGroupHeaderFocus = reactExports.useCallback(() => gridFocusColumnGroupHeaderSelector(apiRef), [apiRef]);
  const moveFocusToRelativeCell = reactExports.useCallback((id2, field, direction) => {
    let columnIndexToFocus = apiRef.current.getColumnIndex(field);
    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
    const currentPage = getVisibleRows(apiRef, {
      pagination: props.pagination,
      paginationMode: props.paginationMode
    });
    const pinnedRows = gridPinnedRowsSelector(apiRef);
    const currentPageRows = [].concat(pinnedRows.top || [], currentPage.rows, pinnedRows.bottom || []);
    let rowIndexToFocus = currentPageRows.findIndex((row) => row.id === id2);
    if (direction === "right") {
      columnIndexToFocus += 1;
    } else if (direction === "left") {
      columnIndexToFocus -= 1;
    } else {
      rowIndexToFocus += 1;
    }
    if (columnIndexToFocus >= visibleColumns.length) {
      rowIndexToFocus += 1;
      if (rowIndexToFocus < currentPageRows.length) {
        columnIndexToFocus = 0;
      }
    } else if (columnIndexToFocus < 0) {
      rowIndexToFocus -= 1;
      if (rowIndexToFocus >= 0) {
        columnIndexToFocus = visibleColumns.length - 1;
      }
    }
    rowIndexToFocus = clamp$3(rowIndexToFocus, 0, currentPageRows.length - 1);
    const rowToFocus = currentPageRows[rowIndexToFocus];
    if (!rowToFocus) {
      return;
    }
    const colSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowToFocus.id, columnIndexToFocus);
    if (colSpanInfo && colSpanInfo.spannedByColSpan) {
      if (direction === "left" || direction === "below") {
        columnIndexToFocus = colSpanInfo.leftVisibleCellIndex;
      } else if (direction === "right") {
        columnIndexToFocus = colSpanInfo.rightVisibleCellIndex;
      }
    }
    columnIndexToFocus = clamp$3(columnIndexToFocus, 0, visibleColumns.length - 1);
    const columnToFocus = visibleColumns[columnIndexToFocus];
    apiRef.current.setCellFocus(rowToFocus.id, columnToFocus.field);
  }, [apiRef, props.pagination, props.paginationMode]);
  const handleCellDoubleClick = reactExports.useCallback(({
    id: id2,
    field
  }) => {
    apiRef.current.setCellFocus(id2, field);
  }, [apiRef]);
  const handleCellKeyDown = reactExports.useCallback((params, event) => {
    if (event.key === "Enter" || event.key === "Tab" || event.key === "Shift" || isNavigationKey(event.key)) {
      return;
    }
    apiRef.current.setCellFocus(params.id, params.field);
  }, [apiRef]);
  const handleColumnHeaderFocus = reactExports.useCallback(({
    field
  }, event) => {
    if (event.target !== event.currentTarget) {
      return;
    }
    apiRef.current.setColumnHeaderFocus(field, event);
  }, [apiRef]);
  const handleColumnGroupHeaderFocus = reactExports.useCallback(({
    fields: fields2,
    depth
  }, event) => {
    if (event.target !== event.currentTarget) {
      return;
    }
    const focusedColumnGroup = gridFocusColumnGroupHeaderSelector(apiRef);
    if (focusedColumnGroup !== null && focusedColumnGroup.depth === depth && fields2.includes(focusedColumnGroup.field)) {
      return;
    }
    apiRef.current.setColumnGroupHeaderFocus(fields2[0], depth, event);
  }, [apiRef]);
  const handleBlur2 = reactExports.useCallback((_2, event) => {
    var _a2, _b2;
    if ((_b2 = (_a2 = event.relatedTarget) == null ? void 0 : _a2.getAttribute("class")) == null ? void 0 : _b2.includes(gridClasses.columnHeader)) {
      return;
    }
    logger.debug(`Clearing focus`);
    apiRef.current.setState((state) => _extends$4({}, state, {
      focus: {
        cell: null,
        columnHeader: null,
        columnHeaderFilter: null,
        columnGroupHeader: null
      }
    }));
  }, [logger, apiRef]);
  const handleCellMouseDown = reactExports.useCallback((params) => {
    lastClickedCell.current = params;
  }, []);
  const handleDocumentClick = reactExports.useCallback((event) => {
    const cellParams = lastClickedCell.current;
    lastClickedCell.current = null;
    const focusedCell = gridFocusCellSelector(apiRef);
    const canUpdateFocus = apiRef.current.unstable_applyPipeProcessors("canUpdateFocus", true, {
      event,
      cell: cellParams
    });
    if (!canUpdateFocus) {
      return;
    }
    if (!focusedCell) {
      if (cellParams) {
        apiRef.current.setCellFocus(cellParams.id, cellParams.field);
      }
      return;
    }
    if ((cellParams == null ? void 0 : cellParams.id) === focusedCell.id && (cellParams == null ? void 0 : cellParams.field) === focusedCell.field) {
      return;
    }
    const cellElement = apiRef.current.getCellElement(focusedCell.id, focusedCell.field);
    if (cellElement == null ? void 0 : cellElement.contains(event.target)) {
      return;
    }
    if (cellParams) {
      apiRef.current.setCellFocus(cellParams.id, cellParams.field);
    } else {
      apiRef.current.setState((state) => _extends$4({}, state, {
        focus: {
          cell: null,
          columnHeader: null,
          columnHeaderFilter: null,
          columnGroupHeader: null
        }
      }));
      apiRef.current.forceUpdate();
      publishCellFocusOut(focusedCell, event);
    }
  }, [apiRef, publishCellFocusOut]);
  const handleCellModeChange = reactExports.useCallback((params) => {
    if (params.cellMode === "view") {
      return;
    }
    const cell = gridFocusCellSelector(apiRef);
    if ((cell == null ? void 0 : cell.id) !== params.id || (cell == null ? void 0 : cell.field) !== params.field) {
      apiRef.current.setCellFocus(params.id, params.field);
    }
  }, [apiRef]);
  const handleRowSet = reactExports.useCallback(() => {
    var _a2;
    const cell = gridFocusCellSelector(apiRef);
    if (cell && !apiRef.current.getRow(cell.id)) {
      const lastFocusedRowId = (_a2 = gridFocusCellSelector(apiRef)) == null ? void 0 : _a2.id;
      let nextRowId = null;
      if (typeof lastFocusedRowId !== "undefined") {
        const lastFocusedRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(lastFocusedRowId);
        const currentPage = getVisibleRows(apiRef, {
          pagination: props.pagination,
          paginationMode: props.paginationMode
        });
        const nextRow = currentPage.rows[clamp$3(lastFocusedRowIndex, 0, currentPage.rows.length - 1)];
        nextRowId = (nextRow == null ? void 0 : nextRow.id) ?? null;
      }
      apiRef.current.setState((state) => _extends$4({}, state, {
        focus: {
          cell: nextRowId === null ? null : {
            id: nextRowId,
            field: cell.field
          },
          columnHeader: null,
          columnHeaderFilter: null,
          columnGroupHeader: null
        }
      }));
    }
  }, [apiRef, props.pagination, props.paginationMode]);
  const handlePaginationModelChange = useEventCallback(() => {
    const currentFocusedCell = gridFocusCellSelector(apiRef);
    if (!currentFocusedCell) {
      return;
    }
    const currentPage = getVisibleRows(apiRef, {
      pagination: props.pagination,
      paginationMode: props.paginationMode
    });
    const rowIsInCurrentPage = currentPage.rows.find((row) => row.id === currentFocusedCell.id);
    if (rowIsInCurrentPage) {
      return;
    }
    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
    apiRef.current.setState((state) => {
      return _extends$4({}, state, {
        tabIndex: {
          cell: {
            id: currentPage.rows[0].id,
            field: visibleColumns[0].field
          },
          columnGroupHeader: null,
          columnHeader: null,
          columnHeaderFilter: null
        }
      });
    });
  });
  const focusApi = {
    setCellFocus,
    setColumnHeaderFocus,
    setColumnHeaderFilterFocus
  };
  const focusPrivateApi = {
    moveFocusToRelativeCell,
    setColumnGroupHeaderFocus,
    getColumnGroupHeaderFocus
  };
  useGridApiMethod(apiRef, focusApi, "public");
  useGridApiMethod(apiRef, focusPrivateApi, "private");
  reactExports.useEffect(() => {
    const doc = ownerDocument(apiRef.current.rootElementRef.current);
    doc.addEventListener("mouseup", handleDocumentClick);
    return () => {
      doc.removeEventListener("mouseup", handleDocumentClick);
    };
  }, [apiRef, hasRootReference, handleDocumentClick]);
  useGridApiEventHandler(apiRef, "columnHeaderBlur", handleBlur2);
  useGridApiEventHandler(apiRef, "cellDoubleClick", handleCellDoubleClick);
  useGridApiEventHandler(apiRef, "cellMouseDown", handleCellMouseDown);
  useGridApiEventHandler(apiRef, "cellKeyDown", handleCellKeyDown);
  useGridApiEventHandler(apiRef, "cellModeChange", handleCellModeChange);
  useGridApiEventHandler(apiRef, "columnHeaderFocus", handleColumnHeaderFocus);
  useGridApiEventHandler(apiRef, "columnGroupHeaderFocus", handleColumnGroupHeaderFocus);
  useGridApiEventHandler(apiRef, "rowsSet", handleRowSet);
  useGridApiEventHandler(apiRef, "paginationModelChange", handlePaginationModelChange);
}, "useGridFocus");
const getRowGroupingCriteriaFromGroupingField = /* @__PURE__ */ __name((groupingColDefField) => {
  const match2 = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);
  if (!match2) {
    return null;
  }
  return match2[1];
}, "getRowGroupingCriteriaFromGroupingField");
const isGroupingColumn = /* @__PURE__ */ __name((field) => field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null, "isGroupingColumn");
function enrichPageRowsWithPinnedRows(apiRef, rows) {
  const pinnedRows = gridPinnedRowsSelector(apiRef) || {};
  return [...pinnedRows.top || [], ...rows, ...pinnedRows.bottom || []];
}
__name(enrichPageRowsWithPinnedRows, "enrichPageRowsWithPinnedRows");
const getLeftColumnIndex = /* @__PURE__ */ __name(({
  currentColIndex,
  firstColIndex,
  lastColIndex,
  isRtl
}) => {
  if (isRtl) {
    if (currentColIndex < lastColIndex) {
      return currentColIndex + 1;
    }
  } else if (!isRtl) {
    if (currentColIndex > firstColIndex) {
      return currentColIndex - 1;
    }
  }
  return null;
}, "getLeftColumnIndex");
const getRightColumnIndex = /* @__PURE__ */ __name(({
  currentColIndex,
  firstColIndex,
  lastColIndex,
  isRtl
}) => {
  if (isRtl) {
    if (currentColIndex > firstColIndex) {
      return currentColIndex - 1;
    }
  } else if (!isRtl) {
    if (currentColIndex < lastColIndex) {
      return currentColIndex + 1;
    }
  }
  return null;
}, "getRightColumnIndex");
function findNonRowSpannedCell(apiRef, rowId, field, rowSpanScanDirection) {
  var _a2, _b2;
  const rowSpanHiddenCells = gridRowSpanningHiddenCellsSelector(apiRef);
  if (!((_a2 = rowSpanHiddenCells[rowId]) == null ? void 0 : _a2[field])) {
    return rowId;
  }
  const filteredSortedRowIds = gridFilteredSortedRowIdsSelector(apiRef);
  let nextRowIndex = filteredSortedRowIds.indexOf(rowId) + (rowSpanScanDirection === "down" ? 1 : -1);
  while (nextRowIndex >= 0 && nextRowIndex < filteredSortedRowIds.length) {
    const nextRowId = filteredSortedRowIds[nextRowIndex];
    if (!((_b2 = rowSpanHiddenCells[nextRowId]) == null ? void 0 : _b2[field])) {
      return nextRowId;
    }
    nextRowIndex += rowSpanScanDirection === "down" ? 1 : -1;
  }
  return rowId;
}
__name(findNonRowSpannedCell, "findNonRowSpannedCell");
const useGridKeyboardNavigation = /* @__PURE__ */ __name((apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridKeyboardNavigation");
  const initialCurrentPageRows = useGridVisibleRows(apiRef, props).rows;
  const isRtl = useRtl();
  const listView = props.unstable_listView;
  const currentPageRows = reactExports.useMemo(() => enrichPageRowsWithPinnedRows(apiRef, initialCurrentPageRows), [apiRef, initialCurrentPageRows]);
  const headerFilteringEnabled = props.signature !== "DataGrid" && props.headerFilters;
  const goToCell = reactExports.useCallback((colIndex, rowId, closestColumnToUse = "left", rowSpanScanDirection = "up") => {
    const visibleSortedRows = gridExpandedSortedRowEntriesSelector(apiRef);
    const nextCellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, colIndex);
    if (nextCellColSpanInfo && nextCellColSpanInfo.spannedByColSpan) {
      if (closestColumnToUse === "left") {
        colIndex = nextCellColSpanInfo.leftVisibleCellIndex;
      } else if (closestColumnToUse === "right") {
        colIndex = nextCellColSpanInfo.rightVisibleCellIndex;
      }
    }
    const field = listView ? gridListColumnSelector(apiRef.current.state).field : gridVisibleColumnFieldsSelector(apiRef)[colIndex];
    const nonRowSpannedRowId = findNonRowSpannedCell(apiRef, rowId, field, rowSpanScanDirection);
    const rowIndexRelativeToAllRows = visibleSortedRows.findIndex((row) => row.id === nonRowSpannedRowId);
    logger.debug(`Navigating to cell row ${rowIndexRelativeToAllRows}, col ${colIndex}`);
    apiRef.current.scrollToIndexes({
      colIndex,
      rowIndex: rowIndexRelativeToAllRows
    });
    apiRef.current.setCellFocus(nonRowSpannedRowId, field);
  }, [apiRef, logger, listView]);
  const goToHeader = reactExports.useCallback((colIndex, event) => {
    logger.debug(`Navigating to header col ${colIndex}`);
    apiRef.current.scrollToIndexes({
      colIndex
    });
    const field = apiRef.current.getVisibleColumns()[colIndex].field;
    apiRef.current.setColumnHeaderFocus(field, event);
  }, [apiRef, logger]);
  const goToHeaderFilter = reactExports.useCallback((colIndex, event) => {
    logger.debug(`Navigating to header filter col ${colIndex}`);
    apiRef.current.scrollToIndexes({
      colIndex
    });
    const field = apiRef.current.getVisibleColumns()[colIndex].field;
    apiRef.current.setColumnHeaderFilterFocus(field, event);
  }, [apiRef, logger]);
  const goToGroupHeader = reactExports.useCallback((colIndex, depth, event) => {
    logger.debug(`Navigating to header col ${colIndex}`);
    apiRef.current.scrollToIndexes({
      colIndex
    });
    const {
      field
    } = apiRef.current.getVisibleColumns()[colIndex];
    apiRef.current.setColumnGroupHeaderFocus(field, depth, event);
  }, [apiRef, logger]);
  const getRowIdFromIndex = reactExports.useCallback((rowIndex) => {
    var _a2;
    return (_a2 = currentPageRows[rowIndex]) == null ? void 0 : _a2.id;
  }, [currentPageRows]);
  const handleColumnHeaderKeyDown = reactExports.useCallback((params, event) => {
    const headerTitleNode = event.currentTarget.querySelector(`.${gridClasses.columnHeaderTitleContainerContent}`);
    const isFromInsideContent = !!headerTitleNode && headerTitleNode.contains(event.target);
    if (isFromInsideContent && params.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field) {
      return;
    }
    const viewportPageSize = apiRef.current.getViewportPageSize();
    const colIndexBefore = params.field ? apiRef.current.getColumnIndex(params.field) : 0;
    const firstRowIndexInPage = currentPageRows.length > 0 ? 0 : null;
    const lastRowIndexInPage = currentPageRows.length - 1;
    const firstColIndex = 0;
    const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;
    const columnGroupMaxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);
    let shouldPreventDefault = true;
    switch (event.key) {
      case "ArrowDown": {
        if (firstRowIndexInPage !== null) {
          if (headerFilteringEnabled) {
            goToHeaderFilter(colIndexBefore, event);
          } else {
            goToCell(colIndexBefore, getRowIdFromIndex(firstRowIndexInPage));
          }
        }
        break;
      }
      case "ArrowRight": {
        const rightColIndex = getRightColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          isRtl
        });
        if (rightColIndex !== null) {
          goToHeader(rightColIndex, event);
        }
        break;
      }
      case "ArrowLeft": {
        const leftColIndex = getLeftColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          isRtl
        });
        if (leftColIndex !== null) {
          goToHeader(leftColIndex, event);
        }
        break;
      }
      case "ArrowUp": {
        if (columnGroupMaxDepth > 0) {
          goToGroupHeader(colIndexBefore, columnGroupMaxDepth - 1, event);
        }
        break;
      }
      case "PageDown": {
        if (firstRowIndexInPage !== null && lastRowIndexInPage !== null) {
          goToCell(colIndexBefore, getRowIdFromIndex(Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage)));
        }
        break;
      }
      case "Home": {
        goToHeader(firstColIndex, event);
        break;
      }
      case "End": {
        goToHeader(lastColIndex, event);
        break;
      }
      case "Enter": {
        if (event.ctrlKey || event.metaKey) {
          apiRef.current.toggleColumnMenu(params.field);
        }
        break;
      }
      case " ": {
        break;
      }
      default: {
        shouldPreventDefault = false;
      }
    }
    if (shouldPreventDefault) {
      event.preventDefault();
    }
  }, [apiRef, currentPageRows.length, headerFilteringEnabled, goToHeaderFilter, goToCell, getRowIdFromIndex, isRtl, goToHeader, goToGroupHeader]);
  const handleHeaderFilterKeyDown = reactExports.useCallback((params, event) => {
    const isEditing = gridHeaderFilteringEditFieldSelector(apiRef) === params.field;
    const isHeaderMenuOpen = gridHeaderFilteringMenuSelector(apiRef) === params.field;
    if (isEditing || isHeaderMenuOpen || !isNavigationKey(event.key)) {
      return;
    }
    const viewportPageSize = apiRef.current.getViewportPageSize();
    const colIndexBefore = params.field ? apiRef.current.getColumnIndex(params.field) : 0;
    const firstRowIndexInPage = 0;
    const lastRowIndexInPage = currentPageRows.length - 1;
    const firstColIndex = 0;
    const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;
    let shouldPreventDefault = true;
    switch (event.key) {
      case "ArrowDown": {
        const rowId = getRowIdFromIndex(firstRowIndexInPage);
        if (rowId != null) {
          goToCell(colIndexBefore, rowId);
        }
        break;
      }
      case "ArrowRight": {
        const rightColIndex = getRightColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          isRtl
        });
        if (rightColIndex !== null) {
          goToHeaderFilter(rightColIndex, event);
        }
        break;
      }
      case "ArrowLeft": {
        const leftColIndex = getLeftColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          isRtl
        });
        if (leftColIndex !== null) {
          goToHeaderFilter(leftColIndex, event);
        } else {
          apiRef.current.setColumnHeaderFilterFocus(params.field, event);
        }
        break;
      }
      case "ArrowUp": {
        goToHeader(colIndexBefore, event);
        break;
      }
      case "PageDown": {
        if (lastRowIndexInPage !== null) {
          goToCell(colIndexBefore, getRowIdFromIndex(Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage)));
        }
        break;
      }
      case "Home": {
        goToHeaderFilter(firstColIndex, event);
        break;
      }
      case "End": {
        goToHeaderFilter(lastColIndex, event);
        break;
      }
      case " ": {
        break;
      }
      default: {
        shouldPreventDefault = false;
      }
    }
    if (shouldPreventDefault) {
      event.preventDefault();
    }
  }, [apiRef, currentPageRows.length, goToHeaderFilter, isRtl, goToHeader, goToCell, getRowIdFromIndex]);
  const handleColumnGroupHeaderKeyDown = reactExports.useCallback((params, event) => {
    const focusedColumnGroup = gridFocusColumnGroupHeaderSelector(apiRef);
    if (focusedColumnGroup === null) {
      return;
    }
    const {
      field: currentField,
      depth: currentDepth
    } = focusedColumnGroup;
    const {
      fields: fields2,
      depth,
      maxDepth
    } = params;
    const viewportPageSize = apiRef.current.getViewportPageSize();
    const currentColIndex = apiRef.current.getColumnIndex(currentField);
    const colIndexBefore = currentField ? apiRef.current.getColumnIndex(currentField) : 0;
    const firstRowIndexInPage = 0;
    const lastRowIndexInPage = currentPageRows.length - 1;
    const firstColIndex = 0;
    const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;
    let shouldPreventDefault = true;
    switch (event.key) {
      case "ArrowDown": {
        if (depth === maxDepth - 1) {
          goToHeader(currentColIndex, event);
        } else {
          goToGroupHeader(currentColIndex, currentDepth + 1, event);
        }
        break;
      }
      case "ArrowUp": {
        if (depth > 0) {
          goToGroupHeader(currentColIndex, currentDepth - 1, event);
        }
        break;
      }
      case "ArrowRight": {
        const remainingRightColumns = fields2.length - fields2.indexOf(currentField) - 1;
        if (currentColIndex + remainingRightColumns + 1 <= lastColIndex) {
          goToGroupHeader(currentColIndex + remainingRightColumns + 1, currentDepth, event);
        }
        break;
      }
      case "ArrowLeft": {
        const remainingLeftColumns = fields2.indexOf(currentField);
        if (currentColIndex - remainingLeftColumns - 1 >= firstColIndex) {
          goToGroupHeader(currentColIndex - remainingLeftColumns - 1, currentDepth, event);
        }
        break;
      }
      case "PageDown": {
        if (lastRowIndexInPage !== null) {
          goToCell(colIndexBefore, getRowIdFromIndex(Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage)));
        }
        break;
      }
      case "Home": {
        goToGroupHeader(firstColIndex, currentDepth, event);
        break;
      }
      case "End": {
        goToGroupHeader(lastColIndex, currentDepth, event);
        break;
      }
      case " ": {
        break;
      }
      default: {
        shouldPreventDefault = false;
      }
    }
    if (shouldPreventDefault) {
      event.preventDefault();
    }
  }, [apiRef, currentPageRows.length, goToHeader, goToGroupHeader, goToCell, getRowIdFromIndex]);
  const handleCellKeyDown = reactExports.useCallback((params, event) => {
    if (isEventTargetInPortal(event)) {
      return;
    }
    const cellParams = apiRef.current.getCellParams(params.id, params.field);
    if (cellParams.cellMode === GridCellModes.Edit || !isNavigationKey(event.key)) {
      return;
    }
    const canUpdateFocus = apiRef.current.unstable_applyPipeProcessors("canUpdateFocus", true, {
      event,
      cell: cellParams
    });
    if (!canUpdateFocus) {
      return;
    }
    if (currentPageRows.length === 0) {
      return;
    }
    const viewportPageSize = apiRef.current.getViewportPageSize();
    const getColumnIndexFn = listView ? () => 0 : apiRef.current.getColumnIndex;
    const colIndexBefore = params.field ? getColumnIndexFn(params.field) : 0;
    const rowIndexBefore = currentPageRows.findIndex((row) => row.id === params.id);
    const firstRowIndexInPage = 0;
    const lastRowIndexInPage = currentPageRows.length - 1;
    const firstColIndex = 0;
    const visibleColumns = listView ? [gridListColumnSelector(apiRef.current.state)] : gridVisibleColumnDefinitionsSelector(apiRef);
    const lastColIndex = visibleColumns.length - 1;
    let shouldPreventDefault = true;
    switch (event.key) {
      case "ArrowDown": {
        if (rowIndexBefore < lastRowIndexInPage) {
          goToCell(colIndexBefore, getRowIdFromIndex(rowIndexBefore + 1), isRtl ? "right" : "left", "down");
        }
        break;
      }
      case "ArrowUp": {
        if (rowIndexBefore > firstRowIndexInPage) {
          goToCell(colIndexBefore, getRowIdFromIndex(rowIndexBefore - 1));
        } else if (headerFilteringEnabled) {
          goToHeaderFilter(colIndexBefore, event);
        } else {
          goToHeader(colIndexBefore, event);
        }
        break;
      }
      case "ArrowRight": {
        const rightColIndex = getRightColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          isRtl
        });
        if (rightColIndex !== null) {
          goToCell(rightColIndex, getRowIdFromIndex(rowIndexBefore), isRtl ? "left" : "right");
        }
        break;
      }
      case "ArrowLeft": {
        const leftColIndex = getLeftColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          isRtl
        });
        if (leftColIndex !== null) {
          goToCell(leftColIndex, getRowIdFromIndex(rowIndexBefore), isRtl ? "right" : "left");
        }
        break;
      }
      case "Tab": {
        if (event.shiftKey && colIndexBefore > firstColIndex) {
          goToCell(colIndexBefore - 1, getRowIdFromIndex(rowIndexBefore), "left");
        } else if (!event.shiftKey && colIndexBefore < lastColIndex) {
          goToCell(colIndexBefore + 1, getRowIdFromIndex(rowIndexBefore), "right");
        }
        break;
      }
      case " ": {
        const field = params.field;
        if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
          break;
        }
        const colDef = params.colDef;
        if (colDef && (colDef.field === GRID_TREE_DATA_GROUPING_FIELD || isGroupingColumn(colDef.field))) {
          break;
        }
        if (!event.shiftKey && rowIndexBefore < lastRowIndexInPage) {
          goToCell(colIndexBefore, getRowIdFromIndex(Math.min(rowIndexBefore + viewportPageSize, lastRowIndexInPage)));
        }
        break;
      }
      case "PageDown": {
        if (rowIndexBefore < lastRowIndexInPage) {
          goToCell(colIndexBefore, getRowIdFromIndex(Math.min(rowIndexBefore + viewportPageSize, lastRowIndexInPage)));
        }
        break;
      }
      case "PageUp": {
        const nextRowIndex = Math.max(rowIndexBefore - viewportPageSize, firstRowIndexInPage);
        if (nextRowIndex !== rowIndexBefore && nextRowIndex >= firstRowIndexInPage) {
          goToCell(colIndexBefore, getRowIdFromIndex(nextRowIndex));
        } else {
          goToHeader(colIndexBefore, event);
        }
        break;
      }
      case "Home": {
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          goToCell(firstColIndex, getRowIdFromIndex(firstRowIndexInPage));
        } else {
          goToCell(firstColIndex, getRowIdFromIndex(rowIndexBefore));
        }
        break;
      }
      case "End": {
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          goToCell(lastColIndex, getRowIdFromIndex(lastRowIndexInPage));
        } else {
          goToCell(lastColIndex, getRowIdFromIndex(rowIndexBefore));
        }
        break;
      }
      default: {
        shouldPreventDefault = false;
      }
    }
    if (shouldPreventDefault) {
      event.preventDefault();
    }
  }, [apiRef, currentPageRows, isRtl, goToCell, getRowIdFromIndex, headerFilteringEnabled, goToHeaderFilter, goToHeader, listView]);
  const checkIfCanStartEditing = reactExports.useCallback((initialValue, {
    event
  }) => {
    if (event.key === " ") {
      return false;
    }
    return initialValue;
  }, []);
  useGridRegisterPipeProcessor(apiRef, "canStartEditing", checkIfCanStartEditing);
  useGridApiEventHandler(apiRef, "columnHeaderKeyDown", handleColumnHeaderKeyDown);
  useGridApiEventHandler(apiRef, "headerFilterKeyDown", handleHeaderFilterKeyDown);
  useGridApiEventHandler(apiRef, "columnGroupHeaderKeyDown", handleColumnGroupHeaderKeyDown);
  useGridApiEventHandler(apiRef, "cellKeyDown", handleCellKeyDown);
}, "useGridKeyboardNavigation");
const useGridRowCount = /* @__PURE__ */ __name((apiRef, props) => {
  var _a2, _b2;
  const logger = useGridLogger(apiRef, "useGridRowCount");
  const visibleTopLevelRowCount = useGridSelector(apiRef, gridFilteredTopLevelRowCountSelector);
  const rowCountState = useGridSelector(apiRef, gridPaginationRowCountSelector);
  const paginationMeta = useGridSelector(apiRef, gridPaginationMetaSelector);
  const paginationModel = useGridSelector(apiRef, gridPaginationModelSelector);
  const previousPageSize = useLazyRef(() => gridPaginationModelSelector(apiRef).pageSize);
  apiRef.current.registerControlState({
    stateId: "paginationRowCount",
    propModel: props.rowCount,
    propOnChange: props.onRowCountChange,
    stateSelector: gridPaginationRowCountSelector,
    changeEvent: "rowCountChange"
  });
  const setRowCount = reactExports.useCallback((newRowCount) => {
    if (rowCountState === newRowCount) {
      return;
    }
    logger.debug("Setting 'rowCount' to", newRowCount);
    apiRef.current.setState((state) => _extends$4({}, state, {
      pagination: _extends$4({}, state.pagination, {
        rowCount: newRowCount
      })
    }));
  }, [apiRef, logger, rowCountState]);
  const paginationRowCountApi = {
    setRowCount
  };
  useGridApiMethod(apiRef, paginationRowCountApi, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _a3, _b3;
    const exportedRowCount = gridPaginationRowCountSelector(apiRef);
    const shouldExportRowCount = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the `rowCount` is controlled
      props.rowCount != null || // Always export if the `rowCount` has been initialized
      ((_b3 = (_a3 = props.initialState) == null ? void 0 : _a3.pagination) == null ? void 0 : _b3.rowCount) != null
    );
    if (!shouldExportRowCount) {
      return prevState;
    }
    return _extends$4({}, prevState, {
      pagination: _extends$4({}, prevState.pagination, {
        rowCount: exportedRowCount
      })
    });
  }, [apiRef, props.rowCount, (_b2 = (_a2 = props.initialState) == null ? void 0 : _a2.pagination) == null ? void 0 : _b2.rowCount]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _a3;
    const restoredRowCount = ((_a3 = context.stateToRestore.pagination) == null ? void 0 : _a3.rowCount) ? context.stateToRestore.pagination.rowCount : gridPaginationRowCountSelector(apiRef);
    apiRef.current.setState((state) => _extends$4({}, state, {
      pagination: _extends$4({}, state.pagination, {
        rowCount: restoredRowCount
      })
    }));
    return params;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  const handlePaginationModelChange = reactExports.useCallback((model) => {
    if (props.paginationMode === "client" || !previousPageSize.current) {
      return;
    }
    if (model.pageSize !== previousPageSize.current) {
      previousPageSize.current = model.pageSize;
      if (rowCountState === -1) {
        apiRef.current.setPage(0);
      }
    }
  }, [props.paginationMode, previousPageSize, rowCountState, apiRef]);
  useGridApiEventHandler(apiRef, "paginationModelChange", handlePaginationModelChange);
  reactExports.useEffect(() => {
    if (props.paginationMode === "client") {
      apiRef.current.setRowCount(visibleTopLevelRowCount);
    } else if (props.rowCount != null) {
      apiRef.current.setRowCount(props.rowCount);
    }
  }, [apiRef, props.paginationMode, visibleTopLevelRowCount, props.rowCount]);
  const isLastPage = paginationMeta.hasNextPage === false;
  reactExports.useEffect(() => {
    if (isLastPage && rowCountState === -1) {
      apiRef.current.setRowCount(paginationModel.pageSize * paginationModel.page + visibleTopLevelRowCount);
    }
  }, [apiRef, visibleTopLevelRowCount, isLastPage, rowCountState, paginationModel]);
}, "useGridRowCount");
const useGridPaginationMeta = /* @__PURE__ */ __name((apiRef, props) => {
  var _a2, _b2;
  const logger = useGridLogger(apiRef, "useGridPaginationMeta");
  const paginationMeta = useGridSelector(apiRef, gridPaginationMetaSelector);
  apiRef.current.registerControlState({
    stateId: "paginationMeta",
    propModel: props.paginationMeta,
    propOnChange: props.onPaginationMetaChange,
    stateSelector: gridPaginationMetaSelector,
    changeEvent: "paginationMetaChange"
  });
  const setPaginationMeta = reactExports.useCallback((newPaginationMeta) => {
    if (paginationMeta === newPaginationMeta) {
      return;
    }
    logger.debug("Setting 'paginationMeta' to", newPaginationMeta);
    apiRef.current.setState((state) => _extends$4({}, state, {
      pagination: _extends$4({}, state.pagination, {
        meta: newPaginationMeta
      })
    }));
  }, [apiRef, logger, paginationMeta]);
  const paginationMetaApi = {
    setPaginationMeta
  };
  useGridApiMethod(apiRef, paginationMetaApi, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _a3, _b3;
    const exportedPaginationMeta = gridPaginationMetaSelector(apiRef);
    const shouldExportRowCount = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the `paginationMeta` is controlled
      props.paginationMeta != null || // Always export if the `paginationMeta` has been initialized
      ((_b3 = (_a3 = props.initialState) == null ? void 0 : _a3.pagination) == null ? void 0 : _b3.meta) != null
    );
    if (!shouldExportRowCount) {
      return prevState;
    }
    return _extends$4({}, prevState, {
      pagination: _extends$4({}, prevState.pagination, {
        meta: exportedPaginationMeta
      })
    });
  }, [apiRef, props.paginationMeta, (_b2 = (_a2 = props.initialState) == null ? void 0 : _a2.pagination) == null ? void 0 : _b2.meta]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _a3;
    const restoredPaginationMeta = ((_a3 = context.stateToRestore.pagination) == null ? void 0 : _a3.meta) ? context.stateToRestore.pagination.meta : gridPaginationMetaSelector(apiRef);
    apiRef.current.setState((state) => _extends$4({}, state, {
      pagination: _extends$4({}, state.pagination, {
        meta: restoredPaginationMeta
      })
    }));
    return params;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  reactExports.useEffect(() => {
    if (props.paginationMeta) {
      apiRef.current.setPaginationMeta(props.paginationMeta);
    }
  }, [apiRef, props.paginationMeta]);
}, "useGridPaginationMeta");
const paginationStateInitializer = /* @__PURE__ */ __name((state, props) => {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const paginationModel = _extends$4({}, getDefaultGridPaginationModel(props.autoPageSize), props.paginationModel ?? ((_b2 = (_a2 = props.initialState) == null ? void 0 : _a2.pagination) == null ? void 0 : _b2.paginationModel));
  throwIfPageSizeExceedsTheLimit(paginationModel.pageSize, props.signature);
  const rowCount = props.rowCount ?? ((_d2 = (_c2 = props.initialState) == null ? void 0 : _c2.pagination) == null ? void 0 : _d2.rowCount);
  const meta = props.paginationMeta ?? ((_f2 = (_e2 = props.initialState) == null ? void 0 : _e2.pagination) == null ? void 0 : _f2.meta) ?? {};
  return _extends$4({}, state, {
    pagination: {
      paginationModel,
      rowCount,
      meta
    }
  });
}, "paginationStateInitializer");
const useGridPagination = /* @__PURE__ */ __name((apiRef, props) => {
  useGridPaginationMeta(apiRef, props);
  useGridPaginationModel(apiRef, props);
  useGridRowCount(apiRef, props);
}, "useGridPagination");
const preferencePanelStateInitializer = /* @__PURE__ */ __name((state, props) => {
  var _a2;
  return _extends$4({}, state, {
    preferencePanel: ((_a2 = props.initialState) == null ? void 0 : _a2.preferencePanel) ?? {
      open: false
    }
  });
}, "preferencePanelStateInitializer");
const useGridPreferencesPanel = /* @__PURE__ */ __name((apiRef, props) => {
  var _a2;
  const logger = useGridLogger(apiRef, "useGridPreferencesPanel");
  const hideTimeout = reactExports.useRef();
  const immediateTimeout = reactExports.useRef();
  const hidePreferences = reactExports.useCallback(() => {
    logger.debug("Hiding Preferences Panel");
    const preferencePanelState = gridPreferencePanelStateSelector(apiRef.current.state);
    if (preferencePanelState.openedPanelValue) {
      apiRef.current.publishEvent("preferencePanelClose", {
        openedPanelValue: preferencePanelState.openedPanelValue
      });
    }
    apiRef.current.setState((state) => _extends$4({}, state, {
      preferencePanel: {
        open: false
      }
    }));
    apiRef.current.forceUpdate();
  }, [apiRef, logger]);
  const doNotHidePanel = reactExports.useCallback(() => {
    immediateTimeout.current = setTimeout(() => clearTimeout(hideTimeout.current), 0);
  }, []);
  const hidePreferencesDelayed = reactExports.useCallback(() => {
    hideTimeout.current = setTimeout(hidePreferences, 100);
  }, [hidePreferences]);
  const showPreferences = reactExports.useCallback((newValue, panelId, labelId) => {
    logger.debug("Opening Preferences Panel");
    doNotHidePanel();
    apiRef.current.setState((state) => _extends$4({}, state, {
      preferencePanel: _extends$4({}, state.preferencePanel, {
        open: true,
        openedPanelValue: newValue,
        panelId,
        labelId
      })
    }));
    apiRef.current.publishEvent("preferencePanelOpen", {
      openedPanelValue: newValue
    });
    apiRef.current.forceUpdate();
  }, [logger, doNotHidePanel, apiRef]);
  useGridApiMethod(apiRef, {
    showPreferences,
    hidePreferences: hidePreferencesDelayed
  }, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _a3;
    const preferencePanelToExport = gridPreferencePanelStateSelector(apiRef.current.state);
    const shouldExportPreferencePanel = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the panel was initialized
      ((_a3 = props.initialState) == null ? void 0 : _a3.preferencePanel) != null || // Always export if the panel is opened
      preferencePanelToExport.open
    );
    if (!shouldExportPreferencePanel) {
      return prevState;
    }
    return _extends$4({}, prevState, {
      preferencePanel: preferencePanelToExport
    });
  }, [apiRef, (_a2 = props.initialState) == null ? void 0 : _a2.preferencePanel]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    const preferencePanel = context.stateToRestore.preferencePanel;
    if (preferencePanel != null) {
      apiRef.current.setState((state) => _extends$4({}, state, {
        preferencePanel
      }));
    }
    return params;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(hideTimeout.current);
      clearTimeout(immediateTimeout.current);
    };
  }, []);
}, "useGridPreferencesPanel");
const getDefaultCellValue = /* @__PURE__ */ __name((colDef) => {
  switch (colDef.type) {
    case "boolean":
      return false;
    case "date":
    case "dateTime":
    case "number":
      return void 0;
    case "singleSelect":
      return null;
    case "string":
    default:
      return "";
  }
}, "getDefaultCellValue");
const _excluded$p = ["id", "field"], _excluded2$3 = ["id", "field"];
const useGridCellEditing = /* @__PURE__ */ __name((apiRef, props) => {
  const [cellModesModel, setCellModesModel] = reactExports.useState({});
  const cellModesModelRef = reactExports.useRef(cellModesModel);
  const prevCellModesModel = reactExports.useRef({});
  const {
    processRowUpdate,
    onProcessRowUpdateError,
    cellModesModel: cellModesModelProp,
    onCellModesModelChange
  } = props;
  const runIfEditModeIsCell = /* @__PURE__ */ __name((callback) => (...args) => {
    if (props.editMode === GridEditModes.Cell) {
      callback(...args);
    }
  }, "runIfEditModeIsCell");
  const throwIfNotEditable = reactExports.useCallback((id2, field) => {
    const params = apiRef.current.getCellParams(id2, field);
    if (!apiRef.current.isCellEditable(params)) {
      throw new Error(`MUI X: The cell with id=${id2} and field=${field} is not editable.`);
    }
  }, [apiRef]);
  const throwIfNotInMode = reactExports.useCallback((id2, field, mode) => {
    if (apiRef.current.getCellMode(id2, field) !== mode) {
      throw new Error(`MUI X: The cell with id=${id2} and field=${field} is not in ${mode} mode.`);
    }
  }, [apiRef]);
  const handleCellDoubleClick = reactExports.useCallback((params, event) => {
    if (!params.isEditable) {
      return;
    }
    if (params.cellMode === GridCellModes.Edit) {
      return;
    }
    const newParams = _extends$4({}, params, {
      reason: GridCellEditStartReasons.cellDoubleClick
    });
    apiRef.current.publishEvent("cellEditStart", newParams, event);
  }, [apiRef]);
  const handleCellFocusOut = reactExports.useCallback((params, event) => {
    if (params.cellMode === GridCellModes.View) {
      return;
    }
    if (apiRef.current.getCellMode(params.id, params.field) === GridCellModes.View) {
      return;
    }
    const newParams = _extends$4({}, params, {
      reason: GridCellEditStopReasons.cellFocusOut
    });
    apiRef.current.publishEvent("cellEditStop", newParams, event);
  }, [apiRef]);
  const handleCellKeyDown = reactExports.useCallback((params, event) => {
    if (params.cellMode === GridCellModes.Edit) {
      if (event.which === 229) {
        return;
      }
      let reason;
      if (event.key === "Escape") {
        reason = GridCellEditStopReasons.escapeKeyDown;
      } else if (event.key === "Enter") {
        reason = GridCellEditStopReasons.enterKeyDown;
      } else if (event.key === "Tab") {
        reason = event.shiftKey ? GridCellEditStopReasons.shiftTabKeyDown : GridCellEditStopReasons.tabKeyDown;
        event.preventDefault();
      }
      if (reason) {
        const newParams = _extends$4({}, params, {
          reason
        });
        apiRef.current.publishEvent("cellEditStop", newParams, event);
      }
    } else if (params.isEditable) {
      let reason;
      const canStartEditing = apiRef.current.unstable_applyPipeProcessors("canStartEditing", true, {
        event,
        cellParams: params,
        editMode: "cell"
      });
      if (!canStartEditing) {
        return;
      }
      if (isPrintableKey(event)) {
        reason = GridCellEditStartReasons.printableKeyDown;
      } else if (isPasteShortcut(event)) {
        reason = GridCellEditStartReasons.pasteKeyDown;
      } else if (event.key === "Enter") {
        reason = GridCellEditStartReasons.enterKeyDown;
      } else if (event.key === "Backspace" || event.key === "Delete") {
        reason = GridCellEditStartReasons.deleteKeyDown;
      }
      if (reason) {
        const newParams = _extends$4({}, params, {
          reason,
          key: event.key
        });
        apiRef.current.publishEvent("cellEditStart", newParams, event);
      }
    }
  }, [apiRef]);
  const handleCellEditStart = reactExports.useCallback((params) => {
    const {
      id: id2,
      field,
      reason
    } = params;
    const startCellEditModeParams = {
      id: id2,
      field
    };
    if (reason === GridCellEditStartReasons.printableKeyDown || reason === GridCellEditStartReasons.deleteKeyDown || reason === GridCellEditStartReasons.pasteKeyDown) {
      startCellEditModeParams.deleteValue = true;
    }
    apiRef.current.startCellEditMode(startCellEditModeParams);
  }, [apiRef]);
  const handleCellEditStop = reactExports.useCallback((params) => {
    const {
      id: id2,
      field,
      reason
    } = params;
    apiRef.current.runPendingEditCellValueMutation(id2, field);
    let cellToFocusAfter;
    if (reason === GridCellEditStopReasons.enterKeyDown) {
      cellToFocusAfter = "below";
    } else if (reason === GridCellEditStopReasons.tabKeyDown) {
      cellToFocusAfter = "right";
    } else if (reason === GridCellEditStopReasons.shiftTabKeyDown) {
      cellToFocusAfter = "left";
    }
    const ignoreModifications = reason === "escapeKeyDown";
    apiRef.current.stopCellEditMode({
      id: id2,
      field,
      ignoreModifications,
      cellToFocusAfter
    });
  }, [apiRef]);
  const runIfNoFieldErrors = /* @__PURE__ */ __name((callback) => async (...args) => {
    var _a2;
    if (callback) {
      const {
        id: id2,
        field
      } = args[0];
      const editRowsState = apiRef.current.state.editRows;
      const hasFieldErrors = (_a2 = editRowsState[id2][field]) == null ? void 0 : _a2.error;
      if (!hasFieldErrors) {
        callback(...args);
      }
    }
  }, "runIfNoFieldErrors");
  useGridApiEventHandler(apiRef, "cellDoubleClick", runIfEditModeIsCell(handleCellDoubleClick));
  useGridApiEventHandler(apiRef, "cellFocusOut", runIfEditModeIsCell(handleCellFocusOut));
  useGridApiEventHandler(apiRef, "cellKeyDown", runIfEditModeIsCell(handleCellKeyDown));
  useGridApiEventHandler(apiRef, "cellEditStart", runIfEditModeIsCell(handleCellEditStart));
  useGridApiEventHandler(apiRef, "cellEditStop", runIfEditModeIsCell(handleCellEditStop));
  useGridApiOptionHandler(apiRef, "cellEditStart", props.onCellEditStart);
  useGridApiOptionHandler(apiRef, "cellEditStop", runIfNoFieldErrors(props.onCellEditStop));
  const getCellMode = reactExports.useCallback((id2, field) => {
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const isEditing = editingState[id2] && editingState[id2][field];
    return isEditing ? GridCellModes.Edit : GridCellModes.View;
  }, [apiRef]);
  const updateCellModesModel = useEventCallback((newModel) => {
    const isNewModelDifferentFromProp = newModel !== props.cellModesModel;
    if (onCellModesModelChange && isNewModelDifferentFromProp) {
      onCellModesModelChange(newModel, {
        api: apiRef.current
      });
    }
    if (props.cellModesModel && isNewModelDifferentFromProp) {
      return;
    }
    setCellModesModel(newModel);
    cellModesModelRef.current = newModel;
    apiRef.current.publishEvent("cellModesModelChange", newModel);
  });
  const updateFieldInCellModesModel = reactExports.useCallback((id2, field, newProps) => {
    const newModel = _extends$4({}, cellModesModelRef.current);
    if (newProps !== null) {
      newModel[id2] = _extends$4({}, newModel[id2], {
        [field]: _extends$4({}, newProps)
      });
    } else {
      const _newModel$id = newModel[id2], otherFields = _objectWithoutPropertiesLoose$1(_newModel$id, [field].map(toPropertyKey));
      newModel[id2] = otherFields;
      if (Object.keys(newModel[id2]).length === 0) {
        delete newModel[id2];
      }
    }
    updateCellModesModel(newModel);
  }, [updateCellModesModel]);
  const updateOrDeleteFieldState = reactExports.useCallback((id2, field, newProps) => {
    apiRef.current.setState((state) => {
      const newEditingState = _extends$4({}, state.editRows);
      if (newProps !== null) {
        newEditingState[id2] = _extends$4({}, newEditingState[id2], {
          [field]: _extends$4({}, newProps)
        });
      } else {
        delete newEditingState[id2][field];
        if (Object.keys(newEditingState[id2]).length === 0) {
          delete newEditingState[id2];
        }
      }
      return _extends$4({}, state, {
        editRows: newEditingState
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const startCellEditMode = reactExports.useCallback((params) => {
    const {
      id: id2,
      field
    } = params, other = _objectWithoutPropertiesLoose$1(params, _excluded$p);
    throwIfNotEditable(id2, field);
    throwIfNotInMode(id2, field, GridCellModes.View);
    updateFieldInCellModesModel(id2, field, _extends$4({
      mode: GridCellModes.Edit
    }, other));
  }, [throwIfNotEditable, throwIfNotInMode, updateFieldInCellModesModel]);
  const updateStateToStartCellEditMode = useEventCallback(async (params) => {
    const {
      id: id2,
      field,
      deleteValue,
      initialValue
    } = params;
    const value = apiRef.current.getCellValue(id2, field);
    let newValue = value;
    if (deleteValue) {
      newValue = getDefaultCellValue(apiRef.current.getColumn(field));
    } else if (initialValue) {
      newValue = initialValue;
    }
    const column2 = apiRef.current.getColumn(field);
    const shouldProcessEditCellProps = !!column2.preProcessEditCellProps && deleteValue;
    let newProps = {
      value: newValue,
      error: false,
      isProcessingProps: shouldProcessEditCellProps
    };
    updateOrDeleteFieldState(id2, field, newProps);
    apiRef.current.setCellFocus(id2, field);
    if (shouldProcessEditCellProps) {
      newProps = await Promise.resolve(column2.preProcessEditCellProps({
        id: id2,
        row: apiRef.current.getRow(id2),
        props: newProps,
        hasChanged: newValue !== value
      }));
      if (apiRef.current.getCellMode(id2, field) === GridCellModes.Edit) {
        const editingState = gridEditRowsStateSelector(apiRef.current.state);
        updateOrDeleteFieldState(id2, field, _extends$4({}, newProps, {
          value: editingState[id2][field].value,
          isProcessingProps: false
        }));
      }
    }
  });
  const stopCellEditMode = reactExports.useCallback((params) => {
    const {
      id: id2,
      field
    } = params, other = _objectWithoutPropertiesLoose$1(params, _excluded2$3);
    throwIfNotInMode(id2, field, GridCellModes.Edit);
    updateFieldInCellModesModel(id2, field, _extends$4({
      mode: GridCellModes.View
    }, other));
  }, [throwIfNotInMode, updateFieldInCellModesModel]);
  const updateStateToStopCellEditMode = useEventCallback(async (params) => {
    const {
      id: id2,
      field,
      ignoreModifications,
      cellToFocusAfter = "none"
    } = params;
    throwIfNotInMode(id2, field, GridCellModes.Edit);
    apiRef.current.runPendingEditCellValueMutation(id2, field);
    const finishCellEditMode = /* @__PURE__ */ __name(() => {
      updateOrDeleteFieldState(id2, field, null);
      updateFieldInCellModesModel(id2, field, null);
      if (cellToFocusAfter !== "none") {
        apiRef.current.moveFocusToRelativeCell(id2, field, cellToFocusAfter);
      }
    }, "finishCellEditMode");
    if (ignoreModifications) {
      finishCellEditMode();
      return;
    }
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const {
      error,
      isProcessingProps
    } = editingState[id2][field];
    if (error || isProcessingProps) {
      prevCellModesModel.current[id2][field].mode = GridCellModes.Edit;
      updateFieldInCellModesModel(id2, field, {
        mode: GridCellModes.Edit
      });
      return;
    }
    const rowUpdate = apiRef.current.getRowWithUpdatedValuesFromCellEditing(id2, field);
    if (processRowUpdate) {
      const handleError = /* @__PURE__ */ __name((errorThrown) => {
        prevCellModesModel.current[id2][field].mode = GridCellModes.Edit;
        updateFieldInCellModesModel(id2, field, {
          mode: GridCellModes.Edit
        });
        if (onProcessRowUpdateError) {
          onProcessRowUpdateError(errorThrown);
        }
      }, "handleError");
      try {
        const row = apiRef.current.getRow(id2);
        Promise.resolve(processRowUpdate(rowUpdate, row, {
          rowId: id2
        })).then((finalRowUpdate) => {
          apiRef.current.updateRows([finalRowUpdate]);
          finishCellEditMode();
        }).catch(handleError);
      } catch (errorThrown) {
        handleError(errorThrown);
      }
    } else {
      apiRef.current.updateRows([rowUpdate]);
      finishCellEditMode();
    }
  });
  const setCellEditingEditCellValue = reactExports.useCallback(async (params) => {
    var _a2, _b2;
    const {
      id: id2,
      field,
      value,
      debounceMs,
      unstable_skipValueParser: skipValueParser
    } = params;
    throwIfNotEditable(id2, field);
    throwIfNotInMode(id2, field, GridCellModes.Edit);
    const column2 = apiRef.current.getColumn(field);
    const row = apiRef.current.getRow(id2);
    let parsedValue = value;
    if (column2.valueParser && !skipValueParser) {
      parsedValue = column2.valueParser(value, row, column2, apiRef);
    }
    let editingState = gridEditRowsStateSelector(apiRef.current.state);
    let newProps = _extends$4({}, editingState[id2][field], {
      value: parsedValue,
      changeReason: debounceMs ? "debouncedSetEditCellValue" : "setEditCellValue"
    });
    if (column2.preProcessEditCellProps) {
      const hasChanged = value !== editingState[id2][field].value;
      newProps = _extends$4({}, newProps, {
        isProcessingProps: true
      });
      updateOrDeleteFieldState(id2, field, newProps);
      newProps = await Promise.resolve(column2.preProcessEditCellProps({
        id: id2,
        row,
        props: newProps,
        hasChanged
      }));
    }
    if (apiRef.current.getCellMode(id2, field) === GridCellModes.View) {
      return false;
    }
    editingState = gridEditRowsStateSelector(apiRef.current.state);
    newProps = _extends$4({}, newProps, {
      isProcessingProps: false
    });
    newProps.value = column2.preProcessEditCellProps ? editingState[id2][field].value : parsedValue;
    updateOrDeleteFieldState(id2, field, newProps);
    editingState = gridEditRowsStateSelector(apiRef.current.state);
    return !((_b2 = (_a2 = editingState[id2]) == null ? void 0 : _a2[field]) == null ? void 0 : _b2.error);
  }, [apiRef, throwIfNotEditable, throwIfNotInMode, updateOrDeleteFieldState]);
  const getRowWithUpdatedValuesFromCellEditing = reactExports.useCallback((id2, field) => {
    const column2 = apiRef.current.getColumn(field);
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const row = apiRef.current.getRow(id2);
    if (!editingState[id2] || !editingState[id2][field]) {
      return apiRef.current.getRow(id2);
    }
    const {
      value
    } = editingState[id2][field];
    return column2.valueSetter ? column2.valueSetter(value, row, column2, apiRef) : _extends$4({}, row, {
      [field]: value
    });
  }, [apiRef]);
  const editingApi = {
    getCellMode,
    startCellEditMode,
    stopCellEditMode
  };
  const editingPrivateApi = {
    setCellEditingEditCellValue,
    getRowWithUpdatedValuesFromCellEditing
  };
  useGridApiMethod(apiRef, editingApi, "public");
  useGridApiMethod(apiRef, editingPrivateApi, "private");
  reactExports.useEffect(() => {
    if (cellModesModelProp) {
      updateCellModesModel(cellModesModelProp);
    }
  }, [cellModesModelProp, updateCellModesModel]);
  useEnhancedEffect(() => {
    const idToIdLookup = gridRowsDataRowIdToIdLookupSelector(apiRef);
    const copyOfPrevCellModes = prevCellModesModel.current;
    prevCellModesModel.current = deepClone(cellModesModel);
    Object.entries(cellModesModel).forEach(([id2, fields2]) => {
      Object.entries(fields2).forEach(([field, params]) => {
        var _a2, _b2;
        const prevMode = ((_b2 = (_a2 = copyOfPrevCellModes[id2]) == null ? void 0 : _a2[field]) == null ? void 0 : _b2.mode) || GridCellModes.View;
        const originalId = idToIdLookup[id2] ?? id2;
        if (params.mode === GridCellModes.Edit && prevMode === GridCellModes.View) {
          updateStateToStartCellEditMode(_extends$4({
            id: originalId,
            field
          }, params));
        } else if (params.mode === GridCellModes.View && prevMode === GridCellModes.Edit) {
          updateStateToStopCellEditMode(_extends$4({
            id: originalId,
            field
          }, params));
        }
      });
    });
  }, [apiRef, cellModesModel, updateStateToStartCellEditMode, updateStateToStopCellEditMode]);
}, "useGridCellEditing");
const _excluded$o = ["id"], _excluded2$2 = ["id"];
const useGridRowEditing = /* @__PURE__ */ __name((apiRef, props) => {
  const [rowModesModel, setRowModesModel] = reactExports.useState({});
  const rowModesModelRef = reactExports.useRef(rowModesModel);
  const prevRowModesModel = reactExports.useRef({});
  const focusTimeout = reactExports.useRef();
  const nextFocusedCell = reactExports.useRef(null);
  const {
    processRowUpdate,
    onProcessRowUpdateError,
    rowModesModel: rowModesModelProp,
    onRowModesModelChange
  } = props;
  const runIfEditModeIsRow = /* @__PURE__ */ __name((callback) => (...args) => {
    if (props.editMode === GridEditModes.Row) {
      callback(...args);
    }
  }, "runIfEditModeIsRow");
  const throwIfNotEditable = reactExports.useCallback((id2, field) => {
    const params = apiRef.current.getCellParams(id2, field);
    if (!apiRef.current.isCellEditable(params)) {
      throw new Error(`MUI X: The cell with id=${id2} and field=${field} is not editable.`);
    }
  }, [apiRef]);
  const throwIfNotInMode = reactExports.useCallback((id2, mode) => {
    if (apiRef.current.getRowMode(id2) !== mode) {
      throw new Error(`MUI X: The row with id=${id2} is not in ${mode} mode.`);
    }
  }, [apiRef]);
  const hasFieldsWithErrors = reactExports.useCallback((rowId) => {
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    return Object.values(editingState[rowId]).some((fieldProps) => fieldProps.error);
  }, [apiRef]);
  const handleCellDoubleClick = reactExports.useCallback((params, event) => {
    if (!params.isEditable) {
      return;
    }
    if (apiRef.current.getRowMode(params.id) === GridRowModes.Edit) {
      return;
    }
    const rowParams = apiRef.current.getRowParams(params.id);
    const newParams = _extends$4({}, rowParams, {
      field: params.field,
      reason: GridRowEditStartReasons.cellDoubleClick
    });
    apiRef.current.publishEvent("rowEditStart", newParams, event);
  }, [apiRef]);
  const handleCellFocusIn = reactExports.useCallback((params) => {
    nextFocusedCell.current = params;
  }, []);
  const handleCellFocusOut = reactExports.useCallback((params, event) => {
    if (!params.isEditable) {
      return;
    }
    if (apiRef.current.getRowMode(params.id) === GridRowModes.View) {
      return;
    }
    nextFocusedCell.current = null;
    focusTimeout.current = setTimeout(() => {
      var _a2;
      if (((_a2 = nextFocusedCell.current) == null ? void 0 : _a2.id) !== params.id) {
        if (!apiRef.current.getRow(params.id)) {
          return;
        }
        if (apiRef.current.getRowMode(params.id) === GridRowModes.View) {
          return;
        }
        if (hasFieldsWithErrors(params.id)) {
          return;
        }
        const rowParams = apiRef.current.getRowParams(params.id);
        const newParams = _extends$4({}, rowParams, {
          field: params.field,
          reason: GridRowEditStopReasons.rowFocusOut
        });
        apiRef.current.publishEvent("rowEditStop", newParams, event);
      }
    });
  }, [apiRef, hasFieldsWithErrors]);
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(focusTimeout.current);
    };
  }, []);
  const handleCellKeyDown = reactExports.useCallback((params, event) => {
    if (params.cellMode === GridRowModes.Edit) {
      if (event.which === 229) {
        return;
      }
      let reason;
      if (event.key === "Escape") {
        reason = GridRowEditStopReasons.escapeKeyDown;
      } else if (event.key === "Enter") {
        reason = GridRowEditStopReasons.enterKeyDown;
      } else if (event.key === "Tab") {
        const columnFields = gridVisibleColumnFieldsSelector(apiRef).filter((field) => {
          const column2 = apiRef.current.getColumn(field);
          if (column2.type === GRID_ACTIONS_COLUMN_TYPE) {
            return true;
          }
          return apiRef.current.isCellEditable(apiRef.current.getCellParams(params.id, field));
        });
        if (event.shiftKey) {
          if (params.field === columnFields[0]) {
            reason = GridRowEditStopReasons.shiftTabKeyDown;
          }
        } else if (params.field === columnFields[columnFields.length - 1]) {
          reason = GridRowEditStopReasons.tabKeyDown;
        }
        event.preventDefault();
        if (!reason) {
          const index2 = columnFields.findIndex((field) => field === params.field);
          const nextFieldToFocus = columnFields[event.shiftKey ? index2 - 1 : index2 + 1];
          apiRef.current.setCellFocus(params.id, nextFieldToFocus);
        }
      }
      if (reason) {
        if (reason !== GridRowEditStopReasons.escapeKeyDown && hasFieldsWithErrors(params.id)) {
          return;
        }
        const newParams = _extends$4({}, apiRef.current.getRowParams(params.id), {
          reason,
          field: params.field
        });
        apiRef.current.publishEvent("rowEditStop", newParams, event);
      }
    } else if (params.isEditable) {
      let reason;
      const canStartEditing = apiRef.current.unstable_applyPipeProcessors("canStartEditing", true, {
        event,
        cellParams: params,
        editMode: "row"
      });
      if (!canStartEditing) {
        return;
      }
      if (isPrintableKey(event)) {
        reason = GridRowEditStartReasons.printableKeyDown;
      } else if (isPasteShortcut(event)) {
        reason = GridRowEditStartReasons.printableKeyDown;
      } else if (event.key === "Enter") {
        reason = GridRowEditStartReasons.enterKeyDown;
      } else if (event.key === "Backspace" || event.key === "Delete") {
        reason = GridRowEditStartReasons.deleteKeyDown;
      }
      if (reason) {
        const rowParams = apiRef.current.getRowParams(params.id);
        const newParams = _extends$4({}, rowParams, {
          field: params.field,
          reason
        });
        apiRef.current.publishEvent("rowEditStart", newParams, event);
      }
    }
  }, [apiRef, hasFieldsWithErrors]);
  const handleRowEditStart = reactExports.useCallback((params) => {
    const {
      id: id2,
      field,
      reason
    } = params;
    const startRowEditModeParams = {
      id: id2,
      fieldToFocus: field
    };
    if (reason === GridRowEditStartReasons.printableKeyDown || reason === GridRowEditStartReasons.deleteKeyDown) {
      startRowEditModeParams.deleteValue = !!field;
    }
    apiRef.current.startRowEditMode(startRowEditModeParams);
  }, [apiRef]);
  const handleRowEditStop = reactExports.useCallback((params) => {
    const {
      id: id2,
      reason,
      field
    } = params;
    apiRef.current.runPendingEditCellValueMutation(id2);
    let cellToFocusAfter;
    if (reason === GridRowEditStopReasons.enterKeyDown) {
      cellToFocusAfter = "below";
    } else if (reason === GridRowEditStopReasons.tabKeyDown) {
      cellToFocusAfter = "right";
    } else if (reason === GridRowEditStopReasons.shiftTabKeyDown) {
      cellToFocusAfter = "left";
    }
    const ignoreModifications = reason === "escapeKeyDown";
    apiRef.current.stopRowEditMode({
      id: id2,
      ignoreModifications,
      field,
      cellToFocusAfter
    });
  }, [apiRef]);
  useGridApiEventHandler(apiRef, "cellDoubleClick", runIfEditModeIsRow(handleCellDoubleClick));
  useGridApiEventHandler(apiRef, "cellFocusIn", runIfEditModeIsRow(handleCellFocusIn));
  useGridApiEventHandler(apiRef, "cellFocusOut", runIfEditModeIsRow(handleCellFocusOut));
  useGridApiEventHandler(apiRef, "cellKeyDown", runIfEditModeIsRow(handleCellKeyDown));
  useGridApiEventHandler(apiRef, "rowEditStart", runIfEditModeIsRow(handleRowEditStart));
  useGridApiEventHandler(apiRef, "rowEditStop", runIfEditModeIsRow(handleRowEditStop));
  useGridApiOptionHandler(apiRef, "rowEditStart", props.onRowEditStart);
  useGridApiOptionHandler(apiRef, "rowEditStop", props.onRowEditStop);
  const getRowMode = reactExports.useCallback((id2) => {
    if (props.editMode === GridEditModes.Cell) {
      return GridRowModes.View;
    }
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const isEditing = editingState[id2] && Object.keys(editingState[id2]).length > 0;
    return isEditing ? GridRowModes.Edit : GridRowModes.View;
  }, [apiRef, props.editMode]);
  const updateRowModesModel = useEventCallback((newModel) => {
    const isNewModelDifferentFromProp = newModel !== props.rowModesModel;
    if (onRowModesModelChange && isNewModelDifferentFromProp) {
      onRowModesModelChange(newModel, {
        api: apiRef.current
      });
    }
    if (props.rowModesModel && isNewModelDifferentFromProp) {
      return;
    }
    setRowModesModel(newModel);
    rowModesModelRef.current = newModel;
    apiRef.current.publishEvent("rowModesModelChange", newModel);
  });
  const updateRowInRowModesModel = reactExports.useCallback((id2, newProps) => {
    const newModel = _extends$4({}, rowModesModelRef.current);
    if (newProps !== null) {
      newModel[id2] = _extends$4({}, newProps);
    } else {
      delete newModel[id2];
    }
    updateRowModesModel(newModel);
  }, [updateRowModesModel]);
  const updateOrDeleteRowState = reactExports.useCallback((id2, newProps) => {
    apiRef.current.setState((state) => {
      const newEditingState = _extends$4({}, state.editRows);
      if (newProps !== null) {
        newEditingState[id2] = newProps;
      } else {
        delete newEditingState[id2];
      }
      return _extends$4({}, state, {
        editRows: newEditingState
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const updateOrDeleteFieldState = reactExports.useCallback((id2, field, newProps) => {
    apiRef.current.setState((state) => {
      const newEditingState = _extends$4({}, state.editRows);
      if (newProps !== null) {
        newEditingState[id2] = _extends$4({}, newEditingState[id2], {
          [field]: _extends$4({}, newProps)
        });
      } else {
        delete newEditingState[id2][field];
        if (Object.keys(newEditingState[id2]).length === 0) {
          delete newEditingState[id2];
        }
      }
      return _extends$4({}, state, {
        editRows: newEditingState
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const startRowEditMode = reactExports.useCallback((params) => {
    const {
      id: id2
    } = params, other = _objectWithoutPropertiesLoose$1(params, _excluded$o);
    throwIfNotInMode(id2, GridRowModes.View);
    updateRowInRowModesModel(id2, _extends$4({
      mode: GridRowModes.Edit
    }, other));
  }, [throwIfNotInMode, updateRowInRowModesModel]);
  const updateStateToStartRowEditMode = useEventCallback((params) => {
    const {
      id: id2,
      fieldToFocus,
      deleteValue,
      initialValue
    } = params;
    const columnFields = gridColumnFieldsSelector(apiRef);
    const newProps = columnFields.reduce((acc, field) => {
      const cellParams = apiRef.current.getCellParams(id2, field);
      if (!cellParams.isEditable) {
        return acc;
      }
      const column2 = apiRef.current.getColumn(field);
      let newValue = apiRef.current.getCellValue(id2, field);
      if (fieldToFocus === field && (deleteValue || initialValue)) {
        if (deleteValue) {
          newValue = getDefaultCellValue(column2);
        } else if (initialValue) {
          newValue = initialValue;
        }
      }
      acc[field] = {
        value: newValue,
        error: false,
        isProcessingProps: !!column2.preProcessEditCellProps && deleteValue
      };
      return acc;
    }, {});
    updateOrDeleteRowState(id2, newProps);
    if (fieldToFocus) {
      apiRef.current.setCellFocus(id2, fieldToFocus);
    }
    columnFields.filter((field) => !!apiRef.current.getColumn(field).preProcessEditCellProps && deleteValue).forEach((field) => {
      const column2 = apiRef.current.getColumn(field);
      const value = apiRef.current.getCellValue(id2, field);
      const newValue = deleteValue ? getDefaultCellValue(column2) : initialValue ?? value;
      Promise.resolve(column2.preProcessEditCellProps({
        id: id2,
        row: apiRef.current.getRow(id2),
        props: newProps[field],
        hasChanged: newValue !== value
      })).then((processedProps) => {
        if (apiRef.current.getRowMode(id2) === GridRowModes.Edit) {
          const editingState = gridEditRowsStateSelector(apiRef.current.state);
          updateOrDeleteFieldState(id2, field, _extends$4({}, processedProps, {
            value: editingState[id2][field].value,
            isProcessingProps: false
          }));
        }
      });
    });
  });
  const stopRowEditMode = reactExports.useCallback((params) => {
    const {
      id: id2
    } = params, other = _objectWithoutPropertiesLoose$1(params, _excluded2$2);
    throwIfNotInMode(id2, GridRowModes.Edit);
    updateRowInRowModesModel(id2, _extends$4({
      mode: GridRowModes.View
    }, other));
  }, [throwIfNotInMode, updateRowInRowModesModel]);
  const updateStateToStopRowEditMode = useEventCallback((params) => {
    const {
      id: id2,
      ignoreModifications,
      field: focusedField,
      cellToFocusAfter = "none"
    } = params;
    apiRef.current.runPendingEditCellValueMutation(id2);
    const finishRowEditMode = /* @__PURE__ */ __name(() => {
      if (cellToFocusAfter !== "none" && focusedField) {
        apiRef.current.moveFocusToRelativeCell(id2, focusedField, cellToFocusAfter);
      }
      updateOrDeleteRowState(id2, null);
      updateRowInRowModesModel(id2, null);
    }, "finishRowEditMode");
    if (ignoreModifications) {
      finishRowEditMode();
      return;
    }
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const row = apiRef.current.getRow(id2);
    const isSomeFieldProcessingProps = Object.values(editingState[id2]).some((fieldProps) => fieldProps.isProcessingProps);
    if (isSomeFieldProcessingProps) {
      prevRowModesModel.current[id2].mode = GridRowModes.Edit;
      return;
    }
    if (hasFieldsWithErrors(id2)) {
      prevRowModesModel.current[id2].mode = GridRowModes.Edit;
      updateRowInRowModesModel(id2, {
        mode: GridRowModes.Edit
      });
      return;
    }
    const rowUpdate = apiRef.current.getRowWithUpdatedValuesFromRowEditing(id2);
    if (processRowUpdate) {
      const handleError = /* @__PURE__ */ __name((errorThrown) => {
        prevRowModesModel.current[id2].mode = GridRowModes.Edit;
        updateRowInRowModesModel(id2, {
          mode: GridRowModes.Edit
        });
        if (onProcessRowUpdateError) {
          onProcessRowUpdateError(errorThrown);
        }
      }, "handleError");
      try {
        Promise.resolve(processRowUpdate(rowUpdate, row, {
          rowId: id2
        })).then((finalRowUpdate) => {
          apiRef.current.updateRows([finalRowUpdate]);
          finishRowEditMode();
        }).catch(handleError);
      } catch (errorThrown) {
        handleError(errorThrown);
      }
    } else {
      apiRef.current.updateRows([rowUpdate]);
      finishRowEditMode();
    }
  });
  const setRowEditingEditCellValue = reactExports.useCallback((params) => {
    const {
      id: id2,
      field,
      value,
      debounceMs,
      unstable_skipValueParser: skipValueParser
    } = params;
    throwIfNotEditable(id2, field);
    const column2 = apiRef.current.getColumn(field);
    const row = apiRef.current.getRow(id2);
    let parsedValue = value;
    if (column2.valueParser && !skipValueParser) {
      parsedValue = column2.valueParser(value, row, column2, apiRef);
    }
    let editingState = gridEditRowsStateSelector(apiRef.current.state);
    let newProps = _extends$4({}, editingState[id2][field], {
      value: parsedValue,
      changeReason: debounceMs ? "debouncedSetEditCellValue" : "setEditCellValue"
    });
    if (!column2.preProcessEditCellProps) {
      updateOrDeleteFieldState(id2, field, newProps);
    }
    return new Promise((resolve) => {
      const promises = [];
      if (column2.preProcessEditCellProps) {
        const hasChanged = newProps.value !== editingState[id2][field].value;
        newProps = _extends$4({}, newProps, {
          isProcessingProps: true
        });
        updateOrDeleteFieldState(id2, field, newProps);
        const _editingState$id = editingState[id2], otherFieldsProps = _objectWithoutPropertiesLoose$1(_editingState$id, [field].map(toPropertyKey));
        const promise = Promise.resolve(column2.preProcessEditCellProps({
          id: id2,
          row,
          props: newProps,
          hasChanged,
          otherFieldsProps
        })).then((processedProps) => {
          if (apiRef.current.getRowMode(id2) === GridRowModes.View) {
            resolve(false);
            return;
          }
          editingState = gridEditRowsStateSelector(apiRef.current.state);
          processedProps = _extends$4({}, processedProps, {
            isProcessingProps: false
          });
          processedProps.value = column2.preProcessEditCellProps ? editingState[id2][field].value : parsedValue;
          updateOrDeleteFieldState(id2, field, processedProps);
        });
        promises.push(promise);
      }
      Object.entries(editingState[id2]).forEach(([thisField, fieldProps]) => {
        if (thisField === field) {
          return;
        }
        const fieldColumn = apiRef.current.getColumn(thisField);
        if (!fieldColumn.preProcessEditCellProps) {
          return;
        }
        fieldProps = _extends$4({}, fieldProps, {
          isProcessingProps: true
        });
        updateOrDeleteFieldState(id2, thisField, fieldProps);
        editingState = gridEditRowsStateSelector(apiRef.current.state);
        const _editingState$id2 = editingState[id2], otherFieldsProps = _objectWithoutPropertiesLoose$1(_editingState$id2, [thisField].map(toPropertyKey));
        const promise = Promise.resolve(fieldColumn.preProcessEditCellProps({
          id: id2,
          row,
          props: fieldProps,
          hasChanged: false,
          otherFieldsProps
        })).then((processedProps) => {
          if (apiRef.current.getRowMode(id2) === GridRowModes.View) {
            resolve(false);
            return;
          }
          processedProps = _extends$4({}, processedProps, {
            isProcessingProps: false
          });
          updateOrDeleteFieldState(id2, thisField, processedProps);
        });
        promises.push(promise);
      });
      Promise.all(promises).then(() => {
        if (apiRef.current.getRowMode(id2) === GridRowModes.Edit) {
          editingState = gridEditRowsStateSelector(apiRef.current.state);
          resolve(!editingState[id2][field].error);
        } else {
          resolve(false);
        }
      });
    });
  }, [apiRef, throwIfNotEditable, updateOrDeleteFieldState]);
  const getRowWithUpdatedValuesFromRowEditing = reactExports.useCallback((id2) => {
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const row = apiRef.current.getRow(id2);
    if (!editingState[id2]) {
      return apiRef.current.getRow(id2);
    }
    let rowUpdate = _extends$4({}, row);
    Object.entries(editingState[id2]).forEach(([field, fieldProps]) => {
      const column2 = apiRef.current.getColumn(field);
      if (column2.valueSetter) {
        rowUpdate = column2.valueSetter(fieldProps.value, rowUpdate, column2, apiRef);
      } else {
        rowUpdate[field] = fieldProps.value;
      }
    });
    return rowUpdate;
  }, [apiRef]);
  const editingApi = {
    getRowMode,
    startRowEditMode,
    stopRowEditMode
  };
  const editingPrivateApi = {
    setRowEditingEditCellValue,
    getRowWithUpdatedValuesFromRowEditing
  };
  useGridApiMethod(apiRef, editingApi, "public");
  useGridApiMethod(apiRef, editingPrivateApi, "private");
  reactExports.useEffect(() => {
    if (rowModesModelProp) {
      updateRowModesModel(rowModesModelProp);
    }
  }, [rowModesModelProp, updateRowModesModel]);
  useEnhancedEffect(() => {
    const idToIdLookup = gridRowsDataRowIdToIdLookupSelector(apiRef);
    const copyOfPrevRowModesModel = prevRowModesModel.current;
    prevRowModesModel.current = deepClone(rowModesModel);
    const ids = /* @__PURE__ */ new Set([...Object.keys(rowModesModel), ...Object.keys(copyOfPrevRowModesModel)]);
    Array.from(ids).forEach((id2) => {
      var _a2;
      const params = rowModesModel[id2] ?? {
        mode: GridRowModes.View
      };
      const prevMode = ((_a2 = copyOfPrevRowModesModel[id2]) == null ? void 0 : _a2.mode) || GridRowModes.View;
      const originalId = idToIdLookup[id2] ?? id2;
      if (params.mode === GridRowModes.Edit && prevMode === GridRowModes.View) {
        updateStateToStartRowEditMode(_extends$4({
          id: originalId
        }, params));
      } else if (params.mode === GridRowModes.View && prevMode === GridRowModes.Edit) {
        updateStateToStopRowEditMode(_extends$4({
          id: originalId
        }, params));
      }
    });
  }, [apiRef, rowModesModel, updateStateToStartRowEditMode, updateStateToStopRowEditMode]);
}, "useGridRowEditing");
const editingStateInitializer = /* @__PURE__ */ __name((state) => _extends$4({}, state, {
  editRows: {}
}), "editingStateInitializer");
const useGridEditing = /* @__PURE__ */ __name((apiRef, props) => {
  useGridCellEditing(apiRef, props);
  useGridRowEditing(apiRef, props);
  const debounceMap = reactExports.useRef({});
  const {
    isCellEditable: isCellEditableProp
  } = props;
  const isCellEditable = reactExports.useCallback((params) => {
    if (isAutogeneratedRowNode(params.rowNode)) {
      return false;
    }
    if (!params.colDef.editable) {
      return false;
    }
    if (!params.colDef.renderEditCell) {
      return false;
    }
    if (isCellEditableProp) {
      return isCellEditableProp(params);
    }
    return true;
  }, [isCellEditableProp]);
  const maybeDebounce = /* @__PURE__ */ __name((id2, field, debounceMs, callback) => {
    if (!debounceMs) {
      callback();
      return;
    }
    if (!debounceMap.current[id2]) {
      debounceMap.current[id2] = {};
    }
    if (debounceMap.current[id2][field]) {
      const [timeout2] = debounceMap.current[id2][field];
      clearTimeout(timeout2);
    }
    const runImmediately = /* @__PURE__ */ __name(() => {
      const [timeout2] = debounceMap.current[id2][field];
      clearTimeout(timeout2);
      callback();
      delete debounceMap.current[id2][field];
    }, "runImmediately");
    const timeout = setTimeout(() => {
      callback();
      delete debounceMap.current[id2][field];
    }, debounceMs);
    debounceMap.current[id2][field] = [timeout, runImmediately];
  }, "maybeDebounce");
  reactExports.useEffect(() => {
    const debounces = debounceMap.current;
    return () => {
      Object.entries(debounces).forEach(([id2, fields2]) => {
        Object.keys(fields2).forEach((field) => {
          const [timeout] = debounces[id2][field];
          clearTimeout(timeout);
          delete debounces[id2][field];
        });
      });
    };
  }, []);
  const runPendingEditCellValueMutation = reactExports.useCallback((id2, field) => {
    if (!debounceMap.current[id2]) {
      return;
    }
    if (!field) {
      Object.keys(debounceMap.current[id2]).forEach((debouncedField) => {
        const [, runCallback] = debounceMap.current[id2][debouncedField];
        runCallback();
      });
    } else if (debounceMap.current[id2][field]) {
      const [, runCallback] = debounceMap.current[id2][field];
      runCallback();
    }
  }, []);
  const setEditCellValue = reactExports.useCallback((params) => {
    const {
      id: id2,
      field,
      debounceMs
    } = params;
    return new Promise((resolve) => {
      maybeDebounce(id2, field, debounceMs, async () => {
        const setEditCellValueToCall = props.editMode === GridEditModes.Row ? apiRef.current.setRowEditingEditCellValue : apiRef.current.setCellEditingEditCellValue;
        if (apiRef.current.getCellMode(id2, field) === GridCellModes.Edit) {
          const result = await setEditCellValueToCall(params);
          resolve(result);
        }
      });
    });
  }, [apiRef, props.editMode]);
  const getRowWithUpdatedValues = reactExports.useCallback((id2, field) => {
    return props.editMode === GridEditModes.Cell ? apiRef.current.getRowWithUpdatedValuesFromCellEditing(id2, field) : apiRef.current.getRowWithUpdatedValuesFromRowEditing(id2);
  }, [apiRef, props.editMode]);
  const getEditCellMeta = reactExports.useCallback((id2, field) => {
    var _a2;
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    return ((_a2 = editingState[id2]) == null ? void 0 : _a2[field]) ?? null;
  }, [apiRef]);
  const editingSharedApi = {
    isCellEditable,
    setEditCellValue,
    getRowWithUpdatedValues,
    unstable_getEditCellMeta: getEditCellMeta
  };
  const editingSharedPrivateApi = {
    runPendingEditCellValueMutation
  };
  useGridApiMethod(apiRef, editingSharedApi, "public");
  useGridApiMethod(apiRef, editingSharedPrivateApi, "private");
}, "useGridEditing");
const rowsStateInitializer = /* @__PURE__ */ __name((state, props, apiRef) => {
  const isDataSourceAvailable = !!props.unstable_dataSource;
  apiRef.current.caches.rows = createRowsInternalCache({
    rows: isDataSourceAvailable ? [] : props.rows,
    getRowId: props.getRowId,
    loading: props.loading,
    rowCount: props.rowCount
  });
  return _extends$4({}, state, {
    rows: getRowsStateFromCache({
      apiRef,
      rowCountProp: props.rowCount,
      loadingProp: isDataSourceAvailable ? true : props.loading,
      previousTree: null,
      previousTreeDepths: null
    })
  });
}, "rowsStateInitializer");
const useGridRows = /* @__PURE__ */ __name((apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridRows");
  const currentPage = useGridVisibleRows(apiRef, props);
  const lastUpdateMs = reactExports.useRef(Date.now());
  const lastRowCount = reactExports.useRef(props.rowCount);
  const timeout = useTimeout();
  const getRow = reactExports.useCallback((id2) => {
    const model = gridRowsLookupSelector(apiRef)[id2];
    if (model) {
      return model;
    }
    const node2 = apiRef.current.getRowNode(id2);
    if (node2 && isAutogeneratedRowNode(node2)) {
      return {
        [GRID_ID_AUTOGENERATED]: id2
      };
    }
    return null;
  }, [apiRef]);
  const getRowIdProp = props.getRowId;
  const getRowId = reactExports.useCallback((row) => {
    if (GRID_ID_AUTOGENERATED in row) {
      return row[GRID_ID_AUTOGENERATED];
    }
    if (getRowIdProp) {
      return getRowIdProp(row);
    }
    return row.id;
  }, [getRowIdProp]);
  const lookup = reactExports.useMemo(() => currentPage.rows.reduce((acc, {
    id: id2
  }, index2) => {
    acc[id2] = index2;
    return acc;
  }, {}), [currentPage.rows]);
  const throttledRowsChange = reactExports.useCallback(({
    cache: cache2,
    throttle: throttle2
  }) => {
    const run = /* @__PURE__ */ __name(() => {
      lastUpdateMs.current = Date.now();
      apiRef.current.setState((state) => _extends$4({}, state, {
        rows: getRowsStateFromCache({
          apiRef,
          rowCountProp: props.rowCount,
          loadingProp: props.loading,
          previousTree: gridRowTreeSelector(apiRef),
          previousTreeDepths: gridRowTreeDepthsSelector(apiRef),
          previousGroupsToFetch: gridRowGroupsToFetchSelector(apiRef)
        })
      }));
      apiRef.current.publishEvent("rowsSet");
      apiRef.current.forceUpdate();
    }, "run");
    timeout.clear();
    apiRef.current.caches.rows = cache2;
    if (!throttle2) {
      run();
      return;
    }
    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);
    if (throttleRemainingTimeMs > 0) {
      timeout.start(throttleRemainingTimeMs, run);
      return;
    }
    run();
  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef, timeout]);
  const setRows = reactExports.useCallback((rows) => {
    logger.debug(`Updating all rows, new length ${rows.length}`);
    const cache2 = createRowsInternalCache({
      rows,
      getRowId: props.getRowId,
      loading: props.loading,
      rowCount: props.rowCount
    });
    const prevCache = apiRef.current.caches.rows;
    cache2.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;
    throttledRowsChange({
      cache: cache2,
      throttle: true
    });
  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);
  const updateRows = reactExports.useCallback((updates) => {
    if (props.signature === GridSignature.DataGrid && updates.length > 1) {
      throw new Error(["MUI X: You cannot update several rows at once in `apiRef.current.updateRows` on the DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));
    }
    const nonPinnedRowsUpdates = computeRowsUpdates(apiRef, updates, props.getRowId);
    const cache2 = updateCacheWithNewRows({
      updates: nonPinnedRowsUpdates,
      getRowId: props.getRowId,
      previousCache: apiRef.current.caches.rows
    });
    throttledRowsChange({
      cache: cache2,
      throttle: true
    });
  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);
  const updateServerRows = reactExports.useCallback((updates, groupKeys) => {
    const nonPinnedRowsUpdates = computeRowsUpdates(apiRef, updates, props.getRowId);
    const cache2 = updateCacheWithNewRows({
      updates: nonPinnedRowsUpdates,
      getRowId: props.getRowId,
      previousCache: apiRef.current.caches.rows,
      groupKeys: groupKeys ?? []
    });
    throttledRowsChange({
      cache: cache2,
      throttle: false
    });
  }, [props.getRowId, throttledRowsChange, apiRef]);
  const setLoading = reactExports.useCallback((loading) => {
    if (loading === props.loading) {
      return;
    }
    logger.debug(`Setting loading to ${loading}`);
    apiRef.current.setState((state) => _extends$4({}, state, {
      rows: _extends$4({}, state.rows, {
        loading
      })
    }));
    apiRef.current.caches.rows.loadingPropBeforePartialUpdates = loading;
  }, [props.loading, apiRef, logger]);
  const getRowModels = reactExports.useCallback(() => {
    const dataRows = gridDataRowIdsSelector(apiRef);
    const idRowsLookup = gridRowsLookupSelector(apiRef);
    return new Map(dataRows.map((id2) => [id2, idRowsLookup[id2] ?? {}]));
  }, [apiRef]);
  const getRowsCount = reactExports.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);
  const getAllRowIds = reactExports.useCallback(() => gridDataRowIdsSelector(apiRef), [apiRef]);
  const getRowIndexRelativeToVisibleRows = reactExports.useCallback((id2) => lookup[id2], [lookup]);
  const setRowChildrenExpansion = reactExports.useCallback((id2, isExpanded) => {
    const currentNode = apiRef.current.getRowNode(id2);
    if (!currentNode) {
      throw new Error(`MUI X: No row with id #${id2} found.`);
    }
    if (currentNode.type !== "group") {
      throw new Error("MUI X: Only group nodes can be expanded or collapsed.");
    }
    const newNode = _extends$4({}, currentNode, {
      childrenExpanded: isExpanded
    });
    apiRef.current.setState((state) => {
      return _extends$4({}, state, {
        rows: _extends$4({}, state.rows, {
          tree: _extends$4({}, state.rows.tree, {
            [id2]: newNode
          })
        })
      });
    });
    apiRef.current.forceUpdate();
    apiRef.current.publishEvent("rowExpansionChange", newNode);
  }, [apiRef]);
  const getRowNode = reactExports.useCallback((id2) => gridRowTreeSelector(apiRef)[id2] ?? null, [apiRef]);
  const getRowGroupChildren = reactExports.useCallback(({
    skipAutoGeneratedRows = true,
    groupId,
    applySorting,
    applyFiltering
  }) => {
    const tree = gridRowTreeSelector(apiRef);
    let children;
    if (applySorting) {
      const groupNode = tree[groupId];
      if (!groupNode) {
        return [];
      }
      const sortedRowIds = gridSortedRowIdsSelector(apiRef);
      children = [];
      const startIndex = sortedRowIds.findIndex((id2) => id2 === groupId) + 1;
      for (let index2 = startIndex; index2 < sortedRowIds.length && tree[sortedRowIds[index2]].depth > groupNode.depth; index2 += 1) {
        const id2 = sortedRowIds[index2];
        if (!skipAutoGeneratedRows || !isAutogeneratedRowNode(tree[id2])) {
          children.push(id2);
        }
      }
    } else {
      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);
    }
    if (applyFiltering) {
      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);
      children = children.filter((childId) => filteredRowsLookup[childId] !== false);
    }
    return children;
  }, [apiRef]);
  const setRowIndex = reactExports.useCallback((rowId, targetIndex) => {
    const node2 = apiRef.current.getRowNode(rowId);
    if (!node2) {
      throw new Error(`MUI X: No row with id #${rowId} found.`);
    }
    if (node2.parent !== GRID_ROOT_GROUP_ID) {
      throw new Error(`MUI X: The row reordering do not support reordering of grouped rows yet.`);
    }
    if (node2.type !== "leaf") {
      throw new Error(`MUI X: The row reordering do not support reordering of footer or grouping rows.`);
    }
    apiRef.current.setState((state) => {
      const group = gridRowTreeSelector(state, apiRef.current.instanceId)[GRID_ROOT_GROUP_ID];
      const allRows = group.children;
      const oldIndex = allRows.findIndex((row) => row === rowId);
      if (oldIndex === -1 || oldIndex === targetIndex) {
        return state;
      }
      logger.debug(`Moving row ${rowId} to index ${targetIndex}`);
      const updatedRows = [...allRows];
      updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);
      return _extends$4({}, state, {
        rows: _extends$4({}, state.rows, {
          tree: _extends$4({}, state.rows.tree, {
            [GRID_ROOT_GROUP_ID]: _extends$4({}, group, {
              children: updatedRows
            })
          })
        })
      });
    });
    apiRef.current.publishEvent("rowsSet");
  }, [apiRef, logger]);
  const replaceRows = reactExports.useCallback((firstRowToRender, newRows) => {
    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {
      throw new Error(["MUI X: You cannot replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));
    }
    if (newRows.length === 0) {
      return;
    }
    const treeDepth = gridRowMaximumTreeDepthSelector(apiRef);
    if (treeDepth > 1) {
      throw new Error("`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping");
    }
    const tree = _extends$4({}, gridRowTreeSelector(apiRef));
    const dataRowIdToModelLookup = _extends$4({}, gridRowsLookupSelector(apiRef));
    const dataRowIdToIdLookup = _extends$4({}, gridRowsDataRowIdToIdLookupSelector(apiRef));
    const rootGroup = tree[GRID_ROOT_GROUP_ID];
    const rootGroupChildren = [...rootGroup.children];
    const seenIds = /* @__PURE__ */ new Set();
    for (let i = 0; i < newRows.length; i += 1) {
      const rowModel = newRows[i];
      const rowId = getRowIdFromRowModel(rowModel, props.getRowId, "A row was provided without id when calling replaceRows().");
      const [removedRowId] = rootGroupChildren.splice(firstRowToRender + i, 1, rowId);
      if (!seenIds.has(removedRowId)) {
        delete dataRowIdToModelLookup[removedRowId];
        delete dataRowIdToIdLookup[removedRowId];
        delete tree[removedRowId];
      }
      const rowTreeNodeConfig = {
        id: rowId,
        depth: 0,
        parent: GRID_ROOT_GROUP_ID,
        type: "leaf",
        groupingKey: null
      };
      dataRowIdToModelLookup[rowId] = rowModel;
      dataRowIdToIdLookup[rowId] = rowId;
      tree[rowId] = rowTreeNodeConfig;
      seenIds.add(rowId);
    }
    tree[GRID_ROOT_GROUP_ID] = _extends$4({}, rootGroup, {
      children: rootGroupChildren
    });
    const dataRowIds = rootGroupChildren.filter((childId) => {
      var _a2;
      return ((_a2 = tree[childId]) == null ? void 0 : _a2.type) === "leaf";
    });
    apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;
    apiRef.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;
    apiRef.current.setState((state) => _extends$4({}, state, {
      rows: _extends$4({}, state.rows, {
        dataRowIdToModelLookup,
        dataRowIdToIdLookup,
        dataRowIds,
        tree
      })
    }));
    apiRef.current.publishEvent("rowsSet");
  }, [apiRef, props.signature, props.getRowId]);
  const rowApi = {
    getRow,
    setLoading,
    getRowId,
    getRowModels,
    getRowsCount,
    getAllRowIds,
    setRows,
    updateRows,
    getRowNode,
    getRowIndexRelativeToVisibleRows,
    unstable_replaceRows: replaceRows
  };
  const rowProApi = {
    setRowIndex,
    setRowChildrenExpansion,
    getRowGroupChildren
  };
  const rowProPrivateApi = {
    updateServerRows
  };
  const groupRows = reactExports.useCallback(() => {
    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);
    let cache2;
    if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {
      cache2 = _extends$4({}, apiRef.current.caches.rows, {
        updates: {
          type: "full",
          rows: gridDataRowIdsSelector(apiRef)
        }
      });
    } else {
      cache2 = createRowsInternalCache({
        rows: props.rows,
        getRowId: props.getRowId,
        loading: props.loading,
        rowCount: props.rowCount
      });
    }
    throttledRowsChange({
      cache: cache2,
      throttle: false
    });
  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);
  const previousDataSource = useLazyRef(() => props.unstable_dataSource);
  const handleStrategyProcessorChange = reactExports.useCallback((methodName) => {
    if (props.unstable_dataSource && props.unstable_dataSource !== previousDataSource.current) {
      previousDataSource.current = props.unstable_dataSource;
      return;
    }
    if (methodName === "rowTreeCreation") {
      groupRows();
    }
  }, [groupRows, previousDataSource, props.unstable_dataSource]);
  const handleStrategyActivityChange = reactExports.useCallback(() => {
    if (apiRef.current.getActiveStrategy("rowTree") !== gridRowGroupingNameSelector(apiRef)) {
      groupRows();
    }
  }, [apiRef, groupRows]);
  useGridApiEventHandler(apiRef, "activeStrategyProcessorChange", handleStrategyProcessorChange);
  useGridApiEventHandler(apiRef, "strategyAvailabilityChange", handleStrategyActivityChange);
  const applyHydrateRowsProcessor = reactExports.useCallback(() => {
    apiRef.current.setState((state) => {
      const response = apiRef.current.unstable_applyPipeProcessors("hydrateRows", {
        tree: gridRowTreeSelector(state, apiRef.current.instanceId),
        treeDepths: gridRowTreeDepthsSelector(state, apiRef.current.instanceId),
        dataRowIds: gridDataRowIdsSelector(state, apiRef.current.instanceId),
        dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef.current.instanceId),
        dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef.current.instanceId)
      });
      return _extends$4({}, state, {
        rows: _extends$4({}, state.rows, response, {
          totalTopLevelRowCount: getTopLevelRowCount({
            tree: response.tree,
            rowCountProp: props.rowCount
          })
        })
      });
    });
    apiRef.current.publishEvent("rowsSet");
    apiRef.current.forceUpdate();
  }, [apiRef, props.rowCount]);
  useGridRegisterPipeApplier(apiRef, "hydrateRows", applyHydrateRowsProcessor);
  useGridApiMethod(apiRef, rowApi, "public");
  useGridApiMethod(apiRef, rowProApi, props.signature === GridSignature.DataGrid ? "private" : "public");
  useGridApiMethod(apiRef, rowProPrivateApi, "private");
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    var _a2;
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    let isRowCountPropUpdated = false;
    if (props.rowCount !== lastRowCount.current) {
      isRowCountPropUpdated = true;
      lastRowCount.current = props.rowCount;
    }
    const areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows;
    const isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;
    const isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount;
    if (areNewRowsAlreadyInState) {
      if (!isNewLoadingAlreadyInState) {
        apiRef.current.setState((state) => _extends$4({}, state, {
          rows: _extends$4({}, state.rows, {
            loading: props.loading
          })
        }));
        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;
        apiRef.current.forceUpdate();
      }
      if (!isNewRowCountAlreadyInState) {
        apiRef.current.setState((state) => _extends$4({}, state, {
          rows: _extends$4({}, state.rows, {
            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),
            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)
          })
        }));
        apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;
        apiRef.current.forceUpdate();
      }
      if (!isRowCountPropUpdated) {
        return;
      }
    }
    logger.debug(`Updating all rows, new length ${(_a2 = props.rows) == null ? void 0 : _a2.length}`);
    throttledRowsChange({
      cache: createRowsInternalCache({
        rows: props.rows,
        getRowId: props.getRowId,
        loading: props.loading,
        rowCount: props.rowCount
      }),
      throttle: false
    });
  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);
}, "useGridRows");
const createFlatRowTree = /* @__PURE__ */ __name((rows) => {
  const tree = {
    [GRID_ROOT_GROUP_ID]: _extends$4({}, buildRootGroup(), {
      children: rows
    })
  };
  for (let i = 0; i < rows.length; i += 1) {
    const rowId = rows[i];
    tree[rowId] = {
      id: rowId,
      depth: 0,
      parent: GRID_ROOT_GROUP_ID,
      type: "leaf",
      groupingKey: null
    };
  }
  return {
    groupingName: GRID_DEFAULT_STRATEGY,
    tree,
    treeDepths: {
      0: rows.length
    },
    dataRowIds: rows
  };
}, "createFlatRowTree");
const updateFlatRowTree = /* @__PURE__ */ __name(({
  previousTree,
  actions
}) => {
  const tree = _extends$4({}, previousTree);
  const idsToRemoveFromRootGroup = {};
  for (let i = 0; i < actions.remove.length; i += 1) {
    const idToDelete = actions.remove[i];
    idsToRemoveFromRootGroup[idToDelete] = true;
    delete tree[idToDelete];
  }
  for (let i = 0; i < actions.insert.length; i += 1) {
    const idToInsert = actions.insert[i];
    tree[idToInsert] = {
      id: idToInsert,
      depth: 0,
      parent: GRID_ROOT_GROUP_ID,
      type: "leaf",
      groupingKey: null
    };
  }
  const rootGroup = tree[GRID_ROOT_GROUP_ID];
  let rootGroupChildren = [...rootGroup.children, ...actions.insert];
  if (Object.values(idsToRemoveFromRootGroup).length) {
    rootGroupChildren = rootGroupChildren.filter((id2) => !idsToRemoveFromRootGroup[id2]);
  }
  tree[GRID_ROOT_GROUP_ID] = _extends$4({}, rootGroup, {
    children: rootGroupChildren
  });
  return {
    groupingName: GRID_DEFAULT_STRATEGY,
    tree,
    treeDepths: {
      0: rootGroupChildren.length
    },
    dataRowIds: rootGroupChildren
  };
}, "updateFlatRowTree");
const flatRowTreeCreationMethod = /* @__PURE__ */ __name((params) => {
  if (params.updates.type === "full") {
    return createFlatRowTree(params.updates.rows);
  }
  return updateFlatRowTree({
    previousTree: params.previousTree,
    actions: params.updates.actions
  });
}, "flatRowTreeCreationMethod");
const useGridRowsPreProcessors = /* @__PURE__ */ __name((apiRef) => {
  useGridRegisterStrategyProcessor(apiRef, GRID_DEFAULT_STRATEGY, "rowTreeCreation", flatRowTreeCreationMethod);
}, "useGridRowsPreProcessors");
const getSelectionModelPropValue = /* @__PURE__ */ __name((selectionModelProp, prevSelectionModel) => {
  if (selectionModelProp == null) {
    return selectionModelProp;
  }
  if (Array.isArray(selectionModelProp)) {
    return selectionModelProp;
  }
  if (prevSelectionModel && prevSelectionModel[0] === selectionModelProp) {
    return prevSelectionModel;
  }
  return [selectionModelProp];
}, "getSelectionModelPropValue");
const rowSelectionStateInitializer = /* @__PURE__ */ __name((state, props) => _extends$4({}, state, {
  rowSelection: props.rowSelection ? getSelectionModelPropValue(props.rowSelectionModel) ?? [] : []
}), "rowSelectionStateInitializer");
const useGridRowSelection = /* @__PURE__ */ __name((apiRef, props) => {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
  const logger = useGridLogger(apiRef, "useGridSelection");
  const runIfRowSelectionIsEnabled = reactExports.useCallback((callback) => (...args) => {
    if (props.rowSelection) {
      callback(...args);
    }
  }, [props.rowSelection]);
  const applyAutoSelection = props.signature !== GridSignature.DataGrid && (((_a2 = props.rowSelectionPropagation) == null ? void 0 : _a2.parents) || ((_b2 = props.rowSelectionPropagation) == null ? void 0 : _b2.descendants));
  const propRowSelectionModel = reactExports.useMemo(() => {
    return getSelectionModelPropValue(props.rowSelectionModel, gridRowSelectionStateSelector(apiRef.current.state));
  }, [apiRef, props.rowSelectionModel]);
  const lastRowToggled = reactExports.useRef(null);
  apiRef.current.registerControlState({
    stateId: "rowSelection",
    propModel: propRowSelectionModel,
    propOnChange: props.onRowSelectionModelChange,
    stateSelector: gridRowSelectionStateSelector,
    changeEvent: "rowSelectionChange"
  });
  const {
    checkboxSelection,
    disableRowSelectionOnClick,
    isRowSelectable: propIsRowSelectable
  } = props;
  const canHaveMultipleSelection = isMultipleRowSelectionEnabled(props);
  const visibleRows = useGridVisibleRows(apiRef, props);
  const tree = useGridSelector(apiRef, gridRowTreeSelector);
  const isNestedData = useGridSelector(apiRef, gridRowMaximumTreeDepthSelector) > 1;
  const expandMouseRowRangeSelection = reactExports.useCallback((id2) => {
    let endId = id2;
    const startId = lastRowToggled.current ?? id2;
    const isSelected = apiRef.current.isRowSelected(id2);
    if (isSelected) {
      const visibleRowIds = gridExpandedSortedRowIdsSelector(apiRef);
      const startIndex = visibleRowIds.findIndex((rowId) => rowId === startId);
      const endIndex = visibleRowIds.findIndex((rowId) => rowId === endId);
      if (startIndex === endIndex) {
        return;
      }
      if (startIndex > endIndex) {
        endId = visibleRowIds[endIndex + 1];
      } else {
        endId = visibleRowIds[endIndex - 1];
      }
    }
    lastRowToggled.current = id2;
    apiRef.current.selectRowRange({
      startId,
      endId
    }, !isSelected);
  }, [apiRef]);
  const setRowSelectionModel = reactExports.useCallback((model) => {
    if (props.signature === GridSignature.DataGrid && !canHaveMultipleSelection && Array.isArray(model) && model.length > 1) {
      throw new Error(["MUI X: `rowSelectionModel` can only contain 1 item in DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock multiple selection."].join("\n"));
    }
    const currentModel = gridRowSelectionStateSelector(apiRef.current.state);
    if (currentModel !== model) {
      logger.debug(`Setting selection model`);
      apiRef.current.setState((state) => _extends$4({}, state, {
        rowSelection: props.rowSelection ? model : []
      }));
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger, props.rowSelection, props.signature, canHaveMultipleSelection]);
  const isRowSelected = reactExports.useCallback((id2) => gridRowSelectionStateSelector(apiRef.current.state).includes(id2), [apiRef]);
  const isRowSelectable = reactExports.useCallback((id2) => {
    if (props.rowSelection === false) {
      return false;
    }
    if (propIsRowSelectable && !propIsRowSelectable(apiRef.current.getRowParams(id2))) {
      return false;
    }
    const rowNode = apiRef.current.getRowNode(id2);
    if ((rowNode == null ? void 0 : rowNode.type) === "footer" || (rowNode == null ? void 0 : rowNode.type) === "pinnedRow") {
      return false;
    }
    return true;
  }, [apiRef, props.rowSelection, propIsRowSelectable]);
  const getSelectedRows = reactExports.useCallback(() => selectedGridRowsSelector(apiRef), [apiRef]);
  const selectRow = reactExports.useCallback((id2, isSelected = true, resetSelection = false) => {
    var _a3, _b3, _c3, _d3, _e3, _f3;
    if (!apiRef.current.isRowSelectable(id2)) {
      return;
    }
    lastRowToggled.current = id2;
    if (resetSelection) {
      logger.debug(`Setting selection for row ${id2}`);
      const newSelection = [];
      const addRow = /* @__PURE__ */ __name((rowId) => {
        newSelection.push(rowId);
      }, "addRow");
      if (isSelected) {
        addRow(id2);
        if (applyAutoSelection) {
          findRowsToSelect(apiRef, tree, id2, ((_a3 = props.rowSelectionPropagation) == null ? void 0 : _a3.descendants) ?? false, ((_b3 = props.rowSelectionPropagation) == null ? void 0 : _b3.parents) ?? false, addRow);
        }
      }
      apiRef.current.setRowSelectionModel(newSelection);
    } else {
      logger.debug(`Toggling selection for row ${id2}`);
      const selection = gridRowSelectionStateSelector(apiRef.current.state);
      const newSelection = new Set(selection);
      newSelection.delete(id2);
      const addRow = /* @__PURE__ */ __name((rowId) => {
        newSelection.add(rowId);
      }, "addRow");
      const removeRow = /* @__PURE__ */ __name((rowId) => {
        newSelection.delete(rowId);
      }, "removeRow");
      if (isSelected) {
        addRow(id2);
        if (applyAutoSelection) {
          findRowsToSelect(apiRef, tree, id2, ((_c3 = props.rowSelectionPropagation) == null ? void 0 : _c3.descendants) ?? false, ((_d3 = props.rowSelectionPropagation) == null ? void 0 : _d3.parents) ?? false, addRow);
        }
      } else if (applyAutoSelection) {
        findRowsToDeselect(apiRef, tree, id2, ((_e3 = props.rowSelectionPropagation) == null ? void 0 : _e3.descendants) ?? false, ((_f3 = props.rowSelectionPropagation) == null ? void 0 : _f3.parents) ?? false, removeRow);
      }
      const isSelectionValid = newSelection.size < 2 || canHaveMultipleSelection;
      if (isSelectionValid) {
        apiRef.current.setRowSelectionModel(Array.from(newSelection));
      }
    }
  }, [apiRef, logger, applyAutoSelection, tree, (_c2 = props.rowSelectionPropagation) == null ? void 0 : _c2.descendants, (_d2 = props.rowSelectionPropagation) == null ? void 0 : _d2.parents, canHaveMultipleSelection]);
  const selectRows = reactExports.useCallback((ids, isSelected = true, resetSelection = false) => {
    logger.debug(`Setting selection for several rows`);
    const selectableIds = ids.filter((id2) => apiRef.current.isRowSelectable(id2));
    let newSelection;
    if (resetSelection) {
      if (isSelected) {
        newSelection = new Set(selectableIds);
        if (applyAutoSelection) {
          const addRow = /* @__PURE__ */ __name((rowId) => {
            newSelection.add(rowId);
          }, "addRow");
          selectableIds.forEach((id2) => {
            var _a3, _b3;
            findRowsToSelect(apiRef, tree, id2, ((_a3 = props.rowSelectionPropagation) == null ? void 0 : _a3.descendants) ?? false, ((_b3 = props.rowSelectionPropagation) == null ? void 0 : _b3.parents) ?? false, addRow);
          });
        }
      } else {
        newSelection = /* @__PURE__ */ new Set();
      }
      const currentLookup = selectedIdsLookupSelector(apiRef);
      if (newSelection.size === Object.keys(currentLookup).length && Array.from(newSelection).every((id2) => currentLookup[id2] === id2)) {
        return;
      }
    } else {
      newSelection = new Set(Object.values(selectedIdsLookupSelector(apiRef)));
      const addRow = /* @__PURE__ */ __name((rowId) => {
        newSelection.add(rowId);
      }, "addRow");
      const removeRow = /* @__PURE__ */ __name((rowId) => {
        newSelection.delete(rowId);
      }, "removeRow");
      selectableIds.forEach((id2) => {
        var _a3, _b3, _c3, _d3;
        if (isSelected) {
          newSelection.add(id2);
          if (applyAutoSelection) {
            findRowsToSelect(apiRef, tree, id2, ((_a3 = props.rowSelectionPropagation) == null ? void 0 : _a3.descendants) ?? false, ((_b3 = props.rowSelectionPropagation) == null ? void 0 : _b3.parents) ?? false, addRow);
          }
        } else {
          removeRow(id2);
          if (applyAutoSelection) {
            findRowsToDeselect(apiRef, tree, id2, ((_c3 = props.rowSelectionPropagation) == null ? void 0 : _c3.descendants) ?? false, ((_d3 = props.rowSelectionPropagation) == null ? void 0 : _d3.parents) ?? false, removeRow);
          }
        }
      });
    }
    const isSelectionValid = newSelection.size < 2 || canHaveMultipleSelection;
    if (isSelectionValid) {
      apiRef.current.setRowSelectionModel(Array.from(newSelection));
    }
  }, [logger, applyAutoSelection, canHaveMultipleSelection, apiRef, tree, (_e2 = props.rowSelectionPropagation) == null ? void 0 : _e2.descendants, (_f2 = props.rowSelectionPropagation) == null ? void 0 : _f2.parents]);
  const selectRowRange = reactExports.useCallback(({
    startId,
    endId
  }, isSelected = true, resetSelection = false) => {
    if (!apiRef.current.getRow(startId) || !apiRef.current.getRow(endId)) {
      return;
    }
    logger.debug(`Expanding selection from row ${startId} to row ${endId}`);
    const allPagesRowIds = gridExpandedSortedRowIdsSelector(apiRef);
    const startIndex = allPagesRowIds.indexOf(startId);
    const endIndex = allPagesRowIds.indexOf(endId);
    const [start2, end2] = startIndex > endIndex ? [endIndex, startIndex] : [startIndex, endIndex];
    const rowsBetweenStartAndEnd = allPagesRowIds.slice(start2, end2 + 1);
    apiRef.current.selectRows(rowsBetweenStartAndEnd, isSelected, resetSelection);
  }, [apiRef, logger]);
  const selectionPublicApi = {
    selectRow,
    setRowSelectionModel,
    getSelectedRows,
    isRowSelected,
    isRowSelectable
  };
  const selectionPrivateApi = {
    selectRows,
    selectRowRange
  };
  useGridApiMethod(apiRef, selectionPublicApi, "public");
  useGridApiMethod(apiRef, selectionPrivateApi, props.signature === GridSignature.DataGrid ? "private" : "public");
  const isFirstRender = reactExports.useRef(true);
  const removeOutdatedSelection = reactExports.useCallback((sortModelUpdated = false) => {
    var _a3;
    if (isFirstRender.current) {
      return;
    }
    const currentSelection = gridRowSelectionStateSelector(apiRef.current.state);
    const rowsLookup = gridRowsLookupSelector(apiRef);
    const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);
    const selectionLookup = _extends$4({}, selectedIdsLookupSelector(apiRef));
    const isNonExistent = /* @__PURE__ */ __name((id2) => {
      if (props.filterMode === "server") {
        return !rowsLookup[id2];
      }
      return filteredRowsLookup[id2] !== true;
    }, "isNonExistent");
    let hasChanged = false;
    currentSelection.forEach((id2) => {
      var _a4;
      if (isNonExistent(id2)) {
        if (props.keepNonExistentRowsSelected) {
          return;
        }
        delete selectionLookup[id2];
        hasChanged = true;
        return;
      }
      if (!((_a4 = props.rowSelectionPropagation) == null ? void 0 : _a4.parents)) {
        return;
      }
      const node2 = tree[id2];
      if (node2.type === "group") {
        const isAutoGenerated = node2.isAutoGenerated;
        if (isAutoGenerated) {
          delete selectionLookup[id2];
          hasChanged = true;
          return;
        }
        if (!node2.children.every((childId) => filteredRowsLookup[childId] === false)) {
          delete selectionLookup[id2];
          hasChanged = true;
        }
      }
    });
    const shouldReapplyPropagation = isNestedData && ((_a3 = props.rowSelectionPropagation) == null ? void 0 : _a3.parents) && Object.keys(selectionLookup).length > 0;
    if (hasChanged || shouldReapplyPropagation && !sortModelUpdated) {
      const newSelection = Object.values(selectionLookup);
      if (shouldReapplyPropagation) {
        apiRef.current.selectRows(newSelection, true, true);
      } else {
        apiRef.current.setRowSelectionModel(newSelection);
      }
    }
  }, [apiRef, isNestedData, (_g2 = props.rowSelectionPropagation) == null ? void 0 : _g2.parents, props.keepNonExistentRowsSelected, props.filterMode, tree]);
  const handleSingleRowSelection = reactExports.useCallback((id2, event) => {
    const hasCtrlKey = event.metaKey || event.ctrlKey;
    const isMultipleSelectionDisabled = !checkboxSelection && !hasCtrlKey && !isKeyboardEvent(event);
    const resetSelection = !canHaveMultipleSelection || isMultipleSelectionDisabled;
    const isSelected = apiRef.current.isRowSelected(id2);
    if (resetSelection) {
      apiRef.current.selectRow(id2, !isMultipleSelectionDisabled ? !isSelected : true, true);
    } else {
      apiRef.current.selectRow(id2, !isSelected, false);
    }
  }, [apiRef, canHaveMultipleSelection, checkboxSelection]);
  const handleRowClick = reactExports.useCallback((params, event) => {
    var _a3;
    if (disableRowSelectionOnClick) {
      return;
    }
    const field = (_a3 = event.target.closest(`.${gridClasses.cell}`)) == null ? void 0 : _a3.getAttribute("data-field");
    if (field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {
      return;
    }
    if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
      return;
    }
    if (field) {
      const column2 = apiRef.current.getColumn(field);
      if ((column2 == null ? void 0 : column2.type) === GRID_ACTIONS_COLUMN_TYPE) {
        return;
      }
    }
    const rowNode = apiRef.current.getRowNode(params.id);
    if (rowNode.type === "pinnedRow") {
      return;
    }
    if (event.shiftKey && canHaveMultipleSelection) {
      expandMouseRowRangeSelection(params.id);
    } else {
      handleSingleRowSelection(params.id, event);
    }
  }, [disableRowSelectionOnClick, canHaveMultipleSelection, apiRef, expandMouseRowRangeSelection, handleSingleRowSelection]);
  const preventSelectionOnShift = reactExports.useCallback((params, event) => {
    var _a3;
    if (canHaveMultipleSelection && event.shiftKey) {
      (_a3 = window.getSelection()) == null ? void 0 : _a3.removeAllRanges();
    }
  }, [canHaveMultipleSelection]);
  const handleRowSelectionCheckboxChange = reactExports.useCallback((params, event) => {
    if (canHaveMultipleSelection && event.nativeEvent.shiftKey) {
      expandMouseRowRangeSelection(params.id);
    } else {
      apiRef.current.selectRow(params.id, params.value, !canHaveMultipleSelection);
    }
  }, [apiRef, expandMouseRowRangeSelection, canHaveMultipleSelection]);
  const handleHeaderSelectionCheckboxChange = reactExports.useCallback((params) => {
    const rowsToBeSelected = props.pagination && props.checkboxSelectionVisibleOnly && props.paginationMode === "client" ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridExpandedSortedRowIdsSelector(apiRef);
    apiRef.current.selectRows(rowsToBeSelected, params.value);
  }, [apiRef, props.checkboxSelectionVisibleOnly, props.pagination, props.paginationMode]);
  const handleCellKeyDown = reactExports.useCallback((params, event) => {
    if (apiRef.current.getCellMode(params.id, params.field) === GridCellModes.Edit) {
      return;
    }
    if (isEventTargetInPortal(event)) {
      return;
    }
    if (isNavigationKey(event.key) && event.shiftKey) {
      const focusCell = gridFocusCellSelector(apiRef);
      if (focusCell && focusCell.id !== params.id) {
        event.preventDefault();
        const isNextRowSelected = apiRef.current.isRowSelected(focusCell.id);
        if (!canHaveMultipleSelection) {
          apiRef.current.selectRow(focusCell.id, !isNextRowSelected, true);
          return;
        }
        const newRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(focusCell.id);
        const previousRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(params.id);
        let start2;
        let end2;
        if (newRowIndex > previousRowIndex) {
          if (isNextRowSelected) {
            start2 = previousRowIndex;
            end2 = newRowIndex - 1;
          } else {
            start2 = previousRowIndex;
            end2 = newRowIndex;
          }
        } else {
          if (isNextRowSelected) {
            start2 = newRowIndex + 1;
            end2 = previousRowIndex;
          } else {
            start2 = newRowIndex;
            end2 = previousRowIndex;
          }
        }
        const rowsBetweenStartAndEnd = visibleRows.rows.slice(start2, end2 + 1).map((row) => row.id);
        apiRef.current.selectRows(rowsBetweenStartAndEnd, !isNextRowSelected);
        return;
      }
    }
    if (event.key === " " && event.shiftKey) {
      event.preventDefault();
      handleSingleRowSelection(params.id, event);
      return;
    }
    if (String.fromCharCode(event.keyCode) === "A" && (event.ctrlKey || event.metaKey)) {
      event.preventDefault();
      selectRows(apiRef.current.getAllRowIds(), true);
    }
  }, [apiRef, handleSingleRowSelection, selectRows, visibleRows.rows, canHaveMultipleSelection]);
  useGridApiEventHandler(apiRef, "sortedRowsSet", runIfRowSelectionIsEnabled(() => removeOutdatedSelection(true)));
  useGridApiEventHandler(apiRef, "filteredRowsSet", runIfRowSelectionIsEnabled(removeOutdatedSelection));
  useGridApiEventHandler(apiRef, "rowClick", runIfRowSelectionIsEnabled(handleRowClick));
  useGridApiEventHandler(apiRef, "rowSelectionCheckboxChange", runIfRowSelectionIsEnabled(handleRowSelectionCheckboxChange));
  useGridApiEventHandler(apiRef, "headerSelectionCheckboxChange", handleHeaderSelectionCheckboxChange);
  useGridApiEventHandler(apiRef, "cellMouseDown", runIfRowSelectionIsEnabled(preventSelectionOnShift));
  useGridApiEventHandler(apiRef, "cellKeyDown", runIfRowSelectionIsEnabled(handleCellKeyDown));
  reactExports.useEffect(() => {
    if (propRowSelectionModel !== void 0) {
      apiRef.current.setRowSelectionModel(propRowSelectionModel);
    }
  }, [apiRef, propRowSelectionModel, props.rowSelection]);
  reactExports.useEffect(() => {
    if (!props.rowSelection) {
      apiRef.current.setRowSelectionModel([]);
    }
  }, [apiRef, props.rowSelection]);
  const isStateControlled = propRowSelectionModel != null;
  reactExports.useEffect(() => {
    if (isStateControlled || !props.rowSelection) {
      return;
    }
    const currentSelection = gridRowSelectionStateSelector(apiRef.current.state);
    if (isRowSelectable) {
      const newSelection = currentSelection.filter((id2) => isRowSelectable(id2));
      if (newSelection.length < currentSelection.length) {
        apiRef.current.setRowSelectionModel(newSelection);
      }
    }
  }, [apiRef, isRowSelectable, isStateControlled, props.rowSelection]);
  reactExports.useEffect(() => {
    if (!props.rowSelection || isStateControlled) {
      return;
    }
    const currentSelection = gridRowSelectionStateSelector(apiRef.current.state);
    if (!canHaveMultipleSelection && currentSelection.length > 1) {
      apiRef.current.setRowSelectionModel([]);
    }
  }, [apiRef, canHaveMultipleSelection, checkboxSelection, isStateControlled, props.rowSelection]);
  reactExports.useEffect(() => {
    runIfRowSelectionIsEnabled(removeOutdatedSelection);
  }, [removeOutdatedSelection, runIfRowSelectionIsEnabled]);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    }
  }, []);
}, "useGridRowSelection");
const useUtilityClasses$d = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  return reactExports.useMemo(() => {
    const slots = {
      cellCheckbox: ["cellCheckbox"],
      columnHeaderCheckbox: ["columnHeaderCheckbox"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes2);
  }, [classes2]);
}, "useUtilityClasses$d");
const useGridRowSelectionPreProcessors = /* @__PURE__ */ __name((apiRef, props) => {
  const ownerState = {
    classes: props.classes
  };
  const classes2 = useUtilityClasses$d(ownerState);
  const updateSelectionColumn = reactExports.useCallback((columnsState) => {
    const selectionColumn = _extends$4({}, GRID_CHECKBOX_SELECTION_COL_DEF, {
      cellClassName: classes2.cellCheckbox,
      headerClassName: classes2.columnHeaderCheckbox,
      headerName: apiRef.current.getLocaleText("checkboxSelectionHeaderName")
    });
    const shouldHaveSelectionColumn = props.checkboxSelection;
    const haveSelectionColumn = columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD] != null;
    if (shouldHaveSelectionColumn && !haveSelectionColumn) {
      columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD] = selectionColumn;
      columnsState.orderedFields = [GRID_CHECKBOX_SELECTION_FIELD, ...columnsState.orderedFields];
    } else if (!shouldHaveSelectionColumn && haveSelectionColumn) {
      delete columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD];
      columnsState.orderedFields = columnsState.orderedFields.filter((field) => field !== GRID_CHECKBOX_SELECTION_FIELD);
    } else if (shouldHaveSelectionColumn && haveSelectionColumn) {
      columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD] = _extends$4({}, selectionColumn, columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD]);
    }
    return columnsState;
  }, [apiRef, classes2, props.checkboxSelection]);
  useGridRegisterPipeProcessor(apiRef, "hydrateColumns", updateSelectionColumn);
}, "useGridRowSelectionPreProcessors");
const sortingStateInitializer = /* @__PURE__ */ __name((state, props) => {
  var _a2, _b2;
  const sortModel = props.sortModel ?? ((_b2 = (_a2 = props.initialState) == null ? void 0 : _a2.sorting) == null ? void 0 : _b2.sortModel) ?? [];
  return _extends$4({}, state, {
    sorting: {
      sortModel: sanitizeSortModel(sortModel, props.disableMultipleColumnsSorting),
      sortedRows: []
    }
  });
}, "sortingStateInitializer");
const useGridSorting = /* @__PURE__ */ __name((apiRef, props) => {
  var _a2, _b2;
  const logger = useGridLogger(apiRef, "useGridSorting");
  apiRef.current.registerControlState({
    stateId: "sortModel",
    propModel: props.sortModel,
    propOnChange: props.onSortModelChange,
    stateSelector: gridSortModelSelector,
    changeEvent: "sortModelChange"
  });
  const upsertSortModel = reactExports.useCallback((field, sortItem) => {
    const sortModel = gridSortModelSelector(apiRef);
    const existingIdx = sortModel.findIndex((c2) => c2.field === field);
    let newSortModel = [...sortModel];
    if (existingIdx > -1) {
      if ((sortItem == null ? void 0 : sortItem.sort) == null) {
        newSortModel.splice(existingIdx, 1);
      } else {
        newSortModel.splice(existingIdx, 1, sortItem);
      }
    } else {
      newSortModel = [...sortModel, sortItem];
    }
    return newSortModel;
  }, [apiRef]);
  const createSortItem = reactExports.useCallback((col, directionOverride) => {
    const sortModel = gridSortModelSelector(apiRef);
    const existing = sortModel.find((c2) => c2.field === col.field);
    if (existing) {
      const nextSort = directionOverride === void 0 ? getNextGridSortDirection(col.sortingOrder ?? props.sortingOrder, existing.sort) : directionOverride;
      return nextSort === void 0 ? void 0 : _extends$4({}, existing, {
        sort: nextSort
      });
    }
    return {
      field: col.field,
      sort: directionOverride === void 0 ? getNextGridSortDirection(col.sortingOrder ?? props.sortingOrder) : directionOverride
    };
  }, [apiRef, props.sortingOrder]);
  const addColumnMenuItem = reactExports.useCallback((columnMenuItems, colDef) => {
    if (colDef == null || colDef.sortable === false || props.disableColumnSorting) {
      return columnMenuItems;
    }
    const sortingOrder = colDef.sortingOrder || props.sortingOrder;
    if (sortingOrder.some((item) => !!item)) {
      return [...columnMenuItems, "columnMenuSortItem"];
    }
    return columnMenuItems;
  }, [props.sortingOrder, props.disableColumnSorting]);
  const applySorting = reactExports.useCallback(() => {
    apiRef.current.setState((state) => {
      if (props.sortingMode === "server") {
        logger.debug("Skipping sorting rows as sortingMode = server");
        return _extends$4({}, state, {
          sorting: _extends$4({}, state.sorting, {
            sortedRows: getTreeNodeDescendants(gridRowTreeSelector(apiRef), GRID_ROOT_GROUP_ID, false)
          })
        });
      }
      const sortModel = gridSortModelSelector(state, apiRef.current.instanceId);
      const sortRowList = buildAggregatedSortingApplier(sortModel, apiRef);
      const sortedRows = apiRef.current.applyStrategyProcessor("sorting", {
        sortRowList
      });
      return _extends$4({}, state, {
        sorting: _extends$4({}, state.sorting, {
          sortedRows
        })
      });
    });
    apiRef.current.publishEvent("sortedRowsSet");
    apiRef.current.forceUpdate();
  }, [apiRef, logger, props.sortingMode]);
  const setSortModel = reactExports.useCallback((model) => {
    const currentModel = gridSortModelSelector(apiRef);
    if (currentModel !== model) {
      logger.debug(`Setting sort model`);
      apiRef.current.setState(mergeStateWithSortModel(model, props.disableMultipleColumnsSorting));
      apiRef.current.forceUpdate();
      apiRef.current.applySorting();
    }
  }, [apiRef, logger, props.disableMultipleColumnsSorting]);
  const sortColumn = reactExports.useCallback((field, direction, allowMultipleSorting) => {
    const column2 = apiRef.current.getColumn(field);
    const sortItem = createSortItem(column2, direction);
    let sortModel;
    if (!allowMultipleSorting || props.disableMultipleColumnsSorting) {
      sortModel = (sortItem == null ? void 0 : sortItem.sort) == null ? [] : [sortItem];
    } else {
      sortModel = upsertSortModel(column2.field, sortItem);
    }
    apiRef.current.setSortModel(sortModel);
  }, [apiRef, upsertSortModel, createSortItem, props.disableMultipleColumnsSorting]);
  const getSortModel = reactExports.useCallback(() => gridSortModelSelector(apiRef), [apiRef]);
  const getSortedRows = reactExports.useCallback(() => {
    const sortedRows = gridSortedRowEntriesSelector(apiRef);
    return sortedRows.map((row) => row.model);
  }, [apiRef]);
  const getSortedRowIds = reactExports.useCallback(() => gridSortedRowIdsSelector(apiRef), [apiRef]);
  const getRowIdFromRowIndex = reactExports.useCallback((index2) => apiRef.current.getSortedRowIds()[index2], [apiRef]);
  const sortApi = {
    getSortModel,
    getSortedRows,
    getSortedRowIds,
    getRowIdFromRowIndex,
    setSortModel,
    sortColumn,
    applySorting
  };
  useGridApiMethod(apiRef, sortApi, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _a3, _b3;
    const sortModelToExport = gridSortModelSelector(apiRef);
    const shouldExportSortModel = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the model is controlled
      props.sortModel != null || // Always export if the model has been initialized
      ((_b3 = (_a3 = props.initialState) == null ? void 0 : _a3.sorting) == null ? void 0 : _b3.sortModel) != null || // Export if the model is not empty
      sortModelToExport.length > 0
    );
    if (!shouldExportSortModel) {
      return prevState;
    }
    return _extends$4({}, prevState, {
      sorting: {
        sortModel: sortModelToExport
      }
    });
  }, [apiRef, props.sortModel, (_b2 = (_a2 = props.initialState) == null ? void 0 : _a2.sorting) == null ? void 0 : _b2.sortModel]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _a3;
    const sortModel = (_a3 = context.stateToRestore.sorting) == null ? void 0 : _a3.sortModel;
    if (sortModel == null) {
      return params;
    }
    apiRef.current.setState(mergeStateWithSortModel(sortModel, props.disableMultipleColumnsSorting));
    return _extends$4({}, params, {
      callbacks: [...params.callbacks, apiRef.current.applySorting]
    });
  }, [apiRef, props.disableMultipleColumnsSorting]);
  const flatSortingMethod = reactExports.useCallback((params) => {
    const rowTree = gridRowTreeSelector(apiRef);
    const rootGroupNode = rowTree[GRID_ROOT_GROUP_ID];
    const sortedChildren = params.sortRowList ? params.sortRowList(rootGroupNode.children.map((childId) => rowTree[childId])) : [...rootGroupNode.children];
    if (rootGroupNode.footerId != null) {
      sortedChildren.push(rootGroupNode.footerId);
    }
    return sortedChildren;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  useGridRegisterStrategyProcessor(apiRef, GRID_DEFAULT_STRATEGY, "sorting", flatSortingMethod);
  const handleColumnHeaderClick = reactExports.useCallback(({
    field,
    colDef
  }, event) => {
    if (!colDef.sortable || props.disableColumnSorting) {
      return;
    }
    const allowMultipleSorting = event.shiftKey || event.metaKey || event.ctrlKey;
    sortColumn(field, void 0, allowMultipleSorting);
  }, [sortColumn, props.disableColumnSorting]);
  const handleColumnHeaderKeyDown = reactExports.useCallback(({
    field,
    colDef
  }, event) => {
    if (!colDef.sortable || props.disableColumnSorting) {
      return;
    }
    if (event.key === "Enter" && !event.ctrlKey && !event.metaKey) {
      sortColumn(field, void 0, event.shiftKey);
    }
  }, [sortColumn, props.disableColumnSorting]);
  const handleColumnsChange = reactExports.useCallback(() => {
    const sortModel = gridSortModelSelector(apiRef);
    const latestColumns = gridColumnLookupSelector(apiRef);
    if (sortModel.length > 0) {
      const newModel = sortModel.filter((sortItem) => latestColumns[sortItem.field]);
      if (newModel.length < sortModel.length) {
        apiRef.current.setSortModel(newModel);
      }
    }
  }, [apiRef]);
  const handleStrategyProcessorChange = reactExports.useCallback((methodName) => {
    if (methodName === "sorting") {
      apiRef.current.applySorting();
    }
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "columnMenu", addColumnMenuItem);
  useGridApiEventHandler(apiRef, "columnHeaderClick", handleColumnHeaderClick);
  useGridApiEventHandler(apiRef, "columnHeaderKeyDown", handleColumnHeaderKeyDown);
  useGridApiEventHandler(apiRef, "rowsSet", apiRef.current.applySorting);
  useGridApiEventHandler(apiRef, "columnsChange", handleColumnsChange);
  useGridApiEventHandler(apiRef, "activeStrategyProcessorChange", handleStrategyProcessorChange);
  useFirstRender(() => {
    apiRef.current.applySorting();
  });
  useEnhancedEffect(() => {
    if (props.sortModel !== void 0) {
      apiRef.current.setSortModel(props.sortModel);
    }
  }, [apiRef, props.sortModel]);
}, "useGridSorting");
function scrollIntoView(dimensions) {
  const {
    containerSize,
    scrollPosition,
    elementSize,
    elementOffset
  } = dimensions;
  const elementEnd = elementOffset + elementSize;
  if (elementSize > containerSize) {
    return elementOffset;
  }
  if (elementEnd - containerSize > scrollPosition) {
    return elementEnd - containerSize;
  }
  if (elementOffset < scrollPosition) {
    return elementOffset;
  }
  return void 0;
}
__name(scrollIntoView, "scrollIntoView");
const useGridScroll = /* @__PURE__ */ __name((apiRef, props) => {
  const isRtl = useRtl();
  const logger = useGridLogger(apiRef, "useGridScroll");
  const colRef = apiRef.current.columnHeadersContainerRef;
  const virtualScrollerRef = apiRef.current.virtualScrollerRef;
  const visibleSortedRows = useGridSelector(apiRef, gridExpandedSortedRowEntriesSelector);
  const scrollToIndexes = reactExports.useCallback((params) => {
    var _a2;
    const dimensions = gridDimensionsSelector(apiRef.current.state);
    const totalRowCount = gridRowCountSelector(apiRef);
    const visibleColumns = props.unstable_listView ? [gridListColumnSelector(apiRef.current.state)] : gridVisibleColumnDefinitionsSelector(apiRef);
    const scrollToHeader = params.rowIndex == null;
    if (!scrollToHeader && totalRowCount === 0 || visibleColumns.length === 0) {
      return false;
    }
    logger.debug(`Scrolling to cell at row ${params.rowIndex}, col: ${params.colIndex} `);
    let scrollCoordinates = {};
    if (params.colIndex !== void 0) {
      const columnPositions = gridColumnPositionsSelector(apiRef);
      let cellWidth;
      if (typeof params.rowIndex !== "undefined") {
        const rowId = (_a2 = visibleSortedRows[params.rowIndex]) == null ? void 0 : _a2.id;
        const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, params.colIndex);
        if (cellColSpanInfo && !cellColSpanInfo.spannedByColSpan) {
          cellWidth = cellColSpanInfo.cellProps.width;
        }
      }
      if (typeof cellWidth === "undefined") {
        cellWidth = visibleColumns[params.colIndex].computedWidth;
      }
      scrollCoordinates.left = scrollIntoView({
        containerSize: dimensions.viewportOuterSize.width,
        scrollPosition: Math.abs(virtualScrollerRef.current.scrollLeft),
        elementSize: cellWidth,
        elementOffset: columnPositions[params.colIndex]
      });
    }
    if (params.rowIndex !== void 0) {
      const rowsMeta = gridRowsMetaSelector(apiRef.current.state);
      const page = gridPageSelector(apiRef);
      const pageSize2 = gridPageSizeSelector(apiRef);
      const elementIndex = !props.pagination ? params.rowIndex : params.rowIndex - page * pageSize2;
      const targetOffsetHeight = rowsMeta.positions[elementIndex + 1] ? rowsMeta.positions[elementIndex + 1] - rowsMeta.positions[elementIndex] : rowsMeta.currentPageTotalHeight - rowsMeta.positions[elementIndex];
      scrollCoordinates.top = scrollIntoView({
        containerSize: dimensions.viewportInnerSize.height,
        scrollPosition: virtualScrollerRef.current.scrollTop,
        elementSize: targetOffsetHeight,
        elementOffset: rowsMeta.positions[elementIndex]
      });
    }
    scrollCoordinates = apiRef.current.unstable_applyPipeProcessors("scrollToIndexes", scrollCoordinates, params);
    if (typeof scrollCoordinates.left !== void 0 || typeof scrollCoordinates.top !== void 0) {
      apiRef.current.scroll(scrollCoordinates);
      return true;
    }
    return false;
  }, [logger, apiRef, virtualScrollerRef, props.pagination, visibleSortedRows, props.unstable_listView]);
  const scroll = reactExports.useCallback((params) => {
    if (virtualScrollerRef.current && params.left !== void 0 && colRef.current) {
      const direction = isRtl ? -1 : 1;
      colRef.current.scrollLeft = params.left;
      virtualScrollerRef.current.scrollLeft = direction * params.left;
      logger.debug(`Scrolling left: ${params.left}`);
    }
    if (virtualScrollerRef.current && params.top !== void 0) {
      virtualScrollerRef.current.scrollTop = params.top;
      logger.debug(`Scrolling top: ${params.top}`);
    }
    logger.debug(`Scrolling, updating container, and viewport`);
  }, [virtualScrollerRef, isRtl, colRef, logger]);
  const getScrollPosition = reactExports.useCallback(() => {
    if (!(virtualScrollerRef == null ? void 0 : virtualScrollerRef.current)) {
      return {
        top: 0,
        left: 0
      };
    }
    return {
      top: virtualScrollerRef.current.scrollTop,
      left: virtualScrollerRef.current.scrollLeft
    };
  }, [virtualScrollerRef]);
  const scrollApi = {
    scroll,
    scrollToIndexes,
    getScrollPosition
  };
  useGridApiMethod(apiRef, scrollApi, "public");
}, "useGridScroll");
function useGridEvents(apiRef, props) {
  useGridApiOptionHandler(apiRef, "columnHeaderClick", props.onColumnHeaderClick);
  useGridApiOptionHandler(apiRef, "columnHeaderContextMenu", props.onColumnHeaderContextMenu);
  useGridApiOptionHandler(apiRef, "columnHeaderDoubleClick", props.onColumnHeaderDoubleClick);
  useGridApiOptionHandler(apiRef, "columnHeaderOver", props.onColumnHeaderOver);
  useGridApiOptionHandler(apiRef, "columnHeaderOut", props.onColumnHeaderOut);
  useGridApiOptionHandler(apiRef, "columnHeaderEnter", props.onColumnHeaderEnter);
  useGridApiOptionHandler(apiRef, "columnHeaderLeave", props.onColumnHeaderLeave);
  useGridApiOptionHandler(apiRef, "cellClick", props.onCellClick);
  useGridApiOptionHandler(apiRef, "cellDoubleClick", props.onCellDoubleClick);
  useGridApiOptionHandler(apiRef, "cellKeyDown", props.onCellKeyDown);
  useGridApiOptionHandler(apiRef, "preferencePanelClose", props.onPreferencePanelClose);
  useGridApiOptionHandler(apiRef, "preferencePanelOpen", props.onPreferencePanelOpen);
  useGridApiOptionHandler(apiRef, "menuOpen", props.onMenuOpen);
  useGridApiOptionHandler(apiRef, "menuClose", props.onMenuClose);
  useGridApiOptionHandler(apiRef, "rowDoubleClick", props.onRowDoubleClick);
  useGridApiOptionHandler(apiRef, "rowClick", props.onRowClick);
  useGridApiOptionHandler(apiRef, "stateChange", props.onStateChange);
}
__name(useGridEvents, "useGridEvents");
function throttle$2(func, wait = 166) {
  let timeout;
  let lastArgs;
  const later = /* @__PURE__ */ __name(() => {
    timeout = void 0;
    func(...lastArgs);
  }, "later");
  function throttled(...args) {
    lastArgs = args;
    if (timeout === void 0) {
      timeout = setTimeout(later, wait);
    }
  }
  __name(throttled, "throttled");
  throttled.clear = () => {
    clearTimeout(timeout);
    timeout = void 0;
  };
  return throttled;
}
__name(throttle$2, "throttle$2");
const DATA_GRID_PROPS_DEFAULT_VALUES = {
  autoHeight: false,
  autoPageSize: false,
  autosizeOnMount: false,
  checkboxSelection: false,
  checkboxSelectionVisibleOnly: false,
  clipboardCopyCellDelimiter: "	",
  columnBufferPx: 150,
  columnHeaderHeight: 56,
  disableAutosize: false,
  disableColumnFilter: false,
  disableColumnMenu: false,
  disableColumnReorder: false,
  disableColumnResize: false,
  disableColumnSelector: false,
  disableColumnSorting: false,
  disableDensitySelector: false,
  disableEval: false,
  disableMultipleColumnsFiltering: false,
  disableMultipleColumnsSorting: false,
  disableMultipleRowSelection: false,
  disableRowSelectionOnClick: false,
  disableVirtualization: false,
  editMode: GridEditModes.Cell,
  filterDebounceMs: 150,
  filterMode: "client",
  hideFooter: false,
  hideFooterPagination: false,
  hideFooterRowCount: false,
  hideFooterSelectedRowCount: false,
  ignoreDiacritics: false,
  ignoreValueFormatterDuringExport: false,
  // TODO v8: Update to 'select'
  indeterminateCheckboxAction: "deselect",
  keepColumnPositionIfDraggedOutside: false,
  keepNonExistentRowsSelected: false,
  loading: false,
  logger: console,
  logLevel: "error",
  pageSizeOptions: [25, 50, 100],
  pagination: false,
  paginationMode: "client",
  resizeThrottleMs: 60,
  rowBufferPx: 150,
  rowHeight: 52,
  rowPositionsDebounceMs: 166,
  rows: [],
  rowSelection: true,
  rowSpacingType: "margin",
  showCellVerticalBorder: false,
  showColumnVerticalBorder: false,
  sortingMode: "client",
  sortingOrder: ["asc", "desc", null],
  throttleRowsMs: 0,
  unstable_rowSpanning: false
};
const EMPTY_SIZE = {
  width: 0,
  height: 0
};
const EMPTY_DIMENSIONS = {
  isReady: false,
  root: EMPTY_SIZE,
  viewportOuterSize: EMPTY_SIZE,
  viewportInnerSize: EMPTY_SIZE,
  contentSize: EMPTY_SIZE,
  minimumSize: EMPTY_SIZE,
  hasScrollX: false,
  hasScrollY: false,
  scrollbarSize: 0,
  headerHeight: 0,
  groupHeaderHeight: 0,
  headerFilterHeight: 0,
  rowWidth: 0,
  rowHeight: 0,
  columnsTotalWidth: 0,
  leftPinnedWidth: 0,
  rightPinnedWidth: 0,
  headersTotalHeight: 0,
  topContainerHeight: 0,
  bottomContainerHeight: 0
};
const dimensionsStateInitializer = /* @__PURE__ */ __name((state) => {
  const dimensions = EMPTY_DIMENSIONS;
  return _extends$4({}, state, {
    dimensions
  });
}, "dimensionsStateInitializer");
function useGridDimensions(apiRef, props) {
  const logger = useGridLogger(apiRef, "useResizeContainer");
  const errorShown = reactExports.useRef(false);
  const rootDimensionsRef = reactExports.useRef(EMPTY_SIZE);
  const dimensionsState = useGridSelector(apiRef, gridDimensionsSelector);
  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);
  const pinnedColumns = useGridSelector(apiRef, gridVisiblePinnedColumnDefinitionsSelector);
  const densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);
  const validRowHeight = reactExports.useMemo(() => getValidRowHeight(props.rowHeight, DATA_GRID_PROPS_DEFAULT_VALUES.rowHeight), [props.rowHeight]);
  const rowHeight = Math.floor(validRowHeight * densityFactor);
  const headerHeight = Math.floor(props.columnHeaderHeight * densityFactor);
  const groupHeaderHeight = Math.floor((props.columnGroupHeaderHeight ?? props.columnHeaderHeight) * densityFactor);
  const headerFilterHeight = Math.floor((props.headerFilterHeight ?? props.columnHeaderHeight) * densityFactor);
  const columnsTotalWidth = roundToDecimalPlaces(gridColumnsTotalWidthSelector(apiRef), 6);
  const headersTotalHeight = getTotalHeaderHeight(apiRef, props);
  const leftPinnedWidth = pinnedColumns.left.reduce((w2, col) => w2 + col.computedWidth, 0);
  const rightPinnedWidth = pinnedColumns.right.reduce((w2, col) => w2 + col.computedWidth, 0);
  const [savedSize, setSavedSize] = reactExports.useState();
  const debouncedSetSavedSize = reactExports.useMemo(() => throttle$2(setSavedSize, props.resizeThrottleMs), [props.resizeThrottleMs]);
  const previousSize = reactExports.useRef();
  const getRootDimensions = /* @__PURE__ */ __name(() => apiRef.current.state.dimensions, "getRootDimensions");
  const setDimensions = useEventCallback((dimensions) => {
    apiRef.current.setState((state) => _extends$4({}, state, {
      dimensions
    }));
  });
  const resize = reactExports.useCallback(() => {
    const element = apiRef.current.mainElementRef.current;
    if (!element) {
      return;
    }
    const computedStyle = ownerWindow(element).getComputedStyle(element);
    const newSize = {
      width: parseFloat(computedStyle.width) || 0,
      height: parseFloat(computedStyle.height) || 0
    };
    if (!previousSize.current || !areElementSizesEqual(previousSize.current, newSize)) {
      apiRef.current.publishEvent("resize", newSize);
      previousSize.current = newSize;
    }
  }, [apiRef]);
  const getViewportPageSize = reactExports.useCallback(() => {
    const dimensions = gridDimensionsSelector(apiRef.current.state);
    if (!dimensions.isReady) {
      return 0;
    }
    const currentPage = getVisibleRows(apiRef, {
      pagination: props.pagination,
      paginationMode: props.paginationMode
    });
    if (props.getRowHeight) {
      const renderContext = gridRenderContextSelector(apiRef);
      const viewportPageSize = renderContext.lastRowIndex - renderContext.firstRowIndex;
      return Math.min(viewportPageSize - 1, currentPage.rows.length);
    }
    const maximumPageSizeWithoutScrollBar = Math.floor(dimensions.viewportInnerSize.height / rowHeight);
    return Math.min(maximumPageSizeWithoutScrollBar, currentPage.rows.length);
  }, [apiRef, props.pagination, props.paginationMode, props.getRowHeight, rowHeight]);
  const updateDimensions = reactExports.useCallback(() => {
    var _a2, _b2;
    const rootElement = apiRef.current.rootElementRef.current;
    const pinnedRowsHeight = calculatePinnedRowsHeight(apiRef);
    const scrollbarSize = measureScrollbarSize(rootElement, columnsTotalWidth, props.scrollbarSize);
    const topContainerHeight = headersTotalHeight + pinnedRowsHeight.top;
    const bottomContainerHeight = pinnedRowsHeight.bottom;
    const nonPinnedColumnsTotalWidth = columnsTotalWidth - leftPinnedWidth - rightPinnedWidth;
    const contentSize = {
      width: nonPinnedColumnsTotalWidth,
      height: rowsMeta.currentPageTotalHeight
    };
    let viewportOuterSize;
    let viewportInnerSize;
    let hasScrollX = false;
    let hasScrollY = false;
    if (props.autoHeight) {
      hasScrollY = false;
      hasScrollX = Math.round(columnsTotalWidth) > Math.round(rootDimensionsRef.current.width);
      viewportOuterSize = {
        width: rootDimensionsRef.current.width,
        height: topContainerHeight + bottomContainerHeight + contentSize.height
      };
      viewportInnerSize = {
        width: Math.max(0, viewportOuterSize.width - (hasScrollY ? scrollbarSize : 0)),
        height: Math.max(0, viewportOuterSize.height - (hasScrollX ? scrollbarSize : 0))
      };
    } else {
      viewportOuterSize = {
        width: rootDimensionsRef.current.width,
        height: rootDimensionsRef.current.height
      };
      viewportInnerSize = {
        width: Math.max(0, viewportOuterSize.width - leftPinnedWidth - rightPinnedWidth),
        height: Math.max(0, viewportOuterSize.height - topContainerHeight - bottomContainerHeight)
      };
      const content = contentSize;
      const container = viewportInnerSize;
      const hasScrollXIfNoYScrollBar = content.width > container.width;
      const hasScrollYIfNoXScrollBar = content.height > container.height;
      if (hasScrollXIfNoYScrollBar || hasScrollYIfNoXScrollBar) {
        hasScrollY = hasScrollYIfNoXScrollBar;
        hasScrollX = content.width + (hasScrollY ? scrollbarSize : 0) > container.width;
        if (hasScrollX) {
          hasScrollY = content.height + scrollbarSize > container.height;
        }
      }
      if (hasScrollY) {
        viewportInnerSize.width -= scrollbarSize;
      }
      if (hasScrollX) {
        viewportInnerSize.height -= scrollbarSize;
      }
    }
    const rowWidth = Math.max(viewportOuterSize.width, columnsTotalWidth + (hasScrollY ? scrollbarSize : 0));
    const minimumSize = {
      width: columnsTotalWidth,
      height: topContainerHeight + contentSize.height + bottomContainerHeight
    };
    const newDimensions = {
      isReady: true,
      root: rootDimensionsRef.current,
      viewportOuterSize,
      viewportInnerSize,
      contentSize,
      minimumSize,
      hasScrollX,
      hasScrollY,
      scrollbarSize,
      headerHeight,
      groupHeaderHeight,
      headerFilterHeight,
      rowWidth,
      rowHeight,
      columnsTotalWidth,
      leftPinnedWidth,
      rightPinnedWidth,
      headersTotalHeight,
      topContainerHeight,
      bottomContainerHeight
    };
    const prevDimensions = apiRef.current.state.dimensions;
    setDimensions(newDimensions);
    if (!areElementSizesEqual(newDimensions.viewportInnerSize, prevDimensions.viewportInnerSize)) {
      apiRef.current.publishEvent("viewportInnerSizeChange", newDimensions.viewportInnerSize);
    }
    (_b2 = (_a2 = apiRef.current).updateRenderContext) == null ? void 0 : _b2.call(_a2);
  }, [apiRef, setDimensions, props.scrollbarSize, props.autoHeight, rowsMeta.currentPageTotalHeight, rowHeight, headerHeight, groupHeaderHeight, headerFilterHeight, columnsTotalWidth, headersTotalHeight, leftPinnedWidth, rightPinnedWidth]);
  const apiPublic = {
    resize,
    getRootDimensions
  };
  const apiPrivate = {
    updateDimensions,
    getViewportPageSize
  };
  useGridApiMethod(apiRef, apiPublic, "public");
  useGridApiMethod(apiRef, apiPrivate, "private");
  useEnhancedEffect(() => {
    if (savedSize) {
      updateDimensions();
      apiRef.current.publishEvent("debouncedResize", rootDimensionsRef.current);
    }
  }, [apiRef, savedSize, updateDimensions]);
  const root2 = apiRef.current.rootElementRef.current;
  useEnhancedEffect(() => {
    if (!root2) {
      return;
    }
    const set = /* @__PURE__ */ __name((k2, v2) => root2.style.setProperty(k2, v2), "set");
    set("--DataGrid-width", `${dimensionsState.viewportOuterSize.width}px`);
    set("--DataGrid-hasScrollX", `${Number(dimensionsState.hasScrollX)}`);
    set("--DataGrid-hasScrollY", `${Number(dimensionsState.hasScrollY)}`);
    set("--DataGrid-scrollbarSize", `${dimensionsState.scrollbarSize}px`);
    set("--DataGrid-rowWidth", `${dimensionsState.rowWidth}px`);
    set("--DataGrid-columnsTotalWidth", `${dimensionsState.columnsTotalWidth}px`);
    set("--DataGrid-leftPinnedWidth", `${dimensionsState.leftPinnedWidth}px`);
    set("--DataGrid-rightPinnedWidth", `${dimensionsState.rightPinnedWidth}px`);
    set("--DataGrid-headerHeight", `${dimensionsState.headerHeight}px`);
    set("--DataGrid-headersTotalHeight", `${dimensionsState.headersTotalHeight}px`);
    set("--DataGrid-topContainerHeight", `${dimensionsState.topContainerHeight}px`);
    set("--DataGrid-bottomContainerHeight", `${dimensionsState.bottomContainerHeight}px`);
    set("--height", `${dimensionsState.rowHeight}px`);
  }, [root2, dimensionsState]);
  const isFirstSizing = reactExports.useRef(true);
  const handleResize = reactExports.useCallback((size2) => {
    rootDimensionsRef.current = size2;
    const isJSDOM2 = /jsdom/.test(window.navigator.userAgent);
    if (size2.height === 0 && !errorShown.current && !props.autoHeight && !isJSDOM2) {
      logger.error(["The parent DOM element of the Data Grid has an empty height.", "Please make sure that this element has an intrinsic height.", "The grid displays with a height of 0px.", "", "More details: https://mui.com/r/x-data-grid-no-dimensions."].join("\n"));
      errorShown.current = true;
    }
    if (size2.width === 0 && !errorShown.current && !isJSDOM2) {
      logger.error(["The parent DOM element of the Data Grid has an empty width.", "Please make sure that this element has an intrinsic width.", "The grid displays with a width of 0px.", "", "More details: https://mui.com/r/x-data-grid-no-dimensions."].join("\n"));
      errorShown.current = true;
    }
    if (isFirstSizing.current) {
      setSavedSize(size2);
      isFirstSizing.current = false;
      return;
    }
    debouncedSetSavedSize(size2);
  }, [props.autoHeight, debouncedSetSavedSize, logger]);
  useEnhancedEffect(updateDimensions, [updateDimensions]);
  useGridApiOptionHandler(apiRef, "sortedRowsSet", updateDimensions);
  useGridApiOptionHandler(apiRef, "paginationModelChange", updateDimensions);
  useGridApiOptionHandler(apiRef, "columnsChange", updateDimensions);
  useGridApiEventHandler(apiRef, "resize", handleResize);
  useGridApiOptionHandler(apiRef, "debouncedResize", props.onResize);
}
__name(useGridDimensions, "useGridDimensions");
function measureScrollbarSize(rootElement, columnsTotalWidth, scrollbarSize) {
  if (scrollbarSize !== void 0) {
    return scrollbarSize;
  }
  if (rootElement === null || columnsTotalWidth === 0) {
    return 0;
  }
  const doc = ownerDocument(rootElement);
  const scrollDiv = doc.createElement("div");
  scrollDiv.style.width = "99px";
  scrollDiv.style.height = "99px";
  scrollDiv.style.position = "absolute";
  scrollDiv.style.overflow = "scroll";
  scrollDiv.className = "scrollDiv";
  rootElement.appendChild(scrollDiv);
  const size2 = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  rootElement.removeChild(scrollDiv);
  return size2;
}
__name(measureScrollbarSize, "measureScrollbarSize");
function roundToDecimalPlaces(value, decimals) {
  return Math.round(value * 10 ** decimals) / 10 ** decimals;
}
__name(roundToDecimalPlaces, "roundToDecimalPlaces");
function areElementSizesEqual(a, b2) {
  return a.width === b2.width && a.height === b2.height;
}
__name(areElementSizesEqual, "areElementSizesEqual");
const ResizeObserver$2 = typeof globalThis.ResizeObserver !== "undefined" ? globalThis.ResizeObserver : (_c = class {
  observe() {
  }
  unobserve() {
  }
  disconnect() {
  }
}, __name(_c, "ResizeObserver"), _c);
const rowsMetaStateInitializer = /* @__PURE__ */ __name((state, props, apiRef) => {
  apiRef.current.caches.rowsMeta = {
    heights: /* @__PURE__ */ new Map()
  };
  return _extends$4({}, state, {
    rowsMeta: {
      currentPageTotalHeight: 0,
      positions: []
    }
  });
}, "rowsMetaStateInitializer");
const useGridRowsMeta = /* @__PURE__ */ __name((apiRef, props) => {
  const {
    getRowHeight: getRowHeightProp,
    getRowSpacing,
    getEstimatedRowHeight
  } = props;
  const heightCache = apiRef.current.caches.rowsMeta.heights;
  const lastMeasuredRowIndex = reactExports.useRef(-1);
  const hasRowWithAutoHeight = reactExports.useRef(false);
  const isHeightMetaValid = reactExports.useRef(false);
  const densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);
  const filterModel = useGridSelector(apiRef, gridFilterModelSelector);
  const paginationState = useGridSelector(apiRef, gridPaginationSelector);
  const sortModel = useGridSelector(apiRef, gridSortModelSelector);
  const currentPage = useGridVisibleRows(apiRef, props);
  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);
  const rowHeight = useGridSelector(apiRef, () => gridDimensionsSelector(apiRef.current.state).rowHeight);
  const getRowHeightEntry = /* @__PURE__ */ __name((rowId) => {
    let entry = heightCache.get(rowId);
    if (entry === void 0) {
      entry = {
        content: rowHeight,
        spacingTop: 0,
        spacingBottom: 0,
        detail: 0,
        autoHeight: false,
        needsFirstMeasurement: true
      };
      heightCache.set(rowId, entry);
    }
    return entry;
  }, "getRowHeightEntry");
  const processHeightEntry = reactExports.useCallback((row) => {
    const baseRowHeight = gridDimensionsSelector(apiRef.current.state).rowHeight;
    const entry = apiRef.current.getRowHeightEntry(row.id);
    if (!getRowHeightProp) {
      entry.content = baseRowHeight;
      entry.needsFirstMeasurement = false;
    } else {
      const rowHeightFromUser = getRowHeightProp(_extends$4({}, row, {
        densityFactor
      }));
      if (rowHeightFromUser === "auto") {
        if (entry.needsFirstMeasurement) {
          const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends$4({}, row, {
            densityFactor
          })) : baseRowHeight;
          entry.content = estimatedRowHeight ?? baseRowHeight;
        }
        hasRowWithAutoHeight.current = true;
        entry.autoHeight = true;
      } else {
        entry.content = getValidRowHeight(rowHeightFromUser, baseRowHeight);
        entry.needsFirstMeasurement = false;
        entry.autoHeight = false;
      }
    }
    if (getRowSpacing) {
      const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);
      const spacing = getRowSpacing(_extends$4({}, row, {
        isFirstVisible: indexRelativeToCurrentPage === 0,
        isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,
        indexRelativeToCurrentPage
      }));
      entry.spacingTop = spacing.top ?? 0;
      entry.spacingBottom = spacing.bottom ?? 0;
    } else {
      entry.spacingTop = 0;
      entry.spacingBottom = 0;
    }
    apiRef.current.unstable_applyPipeProcessors("rowHeight", entry, row);
    return entry;
  }, [apiRef, currentPage.rows.length, getRowHeightProp, getEstimatedRowHeight, rowHeight, getRowSpacing, densityFactor]);
  const hydrateRowsMeta = reactExports.useCallback(() => {
    hasRowWithAutoHeight.current = false;
    pinnedRows.top.forEach(processHeightEntry);
    pinnedRows.bottom.forEach(processHeightEntry);
    const positions = [];
    const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {
      positions.push(acc);
      const entry = processHeightEntry(row);
      const total = entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;
      return acc + total;
    }, 0);
    if (!hasRowWithAutoHeight.current) {
      lastMeasuredRowIndex.current = Infinity;
    }
    apiRef.current.setState((state) => {
      return _extends$4({}, state, {
        rowsMeta: {
          currentPageTotalHeight,
          positions
        }
      });
    });
    isHeightMetaValid.current = true;
  }, [apiRef, pinnedRows, currentPage.rows, processHeightEntry]);
  const getRowHeight = /* @__PURE__ */ __name((rowId) => {
    var _a2;
    return ((_a2 = heightCache.get(rowId)) == null ? void 0 : _a2.content) ?? rowHeight;
  }, "getRowHeight");
  const storeRowHeightMeasurement = /* @__PURE__ */ __name((id2, height2) => {
    const entry = apiRef.current.getRowHeightEntry(id2);
    const didChange = entry.content !== height2;
    entry.needsFirstMeasurement = false;
    entry.content = height2;
    isHeightMetaValid.current && (isHeightMetaValid.current = !didChange);
  }, "storeRowHeightMeasurement");
  const rowHasAutoHeight = /* @__PURE__ */ __name((id2) => {
    var _a2;
    return ((_a2 = heightCache.get(id2)) == null ? void 0 : _a2.autoHeight) ?? false;
  }, "rowHasAutoHeight");
  const getLastMeasuredRowIndex = /* @__PURE__ */ __name(() => {
    return lastMeasuredRowIndex.current;
  }, "getLastMeasuredRowIndex");
  const setLastMeasuredRowIndex = /* @__PURE__ */ __name((index2) => {
    if (hasRowWithAutoHeight.current && index2 > lastMeasuredRowIndex.current) {
      lastMeasuredRowIndex.current = index2;
    }
  }, "setLastMeasuredRowIndex");
  const resetRowHeights = /* @__PURE__ */ __name(() => {
    heightCache.clear();
    hydrateRowsMeta();
  }, "resetRowHeights");
  const resizeObserver = useLazyRef(() => new ResizeObserver$2((entries) => {
    for (let i = 0; i < entries.length; i += 1) {
      const entry = entries[i];
      const height2 = entry.borderBoxSize && entry.borderBoxSize.length > 0 ? entry.borderBoxSize[0].blockSize : entry.contentRect.height;
      const rowId = entry.target.__mui_id;
      apiRef.current.unstable_storeRowHeightMeasurement(rowId, height2);
    }
    if (!isHeightMetaValid.current) {
      apiRef.current.requestPipeProcessorsApplication("rowHeight");
    }
  })).current;
  const observeRowHeight = /* @__PURE__ */ __name((element, rowId) => {
    element.__mui_id = rowId;
    resizeObserver.observe(element);
    return () => resizeObserver.unobserve(element);
  }, "observeRowHeight");
  useGridRegisterPipeApplier(apiRef, "rowHeight", hydrateRowsMeta);
  reactExports.useEffect(() => {
    hydrateRowsMeta();
  }, [filterModel, paginationState, sortModel, hydrateRowsMeta]);
  const rowsMetaApi = {
    unstable_getRowHeight: getRowHeight,
    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,
    unstable_storeRowHeightMeasurement: storeRowHeightMeasurement,
    resetRowHeights
  };
  const rowsMetaPrivateApi = {
    hydrateRowsMeta,
    observeRowHeight,
    rowHasAutoHeight,
    getRowHeightEntry,
    getLastMeasuredRowIndex
  };
  useGridApiMethod(apiRef, rowsMetaApi, "public");
  useGridApiMethod(apiRef, rowsMetaPrivateApi, "private");
}, "useGridRowsMeta");
const useGridStatePersistence = /* @__PURE__ */ __name((apiRef) => {
  const exportState = reactExports.useCallback((params = {}) => {
    const stateToExport = apiRef.current.unstable_applyPipeProcessors("exportState", {}, params);
    return stateToExport;
  }, [apiRef]);
  const restoreState = reactExports.useCallback((stateToRestore) => {
    const response = apiRef.current.unstable_applyPipeProcessors("restoreState", {
      callbacks: []
    }, {
      stateToRestore
    });
    response.callbacks.forEach((callback) => {
      callback();
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const statePersistenceApi = {
    exportState,
    restoreState
  };
  useGridApiMethod(apiRef, statePersistenceApi, "public");
}, "useGridStatePersistence");
const useGridColumnSpanning = /* @__PURE__ */ __name((apiRef) => {
  const lookup = reactExports.useRef({});
  const getCellColSpanInfo = /* @__PURE__ */ __name((rowId, columnIndex) => {
    var _a2;
    return (_a2 = lookup.current[rowId]) == null ? void 0 : _a2[columnIndex];
  }, "getCellColSpanInfo");
  const resetColSpan = /* @__PURE__ */ __name(() => {
    lookup.current = {};
  }, "resetColSpan");
  const calculateColSpan = reactExports.useCallback(({
    rowId,
    minFirstColumn,
    maxLastColumn,
    columns: columns2
  }) => {
    for (let i = minFirstColumn; i < maxLastColumn; i += 1) {
      const cellProps = calculateCellColSpan({
        apiRef,
        lookup: lookup.current,
        columnIndex: i,
        rowId,
        minFirstColumnIndex: minFirstColumn,
        maxLastColumnIndex: maxLastColumn,
        columns: columns2
      });
      if (cellProps.colSpan > 1) {
        i += cellProps.colSpan - 1;
      }
    }
  }, [apiRef]);
  const columnSpanningPublicApi = {
    unstable_getCellColSpanInfo: getCellColSpanInfo
  };
  const columnSpanningPrivateApi = {
    resetColSpan,
    calculateColSpan
  };
  useGridApiMethod(apiRef, columnSpanningPublicApi, "public");
  useGridApiMethod(apiRef, columnSpanningPrivateApi, "private");
  useGridApiEventHandler(apiRef, "columnOrderChange", resetColSpan);
}, "useGridColumnSpanning");
function calculateCellColSpan(params) {
  const {
    apiRef,
    lookup,
    columnIndex,
    rowId,
    minFirstColumnIndex,
    maxLastColumnIndex,
    columns: columns2
  } = params;
  const columnsLength = columns2.length;
  const column2 = columns2[columnIndex];
  const row = apiRef.current.getRow(rowId);
  const value = apiRef.current.getRowValue(row, column2);
  const colSpan = typeof column2.colSpan === "function" ? column2.colSpan(value, row, column2, apiRef) : column2.colSpan;
  if (!colSpan || colSpan === 1) {
    setCellColSpanInfo(lookup, rowId, columnIndex, {
      spannedByColSpan: false,
      cellProps: {
        colSpan: 1,
        width: column2.computedWidth
      }
    });
    return {
      colSpan: 1
    };
  }
  let width2 = column2.computedWidth;
  for (let j = 1; j < colSpan; j += 1) {
    const nextColumnIndex = columnIndex + j;
    if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {
      const nextColumn = columns2[nextColumnIndex];
      width2 += nextColumn.computedWidth;
      setCellColSpanInfo(lookup, rowId, columnIndex + j, {
        spannedByColSpan: true,
        rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),
        leftVisibleCellIndex: columnIndex
      });
    }
    setCellColSpanInfo(lookup, rowId, columnIndex, {
      spannedByColSpan: false,
      cellProps: {
        colSpan,
        width: width2
      }
    });
  }
  return {
    colSpan
  };
}
__name(calculateCellColSpan, "calculateCellColSpan");
function setCellColSpanInfo(lookup, rowId, columnIndex, cellColSpanInfo) {
  if (!lookup[rowId]) {
    lookup[rowId] = {};
  }
  lookup[rowId][columnIndex] = cellColSpanInfo;
}
__name(setCellColSpanInfo, "setCellColSpanInfo");
const recurrentUnwrapGroupingColumnModel = /* @__PURE__ */ __name((columnGroupNode, parents, unwrappedGroupingModelToComplete) => {
  if (isLeaf(columnGroupNode)) {
    if (unwrappedGroupingModelToComplete[columnGroupNode.field] !== void 0) {
      throw new Error([`MUI X: columnGroupingModel contains duplicated field`, `column field ${columnGroupNode.field} occurs two times in the grouping model:`, `- ${unwrappedGroupingModelToComplete[columnGroupNode.field].join(" > ")}`, `- ${parents.join(" > ")}`].join("\n"));
    }
    unwrappedGroupingModelToComplete[columnGroupNode.field] = parents;
    return;
  }
  const {
    groupId,
    children
  } = columnGroupNode;
  children.forEach((child) => {
    recurrentUnwrapGroupingColumnModel(child, [...parents, groupId], unwrappedGroupingModelToComplete);
  });
}, "recurrentUnwrapGroupingColumnModel");
const unwrapGroupingColumnModel = /* @__PURE__ */ __name((columnGroupingModel) => {
  if (!columnGroupingModel) {
    return {};
  }
  const unwrappedSubTree = {};
  columnGroupingModel.forEach((columnGroupNode) => {
    recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);
  });
  return unwrappedSubTree;
}, "unwrapGroupingColumnModel");
const getColumnGroupsHeaderStructure = /* @__PURE__ */ __name((orderedColumns, unwrappedGroupingModel, pinnedFields) => {
  const getParents = /* @__PURE__ */ __name((field) => unwrappedGroupingModel[field] ?? [], "getParents");
  const groupingHeaderStructure = [];
  const maxDepth = Math.max(...orderedColumns.map((field) => getParents(field).length));
  const haveSameParents = /* @__PURE__ */ __name((field1, field2, depth) => isDeepEqual(getParents(field1).slice(0, depth + 1), getParents(field2).slice(0, depth + 1)), "haveSameParents");
  const haveDifferentContainers = /* @__PURE__ */ __name((field1, field2) => {
    if ((pinnedFields == null ? void 0 : pinnedFields.left) && pinnedFields.left.includes(field1) && !pinnedFields.left.includes(field2)) {
      return true;
    }
    if ((pinnedFields == null ? void 0 : pinnedFields.right) && !pinnedFields.right.includes(field1) && pinnedFields.right.includes(field2)) {
      return true;
    }
    return false;
  }, "haveDifferentContainers");
  for (let depth = 0; depth < maxDepth; depth += 1) {
    const depthStructure = orderedColumns.reduce((structure, newField) => {
      const groupId = getParents(newField)[depth] ?? null;
      if (structure.length === 0) {
        return [{
          columnFields: [newField],
          groupId
        }];
      }
      const lastGroup = structure[structure.length - 1];
      const prevField = lastGroup.columnFields[lastGroup.columnFields.length - 1];
      const prevGroupId = lastGroup.groupId;
      if (prevGroupId !== groupId || !haveSameParents(prevField, newField, depth) || // Fix for https://github.com/mui/mui-x/issues/7041
      haveDifferentContainers(prevField, newField)) {
        return [...structure, {
          columnFields: [newField],
          groupId
        }];
      }
      return [...structure.slice(0, structure.length - 1), {
        columnFields: [...lastGroup.columnFields, newField],
        groupId
      }];
    }, []);
    groupingHeaderStructure.push(depthStructure);
  }
  return groupingHeaderStructure;
}, "getColumnGroupsHeaderStructure");
const _excluded$n = ["groupId", "children"];
const createGroupLookup = /* @__PURE__ */ __name((columnGroupingModel) => {
  let groupLookup = {};
  columnGroupingModel.forEach((node2) => {
    if (isLeaf(node2)) {
      return;
    }
    const {
      groupId,
      children
    } = node2, other = _objectWithoutPropertiesLoose$1(node2, _excluded$n);
    if (!groupId) {
      throw new Error("MUI X: An element of the columnGroupingModel does not have either `field` or `groupId`.");
    }
    const groupParam = _extends$4({}, other, {
      groupId
    });
    const subTreeLookup = createGroupLookup(children);
    if (subTreeLookup[groupId] !== void 0 || groupLookup[groupId] !== void 0) {
      throw new Error(`MUI X: The groupId ${groupId} is used multiple times in the columnGroupingModel.`);
    }
    groupLookup = _extends$4({}, groupLookup, subTreeLookup, {
      [groupId]: groupParam
    });
  });
  return _extends$4({}, groupLookup);
}, "createGroupLookup");
const columnGroupsStateInitializer = /* @__PURE__ */ __name((state, props, apiRef) => {
  if (!props.columnGroupingModel) {
    return state;
  }
  const columnFields = gridColumnFieldsSelector(apiRef);
  const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);
  const groupLookup = createGroupLookup(props.columnGroupingModel ?? []);
  const unwrappedGroupingModel = unwrapGroupingColumnModel(props.columnGroupingModel ?? []);
  const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(columnFields, unwrappedGroupingModel, apiRef.current.state.pinnedColumns ?? {});
  const maxDepth = visibleColumnFields.length === 0 ? 0 : Math.max(...visibleColumnFields.map((field) => {
    var _a2;
    return ((_a2 = unwrappedGroupingModel[field]) == null ? void 0 : _a2.length) ?? 0;
  }));
  return _extends$4({}, state, {
    columnGrouping: {
      lookup: groupLookup,
      unwrappedGroupingModel,
      headerStructure: columnGroupsHeaderStructure,
      maxDepth
    }
  });
}, "columnGroupsStateInitializer");
const useGridColumnGrouping = /* @__PURE__ */ __name((apiRef, props) => {
  const getColumnGroupPath = reactExports.useCallback((field) => {
    const unwrappedGroupingModel = gridColumnGroupsUnwrappedModelSelector(apiRef);
    return unwrappedGroupingModel[field] ?? [];
  }, [apiRef]);
  const getAllGroupDetails = reactExports.useCallback(() => {
    const columnGroupLookup = gridColumnGroupsLookupSelector(apiRef);
    return columnGroupLookup;
  }, [apiRef]);
  const columnGroupingApi = {
    getColumnGroupPath,
    getAllGroupDetails
  };
  useGridApiMethod(apiRef, columnGroupingApi, "public");
  const handleColumnIndexChange = reactExports.useCallback(() => {
    const unwrappedGroupingModel = unwrapGroupingColumnModel(props.columnGroupingModel ?? []);
    apiRef.current.setState((state) => {
      var _a2;
      const orderedFields = ((_a2 = state.columns) == null ? void 0 : _a2.orderedFields) ?? [];
      const pinnedColumns = state.pinnedColumns ?? {};
      const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(orderedFields, unwrappedGroupingModel, pinnedColumns);
      return _extends$4({}, state, {
        columnGrouping: _extends$4({}, state.columnGrouping, {
          headerStructure: columnGroupsHeaderStructure
        })
      });
    });
  }, [apiRef, props.columnGroupingModel]);
  const updateColumnGroupingState = reactExports.useCallback((columnGroupingModel) => {
    var _a2, _b2;
    const pinnedColumns = ((_b2 = (_a2 = apiRef.current).getPinnedColumns) == null ? void 0 : _b2.call(_a2)) ?? {};
    const columnFields = gridColumnFieldsSelector(apiRef);
    const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);
    const groupLookup = createGroupLookup(columnGroupingModel ?? []);
    const unwrappedGroupingModel = unwrapGroupingColumnModel(columnGroupingModel ?? []);
    const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(columnFields, unwrappedGroupingModel, pinnedColumns);
    const maxDepth = visibleColumnFields.length === 0 ? 0 : Math.max(...visibleColumnFields.map((field) => {
      var _a3;
      return ((_a3 = unwrappedGroupingModel[field]) == null ? void 0 : _a3.length) ?? 0;
    }));
    apiRef.current.setState((state) => {
      return _extends$4({}, state, {
        columnGrouping: {
          lookup: groupLookup,
          unwrappedGroupingModel,
          headerStructure: columnGroupsHeaderStructure,
          maxDepth
        }
      });
    });
  }, [apiRef]);
  useGridApiEventHandler(apiRef, "columnIndexChange", handleColumnIndexChange);
  useGridApiEventHandler(apiRef, "columnsChange", () => {
    updateColumnGroupingState(props.columnGroupingModel);
  });
  useGridApiEventHandler(apiRef, "columnVisibilityModelChange", () => {
    updateColumnGroupingState(props.columnGroupingModel);
  });
  reactExports.useEffect(() => {
    updateColumnGroupingState(props.columnGroupingModel);
  }, [updateColumnGroupingState, props.columnGroupingModel]);
}, "useGridColumnGrouping");
function createControllablePromise() {
  let resolve;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  promise.resolve = resolve;
  promise.reject = reject;
  return promise;
}
__name(createControllablePromise, "createControllablePromise");
function trackFinger(event, currentTouchId) {
  if (currentTouchId !== void 0 && event.changedTouches) {
    for (let i = 0; i < event.changedTouches.length; i += 1) {
      const touch = event.changedTouches[i];
      if (touch.identifier === currentTouchId) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
__name(trackFinger, "trackFinger");
function computeNewWidth(initialOffsetToSeparator, clickX, columnBounds, resizeDirection) {
  let newWidth = initialOffsetToSeparator;
  if (resizeDirection === "Right") {
    newWidth += clickX - columnBounds.left;
  } else {
    newWidth += columnBounds.right - clickX;
  }
  return newWidth;
}
__name(computeNewWidth, "computeNewWidth");
function computeOffsetToSeparator(clickX, columnBounds, resizeDirection) {
  if (resizeDirection === "Left") {
    return clickX - columnBounds.left;
  }
  return columnBounds.right - clickX;
}
__name(computeOffsetToSeparator, "computeOffsetToSeparator");
function flipResizeDirection(side) {
  if (side === "Right") {
    return "Left";
  }
  return "Right";
}
__name(flipResizeDirection, "flipResizeDirection");
function getResizeDirection(separator, isRtl) {
  const side = separator.classList.contains(gridClasses["columnSeparator--sideRight"]) ? "Right" : "Left";
  if (isRtl) {
    return flipResizeDirection(side);
  }
  return side;
}
__name(getResizeDirection, "getResizeDirection");
function preventClick(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
__name(preventClick, "preventClick");
function useColumnVirtualizationDisabled(apiRef) {
  const promise = reactExports.useRef();
  const selector = /* @__PURE__ */ __name(() => gridVirtualizationColumnEnabledSelector(apiRef), "selector");
  const value = useGridSelector(apiRef, selector);
  reactExports.useEffect(() => {
    if (promise.current && value === false) {
      promise.current.resolve();
      promise.current = void 0;
    }
  });
  const asyncCheck = /* @__PURE__ */ __name(() => {
    if (!promise.current) {
      if (selector() === false) {
        return Promise.resolve();
      }
      promise.current = createControllablePromise();
    }
    return promise.current;
  }, "asyncCheck");
  return asyncCheck;
}
__name(useColumnVirtualizationDisabled, "useColumnVirtualizationDisabled");
function excludeOutliers(inputValues, factor) {
  if (inputValues.length < 4) {
    return inputValues;
  }
  const values2 = inputValues.slice();
  values2.sort((a, b2) => a - b2);
  const q1 = values2[Math.floor(values2.length * 0.25)];
  const q3 = values2[Math.floor(values2.length * 0.75) - 1];
  const iqr = q3 - q1;
  const deviation = iqr < 5 ? 5 : iqr * factor;
  return values2.filter((v2) => v2 > q1 - deviation && v2 < q3 + deviation);
}
__name(excludeOutliers, "excludeOutliers");
function extractColumnWidths(apiRef, options, columns2) {
  const widthByField = {};
  const root2 = apiRef.current.rootElementRef.current;
  root2.classList.add(gridClasses.autosizing);
  columns2.forEach((column2) => {
    const cells = findGridCells(apiRef.current, column2.field);
    const widths = cells.map((cell) => {
      return cell.getBoundingClientRect().width ?? 0;
    });
    const filteredWidths = options.includeOutliers ? widths : excludeOutliers(widths, options.outliersFactor);
    if (options.includeHeaders) {
      const header = findGridHeader(apiRef.current, column2.field);
      if (header) {
        const title = header.querySelector(`.${gridClasses.columnHeaderTitle}`);
        const content = header.querySelector(`.${gridClasses.columnHeaderTitleContainerContent}`);
        const iconContainer = header.querySelector(`.${gridClasses.iconButtonContainer}`);
        const menuContainer = header.querySelector(`.${gridClasses.menuIcon}`);
        const element = title ?? content;
        const style2 = window.getComputedStyle(header, null);
        const paddingWidth = parseInt(style2.paddingLeft, 10) + parseInt(style2.paddingRight, 10);
        const contentWidth = element.scrollWidth + 1;
        const width2 = contentWidth + paddingWidth + ((iconContainer == null ? void 0 : iconContainer.clientWidth) ?? 0) + ((menuContainer == null ? void 0 : menuContainer.clientWidth) ?? 0);
        filteredWidths.push(width2);
      }
    }
    const hasColumnMin = column2.minWidth !== -Infinity && column2.minWidth !== void 0;
    const hasColumnMax = column2.maxWidth !== Infinity && column2.maxWidth !== void 0;
    const min2 = hasColumnMin ? column2.minWidth : 0;
    const max2 = hasColumnMax ? column2.maxWidth : Infinity;
    const maxContent = filteredWidths.length === 0 ? 0 : Math.max(...filteredWidths);
    widthByField[column2.field] = clamp$3(maxContent, min2, max2);
  });
  root2.classList.remove(gridClasses.autosizing);
  return widthByField;
}
__name(extractColumnWidths, "extractColumnWidths");
const columnResizeStateInitializer = /* @__PURE__ */ __name((state) => _extends$4({}, state, {
  columnResize: {
    resizingColumnField: ""
  }
}), "columnResizeStateInitializer");
function createResizeRefs() {
  return {
    colDef: void 0,
    initialColWidth: 0,
    initialTotalWidth: 0,
    previousMouseClickEvent: void 0,
    columnHeaderElement: void 0,
    headerFilterElement: void 0,
    groupHeaderElements: [],
    cellElements: [],
    leftPinnedCellsAfter: [],
    rightPinnedCellsBefore: [],
    fillerLeft: void 0,
    fillerRight: void 0,
    leftPinnedHeadersAfter: [],
    rightPinnedHeadersBefore: []
  };
}
__name(createResizeRefs, "createResizeRefs");
const useGridColumnResize = /* @__PURE__ */ __name((apiRef, props) => {
  const isRtl = useRtl();
  const logger = useGridLogger(apiRef, "useGridColumnResize");
  const refs = useLazyRef(createResizeRefs).current;
  const initialOffsetToSeparator = reactExports.useRef();
  const resizeDirection = reactExports.useRef();
  const stopResizeEventTimeout = useTimeout();
  const touchId = reactExports.useRef();
  const updateWidth = /* @__PURE__ */ __name((newWidth) => {
    var _a2, _b2;
    logger.debug(`Updating width to ${newWidth} for col ${refs.colDef.field}`);
    const prevWidth = refs.columnHeaderElement.offsetWidth;
    const widthDiff = newWidth - prevWidth;
    const columnWidthDiff = newWidth - refs.initialColWidth;
    const newTotalWidth = refs.initialTotalWidth + columnWidthDiff;
    (_b2 = (_a2 = apiRef.current.rootElementRef) == null ? void 0 : _a2.current) == null ? void 0 : _b2.style.setProperty("--DataGrid-rowWidth", `${newTotalWidth}px`);
    refs.colDef.computedWidth = newWidth;
    refs.colDef.width = newWidth;
    refs.colDef.flex = 0;
    refs.columnHeaderElement.style.width = `${newWidth}px`;
    const headerFilterElement = refs.headerFilterElement;
    if (headerFilterElement) {
      headerFilterElement.style.width = `${newWidth}px`;
    }
    refs.groupHeaderElements.forEach((element) => {
      const div = element;
      let finalWidth;
      if (div.getAttribute("aria-colspan") === "1") {
        finalWidth = `${newWidth}px`;
      } else {
        finalWidth = `${div.offsetWidth + widthDiff}px`;
      }
      div.style.width = finalWidth;
    });
    refs.cellElements.forEach((element) => {
      const div = element;
      let finalWidth;
      if (div.getAttribute("aria-colspan") === "1") {
        finalWidth = `${newWidth}px`;
      } else {
        finalWidth = `${div.offsetWidth + widthDiff}px`;
      }
      div.style.setProperty("--width", finalWidth);
    });
    const pinnedPosition = apiRef.current.unstable_applyPipeProcessors("isColumnPinned", false, refs.colDef.field);
    if (pinnedPosition === GridPinnedColumnPosition.LEFT) {
      updateProperty(refs.fillerLeft, "width", widthDiff);
      refs.leftPinnedCellsAfter.forEach((cell) => {
        updateProperty(cell, "left", widthDiff);
      });
      refs.leftPinnedHeadersAfter.forEach((header) => {
        updateProperty(header, "left", widthDiff);
      });
    }
    if (pinnedPosition === GridPinnedColumnPosition.RIGHT) {
      updateProperty(refs.fillerRight, "width", widthDiff);
      refs.rightPinnedCellsBefore.forEach((cell) => {
        updateProperty(cell, "right", widthDiff);
      });
      refs.rightPinnedHeadersBefore.forEach((header) => {
        updateProperty(header, "right", widthDiff);
      });
    }
  }, "updateWidth");
  const finishResize = /* @__PURE__ */ __name((nativeEvent) => {
    stopListening();
    if (refs.previousMouseClickEvent) {
      const prevEvent = refs.previousMouseClickEvent;
      const prevTimeStamp = prevEvent.timeStamp;
      const prevClientX = prevEvent.clientX;
      const prevClientY = prevEvent.clientY;
      if (nativeEvent.timeStamp - prevTimeStamp < 300 && nativeEvent.clientX === prevClientX && nativeEvent.clientY === prevClientY) {
        refs.previousMouseClickEvent = void 0;
        apiRef.current.publishEvent("columnResizeStop", null, nativeEvent);
        return;
      }
    }
    if (refs.colDef) {
      apiRef.current.setColumnWidth(refs.colDef.field, refs.colDef.width);
      logger.debug(`Updating col ${refs.colDef.field} with new width: ${refs.colDef.width}`);
      const columnsState = gridColumnsStateSelector(apiRef.current.state);
      refs.groupHeaderElements.forEach((element) => {
        const fields2 = getFieldsFromGroupHeaderElem(element);
        const div = element;
        const newWidth = fields2.reduce((acc, field) => {
          if (columnsState.columnVisibilityModel[field] !== false) {
            return acc + columnsState.lookup[field].computedWidth;
          }
          return acc;
        }, 0);
        const finalWidth = `${newWidth}px`;
        div.style.width = finalWidth;
      });
    }
    stopResizeEventTimeout.start(0, () => {
      apiRef.current.publishEvent("columnResizeStop", null, nativeEvent);
    });
  }, "finishResize");
  const storeReferences = /* @__PURE__ */ __name((colDef, separator, xStart) => {
    var _a2;
    const root2 = apiRef.current.rootElementRef.current;
    refs.initialColWidth = colDef.computedWidth;
    refs.initialTotalWidth = apiRef.current.getRootDimensions().rowWidth;
    refs.colDef = colDef;
    refs.columnHeaderElement = findHeaderElementFromField(apiRef.current.columnHeadersContainerRef.current, colDef.field);
    const headerFilterElement = root2.querySelector(`.${gridClasses.headerFilterRow} [data-field="${escapeOperandAttributeSelector(colDef.field)}"]`);
    if (headerFilterElement) {
      refs.headerFilterElement = headerFilterElement;
    }
    refs.groupHeaderElements = findGroupHeaderElementsFromField((_a2 = apiRef.current.columnHeadersContainerRef) == null ? void 0 : _a2.current, colDef.field);
    refs.cellElements = findGridCellElementsFromCol(refs.columnHeaderElement, apiRef.current);
    refs.fillerLeft = findGridElement(apiRef.current, isRtl ? "filler--pinnedRight" : "filler--pinnedLeft");
    refs.fillerRight = findGridElement(apiRef.current, isRtl ? "filler--pinnedLeft" : "filler--pinnedRight");
    const pinnedPosition = apiRef.current.unstable_applyPipeProcessors("isColumnPinned", false, refs.colDef.field);
    refs.leftPinnedCellsAfter = pinnedPosition !== GridPinnedColumnPosition.LEFT ? [] : findLeftPinnedCellsAfterCol(apiRef.current, refs.columnHeaderElement, isRtl);
    refs.rightPinnedCellsBefore = pinnedPosition !== GridPinnedColumnPosition.RIGHT ? [] : findRightPinnedCellsBeforeCol(apiRef.current, refs.columnHeaderElement, isRtl);
    refs.leftPinnedHeadersAfter = pinnedPosition !== GridPinnedColumnPosition.LEFT ? [] : findLeftPinnedHeadersAfterCol(apiRef.current, refs.columnHeaderElement, isRtl);
    refs.rightPinnedHeadersBefore = pinnedPosition !== GridPinnedColumnPosition.RIGHT ? [] : findRightPinnedHeadersBeforeCol(apiRef.current, refs.columnHeaderElement, isRtl);
    resizeDirection.current = getResizeDirection(separator, isRtl);
    initialOffsetToSeparator.current = computeOffsetToSeparator(xStart, refs.columnHeaderElement.getBoundingClientRect(), resizeDirection.current);
  }, "storeReferences");
  const handleResizeMouseUp = useEventCallback(finishResize);
  const handleResizeMouseMove = useEventCallback((nativeEvent) => {
    if (nativeEvent.buttons === 0) {
      handleResizeMouseUp(nativeEvent);
      return;
    }
    let newWidth = computeNewWidth(initialOffsetToSeparator.current, nativeEvent.clientX, refs.columnHeaderElement.getBoundingClientRect(), resizeDirection.current);
    newWidth = clamp$3(newWidth, refs.colDef.minWidth, refs.colDef.maxWidth);
    updateWidth(newWidth);
    const params = {
      element: refs.columnHeaderElement,
      colDef: refs.colDef,
      width: newWidth
    };
    apiRef.current.publishEvent("columnResize", params, nativeEvent);
  });
  const handleTouchEnd = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId.current);
    if (!finger) {
      return;
    }
    finishResize(nativeEvent);
  });
  const handleTouchMove = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId.current);
    if (!finger) {
      return;
    }
    if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    let newWidth = computeNewWidth(initialOffsetToSeparator.current, finger.x, refs.columnHeaderElement.getBoundingClientRect(), resizeDirection.current);
    newWidth = clamp$3(newWidth, refs.colDef.minWidth, refs.colDef.maxWidth);
    updateWidth(newWidth);
    const params = {
      element: refs.columnHeaderElement,
      colDef: refs.colDef,
      width: newWidth
    };
    apiRef.current.publishEvent("columnResize", params, nativeEvent);
  });
  const handleTouchStart = useEventCallback((event) => {
    const cellSeparator = findParentElementFromClassName(event.target, gridClasses["columnSeparator--resizable"]);
    if (!cellSeparator) {
      return;
    }
    const touch = event.changedTouches[0];
    if (touch != null) {
      touchId.current = touch.identifier;
    }
    const columnHeaderElement = findParentElementFromClassName(event.target, gridClasses.columnHeader);
    const field = getFieldFromHeaderElem(columnHeaderElement);
    const colDef = apiRef.current.getColumn(field);
    logger.debug(`Start Resize on col ${colDef.field}`);
    apiRef.current.publishEvent("columnResizeStart", {
      field
    }, event);
    storeReferences(colDef, cellSeparator, touch.clientX);
    const doc = ownerDocument(event.currentTarget);
    doc.addEventListener("touchmove", handleTouchMove);
    doc.addEventListener("touchend", handleTouchEnd);
  });
  const stopListening = reactExports.useCallback(() => {
    const doc = ownerDocument(apiRef.current.rootElementRef.current);
    doc.body.style.removeProperty("cursor");
    doc.removeEventListener("mousemove", handleResizeMouseMove);
    doc.removeEventListener("mouseup", handleResizeMouseUp);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
    setTimeout(() => {
      doc.removeEventListener("click", preventClick, true);
    }, 100);
    if (refs.columnHeaderElement) {
      refs.columnHeaderElement.style.pointerEvents = "unset";
    }
  }, [apiRef, refs, handleResizeMouseMove, handleResizeMouseUp, handleTouchMove, handleTouchEnd]);
  const handleResizeStart = reactExports.useCallback(({
    field
  }) => {
    apiRef.current.setState((state) => _extends$4({}, state, {
      columnResize: _extends$4({}, state.columnResize, {
        resizingColumnField: field
      })
    }));
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const handleResizeStop = reactExports.useCallback(() => {
    apiRef.current.setState((state) => _extends$4({}, state, {
      columnResize: _extends$4({}, state.columnResize, {
        resizingColumnField: ""
      })
    }));
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const handleColumnResizeMouseDown = useEventCallback(({
    colDef
  }, event) => {
    if (event.button !== 0) {
      return;
    }
    if (!event.currentTarget.classList.contains(gridClasses["columnSeparator--resizable"])) {
      return;
    }
    event.preventDefault();
    logger.debug(`Start Resize on col ${colDef.field}`);
    apiRef.current.publishEvent("columnResizeStart", {
      field: colDef.field
    }, event);
    storeReferences(colDef, event.currentTarget, event.clientX);
    const doc = ownerDocument(apiRef.current.rootElementRef.current);
    doc.body.style.cursor = "col-resize";
    refs.previousMouseClickEvent = event.nativeEvent;
    doc.addEventListener("mousemove", handleResizeMouseMove);
    doc.addEventListener("mouseup", handleResizeMouseUp);
    doc.addEventListener("click", preventClick, true);
  });
  const handleColumnSeparatorDoubleClick = useEventCallback((params, event) => {
    if (props.disableAutosize) {
      return;
    }
    if (event.button !== 0) {
      return;
    }
    const column2 = apiRef.current.state.columns.lookup[params.field];
    if (column2.resizable === false) {
      return;
    }
    apiRef.current.autosizeColumns(_extends$4({}, props.autosizeOptions, {
      columns: [column2.field]
    }));
  });
  const columnVirtualizationDisabled = useColumnVirtualizationDisabled(apiRef);
  const isAutosizingRef = reactExports.useRef(false);
  const autosizeColumns = reactExports.useCallback(async (userOptions) => {
    var _a2;
    const root2 = (_a2 = apiRef.current.rootElementRef) == null ? void 0 : _a2.current;
    if (!root2) {
      return;
    }
    if (isAutosizingRef.current) {
      return;
    }
    isAutosizingRef.current = true;
    const state = gridColumnsStateSelector(apiRef.current.state);
    const options = _extends$4({}, DEFAULT_GRID_AUTOSIZE_OPTIONS, userOptions, {
      columns: (userOptions == null ? void 0 : userOptions.columns) ?? state.orderedFields
    });
    options.columns = options.columns.filter((c2) => state.columnVisibilityModel[c2] !== false);
    const columns2 = options.columns.map((c2) => apiRef.current.state.columns.lookup[c2]);
    try {
      apiRef.current.unstable_setColumnVirtualization(false);
      await columnVirtualizationDisabled();
      const widthByField = extractColumnWidths(apiRef, options, columns2);
      const newColumns = columns2.map((column2) => _extends$4({}, column2, {
        width: widthByField[column2.field],
        computedWidth: widthByField[column2.field]
      }));
      if (options.expand) {
        const visibleColumns = state.orderedFields.map((field) => state.lookup[field]).filter((c2) => state.columnVisibilityModel[c2.field] !== false);
        const totalWidth = visibleColumns.reduce((total, column2) => total + (widthByField[column2.field] ?? column2.computedWidth ?? column2.width), 0);
        const availableWidth = apiRef.current.getRootDimensions().viewportInnerSize.width;
        const remainingWidth = availableWidth - totalWidth;
        if (remainingWidth > 0) {
          const widthPerColumn = remainingWidth / (newColumns.length || 1);
          newColumns.forEach((column2) => {
            column2.width += widthPerColumn;
            column2.computedWidth += widthPerColumn;
          });
        }
      }
      apiRef.current.updateColumns(newColumns);
      newColumns.forEach((newColumn, index2) => {
        if (newColumn.width !== columns2[index2].width) {
          const width2 = newColumn.width;
          apiRef.current.publishEvent("columnWidthChange", {
            element: apiRef.current.getColumnHeaderElement(newColumn.field),
            colDef: newColumn,
            width: width2
          });
        }
      });
    } finally {
      apiRef.current.unstable_setColumnVirtualization(true);
      isAutosizingRef.current = false;
    }
  }, [apiRef, columnVirtualizationDisabled]);
  reactExports.useEffect(() => stopListening, [stopListening]);
  useOnMount(() => {
    if (props.autosizeOnMount) {
      Promise.resolve().then(() => {
        apiRef.current.autosizeColumns(props.autosizeOptions);
      });
    }
  });
  useGridNativeEventListener(apiRef, () => {
    var _a2;
    return (_a2 = apiRef.current.columnHeadersContainerRef) == null ? void 0 : _a2.current;
  }, "touchstart", handleTouchStart, {
    passive: true
  });
  useGridApiMethod(apiRef, {
    autosizeColumns
  }, "public");
  useGridApiEventHandler(apiRef, "columnResizeStop", handleResizeStop);
  useGridApiEventHandler(apiRef, "columnResizeStart", handleResizeStart);
  useGridApiEventHandler(apiRef, "columnSeparatorMouseDown", handleColumnResizeMouseDown);
  useGridApiEventHandler(apiRef, "columnSeparatorDoubleClick", handleColumnSeparatorDoubleClick);
  useGridApiOptionHandler(apiRef, "columnResize", props.onColumnResize);
  useGridApiOptionHandler(apiRef, "columnWidthChange", props.onColumnWidthChange);
}, "useGridColumnResize");
function updateProperty(element, property, delta) {
  if (!element) {
    return;
  }
  element.style[property] = `${parseInt(element.style[property], 10) + delta}px`;
}
__name(updateProperty, "updateProperty");
function getUnprocessedRange(testRange, processedRange) {
  if (testRange.firstRowIndex >= processedRange.firstRowIndex && testRange.lastRowIndex <= processedRange.lastRowIndex) {
    return null;
  }
  if (testRange.firstRowIndex >= processedRange.firstRowIndex && testRange.lastRowIndex > processedRange.lastRowIndex) {
    return {
      firstRowIndex: processedRange.lastRowIndex,
      lastRowIndex: testRange.lastRowIndex
    };
  }
  if (testRange.firstRowIndex < processedRange.firstRowIndex && testRange.lastRowIndex <= processedRange.lastRowIndex) {
    return {
      firstRowIndex: testRange.firstRowIndex,
      lastRowIndex: processedRange.firstRowIndex - 1
    };
  }
  return testRange;
}
__name(getUnprocessedRange, "getUnprocessedRange");
function isRowContextInitialized(renderContext) {
  return renderContext.firstRowIndex !== 0 || renderContext.lastRowIndex !== 0;
}
__name(isRowContextInitialized, "isRowContextInitialized");
function isRowRangeUpdated(range1, range2) {
  return range1.firstRowIndex !== range2.firstRowIndex || range1.lastRowIndex !== range2.lastRowIndex;
}
__name(isRowRangeUpdated, "isRowRangeUpdated");
const getCellValue = /* @__PURE__ */ __name((row, colDef, apiRef) => {
  if (!row) {
    return null;
  }
  let cellValue = row[colDef.field];
  const valueGetter = colDef.rowSpanValueGetter ?? colDef.valueGetter;
  if (valueGetter) {
    cellValue = valueGetter(cellValue, row, colDef, apiRef);
  }
  return cellValue;
}, "getCellValue");
const EMPTY_STATE = {
  spannedCells: {},
  hiddenCells: {},
  hiddenCellOriginMap: {}
};
const EMPTY_RANGE = {
  firstRowIndex: 0,
  lastRowIndex: 0
};
const skippedFields = /* @__PURE__ */ new Set([GRID_CHECKBOX_SELECTION_FIELD, "__reorder__", GRID_DETAIL_PANEL_TOGGLE_FIELD]);
const DEFAULT_ROWS_TO_PROCESS = 20;
const computeRowSpanningState = /* @__PURE__ */ __name((apiRef, colDefs, visibleRows, range2, rangeToProcess, resetState, processedRange) => {
  const spannedCells = resetState ? {} : _extends$4({}, apiRef.current.state.rowSpanning.spannedCells);
  const hiddenCells = resetState ? {} : _extends$4({}, apiRef.current.state.rowSpanning.hiddenCells);
  const hiddenCellOriginMap = resetState ? {} : _extends$4({}, apiRef.current.state.rowSpanning.hiddenCellOriginMap);
  if (resetState) {
    processedRange = EMPTY_RANGE;
  }
  colDefs.forEach((colDef) => {
    var _a2;
    if (skippedFields.has(colDef.field)) {
      return;
    }
    for (let index2 = rangeToProcess.firstRowIndex; index2 <= rangeToProcess.lastRowIndex; index2 += 1) {
      const row = visibleRows[index2];
      if ((_a2 = hiddenCells[row.id]) == null ? void 0 : _a2[colDef.field]) {
        continue;
      }
      const cellValue = getCellValue(row.model, colDef, apiRef);
      if (cellValue == null) {
        continue;
      }
      let spannedRowId = row.id;
      let spannedRowIndex = index2;
      let rowSpan = 0;
      const backwardsHiddenCells = [];
      if (index2 === rangeToProcess.firstRowIndex) {
        let prevIndex = index2 - 1;
        const prevRowEntry = visibleRows[prevIndex];
        while (prevIndex >= range2.firstRowIndex && getCellValue(prevRowEntry.model, colDef, apiRef) === cellValue) {
          const currentRow = visibleRows[prevIndex + 1];
          if (hiddenCells[currentRow.id]) {
            hiddenCells[currentRow.id][colDef.field] = true;
          } else {
            hiddenCells[currentRow.id] = {
              [colDef.field]: true
            };
          }
          backwardsHiddenCells.push(index2);
          rowSpan += 1;
          spannedRowId = prevRowEntry.id;
          spannedRowIndex = prevIndex;
          prevIndex -= 1;
        }
      }
      backwardsHiddenCells.forEach((hiddenCellIndex) => {
        if (hiddenCellOriginMap[hiddenCellIndex]) {
          hiddenCellOriginMap[hiddenCellIndex][colDef.field] = spannedRowIndex;
        } else {
          hiddenCellOriginMap[hiddenCellIndex] = {
            [colDef.field]: spannedRowIndex
          };
        }
      });
      let relativeIndex = index2 + 1;
      while (relativeIndex <= range2.lastRowIndex && visibleRows[relativeIndex] && getCellValue(visibleRows[relativeIndex].model, colDef, apiRef) === cellValue) {
        const currentRow = visibleRows[relativeIndex];
        if (hiddenCells[currentRow.id]) {
          hiddenCells[currentRow.id][colDef.field] = true;
        } else {
          hiddenCells[currentRow.id] = {
            [colDef.field]: true
          };
        }
        if (hiddenCellOriginMap[relativeIndex]) {
          hiddenCellOriginMap[relativeIndex][colDef.field] = spannedRowIndex;
        } else {
          hiddenCellOriginMap[relativeIndex] = {
            [colDef.field]: spannedRowIndex
          };
        }
        relativeIndex += 1;
        rowSpan += 1;
      }
      if (rowSpan > 0) {
        if (spannedCells[spannedRowId]) {
          spannedCells[spannedRowId][colDef.field] = rowSpan + 1;
        } else {
          spannedCells[spannedRowId] = {
            [colDef.field]: rowSpan + 1
          };
        }
      }
    }
    processedRange = {
      firstRowIndex: Math.min(processedRange.firstRowIndex, rangeToProcess.firstRowIndex),
      lastRowIndex: Math.max(processedRange.lastRowIndex, rangeToProcess.lastRowIndex)
    };
  });
  return {
    spannedCells,
    hiddenCells,
    hiddenCellOriginMap,
    processedRange
  };
}, "computeRowSpanningState");
const rowSpanningStateInitializer = /* @__PURE__ */ __name((state, props, apiRef) => {
  var _a2;
  if (props.unstable_rowSpanning) {
    const rowIds = state.rows.dataRowIds || [];
    const orderedFields = state.columns.orderedFields || [];
    const dataRowIdToModelLookup = state.rows.dataRowIdToModelLookup;
    const columnsLookup = state.columns.lookup;
    const isFilteringPending = Boolean(state.filter.filterModel.items.length) || Boolean((_a2 = state.filter.filterModel.quickFilterValues) == null ? void 0 : _a2.length);
    if (!rowIds.length || !orderedFields.length || !dataRowIdToModelLookup || !columnsLookup || isFilteringPending) {
      return _extends$4({}, state, {
        rowSpanning: EMPTY_STATE
      });
    }
    const rangeToProcess = {
      firstRowIndex: 0,
      lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS - 1, Math.max(rowIds.length - 1, 0))
    };
    const rows = rowIds.map((id2) => ({
      id: id2,
      model: dataRowIdToModelLookup[id2]
    }));
    const colDefs = orderedFields.map((field) => columnsLookup[field]);
    const {
      spannedCells,
      hiddenCells,
      hiddenCellOriginMap
    } = computeRowSpanningState(apiRef, colDefs, rows, rangeToProcess, rangeToProcess, true, EMPTY_RANGE);
    return _extends$4({}, state, {
      rowSpanning: {
        spannedCells,
        hiddenCells,
        hiddenCellOriginMap
      }
    });
  }
  return _extends$4({}, state, {
    rowSpanning: EMPTY_STATE
  });
}, "rowSpanningStateInitializer");
const useGridRowSpanning = /* @__PURE__ */ __name((apiRef, props) => {
  const {
    range: range2,
    rows: visibleRows
  } = useGridVisibleRows(apiRef, props);
  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);
  const colDefs = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const processedRange = useLazyRef(() => {
    return Object.keys(apiRef.current.state.rowSpanning.spannedCells).length > 0 ? {
      firstRowIndex: 0,
      lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS - 1, Math.max(apiRef.current.state.rows.dataRowIds.length - 1, 0))
    } : EMPTY_RANGE;
  });
  const lastRange = reactExports.useRef(EMPTY_RANGE);
  const updateRowSpanningState = reactExports.useCallback(
    // A reset needs to occur when:
    // - The `unstable_rowSpanning` prop is updated (feature flag)
    // - The filtering is applied
    // - The sorting is applied
    // - The `paginationModel` is updated
    // - The rows are updated
    (resetState = true) => {
      if (!props.unstable_rowSpanning) {
        if (apiRef.current.state.rowSpanning !== EMPTY_STATE) {
          apiRef.current.setState((state) => _extends$4({}, state, {
            rowSpanning: EMPTY_STATE
          }));
        }
        return;
      }
      if (range2 === null || !isRowContextInitialized(renderContext)) {
        return;
      }
      if (resetState) {
        processedRange.current = EMPTY_RANGE;
      }
      const rangeToProcess = getUnprocessedRange({
        firstRowIndex: renderContext.firstRowIndex,
        lastRowIndex: Math.min(renderContext.lastRowIndex - 1, range2.lastRowIndex)
      }, processedRange.current);
      if (rangeToProcess === null) {
        return;
      }
      const {
        spannedCells,
        hiddenCells,
        hiddenCellOriginMap,
        processedRange: newProcessedRange
      } = computeRowSpanningState(apiRef, colDefs, visibleRows, range2, rangeToProcess, resetState, processedRange.current);
      processedRange.current = newProcessedRange;
      const newSpannedCellsCount = Object.keys(spannedCells).length;
      const newHiddenCellsCount = Object.keys(hiddenCells).length;
      const currentSpannedCellsCount = Object.keys(apiRef.current.state.rowSpanning.spannedCells).length;
      const currentHiddenCellsCount = Object.keys(apiRef.current.state.rowSpanning.hiddenCells).length;
      const shouldUpdateState = resetState || newSpannedCellsCount !== currentSpannedCellsCount || newHiddenCellsCount !== currentHiddenCellsCount;
      if (!shouldUpdateState) {
        return;
      }
      apiRef.current.setState((state) => {
        return _extends$4({}, state, {
          rowSpanning: {
            spannedCells,
            hiddenCells,
            hiddenCellOriginMap
          }
        });
      });
    },
    [apiRef, props.unstable_rowSpanning, range2, renderContext, visibleRows, colDefs, processedRange]
  );
  const prevRenderContext = reactExports.useRef(renderContext);
  const isFirstRender = reactExports.useRef(true);
  const shouldResetState = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const firstRender = isFirstRender.current;
    if (isFirstRender.current) {
      isFirstRender.current = false;
    }
    if (range2 && lastRange.current && isRowRangeUpdated(range2, lastRange.current)) {
      lastRange.current = range2;
      shouldResetState.current = true;
    }
    if (!firstRender && prevRenderContext.current !== renderContext) {
      if (isRowRangeUpdated(prevRenderContext.current, renderContext)) {
        updateRowSpanningState(shouldResetState.current);
        shouldResetState.current = false;
      }
      prevRenderContext.current = renderContext;
      return;
    }
    updateRowSpanningState();
  }, [updateRowSpanningState, renderContext, range2, lastRange]);
}, "useGridRowSpanning");
const listViewStateInitializer = /* @__PURE__ */ __name((state, props, apiRef) => _extends$4({}, state, {
  listViewColumn: props.unstable_listColumn ? _extends$4({}, props.unstable_listColumn, {
    computedWidth: getListColumnWidth(apiRef)
  }) : void 0
}), "listViewStateInitializer");
function useGridListView(apiRef, props) {
  const updateListColumnWidth = /* @__PURE__ */ __name(() => {
    apiRef.current.setState((state) => {
      if (!state.listViewColumn) {
        return state;
      }
      return _extends$4({}, state, {
        listViewColumn: _extends$4({}, state.listViewColumn, {
          computedWidth: getListColumnWidth(apiRef)
        })
      });
    });
  }, "updateListColumnWidth");
  const prevInnerWidth = reactExports.useRef(null);
  const handleGridSizeChange = /* @__PURE__ */ __name((viewportInnerSize) => {
    if (prevInnerWidth.current !== viewportInnerSize.width) {
      prevInnerWidth.current = viewportInnerSize.width;
      updateListColumnWidth();
    }
  }, "handleGridSizeChange");
  useGridApiEventHandler(apiRef, "viewportInnerSizeChange", handleGridSizeChange);
  useGridApiEventHandler(apiRef, "columnVisibilityModelChange", updateListColumnWidth);
  reactExports.useEffect(() => {
    const listColumn = props.unstable_listColumn;
    if (listColumn) {
      apiRef.current.setState((state) => {
        return _extends$4({}, state, {
          listViewColumn: _extends$4({}, listColumn, {
            computedWidth: getListColumnWidth(apiRef)
          })
        });
      });
    }
  }, [apiRef, props.unstable_listColumn]);
  reactExports.useEffect(() => {
    if (props.unstable_listView && !props.unstable_listColumn)
      ;
  }, [props.unstable_listView, props.unstable_listColumn]);
}
__name(useGridListView, "useGridListView");
function getListColumnWidth(apiRef) {
  return gridDimensionsSelector(apiRef.current.state).viewportInnerSize.width;
}
__name(getListColumnWidth, "getListColumnWidth");
const useDataGridComponent = /* @__PURE__ */ __name((inputApiRef, props) => {
  const apiRef = useGridInitialization(inputApiRef, props);
  useGridRowSelectionPreProcessors(apiRef, props);
  useGridRowsPreProcessors(apiRef);
  useGridInitializeState(dimensionsStateInitializer, apiRef, props);
  useGridInitializeState(rowSelectionStateInitializer, apiRef, props);
  useGridInitializeState(columnsStateInitializer, apiRef, props);
  useGridInitializeState(rowsStateInitializer, apiRef, props);
  useGridInitializeState(editingStateInitializer, apiRef, props);
  useGridInitializeState(focusStateInitializer, apiRef, props);
  useGridInitializeState(sortingStateInitializer, apiRef, props);
  useGridInitializeState(preferencePanelStateInitializer, apiRef, props);
  useGridInitializeState(filterStateInitializer, apiRef, props);
  useGridInitializeState(rowSpanningStateInitializer, apiRef, props);
  useGridInitializeState(densityStateInitializer, apiRef, props);
  useGridInitializeState(columnResizeStateInitializer, apiRef, props);
  useGridInitializeState(paginationStateInitializer, apiRef, props);
  useGridInitializeState(rowsMetaStateInitializer, apiRef, props);
  useGridInitializeState(columnMenuStateInitializer, apiRef, props);
  useGridInitializeState(columnGroupsStateInitializer, apiRef, props);
  useGridInitializeState(virtualizationStateInitializer, apiRef, props);
  useGridInitializeState(listViewStateInitializer, apiRef, props);
  useGridKeyboardNavigation(apiRef, props);
  useGridRowSelection(apiRef, props);
  useGridColumns(apiRef, props);
  useGridRows(apiRef, props);
  useGridRowSpanning(apiRef, props);
  useGridParamsApi(apiRef, props);
  useGridColumnSpanning(apiRef);
  useGridColumnGrouping(apiRef, props);
  useGridEditing(apiRef, props);
  useGridFocus(apiRef, props);
  useGridPreferencesPanel(apiRef, props);
  useGridFilter(apiRef, props);
  useGridSorting(apiRef, props);
  useGridDensity(apiRef, props);
  useGridColumnResize(apiRef, props);
  useGridPagination(apiRef, props);
  useGridRowsMeta(apiRef, props);
  useGridScroll(apiRef, props);
  useGridColumnMenu(apiRef);
  useGridCsvExport(apiRef, props);
  useGridPrintExport(apiRef, props);
  useGridClipboard(apiRef, props);
  useGridDimensions(apiRef, props);
  useGridEvents(apiRef, props);
  useGridStatePersistence(apiRef);
  useGridVirtualization(apiRef, props);
  useGridListView(apiRef, props);
  return apiRef;
}, "useDataGridComponent");
const useUtilityClasses$c = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    headerAlign,
    isDragging,
    isLastColumn,
    showLeftBorder,
    showRightBorder,
    groupId,
    pinnedPosition
  } = ownerState;
  const slots = {
    root: ["columnHeader", headerAlign === "left" && "columnHeader--alignLeft", headerAlign === "center" && "columnHeader--alignCenter", headerAlign === "right" && "columnHeader--alignRight", isDragging && "columnHeader--moving", showRightBorder && "columnHeader--withRightBorder", showLeftBorder && "columnHeader--withLeftBorder", "withBorderColor", groupId === null ? "columnHeader--emptyGroup" : "columnHeader--filledGroup", pinnedPosition === "left" && "columnHeader--pinnedLeft", pinnedPosition === "right" && "columnHeader--pinnedRight", isLastColumn && "columnHeader--last"],
    draggableContainer: ["columnHeaderDraggableContainer"],
    titleContainer: ["columnHeaderTitleContainer", "withBorderColor"],
    titleContainerContent: ["columnHeaderTitleContainerContent"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$c");
function GridColumnGroupHeader(props) {
  var _a2;
  const {
    groupId,
    width: width2,
    depth,
    maxDepth,
    fields: fields2,
    height: height2,
    colIndex,
    hasFocus,
    tabIndex,
    isLastColumn,
    pinnedPosition,
    style: style2,
    indexInSection,
    sectionLength,
    gridHasFiller
  } = props;
  const rootProps = useGridRootProps();
  const headerCellRef = reactExports.useRef(null);
  const apiRef = useGridApiContext();
  const columnGroupsLookup = useGridSelector(apiRef, gridColumnGroupsLookupSelector);
  const group = groupId ? columnGroupsLookup[groupId] : {};
  const {
    headerName = groupId ?? "",
    description = "",
    headerAlign = void 0
  } = group;
  let headerComponent;
  const render = groupId && ((_a2 = columnGroupsLookup[groupId]) == null ? void 0 : _a2.renderHeaderGroup);
  const renderParams = reactExports.useMemo(() => ({
    groupId,
    headerName,
    description,
    depth,
    maxDepth,
    fields: fields2,
    colIndex,
    isLastColumn
  }), [groupId, headerName, description, depth, maxDepth, fields2, colIndex, isLastColumn]);
  if (groupId && render) {
    headerComponent = render(renderParams);
  }
  const showLeftBorder = shouldCellShowLeftBorder(pinnedPosition, indexInSection);
  const showRightBorder = shouldCellShowRightBorder(pinnedPosition, indexInSection, sectionLength, rootProps.showColumnVerticalBorder, gridHasFiller);
  const ownerState = _extends$4({}, props, {
    classes: rootProps.classes,
    showLeftBorder,
    showRightBorder,
    headerAlign,
    depth,
    isDragging: false
  });
  const label = headerName ?? groupId;
  const id2 = useId();
  const elementId = groupId === null ? `empty-group-cell-${id2}` : groupId;
  const classes2 = useUtilityClasses$c(ownerState);
  reactExports.useLayoutEffect(() => {
    if (hasFocus) {
      const focusableElement = headerCellRef.current.querySelector('[tabindex="0"]');
      const elementToFocus = focusableElement || headerCellRef.current;
      elementToFocus == null ? void 0 : elementToFocus.focus();
    }
  }, [apiRef, hasFocus]);
  const publish2 = reactExports.useCallback(
    (eventName) => (event) => {
      if (isEventTargetInPortal(event)) {
        return;
      }
      apiRef.current.publishEvent(eventName, renderParams, event);
    },
    // For now this is stupid, because renderParams change all the time.
    // Need to move it's computation in the api, such that for a given depth+columnField, I can get the group parameters
    [apiRef, renderParams]
  );
  const mouseEventsHandlers = reactExports.useMemo(() => ({
    onKeyDown: publish2("columnGroupHeaderKeyDown"),
    onFocus: publish2("columnGroupHeaderFocus"),
    onBlur: publish2("columnGroupHeaderBlur")
  }), [publish2]);
  const headerClassName = typeof group.headerClassName === "function" ? group.headerClassName(renderParams) : group.headerClassName;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridGenericColumnHeaderItem, _extends$4({
    ref: headerCellRef,
    classes: classes2,
    columnMenuOpen: false,
    colIndex,
    height: height2,
    isResizing: false,
    sortDirection: null,
    hasFocus: false,
    tabIndex,
    isDraggable: false,
    headerComponent,
    headerClassName,
    description,
    elementId,
    width: width2,
    columnMenuIconButton: null,
    columnTitleIconButtons: null,
    resizable: false,
    label,
    "aria-colspan": fields2.length,
    "data-fields": `|-${fields2.join("-|-")}-|`,
    style: style2
  }, mouseEventsHandlers));
}
__name(GridColumnGroupHeader, "GridColumnGroupHeader");
const GridColumnHeaderRow = styled("div", {
  name: "MuiDataGrid",
  slot: "ColumnHeaderRow",
  overridesResolver: (_2, styles2) => styles2.columnHeaderRow
})({
  display: "flex"
});
const useGridColumnHeaders = /* @__PURE__ */ __name((props) => {
  const {
    visibleColumns,
    sortColumnLookup,
    filterColumnLookup,
    columnHeaderTabIndexState,
    columnGroupHeaderTabIndexState,
    columnHeaderFocus,
    columnGroupHeaderFocus,
    headerGroupingMaxDepth,
    columnMenuState,
    columnVisibility,
    columnGroupsHeaderStructure,
    hasOtherElementInTabSequence
  } = props;
  const [dragCol, setDragCol] = reactExports.useState("");
  const [resizeCol, setResizeCol] = reactExports.useState("");
  const apiRef = useGridPrivateApiContext();
  const isRtl = useRtl();
  const rootProps = useGridRootProps();
  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);
  const hasVirtualization = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector);
  const columnGroupsModel = useGridSelector(apiRef, gridColumnGroupsUnwrappedModelSelector);
  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);
  const renderContext = useGridSelector(apiRef, gridRenderContextColumnsSelector);
  const pinnedColumns = useGridSelector(apiRef, gridVisiblePinnedColumnDefinitionsSelector);
  const columnsLookup = useGridSelector(apiRef, gridColumnLookupSelector);
  const offsetLeft = computeOffsetLeft(columnPositions, renderContext, pinnedColumns.left.length);
  const gridHasFiller = dimensions.columnsTotalWidth < dimensions.viewportOuterSize.width;
  reactExports.useEffect(() => {
    if (apiRef.current.columnHeadersContainerRef.current) {
      apiRef.current.columnHeadersContainerRef.current.scrollLeft = 0;
    }
  }, [apiRef]);
  const handleColumnResizeStart = reactExports.useCallback((params) => setResizeCol(params.field), []);
  const handleColumnResizeStop = reactExports.useCallback(() => setResizeCol(""), []);
  const handleColumnReorderStart = reactExports.useCallback((params) => setDragCol(params.field), []);
  const handleColumnReorderStop = reactExports.useCallback(() => setDragCol(""), []);
  const leftRenderContext = reactExports.useMemo(() => {
    return pinnedColumns.left.length ? {
      firstColumnIndex: 0,
      lastColumnIndex: pinnedColumns.left.length
    } : null;
  }, [pinnedColumns.left.length]);
  const rightRenderContext = reactExports.useMemo(() => {
    return pinnedColumns.right.length ? {
      firstColumnIndex: visibleColumns.length - pinnedColumns.right.length,
      lastColumnIndex: visibleColumns.length
    } : null;
  }, [pinnedColumns.right.length, visibleColumns.length]);
  useGridApiEventHandler(apiRef, "columnResizeStart", handleColumnResizeStart);
  useGridApiEventHandler(apiRef, "columnResizeStop", handleColumnResizeStop);
  useGridApiEventHandler(apiRef, "columnHeaderDragStart", handleColumnReorderStart);
  useGridApiEventHandler(apiRef, "columnHeaderDragEnd", handleColumnReorderStop);
  const getColumnsToRender = /* @__PURE__ */ __name((params) => {
    const {
      renderContext: currentContext = renderContext,
      maxLastColumn = visibleColumns.length
    } = params || {};
    const firstColumnToRender = currentContext.firstColumnIndex;
    const lastColumnToRender = !hasVirtualization ? maxLastColumn : currentContext.lastColumnIndex;
    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);
    return {
      renderedColumns,
      firstColumnToRender,
      lastColumnToRender
    };
  }, "getColumnsToRender");
  const getFillers = /* @__PURE__ */ __name((params, children, leftOverflow, borderBottom2 = false) => {
    const isPinnedRight = (params == null ? void 0 : params.position) === GridPinnedColumnPosition.RIGHT;
    const isNotPinned = (params == null ? void 0 : params.position) === void 0;
    const hasScrollbarFiller = pinnedColumns.right.length > 0 && isPinnedRight || pinnedColumns.right.length === 0 && isNotPinned;
    const leftOffsetWidth = offsetLeft - leftOverflow;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [isNotPinned && /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        role: "presentation",
        style: {
          width: leftOffsetWidth
        }
      }), children, isNotPinned && /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        role: "presentation",
        className: clsx(gridClasses.filler, borderBottom2 && gridClasses["filler--borderBottom"])
      }), hasScrollbarFiller && /* @__PURE__ */ jsxRuntimeExports.jsx(GridScrollbarFillerCell, {
        header: true,
        pinnedRight: isPinnedRight,
        borderBottom: borderBottom2,
        borderTop: false
      })]
    });
  }, "getFillers");
  const getCellOffsetStyle = /* @__PURE__ */ __name(({
    pinnedPosition,
    columnIndex,
    computedWidth
  }) => {
    let style2;
    const isLeftPinned = pinnedPosition === GridPinnedColumnPosition.LEFT;
    const isRightPinned = pinnedPosition === GridPinnedColumnPosition.RIGHT;
    if (isLeftPinned || isRightPinned) {
      const pinnedOffset = getPinnedCellOffset(pinnedPosition, computedWidth, columnIndex, columnPositions, dimensions);
      let side = isLeftPinned ? "left" : "right";
      if (isRtl) {
        side = isLeftPinned ? "right" : "left";
      }
      if (pinnedPosition === "left") {
        style2 = {
          [side]: pinnedOffset
        };
      }
      if (pinnedPosition === "right") {
        style2 = {
          [side]: pinnedOffset
        };
      }
    }
    return style2;
  }, "getCellOffsetStyle");
  const getColumnHeaders = /* @__PURE__ */ __name((params, other = {}) => {
    const {
      renderedColumns,
      firstColumnToRender
    } = getColumnsToRender(params);
    const columns2 = [];
    for (let i = 0; i < renderedColumns.length; i += 1) {
      const colDef = renderedColumns[i];
      const columnIndex = firstColumnToRender + i;
      const isFirstColumn = columnIndex === 0;
      const tabIndex = columnHeaderTabIndexState !== null && columnHeaderTabIndexState.field === colDef.field || isFirstColumn && !hasOtherElementInTabSequence ? 0 : -1;
      const hasFocus = columnHeaderFocus !== null && columnHeaderFocus.field === colDef.field;
      const open2 = columnMenuState.open && columnMenuState.field === colDef.field;
      const pinnedPosition = params == null ? void 0 : params.position;
      const style2 = getCellOffsetStyle({
        pinnedPosition,
        columnIndex,
        computedWidth: colDef.computedWidth
      });
      const siblingWithBorderingSeparator = pinnedPosition === GridPinnedColumnPosition.RIGHT ? renderedColumns[i - 1] : renderedColumns[i + 1];
      const isSiblingFocused = siblingWithBorderingSeparator ? columnHeaderFocus !== null && columnHeaderFocus.field === siblingWithBorderingSeparator.field : false;
      const isLastUnpinned = columnIndex + 1 === columnPositions.length - pinnedColumns.right.length;
      columns2.push(/* @__PURE__ */ jsxRuntimeExports.jsx(Memoized, _extends$4({}, sortColumnLookup[colDef.field], {
        columnMenuOpen: open2,
        filterItemsCounter: filterColumnLookup[colDef.field] && filterColumnLookup[colDef.field].length,
        headerHeight: dimensions.headerHeight,
        isDragging: colDef.field === dragCol,
        colDef,
        colIndex: columnIndex,
        isResizing: resizeCol === colDef.field,
        isLast: columnIndex === columnPositions.length - 1,
        hasFocus,
        tabIndex,
        pinnedPosition,
        style: style2,
        indexInSection: i,
        sectionLength: renderedColumns.length,
        gridHasFiller,
        isLastUnpinned,
        isSiblingFocused
      }, other), colDef.field));
    }
    return getFillers(params, columns2, 0);
  }, "getColumnHeaders");
  const getColumnHeadersRow = /* @__PURE__ */ __name(() => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridColumnHeaderRow, {
      role: "row",
      "aria-rowindex": headerGroupingMaxDepth + 1,
      ownerState: rootProps,
      className: gridClasses["row--borderBottom"],
      children: [leftRenderContext && getColumnHeaders({
        position: GridPinnedColumnPosition.LEFT,
        renderContext: leftRenderContext,
        maxLastColumn: leftRenderContext.lastColumnIndex
      }, {
        disableReorder: true
      }), getColumnHeaders({
        renderContext,
        maxLastColumn: visibleColumns.length - pinnedColumns.right.length
      }), rightRenderContext && getColumnHeaders({
        position: GridPinnedColumnPosition.RIGHT,
        renderContext: rightRenderContext,
        maxLastColumn: rightRenderContext.lastColumnIndex
      }, {
        disableReorder: true,
        separatorSide: GridColumnHeaderSeparatorSides.Left
      })]
    });
  }, "getColumnHeadersRow");
  const getColumnGroupHeaders = /* @__PURE__ */ __name(({
    depth,
    params
  }) => {
    var _a2, _b2;
    const columnsToRender = getColumnsToRender(params);
    if (columnsToRender.renderedColumns.length === 0) {
      return null;
    }
    const {
      firstColumnToRender,
      lastColumnToRender
    } = columnsToRender;
    const rowStructure = columnGroupsHeaderStructure[depth];
    const firstColumnFieldToRender = visibleColumns[firstColumnToRender].field;
    const firstGroupToRender = ((_a2 = columnGroupsModel[firstColumnFieldToRender]) == null ? void 0 : _a2[depth]) ?? null;
    const firstGroupIndex = rowStructure.findIndex(({
      groupId,
      columnFields
    }) => groupId === firstGroupToRender && columnFields.includes(firstColumnFieldToRender));
    const lastColumnFieldToRender = visibleColumns[lastColumnToRender - 1].field;
    const lastGroupToRender = ((_b2 = columnGroupsModel[lastColumnFieldToRender]) == null ? void 0 : _b2[depth]) ?? null;
    const lastGroupIndex = rowStructure.findIndex(({
      groupId,
      columnFields
    }) => groupId === lastGroupToRender && columnFields.includes(lastColumnFieldToRender));
    const visibleColumnGroupHeader = rowStructure.slice(firstGroupIndex, lastGroupIndex + 1).map((groupStructure) => {
      return _extends$4({}, groupStructure, {
        columnFields: groupStructure.columnFields.filter((field) => columnVisibility[field] !== false)
      });
    }).filter((groupStructure) => groupStructure.columnFields.length > 0);
    const firstVisibleColumnIndex = visibleColumnGroupHeader[0].columnFields.indexOf(firstColumnFieldToRender);
    const hiddenGroupColumns = visibleColumnGroupHeader[0].columnFields.slice(0, firstVisibleColumnIndex);
    const leftOverflow = hiddenGroupColumns.reduce((acc, field) => {
      const column2 = columnsLookup[field];
      return acc + (column2.computedWidth ?? 0);
    }, 0);
    let columnIndex = firstColumnToRender;
    const children = visibleColumnGroupHeader.map(({
      groupId,
      columnFields
    }, index2) => {
      const hasFocus = columnGroupHeaderFocus !== null && columnGroupHeaderFocus.depth === depth && columnFields.includes(columnGroupHeaderFocus.field);
      const tabIndex = columnGroupHeaderTabIndexState !== null && columnGroupHeaderTabIndexState.depth === depth && columnFields.includes(columnGroupHeaderTabIndexState.field) ? 0 : -1;
      const headerInfo = {
        groupId,
        width: columnFields.reduce((acc, field) => acc + columnsLookup[field].computedWidth, 0),
        fields: columnFields,
        colIndex: columnIndex,
        hasFocus,
        tabIndex
      };
      const pinnedPosition = params.position;
      const style2 = getCellOffsetStyle({
        pinnedPosition,
        columnIndex,
        computedWidth: headerInfo.width
      });
      columnIndex += columnFields.length;
      let indexInSection = index2;
      if (pinnedPosition === "left") {
        indexInSection = columnIndex - 1;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnGroupHeader, {
        groupId,
        width: headerInfo.width,
        fields: headerInfo.fields,
        colIndex: headerInfo.colIndex,
        depth,
        isLastColumn: headerInfo.colIndex === visibleColumns.length - headerInfo.fields.length,
        maxDepth: headerGroupingMaxDepth,
        height: dimensions.groupHeaderHeight,
        hasFocus,
        tabIndex,
        pinnedPosition,
        style: style2,
        indexInSection,
        sectionLength: visibleColumnGroupHeader.length,
        gridHasFiller
      }, index2);
    });
    return getFillers(params, children, leftOverflow);
  }, "getColumnGroupHeaders");
  const getColumnGroupHeadersRows = /* @__PURE__ */ __name(() => {
    if (headerGroupingMaxDepth === 0) {
      return null;
    }
    const headerRows = [];
    for (let depth = 0; depth < headerGroupingMaxDepth; depth += 1) {
      headerRows.push(/* @__PURE__ */ jsxRuntimeExports.jsxs(GridColumnHeaderRow, {
        role: "row",
        "aria-rowindex": depth + 1,
        ownerState: rootProps,
        children: [leftRenderContext && getColumnGroupHeaders({
          depth,
          params: {
            position: GridPinnedColumnPosition.LEFT,
            renderContext: leftRenderContext,
            maxLastColumn: leftRenderContext.lastColumnIndex
          }
        }), getColumnGroupHeaders({
          depth,
          params: {
            renderContext
          }
        }), rightRenderContext && getColumnGroupHeaders({
          depth,
          params: {
            position: GridPinnedColumnPosition.RIGHT,
            renderContext: rightRenderContext,
            maxLastColumn: rightRenderContext.lastColumnIndex
          }
        })]
      }, depth));
    }
    return headerRows;
  }, "getColumnGroupHeadersRows");
  return {
    renderContext,
    leftRenderContext,
    rightRenderContext,
    pinnedColumns,
    visibleColumns,
    getCellOffsetStyle,
    getFillers,
    getColumnHeadersRow,
    getColumnsToRender,
    getColumnGroupHeadersRows,
    isDragging: !!dragCol,
    getInnerProps: () => ({
      role: "rowgroup"
    })
  };
}, "useGridColumnHeaders");
const _excluded$m = ["className"];
const useUtilityClasses$b = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["columnHeaders"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes2);
}, "useUtilityClasses$b");
const GridColumnHeadersRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "ColumnHeaders",
  overridesResolver: (props, styles2) => styles2.columnHeaders
})({
  display: "flex",
  flexDirection: "column",
  borderTopLeftRadius: "var(--unstable_DataGrid-radius)",
  borderTopRightRadius: "var(--unstable_DataGrid-radius)"
});
const GridBaseColumnHeaders = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridColumnHeaders(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$m);
  const rootProps = useGridRootProps();
  const classes2 = useUtilityClasses$b(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeadersRoot, _extends$4({
    ref,
    className: clsx(classes2.root, className),
    ownerState: rootProps
  }, other, {
    role: "presentation"
  }));
}, "GridColumnHeaders"));
const _excluded$l = ["className", "visibleColumns", "sortColumnLookup", "filterColumnLookup", "columnHeaderTabIndexState", "columnGroupHeaderTabIndexState", "columnHeaderFocus", "columnGroupHeaderFocus", "headerGroupingMaxDepth", "columnMenuState", "columnVisibility", "columnGroupsHeaderStructure", "hasOtherElementInTabSequence"];
const GridColumnHeaders2 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridColumnHeaders22(props, ref) {
  const {
    visibleColumns,
    sortColumnLookup,
    filterColumnLookup,
    columnHeaderTabIndexState,
    columnGroupHeaderTabIndexState,
    columnHeaderFocus,
    columnGroupHeaderFocus,
    headerGroupingMaxDepth,
    columnMenuState,
    columnVisibility,
    columnGroupsHeaderStructure,
    hasOtherElementInTabSequence
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$l);
  const {
    getInnerProps,
    getColumnHeadersRow,
    getColumnGroupHeadersRows
  } = useGridColumnHeaders({
    visibleColumns,
    sortColumnLookup,
    filterColumnLookup,
    columnHeaderTabIndexState,
    columnGroupHeaderTabIndexState,
    columnHeaderFocus,
    columnGroupHeaderFocus,
    headerGroupingMaxDepth,
    columnMenuState,
    columnVisibility,
    columnGroupsHeaderStructure,
    hasOtherElementInTabSequence
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridBaseColumnHeaders, _extends$4({
    ref
  }, other, getInnerProps(), {
    children: [getColumnGroupHeadersRows(), getColumnHeadersRow()]
  }));
}, "GridColumnHeaders2"));
const MemoizedGridColumnHeaders = fastMemo(GridColumnHeaders2);
function GridDetailPanels(_2) {
  return null;
}
__name(GridDetailPanels, "GridDetailPanels");
function GridPinnedRows(_2) {
  return null;
}
__name(GridPinnedRows, "GridPinnedRows");
const GridNoResultsOverlay = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function GridNoResultsOverlay2(props, ref) {
  const apiRef = useGridApiContext();
  const noResultsOverlayLabel = apiRef.current.getLocaleText("noResultsOverlayLabel");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlay, _extends$4({
    ref
  }, props, {
    children: noResultsOverlayLabel
  }));
}, "GridNoResultsOverlay"));
const _excluded$k = ["sortingOrder"];
const GridColumnUnsortedIcon = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ __name(function GridColumnHeaderSortIcon2(props) {
  const {
    sortingOrder
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$k);
  const rootProps = useGridRootProps();
  const [nextSortDirection] = sortingOrder;
  const Icon = nextSortDirection === "asc" ? rootProps.slots.columnSortedAscendingIcon : rootProps.slots.columnSortedDescendingIcon;
  return Icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, _extends$4({}, other)) : null;
}, "GridColumnHeaderSortIcon"));
const _excluded$j = ["native"];
function MUISelectOption(_ref) {
  let {
    native
  } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$j);
  if (native) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("option", _extends$4({}, props));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, _extends$4({}, props));
}
__name(MUISelectOption, "MUISelectOption");
const iconSlots = {
  booleanCellTrueIcon: GridCheckIcon,
  booleanCellFalseIcon: GridCloseIcon,
  columnMenuIcon: GridTripleDotsVerticalIcon,
  openFilterButtonIcon: GridFilterListIcon,
  filterPanelDeleteIcon: GridCloseIcon,
  columnFilteredIcon: GridFilterAltIcon,
  columnSelectorIcon: GridColumnIcon,
  columnUnsortedIcon: GridColumnUnsortedIcon,
  columnSortedAscendingIcon: GridArrowUpwardIcon,
  columnSortedDescendingIcon: GridArrowDownwardIcon,
  columnResizeIcon: GridSeparatorIcon,
  densityCompactIcon: GridViewHeadlineIcon,
  densityStandardIcon: GridTableRowsIcon,
  densityComfortableIcon: GridViewStreamIcon,
  exportIcon: GridSaveAltIcon,
  moreActionsIcon: GridMoreVertIcon,
  treeDataCollapseIcon: GridExpandMoreIcon,
  treeDataExpandIcon: GridKeyboardArrowRight,
  groupingCriteriaCollapseIcon: GridExpandMoreIcon,
  groupingCriteriaExpandIcon: GridKeyboardArrowRight,
  detailPanelExpandIcon: GridAddIcon,
  detailPanelCollapseIcon: GridRemoveIcon,
  rowReorderIcon: GridDragIcon,
  quickFilterIcon: GridSearchIcon,
  quickFilterClearIcon: GridCloseIcon,
  columnMenuHideIcon: GridVisibilityOffIcon,
  columnMenuSortAscendingIcon: GridArrowUpwardIcon,
  columnMenuSortDescendingIcon: GridArrowDownwardIcon,
  columnMenuFilterIcon: GridFilterAltIcon,
  columnMenuManageColumnsIcon: GridViewColumnIcon,
  columnMenuClearIcon: GridClearIcon,
  loadIcon: GridLoadIcon,
  filterPanelAddIcon: GridAddIcon,
  filterPanelRemoveAllIcon: GridDeleteForeverIcon,
  columnReorderIcon: GridDragIcon
};
const materialSlots = _extends$4({}, iconSlots, {
  baseBadge: Badge,
  baseCheckbox: Checkbox,
  baseDivider: Divider,
  baseTextField: TextField,
  baseFormControl: FormControl,
  baseSelect: Select,
  baseButton: Button,
  baseIconButton: IconButton,
  baseInputAdornment: InputAdornment,
  baseTooltip: Tooltip,
  basePopper: Popper,
  baseInputLabel: InputLabel,
  baseSelectOption: MUISelectOption,
  baseChip: Chip
});
const DATA_GRID_DEFAULT_SLOTS_COMPONENTS = _extends$4({}, materialSlots, {
  cell: MemoizedGridCell,
  skeletonCell: Memoized$1,
  columnHeaderFilterIconButton: GridColumnHeaderFilterIconButton,
  columnHeaderSortIcon: GridColumnHeaderSortIcon,
  columnMenu: GridColumnMenu,
  columnHeaders: MemoizedGridColumnHeaders,
  detailPanels: GridDetailPanels,
  footer: GridFooter,
  footerRowCount: GridRowCount,
  toolbar: null,
  pinnedRows: GridPinnedRows,
  loadingOverlay: GridLoadingOverlay,
  noResultsOverlay: GridNoResultsOverlay,
  noRowsOverlay: GridNoRowsOverlay,
  pagination: GridPagination,
  filterPanel: GridFilterPanel,
  columnsPanel: GridColumnsPanel,
  columnsManagement: GridColumnsManagement,
  panel: GridPanel,
  row: MemoizedGridRow
});
function computeSlots({
  defaultSlots: defaultSlots2,
  slots
}) {
  const overrides = slots;
  if (!overrides || Object.keys(overrides).length === 0) {
    return defaultSlots2;
  }
  const result = _extends$4({}, defaultSlots2);
  Object.keys(overrides).forEach((key) => {
    const k2 = key;
    if (overrides[k2] !== void 0) {
      result[k2] = overrides[k2];
    }
  });
  return result;
}
__name(computeSlots, "computeSlots");
function groupForwardedProps(props) {
  const keys = Object.keys(props);
  if (!keys.some((key) => key.startsWith("aria-") || key.startsWith("data-"))) {
    return props;
  }
  const newProps = {};
  const forwardedProps = props.forwardedProps ?? {};
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    if (key.startsWith("aria-") || key.startsWith("data-")) {
      forwardedProps[key] = props[key];
    } else {
      newProps[key] = props[key];
    }
  }
  newProps.forwardedProps = forwardedProps;
  return newProps;
}
__name(groupForwardedProps, "groupForwardedProps");
function useProps(allProps) {
  return reactExports.useMemo(() => groupForwardedProps(allProps), [allProps]);
}
__name(useProps, "useProps");
const DATA_GRID_FORCED_PROPS = {
  disableMultipleColumnsFiltering: true,
  disableMultipleColumnsSorting: true,
  throttleRowsMs: void 0,
  hideFooterRowCount: false,
  pagination: true,
  checkboxSelectionVisibleOnly: false,
  disableColumnReorder: true,
  keepColumnPositionIfDraggedOutside: false,
  signature: "DataGrid",
  unstable_listView: false
};
const defaultSlots = DATA_GRID_DEFAULT_SLOTS_COMPONENTS;
const useDataGridProps = /* @__PURE__ */ __name((inProps) => {
  const themedProps = useProps(
    // eslint-disable-next-line material-ui/mui-name-matches-component-name
    useThemeProps({
      props: inProps,
      name: "MuiDataGrid"
    })
  );
  const localeText = reactExports.useMemo(() => _extends$4({}, GRID_DEFAULT_LOCALE_TEXT, themedProps.localeText), [themedProps.localeText]);
  const slots = reactExports.useMemo(() => computeSlots({
    defaultSlots,
    slots: themedProps.slots
  }), [themedProps.slots]);
  const injectDefaultProps = reactExports.useMemo(() => {
    return Object.keys(DATA_GRID_PROPS_DEFAULT_VALUES).reduce((acc, key) => {
      acc[key] = themedProps[key] ?? DATA_GRID_PROPS_DEFAULT_VALUES[key];
      return acc;
    }, {});
  }, [themedProps]);
  return reactExports.useMemo(() => _extends$4({}, themedProps, injectDefaultProps, {
    localeText,
    slots
  }, DATA_GRID_FORCED_PROPS), [themedProps, localeText, slots, injectDefaultProps]);
}, "useDataGridProps");
const configuration = {
  hooks: {
    useGridAriaAttributes,
    useGridRowAriaAttributes
  }
};
const DataGridRaw = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function DataGrid2(inProps, ref) {
  const props = useDataGridProps(inProps);
  const privateApiRef = useDataGridComponent(props.apiRef, props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridContextProvider, {
    privateApiRef,
    configuration,
    props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GridRoot$1, _extends$4({
      className: props.className,
      style: props.style,
      sx: props.sx,
      ref
    }, props.forwardedProps, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridHeader, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(GridVirtualScroller, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(GridFooterPlaceholder, {})]
    }))
  });
}, "DataGrid2"));
const DataGrid = /* @__PURE__ */ reactExports.memo(DataGridRaw);
DataGridRaw.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The ref object that allows Data Grid manipulation. Can be instantiated with `useGridApiRef()`.
   */
  apiRef: PropTypes.shape({
    current: PropTypes.object.isRequired
  }),
  /**
   * The label of the Data Grid.
   */
  "aria-label": PropTypes.string,
  /**
   * The id of the element containing a label for the Data Grid.
   */
  "aria-labelledby": PropTypes.string,
  /**
   * If `true`, the Data Grid height is dynamic and follows the number of rows in the Data Grid.
   * @default false
   * @deprecated Use flex parent container instead: https://mui.com/x/react-data-grid/layout/#flex-parent-container
   * @example
   * <div style={{ display: 'flex', flexDirection: 'column' }}>
   *   <DataGrid />
   * </div>
   */
  autoHeight: PropTypes.bool,
  /**
   * If `true`, the pageSize is calculated according to the container size and the max number of rows to avoid rendering a vertical scroll bar.
   * @default false
   */
  autoPageSize: PropTypes.bool,
  /**
   * If `true`, columns are autosized after the datagrid is mounted.
   * @default false
   */
  autosizeOnMount: PropTypes.bool,
  /**
   * The options for autosize when user-initiated.
   */
  autosizeOptions: PropTypes.shape({
    columns: PropTypes.arrayOf(PropTypes.string),
    expand: PropTypes.bool,
    includeHeaders: PropTypes.bool,
    includeOutliers: PropTypes.bool,
    outliersFactor: PropTypes.number
  }),
  /**
   * Controls the modes of the cells.
   */
  cellModesModel: PropTypes.object,
  /**
   * If `true`, the Data Grid will display an extra column with checkboxes for selecting rows.
   * @default false
   */
  checkboxSelection: PropTypes.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * The character used to separate cell values when copying to the clipboard.
   * @default '\t'
   */
  clipboardCopyCellDelimiter: PropTypes.string,
  /**
   * Column region in pixels to render before/after the viewport
   * @default 150
   */
  columnBufferPx: PropTypes.number,
  /**
   * Sets the height in pixels of the column group headers in the Data Grid.
   * Inherits the `columnHeaderHeight` value if not set.
   */
  columnGroupHeaderHeight: PropTypes.number,
  columnGroupingModel: PropTypes.arrayOf(PropTypes.object),
  /**
   * Sets the height in pixel of the column headers in the Data Grid.
   * @default 56
   */
  columnHeaderHeight: PropTypes.number,
  /**
   * Set of columns of type [[GridColDef]][].
   */
  columns: PropTypes.arrayOf(PropTypes.object).isRequired,
  /**
   * Set the column visibility model of the Data Grid.
   * If defined, the Data Grid will ignore the `hide` property in [[GridColDef]].
   */
  columnVisibilityModel: PropTypes.object,
  /**
   * Set the density of the Data Grid.
   * @default "standard"
   */
  density: PropTypes.oneOf(["comfortable", "compact", "standard"]),
  /**
   * If `true`, column autosizing on header separator double-click is disabled.
   * @default false
   */
  disableAutosize: PropTypes.bool,
  /**
   * If `true`, column filters are disabled.
   * @default false
   */
  disableColumnFilter: PropTypes.bool,
  /**
   * If `true`, the column menu is disabled.
   * @default false
   */
  disableColumnMenu: PropTypes.bool,
  /**
   * If `true`, resizing columns is disabled.
   * @default false
   */
  disableColumnResize: PropTypes.bool,
  /**
   * If `true`, hiding/showing columns is disabled.
   * @default false
   */
  disableColumnSelector: PropTypes.bool,
  /**
   * If `true`, the column sorting feature will be disabled.
   * @default false
   */
  disableColumnSorting: PropTypes.bool,
  /**
   * If `true`, the density selector is disabled.
   * @default false
   */
  disableDensitySelector: PropTypes.bool,
  /**
   * If `true`, `eval()` is not used for performance optimization.
   * @default false
   */
  disableEval: PropTypes.bool,
  /**
   * If `true`, multiple selection using the Ctrl/CMD or Shift key is disabled.
   * The MIT DataGrid will ignore this prop, unless `checkboxSelection` is enabled.
   * @default false (`!props.checkboxSelection` for MIT Data Grid)
   */
  disableMultipleRowSelection: PropTypes.bool,
  /**
   * If `true`, the selection on click on a row or cell is disabled.
   * @default false
   */
  disableRowSelectionOnClick: PropTypes.bool,
  /**
   * If `true`, the virtualization is disabled.
   * @default false
   */
  disableVirtualization: PropTypes.bool,
  /**
   * Controls whether to use the cell or row editing.
   * @default "cell"
   */
  editMode: PropTypes.oneOf(["cell", "row"]),
  /**
   * Use if the actual rowCount is not known upfront, but an estimation is available.
   * If some rows have children (for instance in the tree data), this number represents the amount of top level rows.
   * Applicable only with `paginationMode="server"` and when `rowCount="-1"`
   */
  estimatedRowCount: PropTypes.number,
  /**
   * Unstable features, breaking changes might be introduced.
   * For each feature, if the flag is not explicitly set to `true`, the feature will be fully disabled and any property / method call will not have any effect.
   */
  experimentalFeatures: PropTypes.shape({
    warnIfFocusStateIsNotSynced: PropTypes.bool
  }),
  /**
   * The milliseconds delay to wait after a keystroke before triggering filtering.
   * @default 150
   */
  filterDebounceMs: PropTypes.number,
  /**
   * Filtering can be processed on the server or client-side.
   * Set it to 'server' if you would like to handle filtering on the server-side.
   * @default "client"
   */
  filterMode: PropTypes.oneOf(["client", "server"]),
  /**
   * Set the filter model of the Data Grid.
   */
  filterModel: PropTypes.shape({
    items: PropTypes.arrayOf(PropTypes.shape({
      field: PropTypes.string.isRequired,
      id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
      operator: PropTypes.string.isRequired,
      value: PropTypes.any
    })).isRequired,
    logicOperator: PropTypes.oneOf(["and", "or"]),
    quickFilterExcludeHiddenColumns: PropTypes.bool,
    quickFilterLogicOperator: PropTypes.oneOf(["and", "or"]),
    quickFilterValues: PropTypes.array
  }),
  /**
   * Forwarded props for the Data Grid root element.
   * @ignore - do not document.
   */
  forwardedProps: PropTypes.object,
  /**
   * Function that applies CSS classes dynamically on cells.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @returns {string} The CSS class to apply to the cell.
   */
  getCellClassName: PropTypes.func,
  /**
   * Function that returns the element to render in row detail.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @returns {React.JSX.Element} The row detail element.
   */
  getDetailPanelContent: PropTypes.func,
  /**
   * Function that returns the estimated height for a row.
   * Only works if dynamic row height is used.
   * Once the row height is measured this value is discarded.
   * @param {GridRowHeightParams} params With all properties from [[GridRowHeightParams]].
   * @returns {number | null} The estimated row height value. If `null` or `undefined` then the default row height, based on the density, is applied.
   */
  getEstimatedRowHeight: PropTypes.func,
  /**
   * Function that applies CSS classes dynamically on rows.
   * @param {GridRowClassNameParams} params With all properties from [[GridRowClassNameParams]].
   * @returns {string} The CSS class to apply to the row.
   */
  getRowClassName: PropTypes.func,
  /**
   * Function that sets the row height per row.
   * @param {GridRowHeightParams} params With all properties from [[GridRowHeightParams]].
   * @returns {GridRowHeightReturnValue} The row height value. If `null` or `undefined` then the default row height is applied. If "auto" then the row height is calculated based on the content.
   */
  getRowHeight: PropTypes.func,
  /**
   * Return the id of a given [[GridRowModel]].
   */
  getRowId: PropTypes.func,
  /**
   * Function that allows to specify the spacing between rows.
   * @param {GridRowSpacingParams} params With all properties from [[GridRowSpacingParams]].
   * @returns {GridRowSpacing} The row spacing values.
   */
  getRowSpacing: PropTypes.func,
  /**
   * If `true`, the footer component is hidden.
   * @default false
   */
  hideFooter: PropTypes.bool,
  /**
   * If `true`, the pagination component in the footer is hidden.
   * @default false
   */
  hideFooterPagination: PropTypes.bool,
  /**
   * If `true`, the selected row count in the footer is hidden.
   * @default false
   */
  hideFooterSelectedRowCount: PropTypes.bool,
  /**
   * If `true`, the diacritics (accents) are ignored when filtering or quick filtering.
   * E.g. when filter value is `cafe`, the rows with `caf` will be visible.
   * @default false
   */
  ignoreDiacritics: PropTypes.bool,
  /**
   * If `true`, the Data Grid will not use `valueFormatter` when exporting to CSV or copying to clipboard.
   * If an object is provided, you can choose to ignore the `valueFormatter` for CSV export or clipboard export.
   * @default false
   */
  ignoreValueFormatterDuringExport: PropTypes.oneOfType([PropTypes.shape({
    clipboardExport: PropTypes.bool,
    csvExport: PropTypes.bool
  }), PropTypes.bool]),
  /**
   * If `select`, a group header checkbox in indeterminate state (like "Select All" checkbox)
   * will select all the rows under it.
   * If `deselect`, it will deselect all the rows under it.
   * Works only if `checkboxSelection` is enabled.
   * @default "deselect"
   */
  indeterminateCheckboxAction: PropTypes.oneOf(["deselect", "select"]),
  /**
   * The initial state of the DataGrid.
   * The data in it will be set in the state on initialization but will not be controlled.
   * If one of the data in `initialState` is also being controlled, then the control state wins.
   */
  initialState: PropTypes.object,
  /**
   * Callback fired when a cell is rendered, returns true if the cell is editable.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @returns {boolean} A boolean indicating if the cell is editable.
   */
  isCellEditable: PropTypes.func,
  /**
   * Determines if a row can be selected.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @returns {boolean} A boolean indicating if the row is selectable.
   */
  isRowSelectable: PropTypes.func,
  /**
   * If `true`, the selection model will retain selected rows that do not exist.
   * Useful when using server side pagination and row selections need to be retained
   * when changing pages.
   * @default false
   */
  keepNonExistentRowsSelected: PropTypes.bool,
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: PropTypes.bool,
  /**
   * Set the locale text of the Data Grid.
   * You can find all the translation keys supported in [the source](https://github.com/mui/mui-x/blob/HEAD/packages/x-data-grid/src/constants/localeTextConstants.ts) in the GitHub repository.
   */
  localeText: PropTypes.object,
  /**
   * Pass a custom logger in the components that implements the [[Logger]] interface.
   * @default console
   */
  logger: PropTypes.shape({
    debug: PropTypes.func.isRequired,
    error: PropTypes.func.isRequired,
    info: PropTypes.func.isRequired,
    warn: PropTypes.func.isRequired
  }),
  /**
   * Allows to pass the logging level or false to turn off logging.
   * @default "error" ("warn" in dev mode)
   */
  logLevel: PropTypes.oneOf(["debug", "error", "info", "warn", false]),
  /**
   * Nonce of the inline styles for [Content Security Policy](https://www.w3.org/TR/2016/REC-CSP2-20161215/#script-src-the-nonce-attribute).
   */
  nonce: PropTypes.string,
  /**
   * Callback fired when any cell is clicked.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellClick: PropTypes.func,
  /**
   * Callback fired when a double click event comes from a cell element.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellDoubleClick: PropTypes.func,
  /**
   * Callback fired when the cell turns to edit mode.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.KeyboardEvent | React.MouseEvent>} event The event that caused this prop to be called.
   */
  onCellEditStart: PropTypes.func,
  /**
   * Callback fired when the cell turns to view mode.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
   */
  onCellEditStop: PropTypes.func,
  /**
   * Callback fired when a keydown event comes from a cell element.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.KeyboardEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellKeyDown: PropTypes.func,
  /**
   * Callback fired when the `cellModesModel` prop changes.
   * @param {GridCellModesModel} cellModesModel Object containing which cells are in "edit" mode.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellModesModelChange: PropTypes.func,
  /**
   * Callback called when the data is copied to the clipboard.
   * @param {string} data The data copied to the clipboard.
   */
  onClipboardCopy: PropTypes.func,
  /**
   * Callback fired when a click event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderClick: PropTypes.func,
  /**
   * Callback fired when a contextmenu event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   */
  onColumnHeaderContextMenu: PropTypes.func,
  /**
   * Callback fired when a double click event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderDoubleClick: PropTypes.func,
  /**
   * Callback fired when a mouse enter event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderEnter: PropTypes.func,
  /**
   * Callback fired when a mouse leave event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderLeave: PropTypes.func,
  /**
   * Callback fired when a mouseout event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderOut: PropTypes.func,
  /**
   * Callback fired when a mouseover event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderOver: PropTypes.func,
  /**
   * Callback fired when a column is reordered.
   * @param {GridColumnOrderChangeParams} params With all properties from [[GridColumnOrderChangeParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnOrderChange: PropTypes.func,
  /**
   * Callback fired while a column is being resized.
   * @param {GridColumnResizeParams} params With all properties from [[GridColumnResizeParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnResize: PropTypes.func,
  /**
   * Callback fired when the column visibility model changes.
   * @param {GridColumnVisibilityModel} model The new model.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnVisibilityModelChange: PropTypes.func,
  /**
   * Callback fired when the width of a column is changed.
   * @param {GridColumnResizeParams} params With all properties from [[GridColumnResizeParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnWidthChange: PropTypes.func,
  /**
   * Callback fired when the density changes.
   * @param {GridDensity} density New density value.
   */
  onDensityChange: PropTypes.func,
  /**
   * Callback fired when the Filter model changes before the filters are applied.
   * @param {GridFilterModel} model With all properties from [[GridFilterModel]].
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onFilterModelChange: PropTypes.func,
  /**
   * Callback fired when the menu is closed.
   * @param {GridMenuParams} params With all properties from [[GridMenuParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onMenuClose: PropTypes.func,
  /**
   * Callback fired when the menu is opened.
   * @param {GridMenuParams} params With all properties from [[GridMenuParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onMenuOpen: PropTypes.func,
  /**
   * Callback fired when the pagination meta has changed.
   * @param {GridPaginationMeta} paginationMeta Updated pagination meta.
   */
  onPaginationMetaChange: PropTypes.func,
  /**
   * Callback fired when the pagination model has changed.
   * @param {GridPaginationModel} model Updated pagination model.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onPaginationModelChange: PropTypes.func,
  /**
   * Callback fired when the preferences panel is closed.
   * @param {GridPreferencePanelParams} params With all properties from [[GridPreferencePanelParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onPreferencePanelClose: PropTypes.func,
  /**
   * Callback fired when the preferences panel is opened.
   * @param {GridPreferencePanelParams} params With all properties from [[GridPreferencePanelParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onPreferencePanelOpen: PropTypes.func,
  /**
   * Callback called when `processRowUpdate` throws an error or rejects.
   * @param {any} error The error thrown.
   */
  onProcessRowUpdateError: PropTypes.func,
  /**
   * Callback fired when the Data Grid is resized.
   * @param {ElementSize} containerSize With all properties from [[ElementSize]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onResize: PropTypes.func,
  /**
   * Callback fired when a row is clicked.
   * Not called if the target clicked is an interactive element added by the built-in columns.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowClick: PropTypes.func,
  /**
   * Callback fired when the row count has changed.
   * @param {number} count Updated row count.
   */
  onRowCountChange: PropTypes.func,
  /**
   * Callback fired when a double click event comes from a row container element.
   * @param {GridRowParams} params With all properties from [[RowParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowDoubleClick: PropTypes.func,
  /**
   * Callback fired when the row turns to edit mode.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @param {MuiEvent<React.KeyboardEvent | React.MouseEvent>} event The event that caused this prop to be called.
   */
  onRowEditStart: PropTypes.func,
  /**
   * Callback fired when the row turns to view mode.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
   */
  onRowEditStop: PropTypes.func,
  /**
   * Callback fired when the `rowModesModel` prop changes.
   * @param {GridRowModesModel} rowModesModel Object containing which rows are in "edit" mode.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowModesModelChange: PropTypes.func,
  /**
   * Callback fired when the selection state of one or multiple rows changes.
   * @param {GridRowSelectionModel} rowSelectionModel With all the row ids [[GridSelectionModel]].
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowSelectionModelChange: PropTypes.func,
  /**
   * Callback fired when the sort model changes before a column is sorted.
   * @param {GridSortModel} model With all properties from [[GridSortModel]].
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onSortModelChange: PropTypes.func,
  /**
   * Callback fired when the state of the Data Grid is updated.
   * @param {GridState} state The new state.
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   * @ignore - do not document.
   */
  onStateChange: PropTypes.func,
  /**
   * Select the pageSize dynamically using the component UI.
   * @default [25, 50, 100]
   */
  pageSizeOptions: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    label: PropTypes.string.isRequired,
    value: PropTypes.number.isRequired
  })]).isRequired),
  pagination: PropTypes.oneOf([true]),
  /**
   * The extra information about the pagination state of the Data Grid.
   * Only applicable with `paginationMode="server"`.
   */
  paginationMeta: PropTypes.shape({
    hasNextPage: PropTypes.bool
  }),
  /**
   * Pagination can be processed on the server or client-side.
   * Set it to 'client' if you would like to handle the pagination on the client-side.
   * Set it to 'server' if you would like to handle the pagination on the server-side.
   * @default "client"
   */
  paginationMode: PropTypes.oneOf(["client", "server"]),
  /**
   * The pagination model of type [[GridPaginationModel]] which refers to current `page` and `pageSize`.
   */
  paginationModel: PropTypes.shape({
    page: PropTypes.number.isRequired,
    pageSize: PropTypes.number.isRequired
  }),
  /**
   * Callback called before updating a row with new values in the row and cell editing.
   * @template R
   * @param {R} newRow Row object with the new values.
   * @param {R} oldRow Row object with the old values.
   * @param {{ rowId: GridRowId }} params Additional parameters.
   * @returns {Promise<R> | R} The final values to update the row.
   */
  processRowUpdate: PropTypes.func,
  /**
   * The milliseconds throttle delay for resizing the grid.
   * @default 60
   */
  resizeThrottleMs: PropTypes.number,
  /**
   * Row region in pixels to render before/after the viewport
   * @default 150
   */
  rowBufferPx: PropTypes.number,
  /**
   * Set the total number of rows, if it is different from the length of the value `rows` prop.
   * If some rows have children (for instance in the tree data), this number represents the amount of top level rows.
   * Only works with `paginationMode="server"`, ignored when `paginationMode="client"`.
   */
  rowCount: PropTypes.number,
  /**
   * Sets the height in pixel of a row in the Data Grid.
   * @default 52
   */
  rowHeight: PropTypes.number,
  /**
   * Controls the modes of the rows.
   */
  rowModesModel: PropTypes.object,
  /**
   * The milliseconds delay to wait after measuring the row height before recalculating row positions.
   * Setting it to a lower value could be useful when using dynamic row height,
   * but might reduce performance when displaying a large number of rows.
   * @default 166
   * @deprecated
   */
  rowPositionsDebounceMs: PropTypes.number,
  /**
   * Set of rows of type [[GridRowsProp]].
   * @default []
   */
  rows: PropTypes.arrayOf(PropTypes.object),
  /**
   * If `false`, the row selection mode is disabled.
   * @default true
   */
  rowSelection: PropTypes.bool,
  /**
   * Sets the row selection model of the Data Grid.
   */
  rowSelectionModel: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired), PropTypes.number, PropTypes.string]),
  /**
   * Sets the type of space between rows added by `getRowSpacing`.
   * @default "margin"
   */
  rowSpacingType: PropTypes.oneOf(["border", "margin"]),
  /**
   * Override the height/width of the Data Grid inner scrollbar.
   */
  scrollbarSize: PropTypes.number,
  /**
   * If `true`, vertical borders will be displayed between cells.
   * @default false
   */
  showCellVerticalBorder: PropTypes.bool,
  /**
   * If `true`, vertical borders will be displayed between column header items.
   * @default false
   */
  showColumnVerticalBorder: PropTypes.bool,
  /**
   * Overridable components props dynamically passed to the component at rendering.
   */
  slotProps: PropTypes.object,
  /**
   * Overridable components.
   */
  slots: PropTypes.object,
  /**
   * Sorting can be processed on the server or client-side.
   * Set it to 'client' if you would like to handle sorting on the client-side.
   * Set it to 'server' if you would like to handle sorting on the server-side.
   * @default "client"
   */
  sortingMode: PropTypes.oneOf(["client", "server"]),
  /**
   * The order of the sorting sequence.
   * @default ['asc', 'desc', null]
   */
  sortingOrder: PropTypes.arrayOf(PropTypes.oneOf(["asc", "desc"])),
  /**
   * Set the sort model of the Data Grid.
   */
  sortModel: PropTypes.arrayOf(PropTypes.shape({
    field: PropTypes.string.isRequired,
    sort: PropTypes.oneOf(["asc", "desc"])
  })),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * If `true`, the Data Grid will auto span the cells over the rows having the same value.
   * @default false
   */
  unstable_rowSpanning: PropTypes.bool
};
const styles$a = {
  gridFooterContainer: {
    display: "flex",
    justifyContent: "center",
    gap: 2
  },
  container: { display: "flex", flexDirection: "column", gap: 1, height: "100%" }
};
const BaseButtonStyles = {
  backgroundColor: "orange",
  color: "white",
  borderRadius: "8px",
  padding: "8px 12px",
  textTransform: "capitalize",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  gap: "8px",
  // Espaamento entre o cone e o texto
  "&:hover": {
    backgroundColor: "#ff9800"
  }
};
const OpportunityGridStyles = {
  width: "100%",
  borderCollapse: "collapse",
  fontFamily: "Arial, sans-serif",
  fontSize: "12px",
  fontWeight: "500",
  padding: 0,
  borderRadius: 0,
  color: "#233142",
  "& .MuiDataGrid-columnHeaders": {
    fontWeight: "bold",
    color: "black",
    "& .MuiDataGrid-columnHeader": {
      backgroundColor: "#ececec",
      borderRadius: 0
    }
  },
  "& .MuiDataGrid-topContainer": {
    borderRadius: 0
  },
  "& .MuiDataGrid-columnHeaderTitle": {
    fontWeight: "bold",
    fontSize: 12
  },
  "& .description-cell": {
    color: "blue"
  },
  "& .status-cell": {},
  "& .MuiDataGrid-row": {
    cursor: "pointer",
    ":nth-child(even)": {
      backgroundColor: "#ececec"
    }
  },
  "& .MuiDataGrid-cell": {
    paddingLeft: 1.2
  },
  "& .MuiDataGrid-menuIconButton": {
    display: "none"
  }
};
const buttonStylesMobile = {
  backgroundColor: "orange",
  color: "white",
  borderRadius: "100%",
  padding: 0,
  minWidth: 40,
  height: 40,
  boxShadow: "0px 4px 4px rgba(0, 0, 0, 0.1)",
  // Sombra para elegncia
  "&:hover": {
    backgroundColor: "#ff9800"
  }
};
const basicAppbarStyles = {
  backgroundColor: "#2B3990",
  display: "flex",
  justifyContent: "center",
  padding: "0.2rem"
};
const basicCardStyles = {
  boxShadow: "none",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flexShrink: 1,
  flexGrow: 1,
  paddingBottom: "5px",
  paddingLeft: "5px",
  paddingRight: "5px",
  paddingTop: "5px"
};
const basicCardContentStyles = {
  boxShadow: `rgba(149, 157, 165, 0.2) 0px 8px 24px`,
  display: "flex",
  flexDirection: "column",
  width: "fit-content",
  alignItems: "start",
  gap: 0.8,
  padding: 1,
  justifyContent: "center",
  borderRadius: "16px"
};
const cardTitleStyle = {
  fontSize: 14,
  textTransform: "uppercase",
  width: "100%",
  textAlign: "center",
  color: "textPrimary",
  fontWeight: "500"
};
const alertAnimation = {
  initial: { opacity: 0 },
  animate: { opacity: 1 },
  exit: { opacity: 0 },
  transition: { duration: 0.5 }
};
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
const MotionContext = reactExports.createContext({});
const PresenceContext = reactExports.createContext(null);
const isBrowser$1 = typeof document !== "undefined";
const useIsomorphicLayoutEffect$3 = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
const LazyContext = reactExports.createContext({ strict: false });
const camelToDash = /* @__PURE__ */ __name((str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), "camelToDash");
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
const MotionGlobalConfig = {
  skipAnimations: false,
  useManualTiming: false
};
const _Queue = class _Queue {
  constructor() {
    this.order = [];
    this.scheduled = /* @__PURE__ */ new Set();
  }
  add(process) {
    if (!this.scheduled.has(process)) {
      this.scheduled.add(process);
      this.order.push(process);
      return true;
    }
  }
  remove(process) {
    const index2 = this.order.indexOf(process);
    if (index2 !== -1) {
      this.order.splice(index2, 1);
      this.scheduled.delete(process);
    }
  }
  clear() {
    this.order.length = 0;
    this.scheduled.clear();
  }
};
__name(_Queue, "Queue");
let Queue = _Queue;
function createRenderStep(runNextFrame) {
  let thisFrame = new Queue();
  let nextFrame = new Queue();
  let numToRun = 0;
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (queue.add(callback) && addToCurrentFrame && isProcessing) {
        numToRun = thisFrame.order.length;
      }
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.remove(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      nextFrame.clear();
      numToRun = thisFrame.order.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = thisFrame.order[i];
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame();
          }
          callback(frameData2);
        }
      }
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
__name(createRenderStep, "createRenderStep");
const stepsOrder = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const steps2 = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(() => runNextFrame = true);
    return acc;
  }, {});
  const processStep = /* @__PURE__ */ __name((stepId) => {
    steps2[stepId].process(state);
  }, "processStep");
  const processBatch = /* @__PURE__ */ __name(() => {
    const timestamp = performance.now();
    runNextFrame = false;
    state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    state.timestamp = timestamp;
    state.isProcessing = true;
    stepsOrder.forEach(processStep);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  }, "processBatch");
  const wake = /* @__PURE__ */ __name(() => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  }, "wake");
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps2[key];
    acc[key] = (process, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = /* @__PURE__ */ __name((process) => stepsOrder.forEach((key) => steps2[key].cancel(process)), "cancel");
  return { schedule, cancel, state, steps: steps2 };
}
__name(createRenderBatcher, "createRenderBatcher");
const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);
function useVisualElement(Component, visualState, props, createVisualElement) {
  const { visualElement: parent } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef();
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  reactExports.useInsertionEffect(() => {
    visualElement && visualElement.update(props, presenceContext);
  });
  const wantsHandoff = reactExports.useRef(Boolean(props[optimizedAppearDataAttribute] && !window.HandoffComplete));
  useIsomorphicLayoutEffect$3(() => {
    if (!visualElement)
      return;
    microtask.render(visualElement.render);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  reactExports.useEffect(() => {
    if (!visualElement)
      return;
    visualElement.updateFeatures();
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      wantsHandoff.current = false;
      window.HandoffComplete = true;
    }
  });
  return visualElement;
}
__name(useVisualElement, "useVisualElement");
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
__name(isRefObject, "isRefObject");
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement) {
        instance ? visualElement.mount(instance) : visualElement.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
__name(useMotionRef, "useMotionRef");
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
__name(isVariantLabel, "isVariantLabel");
function isAnimationControls(v2) {
  return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
}
__name(isAnimationControls, "isAnimationControls");
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
__name(isControllingVariants, "isControllingVariants");
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
__name(isVariantNode, "isVariantNode");
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
__name(getCurrentTreeVariants, "getCurrentTreeVariants");
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
__name(useCreateMotionContext, "useCreateMotionContext");
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
__name(variantLabelsAsDependency, "variantLabelsAsDependency");
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name) => !!props[name])
  };
}
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}
__name(loadFeatures, "loadFeatures");
const LayoutGroupContext = reactExports.createContext({});
const SwitchLayoutGroupContext = reactExports.createContext({});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState, Component }) {
  preloadedFeatures2 && loadFeatures(preloadedFeatures2);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser$1) {
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);
      const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
      const isStrict = reactExports.useContext(LazyContext).strict;
      if (context.visualElement) {
        MeasureLayout2 = context.visualElement.loadFeatures(
          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
          configAndProps,
          isStrict,
          preloadedFeatures2,
          initialLayoutGroupConfig
        );
      }
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  __name(MotionComponent, "MotionComponent");
  const ForwardRefComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component;
  return ForwardRefComponent;
}
__name(createMotionComponent, "createMotionComponent");
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
__name(useLayoutId, "useLayoutId");
function createMotionProxy(createConfig) {
  function custom(Component, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component, customMotionComponentConfig));
  }
  __name(custom, "custom");
  if (typeof Proxy === "undefined") {
    return custom;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }
      return componentCache.get(key);
    }
  });
}
__name(createMotionProxy, "createMotionProxy");
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component)
  ) {
    return true;
  }
  return false;
}
__name(isSVGComponent, "isSVGComponent");
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
__name(addScaleCorrector, "addScaleCorrector");
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
__name(isForcedMotionValue, "isForcedMotionValue");
const isMotionValue = /* @__PURE__ */ __name((value) => Boolean(value && value.getVelocity), "isMotionValue");
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(transform, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
  let transformString = "";
  for (let i = 0; i < numTransforms; i++) {
    const key = transformPropOrder[i];
    if (transform[key] !== void 0) {
      const transformName = translateAlias[key] || key;
      transformString += `${transformName}(${transform[key]}) `;
    }
  }
  if (enableHardwareAcceleration && !transform.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
__name(buildTransform, "buildTransform");
const checkStringStartsWith = /* @__PURE__ */ __name((token2) => (key) => typeof key === "string" && key.startsWith(token2), "checkStringStartsWith");
const isCSSVariableName = checkStringStartsWith("--");
const startsAsVariableToken = checkStringStartsWith("var(--");
const isCSSVariableToken = /* @__PURE__ */ __name((value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken)
    return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
}, "isCSSVariableToken");
const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
const getValueAsType = /* @__PURE__ */ __name((value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
}, "getValueAsType");
const clamp$2 = /* @__PURE__ */ __name((min2, max2, v2) => {
  if (v2 > max2)
    return max2;
  if (v2 < min2)
    return min2;
  return v2;
}, "clamp$2");
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = {
  ...number,
  transform: (v2) => clamp$2(0, 1, v2)
};
const scale = {
  ...number,
  default: 1
};
const sanitize = /* @__PURE__ */ __name((v2) => Math.round(v2 * 1e5) / 1e5, "sanitize");
const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
function isString$1(v2) {
  return typeof v2 === "string";
}
__name(isString$1, "isString$1");
const createUnitType = /* @__PURE__ */ __name((unit) => ({
  test: (v2) => isString$1(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
}), "createUnitType");
const degrees = createUnitType("deg");
const percent = createUnitType("%");
const px = createUnitType("px");
const vh = createUnitType("vh");
const vw = createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
};
const int = {
  ...number,
  transform: Math.round
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  backgroundPositionX: px,
  backgroundPositionY: px,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  const { style: style2, vars, transform, transformOrigin: transformOrigin2 } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    }
    const valueType = numberValueTypes[key];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key)) {
      hasTransform2 = true;
      transform[key] = valueAsType;
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin2[key] = valueAsType;
    } else {
      style2[key] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style2.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);
    } else if (style2.transform) {
      style2.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin2;
    style2.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
__name(buildHTMLStyles, "buildHTMLStyles");
const createHtmlRenderState = /* @__PURE__ */ __name(() => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), "createHtmlRenderState");
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
__name(copyRawValuesOnly, "copyRawValuesOnly");
function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
__name(useInitialMotionValues, "useInitialMotionValues");
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {};
  const style2 = {};
  copyRawValuesOnly(style2, styleProp, props);
  Object.assign(style2, useInitialMotionValues(props, visualState, isStatic));
  return style2;
}
__name(useStyle, "useStyle");
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {};
  const style2 = useStyle(props, visualState, isStatic);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none";
    style2.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style2;
  return htmlProps;
}
__name(useHTMLProps, "useHTMLProps");
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
__name(isValidMotionProp, "isValidMotionProp");
let shouldForward = /* @__PURE__ */ __name((key) => !isValidMotionProp(key), "shouldForward");
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = /* @__PURE__ */ __name((key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key), "shouldForward");
}
__name(loadExternalIsValidProp, "loadExternalIsValidProp");
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a2) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
__name(filterProps, "filterProps");
function calcOrigin$1(origin2, offset2, size2) {
  return typeof origin2 === "string" ? origin2 : px.transform(offset2 + size2 * origin2);
}
__name(calcOrigin$1, "calcOrigin$1");
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
__name(calcSVGTransformOrigin, "calcSVGTransformOrigin");
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset2);
  const pathLength = px.transform(length2);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
__name(buildSVGPath, "buildSVGPath");
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, options, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, options, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style: style2, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style2.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style2.transform)) {
    style2.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
__name(buildSVGAttrs, "buildSVGAttrs");
const createSvgRenderState = /* @__PURE__ */ __name(() => ({
  ...createHtmlRenderState(),
  attrs: {}
}), "createSvgRenderState");
const isSVGTag = /* @__PURE__ */ __name((tag) => typeof tag === "string" && tag.toLowerCase() === "svg", "isSVGTag");
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component), props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
__name(useSVGProps, "useSVGProps");
function createUseRender(forwardMotionProps = false) {
  const useRender = /* @__PURE__ */ __name((Component, props, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = Component !== reactExports.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  }, "useRender");
  return useRender;
}
__name(createUseRender, "createUseRender");
function renderHTML(element, { style: style2, vars }, styleProp, projection) {
  Object.assign(element.style, style2, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
__name(renderHTML, "renderHTML");
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
__name(renderSVG, "renderSVG");
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  var _a2;
  const { style: style2 } = props;
  const newValues = {};
  for (const key in style2) {
    if (isMotionValue(style2[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a2 = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a2 === void 0 ? void 0 : _a2.liveStyle) !== void 0) {
      newValues[key] = style2[key];
    }
  }
  return newValues;
}
__name(scrapeMotionValuesFromProps$1, "scrapeMotionValuesFromProps$1");
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
__name(scrapeMotionValuesFromProps, "scrapeMotionValuesFromProps");
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
__name(getValueState, "getValueState");
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}
__name(resolveVariantFromProps, "resolveVariantFromProps");
function useConstant(init2) {
  const ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init2();
  }
  return ref.current;
}
__name(useConstant, "useConstant");
const isKeyframesTarget = /* @__PURE__ */ __name((v2) => {
  return Array.isArray(v2);
}, "isKeyframesTarget");
const isCustomValue = /* @__PURE__ */ __name((v2) => {
  return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
}, "isCustomValue");
const resolveFinalValueInKeyframes = /* @__PURE__ */ __name((v2) => {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
}, "resolveFinalValueInKeyframes");
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
__name(resolveMotionValue, "resolveMotionValue");
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance) => onMount(props, instance, state);
  }
  return state;
}
__name(makeState, "makeState");
const makeUseVisualState = /* @__PURE__ */ __name((config2) => (props, isStatic) => {
  const context = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = /* @__PURE__ */ __name(() => makeState(config2, props, context, presenceContext), "make");
  return isStatic ? make() : useConstant(make);
}, "makeUseVisualState");
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values2 = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values2[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key in target) {
        let valueTarget = target[key];
        if (Array.isArray(valueTarget)) {
          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index2];
        }
        if (valueTarget !== null) {
          values2[key] = valueTarget;
        }
      }
      for (const key in transitionEnd)
        values2[key] = transitionEnd[key];
    });
  }
  return values2;
}
__name(makeLatestValues, "makeLatestValues");
const noop$3 = /* @__PURE__ */ __name((any) => any, "noop$3");
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: steps$1 } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$3, true);
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      frame.read(() => {
        try {
          renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
        } catch (e2) {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      });
      frame.render(() => {
        buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);
        renderSVG(instance, renderState);
      });
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement) {
  const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures: preloadedFeatures2,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    Component
  };
}
__name(createDomMotionConfig, "createDomMotionConfig");
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
__name(addDomEvent, "addDomEvent");
const isPrimaryPointer = /* @__PURE__ */ __name((event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
}, "isPrimaryPointer");
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[`${pointType}X`],
      y: event[`${pointType}Y`]
    }
  };
}
__name(extractEventInfo, "extractEventInfo");
const addPointerInfo = /* @__PURE__ */ __name((handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
}, "addPointerInfo");
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
__name(addPointerEvent, "addPointerEvent");
const combineFunctions = /* @__PURE__ */ __name((a, b2) => (v2) => b2(a(v2)), "combineFunctions");
const pipe$1 = /* @__PURE__ */ __name((...transformers) => transformers.reduce(combineFunctions), "pipe$1");
function createLock(name) {
  let lock = null;
  return () => {
    const openLock = /* @__PURE__ */ __name(() => {
      lock = null;
    }, "openLock");
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
__name(createLock, "createLock");
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = /* @__PURE__ */ __name(() => {
        openHorizontal();
        openVertical();
      }, "lock");
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
__name(getGlobalLock, "getGlobalLock");
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
__name(isDragActive, "isDragActive");
const _Feature = class _Feature {
  constructor(node2) {
    this.isMounted = false;
    this.node = node2;
  }
  update() {
  }
};
__name(_Feature, "Feature");
let Feature = _Feature;
function addHoverEvent(node2, isActive) {
  const eventName = isActive ? "pointerenter" : "pointerleave";
  const callbackName = isActive ? "onHoverStart" : "onHoverEnd";
  const handleEvent = /* @__PURE__ */ __name((event, info) => {
    if (event.pointerType === "touch" || isDragActive())
      return;
    const props = node2.getProps();
    if (node2.animationState && props.whileHover) {
      node2.animationState.setActive("whileHover", isActive);
    }
    const callback = props[callbackName];
    if (callback) {
      frame.postRender(() => callback(event, info));
    }
  }, "handleEvent");
  return addPointerEvent(node2.current, eventName, handleEvent, {
    passive: !node2.getProps()[callbackName]
  });
}
__name(addHoverEvent, "addHoverEvent");
const _HoverGesture = class _HoverGesture extends Feature {
  mount() {
    this.unmount = pipe$1(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
  }
  unmount() {
  }
};
__name(_HoverGesture, "HoverGesture");
let HoverGesture = _HoverGesture;
const _FocusGesture = class _FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible2 = false;
    try {
      isFocusVisible2 = this.node.current.matches(":focus-visible");
    } catch (e2) {
      isFocusVisible2 = true;
    }
    if (!isFocusVisible2 || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe$1(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
};
__name(_FocusGesture, "FocusGesture");
let FocusGesture = _FocusGesture;
const isNodeOrChild = /* @__PURE__ */ __name((parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
}, "isNodeOrChild");
function fireSyntheticPointerEvent(name, handler) {
  if (!handler)
    return;
  const syntheticPointerEvent = new PointerEvent("pointer" + name);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
__name(fireSyntheticPointerEvent, "fireSyntheticPointerEvent");
const _PressGesture = class _PressGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removeStartListeners = noop$3;
    this.removeEndListeners = noop$3;
    this.removeAccessibleListeners = noop$3;
    this.startPointerPress = (startEvent, startInfo) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const props = this.node.getProps();
      const endPointerPress = /* @__PURE__ */ __name((endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
        const handler = !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel : onTap;
        if (handler) {
          frame.update(() => handler(endEvent, endInfo));
        }
      }, "endPointerPress");
      const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, {
        passive: !(props.onTap || props["onPointerUp"])
      });
      const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
        passive: !(props.onTapCancel || props["onPointerCancel"])
      });
      this.removeEndListeners = pipe$1(removePointerUpListener, removePointerCancelListener);
      this.startPress(startEvent, startInfo);
    };
    this.startAccessiblePress = () => {
      const handleKeydown = /* @__PURE__ */ __name((keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        const handleKeyup = /* @__PURE__ */ __name((keyupEvent) => {
          if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
            return;
          fireSyntheticPointerEvent("up", (event, info) => {
            const { onTap } = this.node.getProps();
            if (onTap) {
              frame.postRender(() => onTap(event, info));
            }
          });
        }, "handleKeyup");
        this.removeEndListeners();
        this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
        fireSyntheticPointerEvent("down", (event, info) => {
          this.startPress(event, info);
        });
      }, "handleKeydown");
      const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
      const handleBlur2 = /* @__PURE__ */ __name(() => {
        if (!this.isPressing)
          return;
        fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      }, "handleBlur");
      const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur2);
      this.removeAccessibleListeners = pipe$1(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event, info) {
    this.isPressing = true;
    const { onTapStart, whileTap } = this.node.getProps();
    if (whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", true);
    }
    if (onTapStart) {
      frame.postRender(() => onTapStart(event, info));
    }
  }
  checkPressEnd() {
    this.removeEndListeners();
    this.isPressing = false;
    const props = this.node.getProps();
    if (props.whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", false);
    }
    return !isDragActive();
  }
  cancelPress(event, info) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel } = this.node.getProps();
    if (onTapCancel) {
      frame.postRender(() => onTapCancel(event, info));
    }
  }
  mount() {
    const props = this.node.getProps();
    const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(props.onTapStart || props["onPointerStart"])
    });
    const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe$1(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners();
    this.removeEndListeners();
    this.removeAccessibleListeners();
  }
};
__name(_PressGesture, "PressGesture");
let PressGesture = _PressGesture;
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers$1 = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = /* @__PURE__ */ __name((entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
}, "fireObserverCallback");
const fireAllObserverCallbacks = /* @__PURE__ */ __name((entries) => {
  entries.forEach(fireObserverCallback);
}, "fireAllObserverCallbacks");
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  if (!observers$1.has(lookupRoot)) {
    observers$1.set(lookupRoot, {});
  }
  const rootObservers = observers$1.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
  }
  return rootObservers[key];
}
__name(initIntersectionObserver, "initIntersectionObserver");
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
__name(observeIntersection, "observeIntersection");
const thresholdNames = {
  some: 0,
  all: 1
};
const _InViewFeature = class _InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport: viewport2 = {} } = this.node.getProps();
    const { root: root2, margin: rootMargin, amount = "some", once } = viewport2;
    const options = {
      root: root2 ? root2.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = /* @__PURE__ */ __name((entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    }, "onIntersectionUpdate");
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
};
__name(_InViewFeature, "InViewFeature");
let InViewFeature = _InViewFeature;
function hasViewportOptionChanged({ viewport: viewport2 = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport2[name] !== prevViewport[name];
}
__name(hasViewportOptionChanged, "hasViewportOptionChanged");
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
function shallowCompare(next2, prev2) {
  if (!Array.isArray(prev2))
    return false;
  const prevLength = prev2.length;
  if (prevLength !== next2.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev2[i] !== next2[i])
      return false;
  }
  return true;
}
__name(shallowCompare, "shallowCompare");
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
}
__name(resolveVariant, "resolveVariant");
const secondsToMilliseconds = /* @__PURE__ */ __name((seconds) => seconds * 1e3, "secondsToMilliseconds");
const millisecondsToSeconds = /* @__PURE__ */ __name((milliseconds) => milliseconds / 1e3, "millisecondsToSeconds");
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = /* @__PURE__ */ __name((target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), "criticallyDampedSpring");
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = /* @__PURE__ */ __name((valueKey, { keyframes: keyframes3 }) => {
  if (keyframes3.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes3[1]) : underDampedSpring;
  }
  return ease;
}, "getDefaultTransition");
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
__name(isTransitionDefined, "isTransitionDefined");
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
__name(getValueTransition, "getValueTransition");
const isNotNull = /* @__PURE__ */ __name((value) => value !== null, "isNotNull");
function getFinalKeyframe(keyframes3, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes3.filter(isNotNull);
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
__name(getFinalKeyframe, "getFinalKeyframe");
let now$2;
function clearTime() {
  now$2 = void 0;
}
__name(clearTime, "clearTime");
const time = {
  now: () => {
    if (now$2 === void 0) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now$2;
  },
  set: (newTime) => {
    now$2 = newTime;
    queueMicrotask(clearTime);
  }
};
const isZeroValueString = /* @__PURE__ */ __name((v2) => /^0[^.\s]+$/u.test(v2), "isZeroValueString");
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
__name(isNone, "isNone");
let invariant = noop$3;
const isNumericalString = /* @__PURE__ */ __name((v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2), "isNumericalString");
const splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match2 = splitCSSVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token1, token2, fallback] = match2;
  return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];
}
__name(parseCSSVariable, "parseCSSVariable");
function getVariableValue(current, element, depth = 1) {
  const [token2, fallback] = parseCSSVariable(current);
  if (!token2)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token2);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
__name(getVariableValue, "getVariableValue");
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]);
const isNumOrPxType = /* @__PURE__ */ __name((v2) => v2 === number || v2 === px, "isNumOrPxType");
const getPosFromMatrix = /* @__PURE__ */ __name((matrix, pos) => parseFloat(matrix.split(", ")[pos]), "getPosFromMatrix");
const getTranslateFromMatrix = /* @__PURE__ */ __name((pos2, pos3) => (_bbox, { transform }) => {
  if (transform === "none" || !transform)
    return 0;
  const matrix3d = transform.match(/^matrix3d\((.+)\)$/u);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform.match(/^matrix\((.+)\)$/u);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
}, "getTranslateFromMatrix");
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
__name(removeNonTranslationalTransform, "removeNonTranslationalTransform");
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top: top2 }) => parseFloat(top2),
  left: (_bbox, { left: left2 }) => parseFloat(left2),
  bottom: ({ y: y2 }, { top: top2 }) => parseFloat(top2) + (y2.max - y2.min),
  right: ({ x: x2 }, { left: left2 }) => parseFloat(left2) + (x2.max - x2.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const testValueType = /* @__PURE__ */ __name((v2) => (type) => type.test(v2), "testValueType");
const auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = /* @__PURE__ */ __name((v2) => dimensionValueTypes.find(testValueType(v2)), "findDimensionValueType");
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = false;
let anyNeedsMeasurement = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key, value]) => {
          var _a2;
          (_a2 = element.getValue(key)) === null || _a2 === void 0 ? void 0 : _a2.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete());
  toResolve.clear();
}
__name(measureAllKeyframes, "measureAllKeyframes");
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
__name(readAllKeyframes, "readAllKeyframes");
function flushKeyframeResolvers() {
  readAllKeyframes();
  measureAllKeyframes();
}
__name(flushKeyframeResolvers, "flushKeyframeResolvers");
const _KeyframeResolver = class _KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
    this.isComplete = false;
    this.isAsync = false;
    this.needsMeasurement = false;
    this.isScheduled = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue2;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.isScheduled = true;
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (unresolvedKeyframes[i] === null) {
        if (i === 0) {
          const currentValue = motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.get();
          const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (currentValue !== void 0) {
            unresolvedKeyframes[0] = currentValue;
          } else if (element && name) {
            const valueAsRead = element.readValue(name, finalKeyframe);
            if (valueAsRead !== void 0 && valueAsRead !== null) {
              unresolvedKeyframes[0] = valueAsRead;
            }
          }
          if (unresolvedKeyframes[0] === void 0) {
            unresolvedKeyframes[0] = finalKeyframe;
          }
          if (motionValue2 && currentValue === void 0) {
            motionValue2.set(unresolvedKeyframes[0]);
          }
        } else {
          unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];
        }
      }
    }
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = true;
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
    toResolve.delete(this);
  }
  cancel() {
    if (!this.isComplete) {
      this.isScheduled = false;
      toResolve.delete(this);
    }
  }
  resume() {
    if (!this.isComplete)
      this.scheduleResolve();
  }
};
__name(_KeyframeResolver, "KeyframeResolver");
let KeyframeResolver = _KeyframeResolver;
const isColorString = /* @__PURE__ */ __name((type, testProp) => (v2) => {
  return Boolean(isString$1(v2) && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
}, "isColorString");
const splitColor = /* @__PURE__ */ __name((aName, bName, cName) => (v2) => {
  if (!isString$1(v2))
    return v2;
  const [a, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
}, "splitColor");
const clampRgbUnit = /* @__PURE__ */ __name((v2) => clamp$2(0, 255, v2), "clampRgbUnit");
const rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
const rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red: red2, green: green2, blue: blue2, alpha: alpha$12 = 1 }) => "rgba(" + rgbUnit.transform(red2) + ", " + rgbUnit.transform(green2) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a = "";
  if (v2.length > 5) {
    r2 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b2 = v2.substring(5, 7);
    a = v2.substring(7, 9);
  } else {
    r2 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b2 = v2.substring(3, 4);
    a = v2.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a += a;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
__name(parseHex, "parseHex");
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$12 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$12)) + ")";
  }
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return isString$1(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  }
};
function test(v2) {
  var _a2, _b2;
  return isNaN(v2) && isString$1(v2) && (((_a2 = v2.match(floatRegex)) === null || _a2 === void 0 ? void 0 : _a2.length) || 0) + (((_b2 = v2.match(colorRegex)) === null || _b2 === void 0 ? void 0 : _b2.length) || 0) > 0;
}
__name(test, "test");
const NUMBER_TOKEN = "number";
const COLOR_TOKEN = "color";
const VAR_TOKEN = "var";
const VAR_FUNCTION_TOKEN = "var(";
const SPLIT_TOKEN = "${}";
const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values2 = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types = [];
  let i = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color.test(parsedValue)) {
      indexes.color.push(i);
      types.push(COLOR_TOKEN);
      values2.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i);
      types.push(VAR_TOKEN);
      values2.push(parsedValue);
    } else {
      indexes.number.push(i);
      types.push(NUMBER_TOKEN);
      values2.push(parseFloat(parsedValue));
    }
    ++i;
    return SPLIT_TOKEN;
  });
  const split2 = tokenised.split(SPLIT_TOKEN);
  return { values: values2, split: split2, indexes, types };
}
__name(analyseComplexValue, "analyseComplexValue");
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
__name(parseComplexValue, "parseComplexValue");
function createTransformer(source) {
  const { split: split2, types } = analyseComplexValue(source);
  const numSections = split2.length;
  return (v2) => {
    let output = "";
    for (let i = 0; i < numSections; i++) {
      output += split2[i];
      if (v2[i] !== void 0) {
        const type = types[i];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v2[i]);
        } else if (type === COLOR_TOKEN) {
          output += color.transform(v2[i]);
        } else {
          output += v2[i];
        }
      }
    }
    return output;
  };
}
__name(createTransformer, "createTransformer");
const convertNumbersToZero = /* @__PURE__ */ __name((v2) => typeof v2 === "number" ? 0 : v2, "convertNumbersToZero");
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
__name(getAnimatableNone$1, "getAnimatableNone$1");
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
__name(applyDefaultFilter, "applyDefaultFilter");
const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
const filter$1 = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter: filter$1,
  WebkitFilter: filter$1
};
const getDefaultValueType = /* @__PURE__ */ __name((key) => defaultValueTypes[key], "getDefaultValueType");
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter$1)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
__name(getAnimatableNone, "getAnimatableNone");
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i = 0;
  let animatableTemplate = void 0;
  while (i < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i];
    }
    i++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
    }
  }
}
__name(makeNoneKeyframesAnimatable, "makeNoneKeyframesAnimatable");
const _DOMKeyframesResolver = class _DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.owner, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element.current)
      return;
    super.readKeyframes();
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      const keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string" && isCSSVariableToken(keyframe)) {
        const resolved = getVariableValue(keyframe, element.current);
        if (resolved !== void 0) {
          unresolvedKeyframes[i] = resolved;
        }
        if (i === unresolvedKeyframes.length - 1) {
          this.finalKeyframe = keyframe;
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin2, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin2);
    const targetType = findDimensionValueType(target);
    if (originType === targetType)
      return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        const value = unresolvedKeyframes[i];
        if (typeof value === "string") {
          unresolvedKeyframes[i] = parseFloat(value);
        }
      }
    } else {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this;
    const noneKeyframeIndexes = [];
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (isNone(unresolvedKeyframes[i])) {
        noneKeyframeIndexes.push(i);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element.current)
      return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    var _a2;
    const { element, name, unresolvedKeyframes } = this;
    if (!element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if ((_a2 = this.removedTransforms) === null || _a2 === void 0 ? void 0 : _a2.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
};
__name(_DOMKeyframesResolver, "DOMKeyframesResolver");
let DOMKeyframesResolver = _DOMKeyframesResolver;
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
__name(memo, "memo");
const isAnimatable = /* @__PURE__ */ __name((value, name) => {
  if (name === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
}, "isAnimatable");
function hasKeyframesChanged(keyframes3) {
  const current = keyframes3[0];
  if (keyframes3.length === 1)
    return true;
  for (let i = 0; i < keyframes3.length; i++) {
    if (keyframes3[i] !== current)
      return true;
  }
}
__name(hasKeyframesChanged, "hasKeyframesChanged");
function canAnimate(keyframes3, name, type, velocity) {
  const originKeyframe = keyframes3[0];
  if (originKeyframe === null)
    return false;
  if (name === "display" || name === "visibility")
    return true;
  const targetKeyframe = keyframes3[keyframes3.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes3) || type === "spring" && velocity;
}
__name(canAnimate, "canAnimate");
const _BaseAnimation = class _BaseAnimation {
  constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
    this.isStopped = false;
    this.hasAttemptedResolve = false;
    this.options = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      ...options
    };
    this.updateFinishedPromise();
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    if (!this._resolved && !this.hasAttemptedResolve) {
      flushKeyframeResolvers();
    }
    return this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(keyframes3, finalKeyframe) {
    this.hasAttemptedResolve = true;
    const { name, type, velocity, delay: delay2, onComplete, onUpdate, isGenerator } = this.options;
    if (!isGenerator && !canAnimate(keyframes3, name, type, velocity)) {
      if (!delay2) {
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes3, this.options, finalKeyframe));
        onComplete === null || onComplete === void 0 ? void 0 : onComplete();
        this.resolveFinishedPromise();
        return;
      } else {
        this.options.duration = 0;
      }
    }
    const resolvedAnimation = this.initPlayback(keyframes3, finalKeyframe);
    if (resolvedAnimation === false)
      return;
    this._resolved = {
      keyframes: keyframes3,
      finalKeyframe,
      ...resolvedAnimation
    };
    this.onPostResolved();
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.currentFinishedPromise.then(resolve, reject);
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((resolve) => {
      this.resolveFinishedPromise = resolve;
    });
  }
};
__name(_BaseAnimation, "BaseAnimation");
let BaseAnimation = _BaseAnimation;
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
__name(velocityPerSecond, "velocityPerSecond");
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
__name(calcGeneratorVelocity, "calcGeneratorVelocity");
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration$1 = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration: duration2 = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp$2(minDamping, maxDamping, dampingRatio);
  duration2 = clamp$2(minDuration, maxDuration$1, millisecondsToSeconds(duration2));
  if (dampingRatio < 1) {
    envelope = /* @__PURE__ */ __name((undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration2;
      const a = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a / b2 * c2;
    }, "envelope");
    derivative = /* @__PURE__ */ __name((undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration2;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration2;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    }, "derivative");
  } else {
    envelope = /* @__PURE__ */ __name((undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration2);
      const b2 = (undampedFreq2 - velocity) * duration2 + 1;
      return -safeMin + a * b2;
    }, "envelope");
    derivative = /* @__PURE__ */ __name((undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration2);
      const b2 = (velocity - undampedFreq2) * (duration2 * duration2);
      return a * b2;
    }, "derivative");
  }
  const initialGuess = 5 / duration2;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration2 = secondsToMilliseconds(duration2);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration: duration2
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration: duration2
    };
  }
}
__name(findSpring, "findSpring");
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
__name(approximateRoot, "approximateRoot");
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
__name(calcAngularFreq, "calcAngularFreq");
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
__name(isSpringType, "isSpringType");
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      mass: 1
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
__name(getSpringOptions, "getSpringOptions");
function spring({ keyframes: keyframes3, restDelta, restSpeed, ...options }) {
  const origin2 = keyframes3[0];
  const target = keyframes3[keyframes3.length - 1];
  const state = { done: false, value: origin2 };
  const { stiffness, damping, mass, duration: duration2, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin2;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
  restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = /* @__PURE__ */ __name((t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    }, "resolveSpring");
  } else if (dampingRatio === 1) {
    resolveSpring = /* @__PURE__ */ __name((t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2), "resolveSpring");
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = /* @__PURE__ */ __name((t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      const freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    }, "resolveSpring");
  }
  return {
    calculatedDuration: isResolvedFromDuration ? duration2 || null : null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = initialVelocity;
        if (t2 !== 0) {
          if (dampingRatio < 1) {
            currentVelocity = calcGeneratorVelocity(resolveSpring, t2, current);
          } else {
            currentVelocity = 0;
          }
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration2;
      }
      state.value = state.done ? target : current;
      return state;
    }
  };
}
__name(spring, "spring");
function inertia({ keyframes: keyframes3, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin2 = keyframes3[0];
  const state = {
    done: false,
    value: origin2
  };
  const isOutOfBounds = /* @__PURE__ */ __name((v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2, "isOutOfBounds");
  const nearestBoundary = /* @__PURE__ */ __name((v2) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  }, "nearestBoundary");
  let amplitude = power * velocity;
  const ideal = origin2 + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin2;
  const calcDelta = /* @__PURE__ */ __name((t2) => -amplitude * Math.exp(-t2 / timeConstant), "calcDelta");
  const calcLatest = /* @__PURE__ */ __name((t2) => target + calcDelta(t2), "calcLatest");
  const applyFriction = /* @__PURE__ */ __name((t2) => {
    const delta = calcDelta(t2);
    const latest = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  }, "applyFriction");
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = /* @__PURE__ */ __name((t2) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t2;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  }, "checkCatchBoundary");
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t2);
        checkCatchBoundary(t2);
      }
      if (timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary) {
        return spring$1.next(t2 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t2);
        return state;
      }
    }
  };
}
__name(inertia, "inertia");
const calcBezier = /* @__PURE__ */ __name((t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2, "calcBezier");
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
__name(binarySubdivide, "binarySubdivide");
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$3;
  const getTForX = /* @__PURE__ */ __name((aX) => binarySubdivide(aX, 0, 1, mX1, mX2), "getTForX");
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
__name(cubicBezier, "cubicBezier");
const easeIn = cubicBezier(0.42, 0, 1, 1);
const easeOut = cubicBezier(0, 0, 0.58, 1);
const easeInOut = cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = /* @__PURE__ */ __name((ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
}, "isEasingArray");
const mirrorEasing = /* @__PURE__ */ __name((easing2) => (p2) => p2 <= 0.5 ? easing2(2 * p2) / 2 : (2 - easing2(2 * (1 - p2))) / 2, "mirrorEasing");
const reverseEasing = /* @__PURE__ */ __name((easing2) => (p2) => 1 - easing2(1 - p2), "reverseEasing");
const circIn = /* @__PURE__ */ __name((p2) => 1 - Math.sin(Math.acos(p2)), "circIn");
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circIn);
const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = reverseEasing(backOut);
const backInOut = mirrorEasing(backIn);
const anticipate = /* @__PURE__ */ __name((p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1))), "anticipate");
const easingLookup = {
  linear: noop$3,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = /* @__PURE__ */ __name((definition) => {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0);
    return easingLookup[definition];
  }
  return definition;
}, "easingDefinitionToFunction");
const progress = /* @__PURE__ */ __name((from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
}, "progress");
const mixNumber$1 = /* @__PURE__ */ __name((from2, to, progress2) => {
  return from2 + (to - from2) * progress2;
}, "mixNumber$1");
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
__name(hueToRgb, "hueToRgb");
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red2 = 0;
  let green2 = 0;
  let blue2 = 0;
  if (!saturation) {
    red2 = green2 = blue2 = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red2 = hueToRgb(p2, q2, hue + 1 / 3);
    green2 = hueToRgb(p2, q2, hue);
    blue2 = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red2 * 255),
    green: Math.round(green2 * 255),
    blue: Math.round(blue2 * 255),
    alpha: alpha2
  };
}
__name(hslaToRgba, "hslaToRgba");
const mixLinearColor = /* @__PURE__ */ __name((from2, to, v2) => {
  const fromExpo = from2 * from2;
  const expo = v2 * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
}, "mixLinearColor");
const colorTypes = [hex, rgba, hsla];
const getColorType = /* @__PURE__ */ __name((v2) => colorTypes.find((type) => type.test(v2)), "getColorType");
function asRGBA(color2) {
  const type = getColorType(color2);
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
__name(asRGBA, "asRGBA");
const mixColor = /* @__PURE__ */ __name((from2, to) => {
  const fromRGBA = asRGBA(from2);
  const toRGBA = asRGBA(to);
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba.transform(blended);
  };
}, "mixColor");
const invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin2, target) {
  if (invisibleValues.has(origin2)) {
    return (p2) => p2 <= 0 ? origin2 : target;
  } else {
    return (p2) => p2 >= 1 ? target : origin2;
  }
}
__name(mixVisibility, "mixVisibility");
function mixImmediate(a, b2) {
  return (p2) => p2 > 0 ? b2 : a;
}
__name(mixImmediate, "mixImmediate");
function mixNumber(a, b2) {
  return (p2) => mixNumber$1(a, b2, p2);
}
__name(mixNumber, "mixNumber");
function getMixer(a) {
  if (typeof a === "number") {
    return mixNumber;
  } else if (typeof a === "string") {
    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
  } else if (Array.isArray(a)) {
    return mixArray;
  } else if (typeof a === "object") {
    return color.test(a) ? mixColor : mixObject;
  }
  return mixImmediate;
}
__name(getMixer, "getMixer");
function mixArray(a, b2) {
  const output = [...a];
  const numValues = output.length;
  const blendValue = a.map((v2, i) => getMixer(v2)(v2, b2[i]));
  return (p2) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](p2);
    }
    return output;
  };
}
__name(mixArray, "mixArray");
function mixObject(a, b2) {
  const output = { ...a, ...b2 };
  const blendValue = {};
  for (const key in output) {
    if (a[key] !== void 0 && b2[key] !== void 0) {
      blendValue[key] = getMixer(a[key])(a[key], b2[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v2);
    }
    return output;
  };
}
__name(mixObject, "mixObject");
function matchOrder(origin2, target) {
  var _a2;
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < target.values.length; i++) {
    const type = target.types[i];
    const originIndex = origin2.indexes[type][pointers[type]];
    const originValue = (_a2 = origin2.values[originIndex]) !== null && _a2 !== void 0 ? _a2 : 0;
    orderedOrigin[i] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
__name(matchOrder, "matchOrder");
const mixComplex = /* @__PURE__ */ __name((origin2, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin2);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin2) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin2, target);
    }
    return pipe$1(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    return mixImmediate(origin2, target);
  }
}, "mixComplex");
function mix(from2, to, p2) {
  if (typeof from2 === "number" && typeof to === "number" && typeof p2 === "number") {
    return mixNumber$1(from2, to, p2);
  }
  const mixer = getMixer(from2);
  return mixer(from2, to);
}
__name(mix, "mix");
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || mix;
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i] || noop$3 : ease2;
      mixer = pipe$1(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
__name(createMixers, "createMixers");
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length);
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && input[0] === input[1])
    return () => output[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = /* @__PURE__ */ __name((v2) => {
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v2 < input[i + 1])
          break;
      }
    }
    const progressInRange = progress(input[i], input[i + 1], v2);
    return mixers[i](progressInRange);
  }, "interpolator");
  return isClamp ? (v2) => interpolator(clamp$2(input[0], input[inputLength - 1], v2)) : interpolator;
}
__name(interpolate, "interpolate");
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = progress(0, remaining, i);
    offset2.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
__name(fillOffset, "fillOffset");
function defaultOffset(arr) {
  const offset2 = [0];
  fillOffset(offset2, arr.length - 1);
  return offset2;
}
__name(defaultOffset, "defaultOffset");
function convertOffsetToTimes(offset2, duration2) {
  return offset2.map((o) => o * duration2);
}
__name(convertOffsetToTimes, "convertOffsetToTimes");
function defaultEasing(values2, easing2) {
  return values2.map(() => easing2 || easeInOut).splice(0, values2.length - 1);
}
__name(defaultEasing, "defaultEasing");
function keyframes2({ duration: duration2 = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration2
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration2,
    next: (t2) => {
      state.value = mapTimeToKeyframe(t2);
      state.done = t2 >= duration2;
      return state;
    }
  };
}
__name(keyframes2, "keyframes");
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration2 = 0;
  const timeStep = 50;
  let state = generator.next(duration2);
  while (!state.done && duration2 < maxGeneratorDuration) {
    duration2 += timeStep;
    state = generator.next(duration2);
  }
  return duration2 >= maxGeneratorDuration ? Infinity : duration2;
}
__name(calcGeneratorDuration, "calcGeneratorDuration");
const frameloopDriver = /* @__PURE__ */ __name((update) => {
  const passTimestamp = /* @__PURE__ */ __name(({ timestamp }) => update(timestamp), "passTimestamp");
  return {
    start: () => frame.update(passTimestamp, true),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
}, "frameloopDriver");
const generators = {
  decay: inertia,
  inertia,
  tween: keyframes2,
  keyframes: keyframes2,
  spring
};
const percentToProgress = /* @__PURE__ */ __name((percent2) => percent2 / 100, "percentToProgress");
const _MainThreadAnimation = class _MainThreadAnimation extends BaseAnimation {
  constructor({ KeyframeResolver: KeyframeResolver$1 = KeyframeResolver, ...options }) {
    super(options);
    this.holdTime = null;
    this.startTime = null;
    this.cancelTime = null;
    this.currentTime = 0;
    this.playbackSpeed = 1;
    this.pendingPlayState = "running";
    this.state = "idle";
    this.stop = () => {
      this.resolver.cancel();
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      const { onStop } = this.options;
      onStop && onStop();
    };
    const { name, motionValue: motionValue2, keyframes: keyframes22 } = this.options;
    const onResolved = /* @__PURE__ */ __name((resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), "onResolved");
    if (name && motionValue2 && motionValue2.owner) {
      this.resolver = motionValue2.owner.resolveKeyframes(keyframes22, onResolved, name, motionValue2);
    } else {
      this.resolver = new KeyframeResolver$1(keyframes22, onResolved, name, motionValue2);
    }
    this.resolver.scheduleResolve();
  }
  initPlayback(keyframes$12) {
    const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;
    const generatorFactory = generators[type] || keyframes2;
    let mapPercentToKeyframes;
    let mirroredGenerator;
    if (generatorFactory !== keyframes2 && typeof keyframes$12[0] !== "number") {
      mapPercentToKeyframes = pipe$1(percentToProgress, mix(keyframes$12[0], keyframes$12[1]));
      keyframes$12 = [0, 100];
    }
    const generator = generatorFactory({ ...this.options, keyframes: keyframes$12 });
    if (repeatType === "mirror") {
      mirroredGenerator = generatorFactory({
        ...this.options,
        keyframes: [...keyframes$12].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    const resolvedDuration = calculatedDuration + repeatDelay;
    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    return {
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      calculatedDuration,
      resolvedDuration,
      totalDuration
    };
  }
  onPostResolved() {
    const { autoplay = true } = this.options;
    this.play();
    if (this.pendingPlayState === "paused" || !autoplay) {
      this.pause();
    } else {
      this.state = this.pendingPlayState;
    }
  }
  tick(timestamp, sample = false) {
    const { resolved } = this;
    if (!resolved) {
      const { keyframes: keyframes3 } = this.options;
      return { done: true, value: keyframes3[keyframes3.length - 1] };
    }
    const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes22, calculatedDuration, totalDuration, resolvedDuration } = resolved;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
    }
    const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1);
    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp$2(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes22[0] } : frameGenerator.next(elapsed);
    if (mapPercentToKeyframes) {
      state.value = mapPercentToKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && finalKeyframe !== void 0) {
      state.value = getFinalKeyframe(keyframes22, this.options, finalKeyframe);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  get duration() {
    const { resolved } = this;
    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
  }
  get time() {
    return millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.holdTime !== null || this.speed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.speed;
    }
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    if (!this.resolver.isScheduled) {
      this.resolver.resume();
    }
    if (!this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, onPlay } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    onPlay && onPlay();
    const now2 = this.driver.now();
    if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime || this.state === "finished") {
      this.startTime = now2;
    }
    if (this.state === "finished") {
      this.updateFinishedPromise();
    }
    this.cancelTime = this.startTime;
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    var _a2;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused";
    this.holdTime = (_a2 = this.currentTime) !== null && _a2 !== void 0 ? _a2 : 0;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.pendingPlayState = this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    this.teardown();
    this.state = "finished";
    const { onComplete } = this.options;
    onComplete && onComplete();
  }
  cancel() {
    if (this.cancelTime !== null) {
      this.tick(this.cancelTime);
    }
    this.teardown();
    this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    this.startTime = this.cancelTime = null;
    this.resolver.cancel();
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(time2) {
    this.startTime = 0;
    return this.tick(time2, true);
  }
};
__name(_MainThreadAnimation, "MainThreadAnimation");
let MainThreadAnimation = _MainThreadAnimation;
const isBezierDefinition = /* @__PURE__ */ __name((easing2) => Array.isArray(easing2) && typeof easing2[0] === "number", "isBezierDefinition");
function isWaapiSupportedEasing(easing2) {
  return Boolean(!easing2 || typeof easing2 === "string" && easing2 in supportedWaapiEasing || isBezierDefinition(easing2) || Array.isArray(easing2) && easing2.every(isWaapiSupportedEasing));
}
__name(isWaapiSupportedEasing, "isWaapiSupportedEasing");
const cubicBezierAsString = /* @__PURE__ */ __name(([a, b2, c2, d2]) => `cubic-bezier(${a}, ${b2}, ${c2}, ${d2})`, "cubicBezierAsString");
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasingWithDefault(easing2) {
  return mapEasingToNativeEasing(easing2) || supportedWaapiEasing.easeOut;
}
__name(mapEasingToNativeEasingWithDefault, "mapEasingToNativeEasingWithDefault");
function mapEasingToNativeEasing(easing2) {
  if (!easing2) {
    return void 0;
  } else if (isBezierDefinition(easing2)) {
    return cubicBezierAsString(easing2);
  } else if (Array.isArray(easing2)) {
    return easing2.map(mapEasingToNativeEasingWithDefault);
  } else {
    return supportedWaapiEasing[easing2];
  }
}
__name(mapEasingToNativeEasing, "mapEasingToNativeEasing");
function animateStyle(element, valueName, keyframes3, { delay: delay2 = 0, duration: duration2 = 300, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
  const keyframeOptions = { [valueName]: keyframes3 };
  if (times)
    keyframeOptions.offset = times;
  const easing2 = mapEasingToNativeEasing(ease2);
  if (Array.isArray(easing2))
    keyframeOptions.easing = easing2;
  return element.animate(keyframeOptions, {
    delay: delay2,
    duration: duration2,
    easing: !Array.isArray(easing2) ? easing2 : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
__name(animateStyle, "animateStyle");
const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]);
const sampleDelta = 10;
const maxDuration = 2e4;
function requiresPregeneratedKeyframes(options) {
  return options.type === "spring" || options.name === "backgroundColor" || !isWaapiSupportedEasing(options.ease);
}
__name(requiresPregeneratedKeyframes, "requiresPregeneratedKeyframes");
function pregenerateKeyframes(keyframes3, options) {
  const sampleAnimation = new MainThreadAnimation({
    ...options,
    keyframes: keyframes3,
    repeat: 0,
    delay: 0,
    isGenerator: true
  });
  let state = { done: false, value: keyframes3[0] };
  const pregeneratedKeyframes = [];
  let t2 = 0;
  while (!state.done && t2 < maxDuration) {
    state = sampleAnimation.sample(t2);
    pregeneratedKeyframes.push(state.value);
    t2 += sampleDelta;
  }
  return {
    times: void 0,
    keyframes: pregeneratedKeyframes,
    duration: t2 - sampleDelta,
    ease: "linear"
  };
}
__name(pregenerateKeyframes, "pregenerateKeyframes");
const _AcceleratedAnimation = class _AcceleratedAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    const { name, motionValue: motionValue2, keyframes: keyframes3 } = this.options;
    this.resolver = new DOMKeyframesResolver(keyframes3, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2);
    this.resolver.scheduleResolve();
  }
  initPlayback(keyframes3, finalKeyframe) {
    var _a2;
    let { duration: duration2 = 300, times, ease: ease2, type, motionValue: motionValue2, name } = this.options;
    if (!((_a2 = motionValue2.owner) === null || _a2 === void 0 ? void 0 : _a2.current)) {
      return false;
    }
    if (requiresPregeneratedKeyframes(this.options)) {
      const { onComplete, onUpdate, motionValue: motionValue3, ...options } = this.options;
      const pregeneratedAnimation = pregenerateKeyframes(keyframes3, options);
      keyframes3 = pregeneratedAnimation.keyframes;
      if (keyframes3.length === 1) {
        keyframes3[1] = keyframes3[0];
      }
      duration2 = pregeneratedAnimation.duration;
      times = pregeneratedAnimation.times;
      ease2 = pregeneratedAnimation.ease;
      type = "keyframes";
    }
    const animation = animateStyle(motionValue2.owner.current, name, keyframes3, { ...this.options, duration: duration2, times, ease: ease2 });
    animation.startTime = time.now();
    if (this.pendingTimeline) {
      animation.timeline = this.pendingTimeline;
      this.pendingTimeline = void 0;
    } else {
      animation.onfinish = () => {
        const { onComplete } = this.options;
        motionValue2.set(getFinalKeyframe(keyframes3, this.options, finalKeyframe));
        onComplete && onComplete();
        this.cancel();
        this.resolveFinishedPromise();
      };
    }
    return {
      animation,
      duration: duration2,
      times,
      type,
      ease: ease2,
      keyframes: keyframes3
    };
  }
  get duration() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { duration: duration2 } = resolved;
    return millisecondsToSeconds(duration2);
  }
  get time() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { animation } = resolved;
    return millisecondsToSeconds(animation.currentTime || 0);
  }
  set time(newTime) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.currentTime = secondsToMilliseconds(newTime);
  }
  get speed() {
    const { resolved } = this;
    if (!resolved)
      return 1;
    const { animation } = resolved;
    return animation.playbackRate;
  }
  set speed(newSpeed) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.playbackRate = newSpeed;
  }
  get state() {
    const { resolved } = this;
    if (!resolved)
      return "idle";
    const { animation } = resolved;
    return animation.playState;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(timeline) {
    if (!this._resolved) {
      this.pendingTimeline = timeline;
    } else {
      const { resolved } = this;
      if (!resolved)
        return noop$3;
      const { animation } = resolved;
      animation.timeline = timeline;
      animation.onfinish = null;
    }
    return noop$3;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    if (animation.playState === "finished") {
      this.updateFinishedPromise();
    }
    animation.play();
  }
  pause() {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.pause();
  }
  stop() {
    this.resolver.cancel();
    this.isStopped = true;
    if (this.state === "idle")
      return;
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation, keyframes: keyframes3, duration: duration2, type, ease: ease2, times } = resolved;
    if (animation.playState === "idle" || animation.playState === "finished") {
      return;
    }
    if (this.time) {
      const { motionValue: motionValue2, onUpdate, onComplete, ...options } = this.options;
      const sampleAnimation = new MainThreadAnimation({
        ...options,
        keyframes: keyframes3,
        duration: duration2,
        type,
        ease: ease2,
        times,
        isGenerator: true
      });
      const sampleTime = secondsToMilliseconds(this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    }
    this.cancel();
  }
  complete() {
    const { resolved } = this;
    if (!resolved)
      return;
    resolved.animation.finish();
  }
  cancel() {
    const { resolved } = this;
    if (!resolved)
      return;
    resolved.animation.cancel();
  }
  static supports(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue2 && motionValue2.owner && motionValue2.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !motionValue2.owner.getProps().onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }
};
__name(_AcceleratedAnimation, "AcceleratedAnimation");
let AcceleratedAnimation = _AcceleratedAnimation;
const animateMotionValue = /* @__PURE__ */ __name((name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay2);
  let options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v2) => {
      value.set(v2);
      valueTransition.onUpdate && valueTransition.onUpdate(v2);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    options = {
      ...options,
      ...getDefaultTransition(name, options)
    };
  }
  if (options.duration) {
    options.duration = secondsToMilliseconds(options.duration);
  }
  if (options.repeatDelay) {
    options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
  }
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    options.duration = 0;
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return;
    }
  }
  if (!isHandoff && AcceleratedAnimation.supports(options)) {
    return new AcceleratedAnimation(options);
  } else {
    return new MainThreadAnimation(options);
  }
}, "animateMotionValue");
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
__name(isWillChangeMotionValue, "isWillChangeMotionValue");
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
__name(addUniqueItem, "addUniqueItem");
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1)
    arr.splice(index2, 1);
}
__name(removeItem, "removeItem");
const _SubscriptionManager = class _SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b2, c2);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};
__name(_SubscriptionManager, "SubscriptionManager");
let SubscriptionManager = _SubscriptionManager;
const MAX_VELOCITY_DELTA = 30;
const isFloat = /* @__PURE__ */ __name((value) => {
  return !isNaN(parseFloat(value));
}, "isFloat");
const _MotionValue = class _MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init2, options = {}) {
    this.version = "11.2.6";
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v2, render = true) => {
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v2);
      if (this.current !== this.prev && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init2);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v2, render);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev2, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev2;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2, endAnimation = true) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
};
__name(_MotionValue, "MotionValue");
let MotionValue = _MotionValue;
function motionValue(init2, options) {
  return new MotionValue(init2, options);
}
__name(motionValue, "motionValue");
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
__name(setMotionValue, "setMotionValue");
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
__name(setTarget, "setTarget");
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
__name(shouldBlockAnimation, "shouldBlockAnimation");
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  var _a2;
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  const willChange = visualElement.getValue("willChange");
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, (_a2 = visualElement.latestValues[key]) !== null && _a2 !== void 0 ? _a2 : null);
    const valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      elapsed: 0,
      ...getValueTransition(transition || {}, key)
    };
    let isHandoff = false;
    if (window.HandoffAppearAnimations) {
      const props = visualElement.getProps();
      const appearId = props[optimizedAppearDataAttribute];
      if (appearId) {
        const elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);
        if (elapsed !== null) {
          valueTransition.elapsed = elapsed;
          isHandoff = true;
        }
      }
    }
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
        animation.then(() => willChange.remove(key));
      }
      animations2.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}
__name(animateTarget, "animateTarget");
function animateVariant(visualElement, variant, options = {}) {
  var _a2;
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a2 = visualElement.presenceContext) === null || _a2 === void 0 ? void 0 : _a2.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last2] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last2());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
__name(animateVariant, "animateVariant");
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
__name(animateChildren, "animateChildren");
function sortByTreeOrder(a, b2) {
  return a.sortNodePosition(b2);
}
__name(sortByTreeOrder, "sortByTreeOrder");
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    frame.postRender(() => {
      visualElement.notify("AnimationComplete", definition);
    });
  });
}
__name(animateVisualElement, "animateVisualElement");
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
__name(animateList, "animateList");
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  const state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = /* @__PURE__ */ __name((type) => (acc, definition) => {
    var _a2;
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a2 = visualElement.presenceContext) === null || _a2 === void 0 ? void 0 : _a2.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  }, "buildResolvedTypeValues");
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  __name(setAnimateFunction, "setAnimateFunction");
  function animateChanges(changedActiveType) {
    const props = visualElement.getProps();
    const context = visualElement.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = /* @__PURE__ */ __name((key) => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = false;
      }, "markToAnimate");
      for (const key in allKeys) {
        const next2 = resolvedValues[key];
        const prev2 = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
          valueHasChanged = !shallowCompare(next2, prev2);
        } else {
          valueHasChanged = next2 !== prev2;
        }
        if (valueHasChanged) {
          if (next2 !== void 0 && next2 !== null) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next2 !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && (!isInherited || handledRemovedValues)) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  __name(animateChanges, "animateChanges");
  function setActive(type, isActive) {
    var _a2;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a2 = visualElement.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.forEach((child) => {
      var _a3;
      return (_a3 = child.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  __name(setActive, "setActive");
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state
  };
}
__name(createAnimationState, "createAnimationState");
function checkVariantsDidChange(prev2, next2) {
  if (typeof next2 === "string") {
    return next2 !== prev2;
  } else if (Array.isArray(next2)) {
    return !shallowCompare(next2, prev2);
  }
  return false;
}
__name(checkVariantsDidChange, "checkVariantsDidChange");
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
__name(createTypeState, "createTypeState");
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
__name(createState, "createState");
const _AnimationFeature = class _AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2);
    node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    this.unmount();
    if (isAnimationControls(animate)) {
      this.unmount = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
  }
};
__name(_AnimationFeature, "AnimationFeature");
let AnimationFeature = _AnimationFeature;
let id$2 = 0;
const _ExitAnimationFeature = class _ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$2++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => onExitComplete(this.id));
    }
  }
  mount() {
    const { register } = this.node.presenceContext || {};
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
};
__name(_ExitAnimationFeature, "ExitAnimationFeature");
let ExitAnimationFeature = _ExitAnimationFeature;
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
const distance = /* @__PURE__ */ __name((a, b2) => Math.abs(a - b2), "distance");
function distance2D(a, b2) {
  const xDelta = distance(a.x, b2.x);
  const yDelta = distance(a.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
__name(distance2D, "distance2D");
const _PanSession = class _PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin)
        resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe$1(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
};
__name(_PanSession, "PanSession");
let PanSession = _PanSession;
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
__name(transformPoint, "transformPoint");
function subtractPoint(a, b2) {
  return { x: a.x - b2.x, y: a.y - b2.y };
}
__name(subtractPoint, "subtractPoint");
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
__name(getPanInfo, "getPanInfo");
function startDevicePoint(history) {
  return history[0];
}
__name(startDevicePoint, "startDevicePoint");
function lastDevicePoint(history) {
  return history[history.length - 1];
}
__name(lastDevicePoint, "lastDevicePoint");
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
__name(getVelocity, "getVelocity");
function calcLength(axis) {
  return axis.max - axis.min;
}
__name(calcLength, "calcLength");
function isNear(value, target = 0, maxDistance = 0.01) {
  return Math.abs(value - target) <= maxDistance;
}
__name(isNear, "isNear");
function calcAxisDelta(delta, source, target, origin2 = 0.5) {
  delta.origin = origin2;
  delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
__name(calcAxisDelta, "calcAxisDelta");
function calcBoxDelta(delta, source, target, origin2) {
  calcAxisDelta(delta.x, source.x, target.x, origin2 ? origin2.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin2 ? origin2.originY : void 0);
}
__name(calcBoxDelta, "calcBoxDelta");
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
__name(calcRelativeAxis, "calcRelativeAxis");
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
__name(calcRelativeBox, "calcRelativeBox");
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
__name(calcRelativeAxisPosition, "calcRelativeAxisPosition");
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
__name(calcRelativePosition, "calcRelativePosition");
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mixNumber$1(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mixNumber$1(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
__name(applyConstraints, "applyConstraints");
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
__name(calcRelativeAxisConstraints, "calcRelativeAxisConstraints");
function calcRelativeConstraints(layoutBox, { top: top2, left: left2, bottom: bottom2, right: right2 }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left2, right2),
    y: calcRelativeAxisConstraints(layoutBox.y, top2, bottom2)
  };
}
__name(calcRelativeConstraints, "calcRelativeConstraints");
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
__name(calcViewportAxisConstraints, "calcViewportAxisConstraints");
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
__name(calcViewportConstraints, "calcViewportConstraints");
function calcOrigin(source, target) {
  let origin2 = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin2 = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin2 = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp$2(0, 1, origin2);
}
__name(calcOrigin, "calcOrigin");
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
__name(rebaseAxisConstraints, "rebaseAxisConstraints");
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
__name(resolveDragElastic, "resolveDragElastic");
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
__name(resolveAxisElastic, "resolveAxisElastic");
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
__name(resolvePointElastic, "resolvePointElastic");
const createAxisDelta = /* @__PURE__ */ __name(() => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), "createAxisDelta");
const createDelta = /* @__PURE__ */ __name(() => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), "createDelta");
const createAxis = /* @__PURE__ */ __name(() => ({ min: 0, max: 0 }), "createAxis");
const createBox = /* @__PURE__ */ __name(() => ({
  x: createAxis(),
  y: createAxis()
}), "createBox");
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
__name(eachAxis, "eachAxis");
function convertBoundingBoxToBox({ top: top2, left: left2, right: right2, bottom: bottom2 }) {
  return {
    x: { min: left2, max: right2 },
    y: { min: top2, max: bottom2 }
  };
}
__name(convertBoundingBoxToBox, "convertBoundingBoxToBox");
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
__name(convertBoxToBoundingBox, "convertBoxToBoundingBox");
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
__name(transformBoxPoints, "transformBoxPoints");
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
__name(isIdentityScale, "isIdentityScale");
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
__name(hasScale, "hasScale");
function hasTransform(values2) {
  return hasScale(values2) || has2DTranslate(values2) || values2.z || values2.rotate || values2.rotateX || values2.rotateY || values2.skewX || values2.skewY;
}
__name(hasTransform, "hasTransform");
function has2DTranslate(values2) {
  return is2DTranslate(values2.x) || is2DTranslate(values2.y);
}
__name(has2DTranslate, "has2DTranslate");
function is2DTranslate(value) {
  return value && value !== "0%";
}
__name(is2DTranslate, "is2DTranslate");
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
__name(scalePoint, "scalePoint");
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
__name(applyPointDelta, "applyPointDelta");
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
__name(applyAxisDelta, "applyAxisDelta");
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
__name(applyBoxDelta, "applyBoxDelta");
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node2 = treePath[i];
    delta = node2.projectionDelta;
    const instance = node2.instance;
    if (instance && instance.style && instance.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
      transformBox(box, {
        x: -node2.scroll.offset.x,
        y: -node2.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node2.latestValues)) {
      transformBox(box, node2.latestValues);
    }
  }
  treeScale.x = snapToDefault(treeScale.x);
  treeScale.y = snapToDefault(treeScale.y);
}
__name(applyTreeDeltas, "applyTreeDeltas");
function snapToDefault(scale2) {
  if (Number.isInteger(scale2))
    return scale2;
  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
__name(snapToDefault, "snapToDefault");
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
__name(translateAxis, "translateAxis");
function transformAxis(axis, transforms, [key, scaleKey, originKey]) {
  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
__name(transformAxis, "transformAxis");
const xKeys$1 = ["x", "scaleX", "originX"];
const yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box, transform) {
  transformAxis(box.x, transform, xKeys$1);
  transformAxis(box.y, transform, yKeys$1);
}
__name(transformBox, "transformBox");
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
__name(measureViewportBox, "measureViewportBox");
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
__name(measurePageBox, "measurePageBox");
const getContextWindow = /* @__PURE__ */ __name(({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
}, "getContextWindow");
const elementDragControls = /* @__PURE__ */ new WeakMap();
const _VisualElementDragControls = class _VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = /* @__PURE__ */ __name((event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    }, "onSessionStart");
    const onStart = /* @__PURE__ */ __name((event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length2 = calcLength(measuredAxis);
              current = length2 * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    }, "onStart");
    const onMove = /* @__PURE__ */ __name((event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    }, "onMove");
    const onSessionEnd = /* @__PURE__ */ __name((event, info) => this.stop(event, info), "onSessionEnd");
    const resumeAnimation = /* @__PURE__ */ __name(() => eachAxis((axis) => {
      var _a2;
      return this.getAnimationState(axis) === "paused" && ((_a2 = this.getAxisMotionValue(axis).animation) === null || _a2 === void 0 ? void 0 : _a2.play());
    }), "resumeAnimation");
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next2 = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next2);
  }
  resolveConstraints() {
    var _a2;
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a2 = this.visualElement.projection) === null || _a2 === void 0 ? void 0 : _a2.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a2;
      return (_a2 = this.getAxisMotionValue(axis).animation) === null || _a2 === void 0 ? void 0 : _a2.pause();
    });
  }
  getAnimationState(axis) {
    var _a2;
    return (_a2 = this.getAxisMotionValue(axis).animation) === null || _a2 === void 0 ? void 0 : _a2.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mixNumber$1(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = /* @__PURE__ */ __name(() => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    }, "measureDragConstraints");
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
};
__name(_VisualElementDragControls, "VisualElementDragControls");
let VisualElementDragControls = _VisualElementDragControls;
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
__name(shouldDrag, "shouldDrag");
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
__name(getCurrentDirection, "getCurrentDirection");
const _DragGesture = class _DragGesture extends Feature {
  constructor(node2) {
    super(node2);
    this.removeGroupControls = noop$3;
    this.removeListeners = noop$3;
    this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop$3;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
};
__name(_DragGesture, "DragGesture");
let DragGesture = _DragGesture;
const asyncHandler = /* @__PURE__ */ __name((handler) => (event, info) => {
  if (handler) {
    frame.postRender(() => handler(event, info));
  }
}, "asyncHandler");
const _PanGesture = class _PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop$3;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
};
__name(_PanGesture, "PanGesture");
let PanGesture = _PanGesture;
function usePresence() {
  const context = reactExports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => register(id2), []);
  const safeToRemove = /* @__PURE__ */ __name(() => onExitComplete && onExitComplete(id2), "safeToRemove");
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
__name(usePresence, "usePresence");
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
__name(pixelsToPercent, "pixelsToPercent");
const correctBorderRadius = {
  correct: (latest, node2) => {
    if (!node2.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node2.target.x);
    const y2 = pixelsToPercent(latest, node2.target.y);
    return `${x2}% ${y2}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number")
      shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number")
      shadow[3 + offset2] /= averageScale;
    return template(shadow);
  }
};
const _MeasureLayoutWithContext = class _MeasureLayoutWithContext extends reactExports.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
};
__name(_MeasureLayoutWithContext, "MeasureLayoutWithContext");
let MeasureLayoutWithContext = _MeasureLayoutWithContext;
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
__name(MeasureLayout, "MeasureLayout");
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = /* @__PURE__ */ __name((value) => typeof value === "string" ? parseFloat(value) : value, "asNumber");
const isPx = /* @__PURE__ */ __name((value) => typeof value === "number" || px.test(value), "isPx");
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber$1(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
__name(mixValues, "mixValues");
function getRadius(values2, radiusName) {
  return values2[radiusName] !== void 0 ? values2[radiusName] : values2.borderRadius;
}
__name(getRadius, "getRadius");
const easeCrossfadeIn = compress(0, 0.5, circOut);
const easeCrossfadeOut = compress(0.5, 0.95, noop$3);
function compress(min2, max2, easing2) {
  return (p2) => {
    if (p2 < min2)
      return 0;
    if (p2 > max2)
      return 1;
    return easing2(progress(min2, max2, p2));
  };
}
__name(compress, "compress");
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
__name(copyAxisInto, "copyAxisInto");
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
__name(copyBoxInto, "copyBoxInto");
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
__name(removePointDelta, "removePointDelta");
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin2 = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin2);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
__name(removeAxisDelta, "removeAxisDelta");
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin2, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin2, sourceAxis);
}
__name(removeAxisTransforms, "removeAxisTransforms");
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
__name(removeBoxTransforms, "removeBoxTransforms");
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
__name(isAxisDeltaZero, "isAxisDeltaZero");
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
__name(isDeltaZero, "isDeltaZero");
function boxEquals(a, b2) {
  return a.x.min === b2.x.min && a.x.max === b2.x.max && a.y.min === b2.y.min && a.y.max === b2.y.max;
}
__name(boxEquals, "boxEquals");
function boxEqualsRounded(a, b2) {
  return Math.round(a.x.min) === Math.round(b2.x.min) && Math.round(a.x.max) === Math.round(b2.x.max) && Math.round(a.y.min) === Math.round(b2.y.min) && Math.round(a.y.max) === Math.round(b2.y.max);
}
__name(boxEqualsRounded, "boxEqualsRounded");
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
__name(aspectRatio, "aspectRatio");
const _NodeStack = class _NodeStack {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2);
    node2.scheduleRender();
  }
  remove(node2) {
    removeItem(this.members, node2);
    if (node2 === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node2;
    node2.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node2.scheduleRender();
      node2.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node2.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node2.snapshot = prevLead.snapshot;
        node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node2.root && node2.root.isUpdating) {
        node2.isLayoutDirty = true;
      }
      const { crossfade } = node2.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options, resumingFrom } = node2;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
};
__name(_NodeStack, "NodeStack");
let NodeStack = _NodeStack;
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform = `perspective(${transformPerspective}px) ${transform}`;
    if (rotate)
      transform += `rotate(${rotate}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform += `skewX(${skewX}deg) `;
    if (skewY)
      transform += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
__name(buildProjectionTransform, "buildProjectionTransform");
const compareByDepth = /* @__PURE__ */ __name((a, b2) => a.depth - b2.depth, "compareByDepth");
const _FlatTree = class _FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
};
__name(_FlatTree, "FlatTree");
let FlatTree = _FlatTree;
function delay(callback, timeout) {
  const start2 = time.now();
  const checkElapsed = /* @__PURE__ */ __name(({ timestamp }) => {
    const elapsed = timestamp - start2;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  }, "checkElapsed");
  frame.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
__name(delay, "delay");
function record(data) {
  if (window.MotionDebug) {
    window.MotionDebug.record(data);
  }
}
__name(record, "record");
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
__name(isSVGElement, "isSVGElement");
function animateSingleValue(value, keyframes3, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes3, options));
  return motionValue$1.animation;
}
__name(animateSingleValue, "animateSingleValue");
const transformAxes = ["", "X", "Y", "Z"];
const hiddenVisibility = { visibility: "hidden" };
const animationTarget = 1e3;
let id$1 = 0;
const projectionFrameData = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function resetDistortingTransform(key, visualElement, values2, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values2[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
__name(resetDistortingTransform, "resetDistortingTransform");
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  var _a2;
  return _a2 = class {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id$1++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        record(projectionFrameData);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = /* @__PURE__ */ __name(() => this.root.updateBlockedByResize = false, "resizeUnblockUpdate");
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      if (window.HandoffCancelAllAnimations) {
        window.HandoffCancelAllAnimations();
      }
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        node2.shouldResetTransform = true;
        node2.updateScroll("snapshot");
        if (node2.options.layoutRoot) {
          node2.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp$2(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      steps$1.update.process(frameData);
      steps$1.preRender.process(frameData);
      steps$1.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(() => this.update());
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          node2.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot: checkIsScrollRoot(this.instance),
          offset: measureScroll(this.instance)
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const { scroll } = this.root;
      if (scroll) {
        translateAxis(box.x, scroll.offset.x);
        translateAxis(box.y, scroll.offset.y);
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        const { scroll, options } = node2;
        if (node2 !== this.root && scroll && options.layoutScroll) {
          if (scroll.isRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
          transformBox(withTransforms, {
            x: -node2.scroll.offset.x,
            y: -node2.scroll.offset.y
          });
        }
        if (!hasTransform(node2.latestValues))
          continue;
        transformBox(withTransforms, node2.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        if (!node2.instance)
          continue;
        if (!hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a3;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a3 = this.parent) === null || _a3 === void 0 ? void 0 : _a3.isProjectionDirty) || this.attemptToResolveRelativeTarget);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      projectionFrameData.resolvedTargetDeltas++;
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a3;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a3 = this.parent) === null || _a3 === void 0 ? void 0 : _a3.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.projectionTransform) {
          this.projectionDelta = createDelta();
          this.projectionTransform = "none";
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      projectionFrameData.recalculatedProjection++;
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      this.options.scheduleRender && this.options.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node2) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node2);
      const config2 = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config2 ? config2.transition : void 0,
        preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a3;
      const { layoutId } = this.options;
      return layoutId ? ((_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.lead) || this : this;
    }
    getPrevLead() {
      var _a3;
      const { layoutId } = this.options;
      return layoutId ? (_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i = 0; i < transformAxes.length; i++) {
        resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      var _a3, _b2;
      if (!this.instance || this.isSVG)
        return void 0;
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles2 = {
        visibility: ""
      };
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles2.opacity = "";
        styles2.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        styles2.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles2;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles2.transform = transformTemplate(valuesToRender, styles2.transform);
      }
      const { x: x2, y: y2 } = this.projectionDelta;
      styles2.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles2.opacity = lead === this ? (_b2 = (_a3 = valuesToRender.opacity) !== null && _a3 !== void 0 ? _a3 : this.latestValues.opacity) !== null && _b2 !== void 0 ? _b2 : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles2.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = styles2.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles2[applyTo[i]] = corrected;
          }
        } else {
          styles2[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
      return styles2;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => {
        var _a3;
        return (_a3 = node2.currentAnimation) === null || _a3 === void 0 ? void 0 : _a3.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  }, __name(_a2, "ProjectionNode"), _a2;
}
__name(createProjectionNode, "createProjectionNode");
function updateLayout(node2) {
  node2.updateLayout();
}
__name(updateLayout, "updateLayout");
function notifyLayoutUpdate(node2) {
  var _a2;
  const snapshot = ((_a2 = node2.resumeFrom) === null || _a2 === void 0 ? void 0 : _a2.snapshot) || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout;
    const { animationType } = node2.options;
    const isShared = snapshot.source !== node2.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
        if (node2.relativeTarget && !node2.currentAnimation) {
          node2.isProjectionDirty = true;
          node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node2.relativeTarget = relativeLayout;
            node2.relativeTargetOrigin = relativeSnapshot;
            node2.relativeParent = relativeParent;
          }
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
__name(notifyLayoutUpdate, "notifyLayoutUpdate");
function propagateDirtyNodes(node2) {
  projectionFrameData.totalNodes++;
  if (!node2.parent)
    return;
  if (!node2.isProjecting()) {
    node2.isProjectionDirty = node2.parent.isProjectionDirty;
  }
  node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
  node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
}
__name(propagateDirtyNodes, "propagateDirtyNodes");
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
}
__name(cleanDirtyNodes, "cleanDirtyNodes");
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
__name(clearSnapshot, "clearSnapshot");
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
__name(clearMeasurements, "clearMeasurements");
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = false;
}
__name(clearIsLayoutDirty, "clearIsLayoutDirty");
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node2.resetTransform();
}
__name(resetTransformStyle, "resetTransformStyle");
function finishAnimation(node2) {
  node2.finishAnimation();
  node2.targetDelta = node2.relativeTarget = node2.target = void 0;
  node2.isProjectionDirty = true;
}
__name(finishAnimation, "finishAnimation");
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
__name(resolveTargetDelta, "resolveTargetDelta");
function calcProjection(node2) {
  node2.calcProjection();
}
__name(calcProjection, "calcProjection");
function resetSkewAndRotation(node2) {
  node2.resetSkewAndRotation();
}
__name(resetSkewAndRotation, "resetSkewAndRotation");
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
__name(removeLeadSnapshots, "removeLeadSnapshots");
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber$1(delta.translate, 0, p2);
  output.scale = mixNumber$1(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
__name(mixAxisDelta, "mixAxisDelta");
function mixAxis(output, from2, to, p2) {
  output.min = mixNumber$1(from2.min, to.min, p2);
  output.max = mixNumber$1(from2.max, to.max, p2);
}
__name(mixAxis, "mixAxis");
function mixBox(output, from2, to, p2) {
  mixAxis(output.x, from2.x, to.x, p2);
  mixAxis(output.y, from2.y, to.y, p2);
}
__name(mixBox, "mixBox");
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
__name(hasOpacityCrossfade, "hasOpacityCrossfade");
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const userAgentContains = /* @__PURE__ */ __name((string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string), "userAgentContains");
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$3;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
__name(roundAxis, "roundAxis");
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
__name(roundBox, "roundBox");
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
__name(shouldAnimatePositionOnly, "shouldAnimatePositionOnly");
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser$1)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = /* @__PURE__ */ __name(() => prefersReducedMotion.current = motionMediaQuery.matches, "setReducedMotionPreferences");
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
__name(initPrefersReducedMotion, "initPrefersReducedMotion");
function updateMotionValuesFromProps(element, next2, prev2) {
  const { willChange } = next2;
  for (const key in next2) {
    const nextValue = next2[key];
    const prevValue = prev2[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev2) {
    if (next2[key] === void 0)
      element.removeValue(key);
  }
  return next2;
}
__name(updateMotionValuesFromProps, "updateMotionValuesFromProps");
const visualElementStore = /* @__PURE__ */ new WeakMap();
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = /* @__PURE__ */ __name((v2) => valueTypes.find(testValueType(v2)), "findValueType");
const featureNames = Object.keys(featureDefinitions);
const numFeatures = featureNames.length;
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
const numVariantProps = variantProps.length;
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
__name(getClosestProjectingNode, "getClosestProjectingNode");
const _VisualElement = class _VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.resolveKeyframes = (keyframes3, onComplete, name, value) => {
      return new this.KeyframeResolver(keyframes3, onComplete, name, value, this);
    };
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.scheduleRender = () => frame.render(this.render, false, true);
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key);
        }
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    var _a2;
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove2) => remove2());
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      (_a2 = this.features[key]) === null || _a2 === void 0 ? void 0 : _a2.unmount();
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    const valueIsTransform = transformProps.has(key);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig) {
    let ProjectionNodeConstructor;
    let MeasureLayout2;
    for (let i = 0; i < numFeatures; i++) {
      const name = featureNames[i];
      const { isEnabled: isEnabled2, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name];
      if (ProjectionNode)
        ProjectionNodeConstructor = ProjectionNode;
      if (isEnabled2(renderedProps)) {
        if (!this.features[name] && FeatureConstructor) {
          this.features[name] = new FeatureConstructor(this);
        }
        if (MeasureLayoutComponent) {
          MeasureLayout2 = MeasureLayoutComponent;
        }
      }
    }
    if ((this.type === "html" || this.type === "svg") && !this.projection && ProjectionNodeConstructor) {
      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection = new ProjectionNodeConstructor(this.latestValues, renderedProps["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(this.parent));
      this.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout2 === "string" ? layout2 : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return MeasureLayout2;
  }
  updateFeatures() {
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature.isMounted) {
        feature.update();
      } else {
        feature.mount();
        feature.isMounted = true;
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(startAtParent = false) {
    if (startAtParent) {
      return this.parent ? this.parent.getVariantContext() : void 0;
    }
    if (!this.isControllingVariants) {
      const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
      if (this.props.initial !== void 0) {
        context2.initial = this.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name = variantProps[i];
      const prop = this.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    var _a2;
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a2 = this.getBaseTargetFromProps(this.props, key)) !== null && _a2 !== void 0 ? _a2 : this.readValueFromInstance(this.current, key, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a2;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a2 = this.presenceContext) === null || _a2 === void 0 ? void 0 : _a2.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
};
__name(_VisualElement, "VisualElement");
let VisualElement = _VisualElement;
const _DOMVisualElement = class _DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a, b2) {
    return a.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style: style2 }) {
    delete vars[key];
    delete style2[key];
  }
};
__name(_DOMVisualElement, "DOMVisualElement");
let DOMVisualElement = _DOMVisualElement;
function getComputedStyle$2(element) {
  return window.getComputedStyle(element);
}
__name(getComputedStyle$2, "getComputedStyle$2");
const _HTMLVisualElement = class _HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle$2(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, options, props) {
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current)
          this.current.textContent = `${latest}`;
      });
    }
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderHTML(instance, renderState, styleProp, projection);
  }
};
__name(_HTMLVisualElement, "HTMLVisualElement");
let HTMLVisualElement = _HTMLVisualElement;
const _SVGVisualElement = class _SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, options, props) {
    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
};
__name(_SVGVisualElement, "SVGVisualElement");
let SVGVisualElement = _SVGVisualElement;
const createDomVisualElement = /* @__PURE__ */ __name((Component, options) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, {
    allowProjection: Component !== reactExports.Fragment,
    enableHardwareAcceleration: true
  });
}, "createDomVisualElement");
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const preloadedFeatures = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
};
const motion = /* @__PURE__ */ createMotionProxy((Component, config2) => createDomMotionConfig(Component, config2, preloadedFeatures, createDomVisualElement));
function useIsMounted() {
  const isMounted = reactExports.useRef(false);
  useIsomorphicLayoutEffect$3(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
__name(useIsMounted, "useIsMounted");
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount] = reactExports.useState(0);
  const forceRender = reactExports.useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = reactExports.useCallback(() => frame.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
__name(useForceUpdate, "useForceUpdate");
const _PopChildMeasure = class _PopChildMeasure extends reactExports.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0;
      size2.width = element.offsetWidth || 0;
      size2.top = element.offsetTop;
      size2.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
__name(_PopChildMeasure, "PopChildMeasure");
let PopChildMeasure = _PopChildMeasure;
function PopChild({ children, isPresent }) {
  const id2 = reactExports.useId();
  const ref = reactExports.useRef(null);
  const size2 = reactExports.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  const { nonce } = reactExports.useContext(MotionConfigContext);
  reactExports.useInsertionEffect(() => {
    const { width: width2, height: height2, top: top2, left: left2 } = size2.current;
    if (isPresent || !ref.current || !width2 || !height2)
      return;
    ref.current.dataset.motionPopId = id2;
    const style2 = document.createElement("style");
    if (nonce)
      style2.nonce = nonce;
    document.head.appendChild(style2);
    if (style2.sheet) {
      style2.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width2}px !important;
            height: ${height2}px !important;
            top: ${top2}px !important;
            left: ${left2}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style2);
    };
  }, [isPresent]);
  return jsxRuntimeExports.jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2, children: reactExports.cloneElement(children, { ref }) });
}
__name(PopChild, "PopChild");
const PresenceChild = /* @__PURE__ */ __name(({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = reactExports.useId();
  const context = reactExports.useMemo(
    () => ({
      id: id2,
      initial,
      isPresent,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? [Math.random()] : [isPresent]
  );
  reactExports.useMemo(() => {
    presenceChildren.forEach((_2, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  reactExports.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = jsxRuntimeExports.jsx(PopChild, { isPresent, children });
  }
  return jsxRuntimeExports.jsx(PresenceContext.Provider, { value: context, children });
}, "PresenceChild");
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
__name(newChildrenMap, "newChildrenMap");
function useUnmountEffect(callback) {
  return reactExports.useEffect(() => () => callback(), []);
}
__name(useUnmountEffect, "useUnmountEffect");
const getChildKey = /* @__PURE__ */ __name((child) => child.key || "", "getChildKey");
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key = getChildKey(child);
    allChildren.set(key, child);
  });
}
__name(updateChildLookup, "updateChildLookup");
function onlyElements(children) {
  const filtered = [];
  reactExports.Children.forEach(children, (child) => {
    if (reactExports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
__name(onlyElements, "onlyElements");
const AnimatePresence = /* @__PURE__ */ __name(({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = "sync" }) => {
  const forceRender = reactExports.useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];
  const isMounted = useIsMounted();
  const filteredChildren = onlyElements(children);
  let childrenToRender = filteredChildren;
  const exitingChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  const presentChildren = reactExports.useRef(childrenToRender);
  const allChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  const isInitialRender = reactExports.useRef(true);
  useIsomorphicLayoutEffect$3(() => {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(() => {
    isInitialRender.current = true;
    allChildren.clear();
    exitingChildren.clear();
  });
  if (isInitialRender.current) {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: childrenToRender.map((child) => jsxRuntimeExports.jsx(PresenceChild, { isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode, children: child }, getChildKey(child))) });
  }
  childrenToRender = [...childrenToRender];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i = 0; i < numPresent; i++) {
    const key = presentKeys[i];
    if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {
      exitingChildren.set(key, void 0);
    }
  }
  if (mode === "wait" && exitingChildren.size) {
    childrenToRender = [];
  }
  exitingChildren.forEach((component, key) => {
    if (targetKeys.indexOf(key) !== -1)
      return;
    const child = allChildren.get(key);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key);
    let exitingComponent = component;
    if (!exitingComponent) {
      const onExit = /* @__PURE__ */ __name(() => {
        exitingChildren.delete(key);
        const leftOverKeys = Array.from(allChildren.keys()).filter((childKey) => !targetKeys.includes(childKey));
        leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey));
        presentChildren.current = filteredChildren.filter((presentChild) => {
          const presentChildKey = getChildKey(presentChild);
          return (
            // filter out the node exiting
            presentChildKey === key || // filter out the leftover children
            leftOverKeys.includes(presentChildKey)
          );
        });
        if (!exitingChildren.size) {
          if (isMounted.current === false)
            return;
          forceRender();
          onExitComplete && onExitComplete();
        }
      }, "onExit");
      exitingComponent = jsxRuntimeExports.jsx(PresenceChild, { isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout, mode, children: child }, getChildKey(child));
      exitingChildren.set(key, exitingComponent);
    }
    childrenToRender.splice(insertionIndex, 0, exitingComponent);
  });
  childrenToRender = childrenToRender.map((child) => {
    const key = child.key;
    return exitingChildren.has(key) ? child : jsxRuntimeExports.jsx(PresenceChild, { isPresent: true, presenceAffectsLayout, mode, children: child }, getChildKey(child));
  });
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: exitingChildren.size ? childrenToRender : childrenToRender.map((child) => reactExports.cloneElement(child)) });
}, "AnimatePresence");
const quoteDetailPageStyles = {
  height: "100vh",
  width: "100%",
  padding: 1,
  backgroundColor: "lightgray",
  display: "flex",
  flexDirection: "column",
  gap: 1
};
const boxDefaultStyles = {
  backgroundColor: "white",
  padding: 0.5
};
const typographyStyles = {
  heading1: {
    fontSize: "1.4rem",
    fontWeight: 700,
    color: "text.primary",
    lineHeight: 1.5
  },
  heading2: {
    fontSize: "1rem",
    fontWeight: 600,
    color: "text.secondary",
    lineHeight: 1.4
  },
  bodyText: {
    fontSize: "0.9rem",
    fontWeight: 400,
    color: "text.primary",
    lineHeight: 1.6
  },
  smallText: {
    fontSize: "0.8rem",
    fontWeight: 400,
    color: "text.secondary",
    lineHeight: 1.4
  },
  caption: {
    fontSize: "0.75rem",
    fontWeight: 300,
    color: "text.disabled",
    lineHeight: 1.3,
    fontStyle: "italic"
  }
};
function bind(fn2, thisArg) {
  return /* @__PURE__ */ __name(function wrap() {
    return fn2.apply(thisArg, arguments);
  }, "wrap");
}
__name(bind, "bind");
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str = toString.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = /* @__PURE__ */ __name((type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
}, "kindOfTest");
const typeOfTest = /* @__PURE__ */ __name((type) => (thing) => typeof thing === type, "typeOfTest");
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
__name(isBuffer, "isBuffer");
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
__name(isArrayBufferView, "isArrayBufferView");
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = /* @__PURE__ */ __name((thing) => thing !== null && typeof thing === "object", "isObject$1");
const isBoolean = /* @__PURE__ */ __name((thing) => thing === true || thing === false, "isBoolean");
const isPlainObject$1 = /* @__PURE__ */ __name((val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
}, "isPlainObject$1");
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = /* @__PURE__ */ __name((val) => isObject$1(val) && isFunction(val.pipe), "isStream");
const isFormData = /* @__PURE__ */ __name((thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
}, "isFormData");
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = /* @__PURE__ */ __name((str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), "trim");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn2.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn2.call(null, obj[key], key, obj);
    }
  }
}
__name(forEach, "forEach");
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
__name(findKey, "findKey");
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = /* @__PURE__ */ __name((context) => !isUndefined(context) && context !== _global, "isContextDefined");
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = /* @__PURE__ */ __name((val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject$1(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }, "assignValue");
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
__name(merge$1, "merge$1");
const extend = /* @__PURE__ */ __name((a, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
}, "extend");
const stripBOM = /* @__PURE__ */ __name((content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}, "stripBOM");
const inherits = /* @__PURE__ */ __name((constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}, "inherits");
const toFlatObject = /* @__PURE__ */ __name((sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}, "toFlatObject");
const endsWith = /* @__PURE__ */ __name((str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
}, "endsWith");
const toArray = /* @__PURE__ */ __name((thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}, "toArray");
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = /* @__PURE__ */ __name((obj, fn2) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
}, "forEachEntry");
const matchAll = /* @__PURE__ */ __name((regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
}, "matchAll");
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = /* @__PURE__ */ __name((str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    /* @__PURE__ */ __name(function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }, "replacer")
  );
}, "toCamelCase");
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = /* @__PURE__ */ __name((obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
}, "reduceDescriptors");
const freezeMethods = /* @__PURE__ */ __name((obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
}, "freezeMethods");
const toObjectSet = /* @__PURE__ */ __name((arrayOrString, delimiter2) => {
  const obj = {};
  const define = /* @__PURE__ */ __name((arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  }, "define");
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
  return obj;
}, "toObjectSet");
const noop$2 = /* @__PURE__ */ __name(() => {
}, "noop$2");
const toFiniteNumber = /* @__PURE__ */ __name((value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
}, "toFiniteNumber");
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = /* @__PURE__ */ __name((size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length2 | 0];
  }
  return str;
}, "generateString");
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
__name(isSpecCompliantForm, "isSpecCompliantForm");
const toJSONObject = /* @__PURE__ */ __name((obj) => {
  const stack = new Array(10);
  const visit = /* @__PURE__ */ __name((source, i) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  }, "visit");
  return visit(obj, 0);
}, "toJSONObject");
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = /* @__PURE__ */ __name((thing) => thing && (isObject$1(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch), "isThenable");
const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject: isPlainObject$1,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  response && (this.response = response);
}
__name(AxiosError, "AxiosError");
utils$1.inherits(AxiosError, Error, {
  toJSON: /* @__PURE__ */ __name(function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }, "toJSON")
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, /* @__PURE__ */ __name(function filter3(obj) {
    return obj !== Error.prototype;
  }, "filter"), (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config2, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
__name(isVisitable, "isVisitable");
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
__name(removeBrackets, "removeBrackets");
function renderKey(path, key, dots2) {
  if (!path)
    return key;
  return path.concat(key).map(/* @__PURE__ */ __name(function each(token2, i) {
    token2 = removeBrackets(token2);
    return !dots2 && i ? "[" + token2 + "]" : token2;
  }, "each")).join(dots2 ? "." : "");
}
__name(renderKey, "renderKey");
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
__name(isFlatArray, "isFlatArray");
const predicates = utils$1.toFlatObject(utils$1, {}, null, /* @__PURE__ */ __name(function filter(prop) {
  return /^is[A-Z]/.test(prop);
}, "filter"));
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, /* @__PURE__ */ __name(function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  }, "defined"));
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots2 = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  __name(convertValue, "convertValue");
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(/* @__PURE__ */ __name(function each(el2, index2) {
          !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots2) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        }, "each"));
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots2), convertValue(value));
    return false;
  }
  __name(defaultVisitor, "defaultVisitor");
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$1.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, /* @__PURE__ */ __name(function each(el2, key) {
      const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils$1.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path ? path.concat(key) : [key]);
      }
    }, "each"));
    stack.pop();
  }
  __name(build, "build");
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
__name(toFormData, "toFormData");
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, /* @__PURE__ */ __name(function replacer(match2) {
    return charMap[match2];
  }, "replacer"));
}
__name(encode$1, "encode$1");
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
__name(AxiosURLSearchParams, "AxiosURLSearchParams");
const prototype = AxiosURLSearchParams.prototype;
prototype.append = /* @__PURE__ */ __name(function append2(name, value) {
  this._pairs.push([name, value]);
}, "append");
prototype.toString = /* @__PURE__ */ __name(function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(/* @__PURE__ */ __name(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "each"), "").join("&");
}, "toString");
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
__name(encode, "encode");
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
__name(buildURL, "buildURL");
const _InterceptorManager = class _InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn2) {
    utils$1.forEach(this.handlers, /* @__PURE__ */ __name(function forEachHandler(h2) {
      if (h2 !== null) {
        fn2(h2);
      }
    }, "forEachHandler"));
  }
};
__name(_InterceptorManager, "InterceptorManager");
let InterceptorManager = _InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$2 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform$1 = {
  ...utils,
  ...platform$2
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform$1.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform$1.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
__name(toURLEncodedForm, "toURLEncodedForm");
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
__name(parsePropPath, "parsePropPath");
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
__name(arrayToObject, "arrayToObject");
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  __name(buildPath, "buildPath");
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
__name(formDataToJSON, "formDataToJSON");
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
__name(stringifySafely, "stringifySafely");
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [/* @__PURE__ */ __name(function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }, "transformRequest")],
  transformResponse: [/* @__PURE__ */ __name(function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }, "transformResponse")],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform$1.classes.FormData,
    Blob: platform$1.classes.Blob
  },
  validateStatus: /* @__PURE__ */ __name(function validateStatus(status) {
    return status >= 200 && status < 300;
  }, "validateStatus"),
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = /* @__PURE__ */ __name((rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(/* @__PURE__ */ __name(function parser(line2) {
    i = line2.indexOf(":");
    key = line2.substring(0, i).trim().toLowerCase();
    val = line2.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  }, "parser"));
  return parsed;
}, "parseHeaders");
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
__name(normalizeHeader, "normalizeHeader");
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
__name(normalizeValue, "normalizeValue");
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
__name(parseTokens, "parseTokens");
const isValidHeaderName = /* @__PURE__ */ __name((str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim()), "isValidHeaderName");
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils$1.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value))
    return;
  if (utils$1.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils$1.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
__name(matchHeaderValue, "matchHeaderValue");
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
__name(formatHeader, "formatHeader");
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
__name(buildAccessors, "buildAccessors");
const _AxiosHeaders = class _AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    __name(setHeader, "setHeader");
    const setHeaders = /* @__PURE__ */ __name((headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite)), "setHeaders");
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    __name(deleteHeader, "deleteHeader");
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    __name(defineAccessor, "defineAccessor");
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
__name(_AxiosHeaders, "AxiosHeaders");
let AxiosHeaders = _AxiosHeaders;
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
function transformData(fns, response) {
  const config2 = this || defaults;
  const context = response || config2;
  const headers = AxiosHeaders.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, /* @__PURE__ */ __name(function transform(fn2) {
    data = fn2.call(config2, data, headers.normalize(), response ? response.status : void 0);
  }, "transform"));
  headers.normalize();
  return data;
}
__name(transformData, "transformData");
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
__name(isCancel, "isCancel");
function CanceledError(message, config2, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
__name(CanceledError, "CanceledError");
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
__name(settle, "settle");
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
__name(parseProtocol, "parseProtocol");
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return /* @__PURE__ */ __name(function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  }, "push");
}
__name(speedometer, "speedometer");
function throttle$1(fn2, freq) {
  let timestamp = 0;
  const threshold = 1e3 / freq;
  let timer = null;
  return /* @__PURE__ */ __name(function throttled() {
    const force = this === true;
    const now2 = Date.now();
    if (force || now2 - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now2;
      return fn2.apply(null, arguments);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn2.apply(null, arguments);
      }, threshold - (now2 - timestamp));
    }
  }, "throttled");
}
__name(throttle$1, "throttle$1");
const progressEventReducer = /* @__PURE__ */ __name((listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle$1((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  }, freq);
}, "progressEventReducer");
const isURLSameOrigin = platform$1.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (/* @__PURE__ */ __name(function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    __name(resolveURL, "resolveURL");
    originURL = resolveURL(window.location.href);
    return /* @__PURE__ */ __name(function isURLSameOrigin2(requestURL) {
      const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    }, "isURLSameOrigin");
  }, "standardBrowserEnv"))()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  (/* @__PURE__ */ __name(function nonStandardBrowserEnv() {
    return /* @__PURE__ */ __name(function isURLSameOrigin2() {
      return true;
    }, "isURLSameOrigin");
  }, "nonStandardBrowserEnv"))()
);
const cookies = platform$1.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
__name(isAbsoluteURL, "isAbsoluteURL");
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
__name(combineURLs, "combineURLs");
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
__name(buildFullPath, "buildFullPath");
const headersToObject = /* @__PURE__ */ __name((thing) => thing instanceof AxiosHeaders ? { ...thing } : thing, "headersToObject");
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  __name(getMergedValue, "getMergedValue");
  function mergeDeepProperties(a, b2, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a, b2, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  __name(mergeDeepProperties, "mergeDeepProperties");
  function valueFromConfig2(a, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  __name(valueFromConfig2, "valueFromConfig2");
  function defaultToConfig2(a, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  __name(defaultToConfig2, "defaultToConfig2");
  function mergeDirectKeys(a, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  __name(mergeDirectKeys, "mergeDirectKeys");
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), /* @__PURE__ */ __name(function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  }, "computeConfigValue"));
  return config3;
}
__name(mergeConfig, "mergeConfig");
const resolveConfig = /* @__PURE__ */ __name((config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data)) {
    if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform$1.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
}, "resolveConfig");
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(/* @__PURE__ */ __name(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
    let { responseType } = _config;
    let onCanceled;
    function done() {
      if (_config.cancelToken) {
        _config.cancelToken.unsubscribe(onCanceled);
      }
      if (_config.signal) {
        _config.signal.removeEventListener("abort", onCanceled);
      }
    }
    __name(done, "done");
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(/* @__PURE__ */ __name(function _resolve(value) {
        resolve(value);
        done();
      }, "_resolve"), /* @__PURE__ */ __name(function _reject(err) {
        reject(err);
        done();
      }, "_reject"), response);
      request = null;
    }
    __name(onloadend, "onloadend");
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = /* @__PURE__ */ __name(function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      }, "handleLoad");
    }
    request.onabort = /* @__PURE__ */ __name(function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, _config, request));
      request = null;
    }, "handleAbort");
    request.onerror = /* @__PURE__ */ __name(function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, _config, request));
      request = null;
    }, "handleError");
    request.ontimeout = /* @__PURE__ */ __name(function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        _config,
        request
      ));
      request = null;
    }, "handleTimeout");
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), /* @__PURE__ */ __name(function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      }, "setRequestHeader"));
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (typeof _config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(_config.onDownloadProgress, true));
    }
    if (typeof _config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(_config.onUploadProgress));
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = /* @__PURE__ */ __name((cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
        request.abort();
        request = null;
      }, "onCanceled");
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  }, "dispatchXhrRequest"));
};
const composeSignals = /* @__PURE__ */ __name((signals, timeout) => {
  let controller = new AbortController();
  let aborted;
  const onabort = /* @__PURE__ */ __name(function(cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
    }
  }, "onabort");
  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
  }, timeout);
  const unsubscribe = /* @__PURE__ */ __name(() => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach((signal2) => {
        signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
      });
      signals = null;
    }
  }, "unsubscribe");
  signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
  const { signal } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
}, "composeSignals");
const streamChunk = /* @__PURE__ */ __name(function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end2;
  while (pos < len) {
    end2 = pos + chunkSize;
    yield chunk.slice(pos, end2);
    pos = end2;
  }
}, "streamChunk");
const readBytes = /* @__PURE__ */ __name(async function* (iterable, chunkSize, encode2) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode2(String(chunk)), chunkSize);
  }
}, "readBytes");
const trackStream = /* @__PURE__ */ __name((stream2, chunkSize, onProgress, onFinish, encode2) => {
  const iterator = readBytes(stream2, chunkSize, encode2);
  let bytes = 0;
  return new ReadableStream({
    type: "bytes",
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (done) {
        controller.close();
        onFinish();
        return;
      }
      let len = value.byteLength;
      onProgress && onProgress(bytes += len);
      controller.enqueue(new Uint8Array(value));
    },
    cancel(reason) {
      onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
}, "trackStream");
const fetchProgressDecorator = /* @__PURE__ */ __name((total, fn2) => {
  const lengthComputable = total != null;
  return (loaded) => setTimeout(() => fn2({
    lengthComputable,
    total,
    loaded
  }));
}, "fetchProgressDecorator");
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const supportsRequestStream = isReadableStreamSupported && (() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform$1.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
})();
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && !!(() => {
  try {
    return utils$1.isReadableStream(new Response("").body);
  } catch (err) {
  }
})();
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config2) => {
      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
const getBodyLength = /* @__PURE__ */ __name(async (body2) => {
  if (body2 == null) {
    return 0;
  }
  if (utils$1.isBlob(body2)) {
    return body2.size;
  }
  if (utils$1.isSpecCompliantForm(body2)) {
    return (await new Request(body2).arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body2)) {
    return body2.byteLength;
  }
  if (utils$1.isURLSearchParams(body2)) {
    body2 = body2 + "";
  }
  if (utils$1.isString(body2)) {
    return (await encodeText(body2)).byteLength;
  }
}, "getBodyLength");
const resolveBodyLength = /* @__PURE__ */ __name(async (headers, body2) => {
  const length2 = utils$1.toFiniteNumber(headers.getContentLength());
  return length2 == null ? getBodyLength(body2) : length2;
}, "resolveBodyLength");
const fetchAdapter = isFetchSupported && (async (config2) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals([signal, cancelToken], timeout) : [];
  let finished, request;
  const onFinish = /* @__PURE__ */ __name(() => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  }, "onFinish");
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(
          requestContentLength,
          progressEventReducer(onUploadProgress)
        ), null, encodeText);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "cors" : "omit";
    }
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      withCredentials
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(
          responseContentLength,
          progressEventReducer(onDownloadProgress, true)
        ), isStreamResponse && onFinish, encodeText),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config2, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn2, value) => {
  if (fn2) {
    try {
      Object.defineProperty(fn2, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn2, "adapterName", { value });
  }
});
const renderReason = /* @__PURE__ */ __name((reason) => `- ${reason}`, "renderReason");
const isResolvedHandle = /* @__PURE__ */ __name((adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false, "isResolvedHandle");
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length: length2 } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length2; i++) {
      nameOrAdapter = adapters2[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2);
  }
}
__name(throwIfCancellationRequested, "throwIfCancellationRequested");
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults.adapter);
  return adapter(config2).then(/* @__PURE__ */ __name(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders.from(response.headers);
    return response;
  }, "onAdapterResolution"), /* @__PURE__ */ __name(function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  }, "onAdapterRejection"));
}
__name(dispatchRequest, "dispatchRequest");
const VERSION = "1.7.2";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = /* @__PURE__ */ __name(function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  }, "validator");
});
const deprecatedWarnings = {};
validators$1.transitional = /* @__PURE__ */ __name(function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  __name(formatMessage, "formatMessage");
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
}, "transitional");
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
__name(assertOptions, "assertOptions");
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
const _Axios = class _Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(/* @__PURE__ */ __name(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    }, "unshiftRequestInterceptors"));
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(/* @__PURE__ */ __name(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    }, "pushResponseInterceptors"));
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
__name(_Axios, "Axios");
let Axios = _Axios;
utils$1.forEach(["delete", "get", "head", "options"], /* @__PURE__ */ __name(function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
}, "forEachMethodNoData"));
utils$1.forEach(["post", "put", "patch"], /* @__PURE__ */ __name(function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return /* @__PURE__ */ __name(function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    }, "httpMethod");
  }
  __name(generateHTTPMethod, "generateHTTPMethod");
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
}, "forEachMethodWithData"));
const _CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(/* @__PURE__ */ __name(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    }, "promiseExecutor"));
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i = token2._listeners.length;
      while (i-- > 0) {
        token2._listeners[i](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = /* @__PURE__ */ __name(function reject() {
        token2.unsubscribe(_resolve);
      }, "reject");
      return promise;
    };
    executor(/* @__PURE__ */ __name(function cancel(message, config2, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config2, request);
      resolvePromise(token2.reason);
    }, "cancel"));
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new _CancelToken(/* @__PURE__ */ __name(function executor(c2) {
      cancel = c2;
    }, "executor"));
    return {
      token: token2,
      cancel
    };
  }
};
__name(_CancelToken, "CancelToken");
let CancelToken = _CancelToken;
function spread(callback) {
  return /* @__PURE__ */ __name(function wrap(arr) {
    return callback.apply(null, arr);
  }, "wrap");
}
__name(spread, "spread");
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
__name(isAxiosError, "isAxiosError");
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios(defaultConfig);
  const instance = bind(Axios.prototype.request, context);
  utils$1.extend(instance, Axios.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = /* @__PURE__ */ __name(function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  }, "create");
  return instance;
}
__name(createInstance, "createInstance");
const axios = createInstance(defaults);
axios.Axios = Axios;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = /* @__PURE__ */ __name(function all(promises) {
  return Promise.all(promises);
}, "all");
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode;
axios.default = axios;
const api = axios.create({
  baseURL: "https://apicontrolehomologacao.dse.com.br",
  headers: {
    "Content-Type": "application/json",
    Authorization: window.localStorage.getItem("token")
  }
});
api.interceptors.request.use(
  function(config2) {
    const token2 = window.localStorage.getItem("token") || "";
    config2.headers["Authorization"] = token2;
    return config2;
  },
  function(error) {
    return Promise.reject(error);
  }
);
api.interceptors.response.use(
  function(response) {
    return response;
  },
  function(error) {
    console.log("error message: ", error.response.data.message);
    if (!window.localStorage.getItem("token") || error.response.data.message === "Not authorized") {
      window.location.href = "/";
    }
    return Promise.reject(error);
  }
);
const logIn = /* @__PURE__ */ __name(async (username, password) => {
  try {
    const response = await api.post(
      `/users/login`,
      {
        username,
        password
      },
      {
        withCredentials: false,
        headers: {
          Accept: "*/*"
        }
      }
    );
    return response.data;
  } catch (e2) {
    return { message: "login failed" };
  }
}, "logIn");
const postRequistionItems = /* @__PURE__ */ __name(async (requisitionId, requisitionItems) => {
  try {
    const response = await api.post(`requisition/requisitionItems/${requisitionId}`, requisitionItems);
    return response.data;
  } catch (e2) {
    throw new Error(e2);
  }
}, "postRequistionItems");
const postRequisition = /* @__PURE__ */ __name(async (requistions) => {
  try {
    const response = await api.post("/requisition", requistions);
    return response;
  } catch (e2) {
    throw new Error(e2);
  }
}, "postRequisition");
const fetchAllTypes = /* @__PURE__ */ __name(async () => {
  try {
    const response = await api.get(`requisition/types`);
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "fetchAllTypes");
const fetchAllProjects = /* @__PURE__ */ __name(async () => {
  try {
    const response = await api.get("/project");
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "fetchAllProjects");
const fetchProjectOptionsByUser = /* @__PURE__ */ __name(async (userID) => {
  try {
    const response = await api.get("/project", {
      params: { userID }
    });
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "fetchProjectOptionsByUser");
const deleteRequisition = /* @__PURE__ */ __name(async (id2) => {
  try {
    await api.delete(`/requisition/${id2}`);
  } catch (e2) {
    console.log(e2);
  }
}, "deleteRequisition");
const searchProducts = /* @__PURE__ */ __name(async (name, type) => {
  try {
    const response = await api.get("/products", {
      params: {
        search: name,
        typeId: type
      }
    });
    return response.data;
  } catch (e2) {
    throw new Error(e2);
  }
}, "searchProducts");
const fecthRequisitions = /* @__PURE__ */ __name(async (user, currentKanbanFilter, search) => {
  try {
    const response = await api.get("/requisition", {
      params: {
        userID: user.CODPESSOA,
        search,
        currentKanbanFilter
      }
    });
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "fecthRequisitions");
const fetchRequsitionById = /* @__PURE__ */ __name(async (id2) => {
  try {
    const response = await api.get(`requisition/${id2}`);
    return response.data;
  } catch (e2) {
    throw new Error(e2);
  }
}, "fetchRequsitionById");
const fetchItems = /* @__PURE__ */ __name(async (id2) => {
  try {
    const response = await api.get(
      `requisition/requisitionItems/${id2}`
    );
    return response.data;
  } catch (e2) {
    return null;
  }
}, "fetchItems");
const deleteRequisitionItems = /* @__PURE__ */ __name(async (ids, requisitionId) => {
  console.log("payload: ", { ids, requisitionId });
  try {
    const response = await api.delete(
      `requisition/requisitionItems/${requisitionId}`,
      {
        params: { ids }
      }
    );
    return response;
  } catch (e2) {
    throw new Error(e2);
  }
}, "deleteRequisitionItems");
const fetchPersons = /* @__PURE__ */ __name(async () => {
  try {
    const response = await api.get("/pessoa");
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "fetchPersons");
const fetchPersonById = /* @__PURE__ */ __name(async (id2) => {
  try {
    const response = await api.get(`pessoa/${id2}`);
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "fetchPersonById");
const updateRequisitionItems = /* @__PURE__ */ __name(async (items, requisitonId) => {
  try {
    const response = await api.put(`/requisition/requisitionItems/${requisitonId}`, items);
    return response;
  } catch (e2) {
    console.log(e2);
    throw new Error(e2);
  }
}, "updateRequisitionItems");
const updateRequisition = /* @__PURE__ */ __name(async (codpessoa, requisition) => {
  try {
    const response = await api.put(`requisition/${requisition.ID_REQUISICAO}`, {
      codpessoa,
      requisition
    });
    return response;
  } catch (e2) {
    throw new Error(e2);
  }
}, "updateRequisition");
const quoteFields = [
  {
    dataKey: "observacao",
    label: "Observao",
    type: "string"
  },
  {
    dataKey: "descricao",
    label: "Descrio",
    type: "string"
  },
  {
    dataKey: "id_cotacao",
    label: "ID da Cotao",
    type: "string"
  },
  {
    dataKey: "id_requisicao",
    label: "ID da Requisio",
    type: "string"
  },
  {
    dataKey: "data_cotacao",
    label: "Data da Cotao",
    type: "date"
  },
  {
    dataKey: "validade",
    label: "Validade da Cotao",
    type: "date"
  },
  {
    dataKey: "status",
    label: "Status",
    type: "string"
  },
  {
    dataKey: "fornecedor",
    label: "Fornecedor",
    type: "string"
  },
  {
    dataKey: "total",
    label: "Total da Cotao",
    type: "number"
  },
  {
    dataKey: "condicoes_pagamento",
    label: "Condies de Pagamento",
    type: "string"
  },
  {
    dataKey: "data_validade",
    label: "Data de Validade",
    type: "date"
  }
];
const dummyQuotes = [
  {
    id_cotacao: 1,
    id_requisicao: 1001,
    fornecedor: "ABC Supplies Ltd.",
    data_cotacao: "2025-02-03T10:00:00Z",
    descricao: "Cotao para materiais de construo e ferramentas.",
    observacao: "Entrega prevista em 7 dias teis.",
    condicoes_pagamento: "crdito",
    itens: [
      {
        id_item_cotacao: 1,
        id_cotacao: 1,
        descricao_item: "Parafusos de ao inox (100 unidades)",
        preco_unitario: 5.5,
        quantidade: 10,
        subtotal: 55
      },
      {
        id_item_cotacao: 2,
        id_cotacao: 1,
        descricao_item: "Chave de fenda eltrica",
        preco_unitario: 250,
        quantidade: 2,
        subtotal: 500
      },
      {
        id_item_cotacao: 3,
        id_cotacao: 1,
        descricao_item: "Martelo de borracha",
        preco_unitario: 45,
        quantidade: 3,
        subtotal: 135
      },
      {
        id_item_cotacao: 4,
        id_cotacao: 1,
        descricao_item: "Serra circular manual",
        preco_unitario: 600,
        quantidade: 1,
        subtotal: 600
      },
      {
        id_item_cotacao: 5,
        id_cotacao: 1,
        descricao_item: "Brocas de ao rpido (jogo com 10)",
        preco_unitario: 85,
        quantidade: 2,
        subtotal: 170
      },
      {
        id_item_cotacao: 6,
        id_cotacao: 1,
        descricao_item: "Trena de 5 metros",
        preco_unitario: 30,
        quantidade: 4,
        subtotal: 120
      },
      {
        id_item_cotacao: 7,
        id_cotacao: 1,
        descricao_item: "Chave inglesa ajustvel",
        preco_unitario: 75,
        quantidade: 2,
        subtotal: 150
      },
      {
        id_item_cotacao: 8,
        id_cotacao: 1,
        descricao_item: "Alicate universal",
        preco_unitario: 40,
        quantidade: 5,
        subtotal: 200
      },
      {
        id_item_cotacao: 9,
        id_cotacao: 1,
        descricao_item: "P para concreto",
        preco_unitario: 25,
        quantidade: 6,
        subtotal: 150
      },
      {
        id_item_cotacao: 10,
        id_cotacao: 1,
        descricao_item: "Tubo de silicone para vedao",
        preco_unitario: 18,
        quantidade: 8,
        subtotal: 144
      },
      {
        id_item_cotacao: 11,
        id_cotacao: 1,
        descricao_item: "Luva de proteo trmica",
        preco_unitario: 20,
        quantidade: 12,
        subtotal: 240
      },
      {
        id_item_cotacao: 12,
        id_cotacao: 1,
        descricao_item: "Mscara de proteo respiratria",
        preco_unitario: 15,
        quantidade: 10,
        subtotal: 150
      },
      {
        id_item_cotacao: 13,
        id_cotacao: 1,
        descricao_item: "culos de proteo",
        preco_unitario: 25,
        quantidade: 10,
        subtotal: 250
      },
      {
        id_item_cotacao: 14,
        id_cotacao: 1,
        descricao_item: "Nvel de bolha magntico",
        preco_unitario: 120,
        quantidade: 3,
        subtotal: 360
      },
      {
        id_item_cotacao: 15,
        id_cotacao: 1,
        descricao_item: "Fita isolante (rolo de 20 metros)",
        preco_unitario: 10,
        quantidade: 15,
        subtotal: 150
      },
      {
        id_item_cotacao: 16,
        id_cotacao: 1,
        descricao_item: "Extenso eltrica de 10 metros",
        preco_unitario: 80,
        quantidade: 2,
        subtotal: 160
      },
      {
        id_item_cotacao: 17,
        id_cotacao: 1,
        descricao_item: "Marreta 1 kg",
        preco_unitario: 50,
        quantidade: 4,
        subtotal: 200
      },
      {
        id_item_cotacao: 18,
        id_cotacao: 1,
        descricao_item: "Tinta acrlica branca (lata 18L)",
        preco_unitario: 400,
        quantidade: 1,
        subtotal: 400
      },
      {
        id_item_cotacao: 19,
        id_cotacao: 1,
        descricao_item: "Rolo para pintura",
        preco_unitario: 25,
        quantidade: 6,
        subtotal: 150
      },
      {
        id_item_cotacao: 20,
        id_cotacao: 1,
        descricao_item: "Lixa para madeira (jogo com 5 folhas)",
        preco_unitario: 12,
        quantidade: 8,
        subtotal: 96
      },
      {
        id_item_cotacao: 21,
        id_cotacao: 1,
        descricao_item: "Chave de grifo grande",
        preco_unitario: 90,
        quantidade: 3,
        subtotal: 270
      },
      {
        id_item_cotacao: 22,
        id_cotacao: 1,
        descricao_item: "Ponteira para parafusadeira",
        preco_unitario: 15,
        quantidade: 10,
        subtotal: 150
      }
    ]
  },
  {
    id_cotacao: 2,
    id_requisicao: 1002,
    fornecedor: "XYZ Industrial",
    data_cotacao: "2025-02-02T15:30:00Z",
    descricao: "Cotao para cabos e equipamentos eletrnicos.",
    observacao: "Necessrio pagamento antecipado.",
    condicoes_pagamento: "crdito",
    itens: [
      {
        id_item_cotacao: 3,
        id_cotacao: 2,
        descricao_item: "Cabo HDMI de alta velocidade",
        preco_unitario: 30,
        quantidade: 5,
        subtotal: 150
      },
      {
        id_item_cotacao: 4,
        id_cotacao: 2,
        descricao_item: "Monitor Full HD 24 polegadas",
        preco_unitario: 900,
        quantidade: 1,
        subtotal: 900
      }
    ]
  },
  {
    id_cotacao: 3,
    id_requisicao: 1003,
    fornecedor: "Tech World",
    data_cotacao: "2025-01-30T09:45:00Z",
    descricao: "Cotao para perifricos de informtica.",
    observacao: "Itens sob encomenda.",
    condicoes_pagamento: "crdito",
    itens: [
      {
        id_item_cotacao: 5,
        id_cotacao: 3,
        descricao_item: "Mouse sem fio ergonmico",
        preco_unitario: 120,
        quantidade: 3,
        subtotal: 360
      },
      {
        id_item_cotacao: 6,
        id_cotacao: 3,
        descricao_item: "Teclado mecnico RGB",
        preco_unitario: 300,
        quantidade: 1,
        subtotal: 300
      }
    ]
  }
];
const defaultQuote = {
  id_cotacao: 0,
  id_requisicao: 0,
  fornecedor: "Fornecedor Padro",
  data_cotacao: (/* @__PURE__ */ new Date()).toISOString(),
  descricao: "Descrio padro da cotao.",
  observacao: "Sem observaes.",
  condicoes_pagamento: " vista",
  itens: [
    {
      id_item_cotacao: 0,
      id_cotacao: 0,
      descricao_item: "Item padro",
      preco_unitario: 0,
      quantidade: 1,
      subtotal: 0
    }
  ]
};
const ItemsContext = reactExports.createContext({
  productIdList: [],
  refreshItems: false,
  editing: [false],
  adding: false,
  changing: [false],
  deleting: [false],
  editingObservation: [false],
  selection: { items: [] },
  toggleEditing: () => {
  },
  toggleChanging: () => {
  },
  toggleAdding: () => {
  },
  setEditing: () => {
  },
  toggleDeleting: () => {
  },
  toggleEditingObservation: () => {
  },
  setEditingObservation: () => {
  },
  toggleRefreshItems: () => {
  },
  changeSelection: () => {
  },
  setProductIdList: () => {
  }
});
const ItemsContextProvider = /* @__PURE__ */ __name(({
  children
}) => {
  const [editing, setEditing] = reactExports.useState([false]);
  const [adding, setAdding] = reactExports.useState(false);
  const [changing, setChanging] = reactExports.useState([false]);
  const [deleting, setDeleting] = reactExports.useState([false]);
  const [selection, setSelection] = reactExports.useState({ items: [] });
  const [editingObservation, setEditingObservation] = reactExports.useState([false]);
  const [refreshItems, setRefresh] = reactExports.useState(false);
  const [productIdList, setProductIdList] = reactExports.useState([]);
  const changeSelection = /* @__PURE__ */ __name((items) => {
    if (items) {
      setSelection({ items: [...items] });
      return;
    }
    setSelection({ items: [] });
  }, "changeSelection");
  const toggleRefreshItems = /* @__PURE__ */ __name(() => {
    console.log("toggleRefresh ", !refreshItems);
    setRefresh(!refreshItems);
  }, "toggleRefreshItems");
  const toggleEditing = /* @__PURE__ */ __name((item) => {
    setEditing(editing[0] ? [false] : [true, item]);
  }, "toggleEditing");
  const toggleChanging = /* @__PURE__ */ __name((item) => {
    console.log(
      "toggleChangingItem: ",
      changing[0] ? [!changing] : [!changing[0], item]
    );
    setChanging(changing[0] ? [!changing[0]] : [!changing[0], item]);
  }, "toggleChanging");
  const toggleAdding = /* @__PURE__ */ __name(() => {
    console.log("toggleAdding: ", !adding);
    setAdding(!adding);
  }, "toggleAdding");
  const toggleDeleting = /* @__PURE__ */ __name((item) => {
    setDeleting(deleting[0] ? [false] : [true, item]);
  }, "toggleDeleting");
  const toggleEditingObservation = /* @__PURE__ */ __name((item) => {
    setEditingObservation(
      editingObservation[0] ? [false] : [!editingObservation[0], item]
    );
  }, "toggleEditingObservation");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ItemsContext.Provider,
    {
      value: {
        editing,
        adding,
        changing,
        deleting,
        selection,
        editingObservation,
        refreshItems,
        toggleAdding,
        toggleChanging,
        toggleEditing,
        setEditing,
        toggleDeleting,
        toggleEditingObservation,
        setEditingObservation,
        toggleRefreshItems,
        changeSelection,
        productIdList,
        setProductIdList
      },
      children
    }
  );
}, "ItemsContextProvider");
const useRequisitionItems = /* @__PURE__ */ __name((requisitionId, isInsertingQuantity, addedItems) => {
  const [items, setItems] = reactExports.useState([]);
  const [visibleItems, setVisibleItems] = reactExports.useState([]);
  const [isEditing, setIsEditing] = reactExports.useState(false);
  const [toggleSave, setToggleSave] = reactExports.useState(false);
  const [rowModesModel, setRowModesModel] = React$1.useState({});
  const [selectedRows, setSelectedRows] = reactExports.useState();
  const gridApiRef = useGridApiRef();
  const [alert2, setAlert] = reactExports.useState();
  const [reverseChanges, setReverseChanges] = reactExports.useState(false);
  const [refresh, setRefresh] = reactExports.useState(false);
  const shouldExecuteSaveItems = reactExports.useRef(false);
  const shouldExecuteResetItems = reactExports.useRef(false);
  const { adding, setProductIdList } = reactExports.useContext(ItemsContext);
  const displayAlert = /* @__PURE__ */ __name(async (severity, message) => {
    setTimeout(() => {
      setAlert(void 0);
    }, 3e3);
    setAlert({ severity, message });
    return;
  }, "displayAlert");
  const handleDelete = /* @__PURE__ */ __name(async (requisitionItems) => {
    console.log("os items deletados sero: ", requisitionItems);
    try {
      const ids = requisitionItems.map((item) => item.ID);
      const response = await deleteRequisitionItems(ids, requisitionId);
      if (response.status === 200) {
        setRefresh(!refresh);
        displayAlert("success", "Items deletados com sucesso!");
        return;
      }
    } catch (e2) {
      displayAlert("error", "Houve algum erro ao deletar o item");
    }
  }, "handleDelete");
  const handleCancelItems = /* @__PURE__ */ __name(async (items2) => {
    const updatedItems = items2.map((item) => ({ ...item, ATIVO: 0 }));
    try {
      const response = await updateRequisitionItems(updatedItems, requisitionId);
      if (response.status === 200) {
        setRefresh(!refresh);
        displayAlert("success", "Items inativados com sucesso!");
        return;
      }
    } catch (e2) {
      displayAlert("error", "Houve algum erro ao inativar os itens");
    }
  }, "handleCancelItems");
  const handleActivateItems = /* @__PURE__ */ __name(async (items2) => {
    const updatedItems = items2.map((item) => ({ ...item, ATIVO: 1 }));
    try {
      const response = await updateRequisitionItems(updatedItems, requisitionId);
      if (response.status === 200) {
        setRefresh(!refresh);
        displayAlert("success", "Items ativados com sucesso!");
        return;
      }
    } catch (e2) {
      displayAlert("error", "Houve algum erro ao ativar os itens");
    }
  }, "handleActivateItems");
  const handleCopyContent = /* @__PURE__ */ __name(async (selectedItems) => {
    const container = document.createElement("div");
    container.innerHTML = `
        <table>
            <thead>
                <tr>
                    <th>Nome</th>
                    <th>Quantidade</th>
                </tr>
            </thead>
            <tbody>
                ${selectedItems.map((item) => `
                    <tr>
                        <td>${item.nome_fantasia}</td>
                        <td>${item.QUANTIDADE}</td>
                    </tr>
                `).join("")}
            </tbody>
        </table>
    `;
    const table = container.firstElementChild;
    if (!table) {
      displayAlert("error", "Erro ao gerar a tabela.");
      return;
    }
    try {
      const blob = new Blob([table.outerHTML], { type: "text/html" });
      const clipboardItem = new ClipboardItem({ "text/html": blob });
      await navigator.clipboard.write([clipboardItem]);
      displayAlert("success", "Tabela copiada para a rea de transferncia!");
    } catch (e2) {
      displayAlert("error", "Houve um erro ao copiar a tabela.");
      console.error(e2);
    }
  }, "handleCopyContent");
  const handleChangeSelection = /* @__PURE__ */ __name((rowSelectionModel) => {
    setSelectedRows(items.filter((item) => rowSelectionModel.includes(item.ID)));
  }, "handleChangeSelection");
  const handleRowModesModelChange = /* @__PURE__ */ __name((newRowModesModel) => {
    shouldExecuteSaveItems.current = true;
    shouldExecuteResetItems.current = true;
    setRowModesModel(newRowModesModel);
  }, "handleRowModesModelChange");
  const handleCancelEdition = /* @__PURE__ */ __name(async () => {
    const row = Object.keys(rowModesModel)[0];
    const { fieldToFocus } = rowModesModel[row];
    stopEditMode(Number(row), fieldToFocus, true);
    setIsEditing(false);
    setReverseChanges(!reverseChanges);
  }, "handleCancelEdition");
  const processRowUpdate = /* @__PURE__ */ __name((newRow, oldRow) => {
    if (isEditing) {
      const updatedRow = { ...newRow };
      setVisibleItems(visibleItems.map((item) => item.ID === updatedRow.ID ? updatedRow : item));
      return updatedRow;
    }
    return oldRow;
  }, "processRowUpdate");
  const fetchReqItems = reactExports.useCallback(async () => {
    const items2 = await fetchItems(requisitionId);
    console.log({
      isInsertingQuantity,
      addedItems
    });
    if (items2) {
      if (isInsertingQuantity && (addedItems == null ? void 0 : addedItems.length)) {
        const itemsToBeSet = items2.filter((item) => addedItems.find((addedItem) => addedItem.ID === item.ID));
        setItems(itemsToBeSet);
        setVisibleItems(itemsToBeSet);
        return;
      }
      setProductIdList(items2.map((item) => item.ID_PRODUTO));
      setItems(items2);
      setVisibleItems(items2);
    }
  }, [isInsertingQuantity, addedItems]);
  const saveItems = reactExports.useCallback(async () => {
    try {
      const response = await updateRequisitionItems(visibleItems, requisitionId);
      if (response.status === 200) {
        displayAlert("success", "Items atualizados com sucesso!");
        return;
      }
    } catch (e2) {
      displayAlert("error", "Houve algum erro ao atualizar os itens");
    }
  }, [toggleSave]);
  const stopEditMode = /* @__PURE__ */ __name(async (row, fieldToFocus, ignoreModifications) => {
    gridApiRef.current.stopRowEditMode({ id: row, field: fieldToFocus, ignoreModifications });
  }, "stopEditMode");
  const handleSave = /* @__PURE__ */ __name(async () => {
    const row = Object.keys(rowModesModel)[0];
    const { fieldToFocus } = rowModesModel[row];
    await stopEditMode(Number(row), fieldToFocus, false);
    setToggleSave(!toggleSave);
    setIsEditing(false);
  }, "handleSave");
  reactExports.useEffect(() => {
    const handleClick = /* @__PURE__ */ __name((event) => {
      const target = event.target;
      const isRowClicked = target.closest(".MuiDataGrid-row");
      const isCellClicked = target.closest(".MuiDataGrid-cell");
      if (!isRowClicked && !isCellClicked && isEditing) {
        handleCancelEdition();
      }
    }, "handleClick");
    window.addEventListener("click", handleClick);
    return () => {
      window.removeEventListener("click", handleClick);
    };
  }, [isEditing]);
  reactExports.useEffect(() => {
    fetchReqItems();
  }, [refresh, adding]);
  reactExports.useEffect(() => {
    if (shouldExecuteResetItems.current) {
      setVisibleItems(items);
      return;
    }
  }, [reverseChanges]);
  reactExports.useEffect(() => {
    if (shouldExecuteSaveItems.current) {
      saveItems();
    }
  }, [toggleSave, saveItems]);
  return {
    items,
    visibleItems,
    isEditing,
    alert: alert2,
    rowModesModel,
    gridApiRef,
    selectedRows,
    displayAlert,
    handleRowModesModelChange,
    handleCancelEdition,
    processRowUpdate,
    handleSave,
    setIsEditing,
    handleChangeSelection,
    handleDelete,
    handleCancelItems,
    handleActivateItems,
    handleCopyContent
  };
}, "useRequisitionItems");
const DropdownContext = /* @__PURE__ */ reactExports.createContext(null);
function areEqual(a, b2) {
  return a === b2;
}
__name(areEqual, "areEqual");
const EMPTY_OBJECT$1 = {};
const NOOP$1 = /* @__PURE__ */ __name(() => {
}, "NOOP$1");
function getControlledState(internalState, controlledProps) {
  const augmentedState = _extends$4({}, internalState);
  Object.keys(controlledProps).forEach((key) => {
    if (controlledProps[key] !== void 0) {
      augmentedState[key] = controlledProps[key];
    }
  });
  return augmentedState;
}
__name(getControlledState, "getControlledState");
function useStateChangeDetection(parameters) {
  const {
    nextState,
    initialState: initialState2,
    stateComparers,
    onStateChange,
    controlledProps,
    lastActionRef
  } = parameters;
  const internalPreviousStateRef = reactExports.useRef(initialState2);
  reactExports.useEffect(() => {
    if (lastActionRef.current === null) {
      return;
    }
    const previousState = getControlledState(internalPreviousStateRef.current, controlledProps);
    Object.keys(nextState).forEach((key) => {
      var _stateComparers$key;
      const stateComparer = (_stateComparers$key = stateComparers[key]) != null ? _stateComparers$key : areEqual;
      const nextStateItem = nextState[key];
      const previousStateItem = previousState[key];
      if (previousStateItem == null && nextStateItem != null || previousStateItem != null && nextStateItem == null || previousStateItem != null && nextStateItem != null && !stateComparer(nextStateItem, previousStateItem)) {
        var _event, _type;
        onStateChange == null || onStateChange((_event = lastActionRef.current.event) != null ? _event : null, key, nextStateItem, (_type = lastActionRef.current.type) != null ? _type : "", nextState);
      }
    });
    internalPreviousStateRef.current = nextState;
    lastActionRef.current = null;
  }, [internalPreviousStateRef, nextState, lastActionRef, onStateChange, stateComparers, controlledProps]);
}
__name(useStateChangeDetection, "useStateChangeDetection");
function useControllableReducer(parameters) {
  const lastActionRef = reactExports.useRef(null);
  const {
    reducer,
    initialState: initialState2,
    controlledProps = EMPTY_OBJECT$1,
    stateComparers = EMPTY_OBJECT$1,
    onStateChange = NOOP$1,
    actionContext,
    componentName = ""
  } = parameters;
  reactExports.useRef(controlledProps);
  const reducerWithControlledState = reactExports.useCallback((state, action) => {
    lastActionRef.current = action;
    const controlledState = getControlledState(state, controlledProps);
    const newState = reducer(controlledState, action);
    return newState;
  }, [controlledProps, reducer]);
  const [nextState, dispatch] = reactExports.useReducer(reducerWithControlledState, initialState2);
  const dispatchWithContext = reactExports.useCallback((action) => {
    dispatch(_extends$4({}, action, {
      context: actionContext
    }));
  }, [actionContext]);
  useStateChangeDetection({
    nextState,
    initialState: initialState2,
    stateComparers: stateComparers != null ? stateComparers : EMPTY_OBJECT$1,
    onStateChange: onStateChange != null ? onStateChange : NOOP$1,
    controlledProps,
    lastActionRef
  });
  return [getControlledState(nextState, controlledProps), dispatchWithContext];
}
__name(useControllableReducer, "useControllableReducer");
const DropdownActionTypes = {
  blur: "dropdown:blur",
  escapeKeyDown: "dropdown:escapeKeyDown",
  toggle: "dropdown:toggle",
  open: "dropdown:open",
  close: "dropdown:close"
};
function dropdownReducer(state, action) {
  switch (action.type) {
    case DropdownActionTypes.blur:
      return {
        open: false,
        changeReason: action.event
      };
    case DropdownActionTypes.escapeKeyDown:
      return {
        open: false,
        changeReason: action.event
      };
    case DropdownActionTypes.toggle:
      return {
        open: !state.open,
        changeReason: action.event
      };
    case DropdownActionTypes.open:
      return {
        open: true,
        changeReason: action.event
      };
    case DropdownActionTypes.close:
      return {
        open: false,
        changeReason: action.event
      };
    default:
      throw new Error(`Unhandled action`);
  }
}
__name(dropdownReducer, "dropdownReducer");
function useDropdown(parameters = {}) {
  const {
    defaultOpen,
    onOpenChange,
    open: openProp,
    componentName = "useDropdown"
  } = parameters;
  const [popupId, setPopupId] = reactExports.useState("");
  const [triggerElement, setTriggerElement] = reactExports.useState(null);
  const lastActionType = reactExports.useRef(null);
  const handleStateChange = reactExports.useCallback((event, field, value, reason) => {
    if (field === "open") {
      onOpenChange == null || onOpenChange(event, value);
    }
    lastActionType.current = reason;
  }, [onOpenChange]);
  const controlledProps = reactExports.useMemo(() => openProp !== void 0 ? {
    open: openProp
  } : {}, [openProp]);
  const [state, dispatch] = useControllableReducer({
    controlledProps,
    initialState: defaultOpen ? {
      open: true,
      changeReason: null
    } : {
      open: false,
      changeReason: null
    },
    onStateChange: handleStateChange,
    reducer: dropdownReducer,
    componentName
  });
  reactExports.useEffect(() => {
    if (!state.open && lastActionType.current !== null && lastActionType.current !== DropdownActionTypes.blur) {
      triggerElement == null || triggerElement.focus();
    }
  }, [state.open, triggerElement]);
  const contextValue = {
    state,
    dispatch,
    popupId,
    registerPopup: setPopupId,
    registerTrigger: setTriggerElement,
    triggerElement
  };
  return {
    contextValue,
    open: state.open
  };
}
__name(useDropdown, "useDropdown");
function Dropdown(props) {
  const {
    children,
    open: open2,
    defaultOpen,
    onOpenChange
  } = props;
  const {
    contextValue
  } = useDropdown({
    defaultOpen,
    onOpenChange,
    open: open2
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownContext.Provider, {
    value: contextValue,
    children
  });
}
__name(Dropdown, "Dropdown");
const GLOBAL_CLASS_PREFIX = "base";
function buildStateClass(state) {
  return `${GLOBAL_CLASS_PREFIX}--${state}`;
}
__name(buildStateClass, "buildStateClass");
function buildSlotClass(componentName, slot) {
  return `${GLOBAL_CLASS_PREFIX}-${componentName}-${slot}`;
}
__name(buildSlotClass, "buildSlotClass");
function generateUtilityClass(componentName, slot) {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? buildStateClass(globalStateClass) : buildSlotClass(componentName, slot);
}
__name(generateUtilityClass, "generateUtilityClass");
function generateUtilityClasses(componentName, slots) {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot);
  });
  return result;
}
__name(generateUtilityClasses, "generateUtilityClasses");
const COMPONENT_NAME$4 = "Menu";
function getMenuUtilityClass(slot) {
  return generateUtilityClass(COMPONENT_NAME$4, slot);
}
__name(getMenuUtilityClass, "getMenuUtilityClass");
generateUtilityClasses(COMPONENT_NAME$4, ["root", "listbox", "expanded"]);
const ListActionTypes = {
  blur: "list:blur",
  focus: "list:focus",
  itemClick: "list:itemClick",
  itemHover: "list:itemHover",
  itemsChange: "list:itemsChange",
  keyDown: "list:keyDown",
  resetHighlight: "list:resetHighlight",
  highlightLast: "list:highlightLast",
  textNavigation: "list:textNavigation",
  clearSelection: "list:clearSelection"
};
function findValidItemToHighlight(currentIndex, lookupDirection, items, includeDisabledItems, isItemDisabled, wrapAround) {
  if (items.length === 0 || !includeDisabledItems && items.every((item, itemIndex) => isItemDisabled(item, itemIndex))) {
    return -1;
  }
  let nextFocus = currentIndex;
  for (; ; ) {
    if (!wrapAround && lookupDirection === "next" && nextFocus === items.length || !wrapAround && lookupDirection === "previous" && nextFocus === -1) {
      return -1;
    }
    const nextFocusDisabled = includeDisabledItems ? false : isItemDisabled(items[nextFocus], nextFocus);
    if (nextFocusDisabled) {
      nextFocus += lookupDirection === "next" ? 1 : -1;
      if (wrapAround) {
        nextFocus = (nextFocus + items.length) % items.length;
      }
    } else {
      return nextFocus;
    }
  }
}
__name(findValidItemToHighlight, "findValidItemToHighlight");
function moveHighlight(previouslyHighlightedValue, offset2, context) {
  var _items$nextIndex;
  const {
    items,
    isItemDisabled,
    disableListWrap,
    disabledItemsFocusable,
    itemComparer,
    focusManagement
  } = context;
  const defaultHighlightedIndex = focusManagement === "DOM" ? 0 : -1;
  const maxIndex = items.length - 1;
  const previouslyHighlightedIndex = previouslyHighlightedValue == null ? -1 : items.findIndex((item) => itemComparer(item, previouslyHighlightedValue));
  let nextIndexCandidate;
  let lookupDirection;
  let wrapAround = !disableListWrap;
  switch (offset2) {
    case "reset":
      if (defaultHighlightedIndex === -1) {
        return null;
      }
      nextIndexCandidate = 0;
      lookupDirection = "next";
      wrapAround = false;
      break;
    case "start":
      nextIndexCandidate = 0;
      lookupDirection = "next";
      wrapAround = false;
      break;
    case "end":
      nextIndexCandidate = maxIndex;
      lookupDirection = "previous";
      wrapAround = false;
      break;
    default: {
      const newIndex = previouslyHighlightedIndex + offset2;
      if (newIndex < 0) {
        if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(offset2) > 1) {
          nextIndexCandidate = 0;
          lookupDirection = "next";
        } else {
          nextIndexCandidate = maxIndex;
          lookupDirection = "previous";
        }
      } else if (newIndex > maxIndex) {
        if (!wrapAround || Math.abs(offset2) > 1) {
          nextIndexCandidate = maxIndex;
          lookupDirection = "previous";
        } else {
          nextIndexCandidate = 0;
          lookupDirection = "next";
        }
      } else {
        nextIndexCandidate = newIndex;
        lookupDirection = offset2 >= 0 ? "next" : "previous";
      }
    }
  }
  const nextIndex = findValidItemToHighlight(nextIndexCandidate, lookupDirection, items, disabledItemsFocusable, isItemDisabled, wrapAround);
  if (nextIndex === -1 && previouslyHighlightedValue !== null && !isItemDisabled(previouslyHighlightedValue, previouslyHighlightedIndex)) {
    return previouslyHighlightedValue;
  }
  return (_items$nextIndex = items[nextIndex]) != null ? _items$nextIndex : null;
}
__name(moveHighlight, "moveHighlight");
function toggleSelection(item, selectedValues, selectionMode, itemComparer) {
  if (selectionMode === "none") {
    return [];
  }
  if (selectionMode === "single") {
    if (itemComparer(selectedValues[0], item)) {
      return selectedValues;
    }
    return [item];
  }
  if (selectedValues.some((sv) => itemComparer(sv, item))) {
    return selectedValues.filter((sv) => !itemComparer(sv, item));
  }
  return [...selectedValues, item];
}
__name(toggleSelection, "toggleSelection");
function handleItemSelection(item, state, context) {
  const {
    itemComparer,
    isItemDisabled,
    selectionMode,
    items
  } = context;
  const {
    selectedValues
  } = state;
  const itemIndex = items.findIndex((i) => itemComparer(item, i));
  if (isItemDisabled(item, itemIndex)) {
    return state;
  }
  const newSelectedValues = toggleSelection(item, selectedValues, selectionMode, itemComparer);
  return _extends$4({}, state, {
    selectedValues: newSelectedValues,
    highlightedValue: item
  });
}
__name(handleItemSelection, "handleItemSelection");
function handleKeyDown(key, state, context) {
  const previouslySelectedValue = state.highlightedValue;
  const {
    orientation,
    pageSize: pageSize2
  } = context;
  switch (key) {
    case "Home":
      return _extends$4({}, state, {
        highlightedValue: moveHighlight(previouslySelectedValue, "start", context)
      });
    case "End":
      return _extends$4({}, state, {
        highlightedValue: moveHighlight(previouslySelectedValue, "end", context)
      });
    case "PageUp":
      return _extends$4({}, state, {
        highlightedValue: moveHighlight(previouslySelectedValue, -pageSize2, context)
      });
    case "PageDown":
      return _extends$4({}, state, {
        highlightedValue: moveHighlight(previouslySelectedValue, pageSize2, context)
      });
    case "ArrowUp":
      if (orientation !== "vertical") {
        break;
      }
      return _extends$4({}, state, {
        highlightedValue: moveHighlight(previouslySelectedValue, -1, context)
      });
    case "ArrowDown":
      if (orientation !== "vertical") {
        break;
      }
      return _extends$4({}, state, {
        highlightedValue: moveHighlight(previouslySelectedValue, 1, context)
      });
    case "ArrowLeft": {
      if (orientation === "vertical") {
        break;
      }
      const offset2 = orientation === "horizontal-ltr" ? -1 : 1;
      return _extends$4({}, state, {
        highlightedValue: moveHighlight(previouslySelectedValue, offset2, context)
      });
    }
    case "ArrowRight": {
      if (orientation === "vertical") {
        break;
      }
      const offset2 = orientation === "horizontal-ltr" ? 1 : -1;
      return _extends$4({}, state, {
        highlightedValue: moveHighlight(previouslySelectedValue, offset2, context)
      });
    }
    case "Enter":
    case " ":
      if (state.highlightedValue === null) {
        return state;
      }
      return handleItemSelection(state.highlightedValue, state, context);
  }
  return state;
}
__name(handleKeyDown, "handleKeyDown");
function handleBlur(state, context) {
  if (context.focusManagement === "DOM") {
    return state;
  }
  return _extends$4({}, state, {
    highlightedValue: null
  });
}
__name(handleBlur, "handleBlur");
function textCriteriaMatches(nextFocus, searchString, stringifyItem) {
  var _stringifyItem;
  const text = (_stringifyItem = stringifyItem(nextFocus)) == null ? void 0 : _stringifyItem.trim().toLowerCase();
  if (!text || text.length === 0) {
    return false;
  }
  return text.indexOf(searchString) === 0;
}
__name(textCriteriaMatches, "textCriteriaMatches");
function handleTextNavigation(state, searchString, context) {
  const {
    items,
    isItemDisabled,
    disabledItemsFocusable,
    getItemAsString
  } = context;
  const startWithCurrentItem = searchString.length > 1;
  let nextItem2 = startWithCurrentItem ? state.highlightedValue : moveHighlight(state.highlightedValue, 1, context);
  for (let index2 = 0; index2 < items.length; index2 += 1) {
    if (!nextItem2 || !startWithCurrentItem && state.highlightedValue === nextItem2) {
      return state;
    }
    if (textCriteriaMatches(nextItem2, searchString, getItemAsString) && (!isItemDisabled(nextItem2, items.indexOf(nextItem2)) || disabledItemsFocusable)) {
      return _extends$4({}, state, {
        highlightedValue: nextItem2
      });
    }
    nextItem2 = moveHighlight(nextItem2, 1, context);
  }
  return state;
}
__name(handleTextNavigation, "handleTextNavigation");
function handleItemsChange(items, previousItems, state, context) {
  var _state$selectedValues;
  const {
    itemComparer,
    focusManagement
  } = context;
  let newHighlightedValue = null;
  if (state.highlightedValue != null) {
    var _items$find;
    newHighlightedValue = (_items$find = items.find((item) => itemComparer(item, state.highlightedValue))) != null ? _items$find : null;
  } else if (focusManagement === "DOM" && previousItems.length === 0) {
    newHighlightedValue = moveHighlight(null, "reset", context);
  }
  const selectedValues = (_state$selectedValues = state.selectedValues) != null ? _state$selectedValues : [];
  const newSelectedValues = selectedValues.filter((selectedValue) => items.some((item) => itemComparer(item, selectedValue)));
  return _extends$4({}, state, {
    highlightedValue: newHighlightedValue,
    selectedValues: newSelectedValues
  });
}
__name(handleItemsChange, "handleItemsChange");
function handleResetHighlight(state, context) {
  return _extends$4({}, state, {
    highlightedValue: moveHighlight(null, "reset", context)
  });
}
__name(handleResetHighlight, "handleResetHighlight");
function handleHighlightLast(state, context) {
  return _extends$4({}, state, {
    highlightedValue: moveHighlight(null, "end", context)
  });
}
__name(handleHighlightLast, "handleHighlightLast");
function handleClearSelection(state, context) {
  return _extends$4({}, state, {
    selectedValues: [],
    highlightedValue: moveHighlight(null, "reset", context)
  });
}
__name(handleClearSelection, "handleClearSelection");
function listReducer(state, action) {
  const {
    type,
    context
  } = action;
  switch (type) {
    case ListActionTypes.keyDown:
      return handleKeyDown(action.key, state, context);
    case ListActionTypes.itemClick:
      return handleItemSelection(action.item, state, context);
    case ListActionTypes.blur:
      return handleBlur(state, context);
    case ListActionTypes.textNavigation:
      return handleTextNavigation(state, action.searchString, context);
    case ListActionTypes.itemsChange:
      return handleItemsChange(action.items, action.previousItems, state, context);
    case ListActionTypes.resetHighlight:
      return handleResetHighlight(state, context);
    case ListActionTypes.highlightLast:
      return handleHighlightLast(state, context);
    case ListActionTypes.clearSelection:
      return handleClearSelection(state, context);
    default:
      return state;
  }
}
__name(listReducer, "listReducer");
function areArraysEqual(array1, array2, itemComparer = (a, b2) => a === b2) {
  return array1.length === array2.length && array1.every((value, index2) => itemComparer(value, array2[index2]));
}
__name(areArraysEqual, "areArraysEqual");
const TEXT_NAVIGATION_RESET_TIMEOUT = 500;
function useTextNavigation(callback) {
  const textCriteriaRef = reactExports.useRef({
    searchString: "",
    lastTime: null
  });
  return reactExports.useCallback((event) => {
    if (event.key.length === 1 && event.key !== " ") {
      const textCriteria = textCriteriaRef.current;
      const lowerKey = event.key.toLowerCase();
      const currentTime = performance.now();
      if (textCriteria.searchString.length > 0 && textCriteria.lastTime && currentTime - textCriteria.lastTime > TEXT_NAVIGATION_RESET_TIMEOUT) {
        textCriteria.searchString = lowerKey;
      } else if (textCriteria.searchString.length !== 1 || lowerKey !== textCriteria.searchString) {
        textCriteria.searchString += lowerKey;
      }
      textCriteria.lastTime = currentTime;
      callback(textCriteria.searchString, event);
    }
  }, [callback]);
}
__name(useTextNavigation, "useTextNavigation");
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
__name(extractEventHandlers, "extractEventHandlers");
const EMPTY_OBJECT = {};
const NOOP = /* @__PURE__ */ __name(() => {
}, "NOOP");
const defaultItemComparer = /* @__PURE__ */ __name((optionA, optionB) => optionA === optionB, "defaultItemComparer");
const defaultIsItemDisabled = /* @__PURE__ */ __name(() => false, "defaultIsItemDisabled");
const defaultItemStringifier = /* @__PURE__ */ __name((item) => typeof item === "string" ? item : String(item), "defaultItemStringifier");
const defaultGetInitialState = /* @__PURE__ */ __name(() => ({
  highlightedValue: null,
  selectedValues: []
}), "defaultGetInitialState");
function useList(params) {
  const {
    controlledProps = EMPTY_OBJECT,
    disabledItemsFocusable = false,
    disableListWrap = false,
    focusManagement = "activeDescendant",
    getInitialState = defaultGetInitialState,
    getItemDomElement,
    getItemId,
    isItemDisabled = defaultIsItemDisabled,
    rootRef: externalListRef,
    onStateChange = NOOP,
    items,
    itemComparer = defaultItemComparer,
    getItemAsString = defaultItemStringifier,
    onChange,
    onHighlightChange,
    onItemsChange,
    orientation = "vertical",
    pageSize: pageSize2 = 5,
    reducerActionContext = EMPTY_OBJECT,
    selectionMode = "single",
    stateReducer: externalReducer,
    componentName = "useList"
  } = params;
  const listRef = reactExports.useRef(null);
  const handleRef = useForkRef(externalListRef, listRef);
  const handleHighlightChange = reactExports.useCallback((event, value, reason) => {
    onHighlightChange == null || onHighlightChange(event, value, reason);
    if (focusManagement === "DOM" && value != null && (reason === ListActionTypes.itemClick || reason === ListActionTypes.keyDown || reason === ListActionTypes.textNavigation)) {
      var _getItemDomElement;
      getItemDomElement == null || (_getItemDomElement = getItemDomElement(value)) == null || _getItemDomElement.focus();
    }
  }, [getItemDomElement, onHighlightChange, focusManagement]);
  const stateComparers = reactExports.useMemo(() => ({
    highlightedValue: itemComparer,
    selectedValues: (valuesArray1, valuesArray2) => areArraysEqual(valuesArray1, valuesArray2, itemComparer)
  }), [itemComparer]);
  const handleStateChange = reactExports.useCallback((event, field, value, reason, state2) => {
    onStateChange == null || onStateChange(event, field, value, reason, state2);
    switch (field) {
      case "highlightedValue":
        handleHighlightChange(event, value, reason);
        break;
      case "selectedValues":
        onChange == null || onChange(event, value, reason);
        break;
    }
  }, [handleHighlightChange, onChange, onStateChange]);
  const listActionContext = reactExports.useMemo(() => {
    return {
      disabledItemsFocusable,
      disableListWrap,
      focusManagement,
      isItemDisabled,
      itemComparer,
      items,
      getItemAsString,
      onHighlightChange: handleHighlightChange,
      orientation,
      pageSize: pageSize2,
      selectionMode,
      stateComparers
    };
  }, [disabledItemsFocusable, disableListWrap, focusManagement, isItemDisabled, itemComparer, items, getItemAsString, handleHighlightChange, orientation, pageSize2, selectionMode, stateComparers]);
  const initialState2 = getInitialState();
  const reducer = externalReducer != null ? externalReducer : listReducer;
  const actionContext = reactExports.useMemo(() => _extends$4({}, reducerActionContext, listActionContext), [reducerActionContext, listActionContext]);
  const [state, dispatch] = useControllableReducer({
    reducer,
    actionContext,
    initialState: initialState2,
    controlledProps,
    stateComparers,
    onStateChange: handleStateChange,
    componentName
  });
  const {
    highlightedValue,
    selectedValues
  } = state;
  const handleTextNavigation2 = useTextNavigation((searchString, event) => dispatch({
    type: ListActionTypes.textNavigation,
    event,
    searchString
  }));
  const previousItems = reactExports.useRef([]);
  reactExports.useEffect(() => {
    if (areArraysEqual(previousItems.current, items, itemComparer)) {
      return;
    }
    dispatch({
      type: ListActionTypes.itemsChange,
      event: null,
      items,
      previousItems: previousItems.current
    });
    previousItems.current = items;
    onItemsChange == null || onItemsChange(items);
  }, [items, itemComparer, dispatch, onItemsChange]);
  const createHandleKeyDown = /* @__PURE__ */ __name((externalHandlers) => (event) => {
    var _externalHandlers$onK;
    (_externalHandlers$onK = externalHandlers.onKeyDown) == null || _externalHandlers$onK.call(externalHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const keysToPreventDefault = ["Home", "End", "PageUp", "PageDown"];
    if (orientation === "vertical") {
      keysToPreventDefault.push("ArrowUp", "ArrowDown");
    } else {
      keysToPreventDefault.push("ArrowLeft", "ArrowRight");
    }
    if (focusManagement === "activeDescendant") {
      keysToPreventDefault.push(" ", "Enter");
    }
    if (keysToPreventDefault.includes(event.key)) {
      event.preventDefault();
    }
    dispatch({
      type: ListActionTypes.keyDown,
      key: event.key,
      event
    });
    handleTextNavigation2(event);
  }, "createHandleKeyDown");
  const createHandleBlur = /* @__PURE__ */ __name((externalHandlers) => (event) => {
    var _externalHandlers$onB, _listRef$current;
    (_externalHandlers$onB = externalHandlers.onBlur) == null || _externalHandlers$onB.call(externalHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if ((_listRef$current = listRef.current) != null && _listRef$current.contains(event.relatedTarget)) {
      return;
    }
    dispatch({
      type: ListActionTypes.blur,
      event
    });
  }, "createHandleBlur");
  const getRootProps = /* @__PURE__ */ __name((externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    return _extends$4({}, externalProps, {
      "aria-activedescendant": focusManagement === "activeDescendant" && highlightedValue != null ? getItemId(highlightedValue) : void 0,
      tabIndex: focusManagement === "DOM" ? -1 : 0,
      ref: handleRef
    }, externalEventHandlers, {
      onBlur: createHandleBlur(externalEventHandlers),
      onKeyDown: createHandleKeyDown(externalEventHandlers)
    });
  }, "getRootProps");
  const getItemState = reactExports.useCallback((item) => {
    const selected = (selectedValues != null ? selectedValues : []).some((value) => value != null && itemComparer(item, value));
    const highlighted = highlightedValue != null && itemComparer(item, highlightedValue);
    const focusable = focusManagement === "DOM";
    return {
      focusable,
      highlighted,
      selected
    };
  }, [itemComparer, selectedValues, highlightedValue, focusManagement]);
  const contextValue = reactExports.useMemo(() => ({
    dispatch,
    getItemState
  }), [dispatch, getItemState]);
  reactExports.useDebugValue({
    state
  });
  return {
    contextValue,
    dispatch,
    getRootProps,
    rootRef: handleRef,
    state
  };
}
__name(useList, "useList");
const ListContext = /* @__PURE__ */ reactExports.createContext(null);
function useListItem(parameters) {
  const {
    handlePointerOverEvents = false,
    item
  } = parameters;
  const listContext = reactExports.useContext(ListContext);
  if (!listContext) {
    throw new Error("useListItem must be used within a ListProvider");
  }
  const {
    dispatch,
    getItemState
  } = listContext;
  const {
    highlighted,
    selected,
    focusable
  } = getItemState(item);
  const createHandleClick = reactExports.useCallback((externalHandlers) => (event) => {
    var _externalHandlers$onC;
    (_externalHandlers$onC = externalHandlers.onClick) == null || _externalHandlers$onC.call(externalHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    dispatch({
      type: ListActionTypes.itemClick,
      item,
      event
    });
  }, [dispatch, item]);
  const createHandlePointerOver = reactExports.useCallback((externalHandlers) => (event) => {
    var _externalHandlers$onM;
    (_externalHandlers$onM = externalHandlers.onMouseOver) == null || _externalHandlers$onM.call(externalHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    dispatch({
      type: ListActionTypes.itemHover,
      item,
      event
    });
  }, [dispatch, item]);
  let tabIndex;
  if (focusable) {
    tabIndex = highlighted ? 0 : -1;
  }
  const getRootProps = /* @__PURE__ */ __name((externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    return _extends$4({}, externalProps, {
      onClick: createHandleClick(externalEventHandlers),
      onPointerOver: handlePointerOverEvents ? createHandlePointerOver(externalEventHandlers) : void 0,
      tabIndex
    });
  }, "getRootProps");
  return {
    getRootProps,
    highlighted,
    selected
  };
}
__name(useListItem, "useListItem");
function menuReducer(state, action) {
  if (action.type === ListActionTypes.itemHover) {
    return _extends$4({}, state, {
      highlightedValue: action.item
    });
  }
  const newState = listReducer(state, action);
  if (newState.highlightedValue === null && action.context.items.length > 0) {
    return _extends$4({}, newState, {
      highlightedValue: action.context.items[0]
    });
  }
  if (action.type === ListActionTypes.keyDown) {
    if (action.event.key === "Escape") {
      return _extends$4({}, newState, {
        open: false
      });
    }
  }
  if (action.type === ListActionTypes.blur) {
    var _action$context$listb;
    if (!((_action$context$listb = action.context.listboxRef.current) != null && _action$context$listb.contains(action.event.relatedTarget))) {
      var _action$context$listb2, _action$event$related;
      const listboxId = (_action$context$listb2 = action.context.listboxRef.current) == null ? void 0 : _action$context$listb2.getAttribute("id");
      const controlledBy = (_action$event$related = action.event.relatedTarget) == null ? void 0 : _action$event$related.getAttribute("aria-controls");
      if (listboxId && controlledBy && listboxId === controlledBy) {
        return newState;
      }
      return _extends$4({}, newState, {
        open: false,
        highlightedValue: action.context.items[0]
      });
    }
  }
  return newState;
}
__name(menuReducer, "menuReducer");
const CompoundComponentContext = /* @__PURE__ */ reactExports.createContext(null);
function sortSubitems(subitems) {
  const subitemsArray = Array.from(subitems.keys()).map((key) => {
    const subitem = subitems.get(key);
    return {
      key,
      subitem
    };
  });
  subitemsArray.sort((a, b2) => {
    const aNode = a.subitem.ref.current;
    const bNode = b2.subitem.ref.current;
    if (aNode === null || bNode === null || aNode === bNode) {
      return 0;
    }
    return aNode.compareDocumentPosition(bNode) & Node.DOCUMENT_POSITION_PRECEDING ? 1 : -1;
  });
  return new Map(subitemsArray.map((item) => [item.key, item.subitem]));
}
__name(sortSubitems, "sortSubitems");
function useCompoundParent() {
  const [subitems, setSubitems] = reactExports.useState(/* @__PURE__ */ new Map());
  const subitemKeys = reactExports.useRef(/* @__PURE__ */ new Set());
  const deregisterItem = reactExports.useCallback(/* @__PURE__ */ __name(function deregisterItem2(id2) {
    subitemKeys.current.delete(id2);
    setSubitems((previousState) => {
      const newState = new Map(previousState);
      newState.delete(id2);
      return newState;
    });
  }, "deregisterItem2"), []);
  const registerItem = reactExports.useCallback(/* @__PURE__ */ __name(function registerItem2(id2, item) {
    let providedOrGeneratedId;
    if (typeof id2 === "function") {
      providedOrGeneratedId = id2(subitemKeys.current);
    } else {
      providedOrGeneratedId = id2;
    }
    subitemKeys.current.add(providedOrGeneratedId);
    setSubitems((previousState) => {
      const newState = new Map(previousState);
      newState.set(providedOrGeneratedId, item);
      return newState;
    });
    return {
      id: providedOrGeneratedId,
      deregister: () => deregisterItem(providedOrGeneratedId)
    };
  }, "registerItem2"), [deregisterItem]);
  const sortedSubitems = reactExports.useMemo(() => sortSubitems(subitems), [subitems]);
  const getItemIndex = reactExports.useCallback(/* @__PURE__ */ __name(function getItemIndex2(id2) {
    return Array.from(sortedSubitems.keys()).indexOf(id2);
  }, "getItemIndex2"), [sortedSubitems]);
  const contextValue = reactExports.useMemo(() => ({
    getItemIndex,
    registerItem,
    totalSubitemCount: subitems.size
  }), [getItemIndex, registerItem, subitems.size]);
  return {
    contextValue,
    subitems: sortedSubitems
  };
}
__name(useCompoundParent, "useCompoundParent");
function useCompoundItem(id2, itemMetadata) {
  const context = reactExports.useContext(CompoundComponentContext);
  if (context === null) {
    throw new Error("useCompoundItem must be used within a useCompoundParent");
  }
  const {
    registerItem
  } = context;
  const [registeredId, setRegisteredId] = reactExports.useState(typeof id2 === "function" ? void 0 : id2);
  useEnhancedEffect(() => {
    const {
      id: returnedId,
      deregister
    } = registerItem(id2, itemMetadata);
    setRegisteredId(returnedId);
    return deregister;
  }, [registerItem, itemMetadata, id2]);
  return {
    id: registeredId,
    index: registeredId !== void 0 ? context.getItemIndex(registeredId) : -1,
    totalItemCount: context.totalSubitemCount
  };
}
__name(useCompoundItem, "useCompoundItem");
function combineHooksSlotProps(getFirstProps, getSecondProps) {
  return /* @__PURE__ */ __name(function getCombinedProps(external = {}) {
    const firstResult = _extends$4({}, external, getFirstProps(external));
    const result = _extends$4({}, firstResult, getSecondProps(firstResult));
    return result;
  }, "getCombinedProps");
}
__name(combineHooksSlotProps, "combineHooksSlotProps");
const FALLBACK_MENU_CONTEXT$1 = {
  dispatch: () => {
  },
  popupId: "",
  registerPopup: () => {
  },
  registerTrigger: () => {
  },
  state: {
    open: true,
    changeReason: null
  },
  triggerElement: null
};
function useMenu(parameters = {}) {
  var _useId, _React$useContext;
  const {
    listboxRef: listboxRefProp,
    onItemsChange,
    id: idParam,
    disabledItemsFocusable = true,
    disableListWrap = false,
    autoFocus = true,
    componentName = "useMenu"
  } = parameters;
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(rootRef, listboxRefProp);
  const listboxId = (_useId = useId(idParam)) != null ? _useId : "";
  const {
    state: {
      open: open2,
      changeReason
    },
    dispatch: menuDispatch,
    triggerElement,
    registerPopup
  } = (_React$useContext = reactExports.useContext(DropdownContext)) != null ? _React$useContext : FALLBACK_MENU_CONTEXT$1;
  const isInitiallyOpen = reactExports.useRef(open2);
  const {
    subitems,
    contextValue: compoundComponentContextValue
  } = useCompoundParent();
  const subitemKeys = reactExports.useMemo(() => Array.from(subitems.keys()), [subitems]);
  const getItemDomElement = reactExports.useCallback((itemId) => {
    var _subitems$get$ref$cur, _subitems$get;
    if (itemId == null) {
      return null;
    }
    return (_subitems$get$ref$cur = (_subitems$get = subitems.get(itemId)) == null ? void 0 : _subitems$get.ref.current) != null ? _subitems$get$ref$cur : null;
  }, [subitems]);
  const isItemDisabled = reactExports.useCallback((id2) => {
    var _subitems$get2;
    return (subitems == null || (_subitems$get2 = subitems.get(id2)) == null ? void 0 : _subitems$get2.disabled) || false;
  }, [subitems]);
  const getItemAsString = reactExports.useCallback((id2) => {
    var _subitems$get3, _subitems$get4;
    return ((_subitems$get3 = subitems.get(id2)) == null ? void 0 : _subitems$get3.label) || ((_subitems$get4 = subitems.get(id2)) == null || (_subitems$get4 = _subitems$get4.ref.current) == null ? void 0 : _subitems$get4.innerText);
  }, [subitems]);
  const reducerActionContext = reactExports.useMemo(() => ({
    listboxRef: rootRef
  }), [rootRef]);
  const {
    dispatch: listDispatch,
    getRootProps: getListRootProps,
    contextValue: listContextValue,
    state: {
      highlightedValue
    },
    rootRef: mergedListRef
  } = useList({
    disabledItemsFocusable,
    disableListWrap,
    focusManagement: "DOM",
    getItemDomElement,
    getInitialState: () => ({
      selectedValues: [],
      highlightedValue: null
    }),
    isItemDisabled,
    items: subitemKeys,
    getItemAsString,
    rootRef: handleRef,
    onItemsChange,
    reducerActionContext,
    selectionMode: "none",
    stateReducer: menuReducer,
    componentName
  });
  useEnhancedEffect(() => {
    registerPopup(listboxId);
  }, [listboxId, registerPopup]);
  useEnhancedEffect(() => {
    if (open2 && (changeReason == null ? void 0 : changeReason.type) === "keydown" && changeReason.key === "ArrowUp") {
      listDispatch({
        type: ListActionTypes.highlightLast,
        event: changeReason
      });
    }
  }, [open2, changeReason, listDispatch]);
  reactExports.useEffect(() => {
    if (open2 && autoFocus && highlightedValue && !isInitiallyOpen.current) {
      var _subitems$get5;
      (_subitems$get5 = subitems.get(highlightedValue)) == null || (_subitems$get5 = _subitems$get5.ref) == null || (_subitems$get5 = _subitems$get5.current) == null || _subitems$get5.focus();
    }
  }, [open2, autoFocus, highlightedValue, subitems, subitemKeys]);
  reactExports.useEffect(() => {
    var _rootRef$current;
    if ((_rootRef$current = rootRef.current) != null && _rootRef$current.contains(document.activeElement) && highlightedValue !== null) {
      var _subitems$get6;
      subitems == null || (_subitems$get6 = subitems.get(highlightedValue)) == null || (_subitems$get6 = _subitems$get6.ref.current) == null || _subitems$get6.focus();
    }
  }, [highlightedValue, subitems]);
  const createHandleBlur = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onBlur, _rootRef$current2;
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null || _otherHandlers$onBlur.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if ((_rootRef$current2 = rootRef.current) != null && _rootRef$current2.contains(event.relatedTarget) || event.relatedTarget === triggerElement) {
      return;
    }
    menuDispatch({
      type: DropdownActionTypes.blur,
      event
    });
  }, "createHandleBlur");
  const createHandleKeyDown = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.key === "Escape") {
      menuDispatch({
        type: DropdownActionTypes.escapeKeyDown,
        event
      });
    }
  }, "createHandleKeyDown");
  const getOwnListboxHandlers = /* @__PURE__ */ __name((otherHandlers = {}) => ({
    onBlur: createHandleBlur(otherHandlers),
    onKeyDown: createHandleKeyDown(otherHandlers)
  }), "getOwnListboxHandlers");
  const getListboxProps = /* @__PURE__ */ __name((externalProps = {}) => {
    const getCombinedRootProps = combineHooksSlotProps(getOwnListboxHandlers, getListRootProps);
    const externalEventHandlers = extractEventHandlers(externalProps);
    return _extends$4({}, externalProps, externalEventHandlers, getCombinedRootProps(externalEventHandlers), {
      id: listboxId,
      role: "menu"
    });
  }, "getListboxProps");
  reactExports.useDebugValue({
    subitems,
    highlightedValue
  });
  return {
    contextValue: _extends$4({}, compoundComponentContextValue, listContextValue),
    dispatch: listDispatch,
    getListboxProps,
    highlightedValue,
    listboxRef: mergedListRef,
    menuItems: subitems,
    open: open2,
    triggerElement
  };
}
__name(useMenu, "useMenu");
function MenuProvider(props) {
  const {
    value,
    children
  } = props;
  const {
    dispatch,
    getItemIndex,
    getItemState,
    registerItem,
    totalSubitemCount
  } = value;
  const listContextValue = reactExports.useMemo(() => ({
    dispatch,
    getItemState,
    getItemIndex
  }), [dispatch, getItemIndex, getItemState]);
  const compoundComponentContextValue = reactExports.useMemo(() => ({
    getItemIndex,
    registerItem,
    totalSubitemCount
  }), [registerItem, getItemIndex, totalSubitemCount]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CompoundComponentContext.Provider, {
    value: compoundComponentContextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
      value: listContextValue,
      children
    })
  });
}
__name(MenuProvider, "MenuProvider");
const min$1 = Math.min;
const max$1 = Math.max;
const round$2 = Math.round;
const floor$1 = Math.floor;
const createCoords = /* @__PURE__ */ __name((v2) => ({
  x: v2,
  y: v2
}), "createCoords");
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start2, value, end2) {
  return max$1(start2, min$1(value, end2));
}
__name(clamp$1, "clamp$1");
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
__name(evaluate, "evaluate");
function getSide(placement) {
  return placement.split("-")[0];
}
__name(getSide, "getSide");
function getAlignment(placement) {
  return placement.split("-")[1];
}
__name(getAlignment, "getAlignment");
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
__name(getOppositeAxis, "getOppositeAxis");
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
__name(getAxisLength, "getAxisLength");
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
__name(getSideAxis, "getSideAxis");
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
__name(getAlignmentAxis, "getAlignmentAxis");
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
__name(getAlignmentSides, "getAlignmentSides");
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
__name(getExpandedPlacements, "getExpandedPlacements");
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
__name(getOppositeAlignmentPlacement, "getOppositeAlignmentPlacement");
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
__name(getSideList, "getSideList");
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
__name(getOppositeAxisPlacements, "getOppositeAxisPlacements");
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
__name(getOppositePlacement, "getOppositePlacement");
function expandPaddingObject(padding2) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding2
  };
}
__name(expandPaddingObject, "expandPaddingObject");
function getPaddingObject(padding2) {
  return typeof padding2 !== "number" ? expandPaddingObject(padding2) : {
    top: padding2,
    right: padding2,
    bottom: padding2,
    left: padding2
  };
}
__name(getPaddingObject, "getPaddingObject");
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width: width2,
    height: height2
  } = rect;
  return {
    width: width2,
    height: height2,
    top: y2,
    left: x2,
    right: x2 + width2,
    bottom: y2 + height2,
    x: x2,
    y: y2
  };
}
__name(rectToClientRect, "rectToClientRect");
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference: reference2,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
  const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
  const commonAlign = reference2[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference2.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case "right":
      coords = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference2.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference2.x,
        y: reference2.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
__name(computeCoordsFromPlacement, "computeCoordsFromPlacement");
const computePosition$1 = /* @__PURE__ */ __name(async (reference2, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference: reference2,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn2({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference: reference2,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference: reference2,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
}, "computePosition$1");
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding: padding2 = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding2);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
__name(detectOverflow, "detectOverflow");
const flip$2 = /* @__PURE__ */ __name(function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a, b2) => a.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b2) => a[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
}, "flip$2");
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
__name(convertValueToCoords, "convertValueToCoords");
const offset$2 = /* @__PURE__ */ __name(function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
}, "offset$2");
const shift$2 = /* @__PURE__ */ __name(function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
}, "shift$2");
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
__name(getNodeName, "getNodeName");
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
__name(getWindow, "getWindow");
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
__name(getDocumentElement, "getDocumentElement");
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
__name(isNode, "isNode");
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
__name(isElement, "isElement");
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
__name(isHTMLElement, "isHTMLElement");
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
__name(isShadowRoot, "isShadowRoot");
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
__name(isOverflowElement, "isOverflowElement");
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
__name(isTableElement, "isTableElement");
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
__name(isTopLayer, "isTopLayer");
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
__name(isContainingBlock, "isContainingBlock");
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
__name(getContainingBlock, "getContainingBlock");
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
__name(isWebKit, "isWebKit");
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
__name(isLastTraversableNode, "isLastTraversableNode");
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
__name(getComputedStyle$1, "getComputedStyle$1");
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
__name(getNodeScroll, "getNodeScroll");
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
__name(getParentNode, "getParentNode");
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
__name(getNearestOverflowAncestor, "getNearestOverflowAncestor");
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
__name(getOverflowAncestors, "getOverflowAncestors");
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
__name(getFrameElement, "getFrameElement");
function getCssDimensions(element) {
  const css2 = getComputedStyle$1(element);
  let width2 = parseFloat(css2.width) || 0;
  let height2 = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width2;
  const offsetHeight = hasOffset ? element.offsetHeight : height2;
  const shouldFallback = round$2(width2) !== offsetWidth || round$2(height2) !== offsetHeight;
  if (shouldFallback) {
    width2 = offsetWidth;
    height2 = offsetHeight;
  }
  return {
    width: width2,
    height: height2,
    $: shouldFallback
  };
}
__name(getCssDimensions, "getCssDimensions");
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
__name(unwrapElement, "unwrapElement");
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width: width2,
    height: height2,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round$2(rect.width) : rect.width) / width2;
  let y2 = ($ ? round$2(rect.height) : rect.height) / height2;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
__name(getScale, "getScale");
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
__name(getVisualOffsets, "getVisualOffsets");
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
__name(shouldAddVisualOffsets, "shouldAddVisualOffsets");
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale2 = getScale(offsetParent);
      }
    } else {
      scale2 = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width2 = clientRect.width / scale2.x;
  let height2 = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle$1(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width2 *= iframeScale.x;
      height2 *= iframeScale.y;
      x2 += left2;
      y2 += top2;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width: width2,
    height: height2,
    x: x2,
    y: y2
  });
}
__name(getBoundingClientRect, "getBoundingClientRect");
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale2 = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y
  };
}
__name(convertOffsetParentRelativeRectToViewportRelativeRect, "convertOffsetParentRelativeRectToViewportRelativeRect");
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
__name(getClientRects, "getClientRects");
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
__name(getWindowScrollBarX, "getWindowScrollBarX");
function getDocumentRect(element) {
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body2 = element.ownerDocument.body;
  const width2 = max$1(html2.scrollWidth, html2.clientWidth, body2.scrollWidth, body2.clientWidth);
  const height2 = max$1(html2.scrollHeight, html2.clientHeight, body2.scrollHeight, body2.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body2).direction === "rtl") {
    x2 += max$1(html2.clientWidth, body2.clientWidth) - width2;
  }
  return {
    width: width2,
    height: height2,
    x: x2,
    y: y2
  };
}
__name(getDocumentRect, "getDocumentRect");
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width2 = html2.clientWidth;
  let height2 = html2.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x2,
    y: y2
  };
}
__name(getViewportRect, "getViewportRect");
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top2 = clientRect.top + element.clientTop;
  const left2 = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width2 = element.clientWidth * scale2.x;
  const height2 = element.clientHeight * scale2.y;
  const x2 = left2 * scale2.x;
  const y2 = top2 * scale2.y;
  return {
    width: width2,
    height: height2,
    x: x2,
    y: y2
  };
}
__name(getInnerBoundingClientRect, "getInnerBoundingClientRect");
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
__name(getClientRectFromClippingAncestor, "getClientRectFromClippingAncestor");
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
__name(hasFixedPositionAncestor, "hasFixedPositionAncestor");
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
__name(getClippingElementAncestors, "getClippingElementAncestors");
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
__name(getClippingRect, "getClippingRect");
function getDimensions(element) {
  const {
    width: width2,
    height: height2
  } = getCssDimensions(element);
  return {
    width: width2,
    height: height2
  };
}
__name(getDimensions, "getDimensions");
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x2 = rect.left + scroll.scrollLeft - offsets.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
__name(getRectRelativeToOffsetParent, "getRectRelativeToOffsetParent");
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
__name(isStaticPositioned, "isStaticPositioned");
function getTrueOffsetParent(element, polyfill2) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  return element.offsetParent;
}
__name(getTrueOffsetParent, "getTrueOffsetParent");
function getOffsetParent(element, polyfill2) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
__name(getOffsetParent, "getOffsetParent");
const getElementRects = /* @__PURE__ */ __name(async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
}, "getElementRects");
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
__name(isRTL, "isRTL");
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  __name(cleanup, "cleanup");
  function refresh(skip2, threshold) {
    if (skip2 === void 0) {
      skip2 = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left: left2,
      top: top2,
      width: width2,
      height: height2
    } = element.getBoundingClientRect();
    if (!skip2) {
      onMove();
    }
    if (!width2 || !height2) {
      return;
    }
    const insetTop = floor$1(top2);
    const insetRight = floor$1(root2.clientWidth - (left2 + width2));
    const insetBottom = floor$1(root2.clientHeight - (top2 + height2));
    const insetLeft = floor$1(left2);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max$1(0, min$1(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    __name(handleObserve, "handleObserve");
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  __name(refresh, "refresh");
  refresh(true);
  return cleanup;
}
__name(observeMove, "observeMove");
function autoUpdate(reference2, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference2);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference2) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference2);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  __name(frameLoop, "frameLoop");
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
__name(autoUpdate, "autoUpdate");
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const computePosition = /* @__PURE__ */ __name((reference2, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference2, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
}, "computePosition");
var index$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a, b2) {
  if (a === b2) {
    return true;
  }
  if (typeof a !== typeof b2) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b2.toString()) {
    return true;
  }
  let length2;
  let i;
  let keys;
  if (a && b2 && typeof a === "object") {
    if (Array.isArray(a)) {
      length2 = a.length;
      if (length2 !== b2.length)
        return false;
      for (i = length2; i-- !== 0; ) {
        if (!deepEqual(a[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length2 = keys.length;
    if (length2 !== Object.keys(b2).length) {
      return false;
    }
    for (i = length2; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i])) {
        return false;
      }
    }
    for (i = length2; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b2 !== b2;
}
__name(deepEqual, "deepEqual");
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
__name(getDPR, "getDPR");
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
__name(roundByDPR, "roundByDPR");
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
__name(useLatestRef, "useLatestRef");
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open: open2
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware2);
  if (!deepEqual(latestMiddleware, middleware2)) {
    setLatestMiddleware(middleware2);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node2) => {
    if (node2 !== referenceRef.current) {
      referenceRef.current = node2;
      _setReference(node2);
    }
  }, []);
  const setFloating = reactExports.useCallback((node2) => {
    if (node2 !== floatingRef.current) {
      floatingRef.current = node2;
      _setFloating(node2);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index$1(() => {
    if (open2 === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open2]);
  const isMountedRef = reactExports.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
__name(useFloating, "useFloating");
const offset = /* @__PURE__ */ __name((options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
}), "offset");
const shift = /* @__PURE__ */ __name((options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
}), "shift");
const flip = /* @__PURE__ */ __name((options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
}), "flip");
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
__name(getContainer$1, "getContainer$1");
const Portal = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Portal22(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
  });
}, "Portal2"));
function isHostComponent(element) {
  return typeof element === "string";
}
__name(isHostComponent, "isHostComponent");
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return _extends$4({}, otherProps, {
    ownerState: _extends$4({}, otherProps.ownerState, ownerState)
  });
}
__name(appendOwnerState, "appendOwnerState");
const defaultContextValue = {
  disableDefaultClasses: false
};
const ClassNameConfiguratorContext = /* @__PURE__ */ reactExports.createContext(defaultContextValue);
function useClassNamesOverride(generateUtilityClass2) {
  const {
    disableDefaultClasses
  } = reactExports.useContext(ClassNameConfiguratorContext);
  return (slot) => {
    if (disableDefaultClasses) {
      return "";
    }
    return generateUtilityClass2(slot);
  };
}
__name(useClassNamesOverride, "useClassNamesOverride");
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
__name(resolveComponentProps, "resolveComponentProps");
function useRootElementName(parameters) {
  const {
    rootElementName: rootElementNameProp = "",
    componentName
  } = parameters;
  const [rootElementName, setRootElementName] = reactExports.useState(rootElementNameProp.toUpperCase());
  const updateRootElementName = reactExports.useCallback((instance) => {
    var _instance$tagName;
    setRootElementName((_instance$tagName = instance == null ? void 0 : instance.tagName) != null ? _instance$tagName : "");
  }, []);
  return [rootElementName, updateRootElementName];
}
__name(useRootElementName, "useRootElementName");
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
__name(omitEventHandlers, "omitEventHandlers");
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = _extends$4({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends$4({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(_extends$4({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends$4({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends$4({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
__name(mergeSlotProps, "mergeSlotProps");
const _excluded$i = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false
  } = parameters, rest = _objectWithoutPropertiesLoose$1(parameters, _excluded$i);
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends$4({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = appendOwnerState(elementType, _extends$4({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}
__name(useSlotProps, "useSlotProps");
const COMPONENT_NAME$3 = "Popup";
function getPopupUtilityClass(slot) {
  return generateUtilityClass(COMPONENT_NAME$3, slot);
}
__name(getPopupUtilityClass, "getPopupUtilityClass");
generateUtilityClasses(COMPONENT_NAME$3, ["root", "open"]);
const TransitionContext = /* @__PURE__ */ reactExports.createContext(null);
function useTransitionStateManager() {
  const transitionContext = reactExports.useContext(TransitionContext);
  if (!transitionContext) {
    throw new Error("Missing transition context");
  }
  const {
    registerTransition,
    requestedEnter,
    onExited
  } = transitionContext;
  reactExports.useEffect(() => {
    return registerTransition();
  }, [registerTransition]);
  return {
    onExited,
    requestedEnter
  };
}
__name(useTransitionStateManager, "useTransitionStateManager");
function useTransitionTrigger(requestEnter) {
  const [exitTransitionFinished, setExitTransitionFinished] = reactExports.useState(true);
  const hasPendingExitTransition = reactExports.useRef(false);
  const registeredTransitions = reactExports.useRef(0);
  const [hasTransition, setHasTransition] = reactExports.useState(false);
  const previousRequestEnter = reactExports.useRef(requestEnter);
  reactExports.useEffect(() => {
    if (!requestEnter && // checking registeredTransitions.current instead of hasTransition to avoid this effect re-firing whenever hasTransition changes
    registeredTransitions.current > 0 && // prevents waiting for a pending transition right after mounting
    previousRequestEnter.current !== requestEnter) {
      hasPendingExitTransition.current = true;
      setExitTransitionFinished(false);
    }
    previousRequestEnter.current = requestEnter;
  }, [requestEnter]);
  const handleExited = reactExports.useCallback(() => {
    hasPendingExitTransition.current = false;
    setExitTransitionFinished(true);
  }, []);
  const registerTransition = reactExports.useCallback(() => {
    registeredTransitions.current += 1;
    setHasTransition(true);
    return () => {
      registeredTransitions.current -= 1;
      if (registeredTransitions.current === 0) {
        setHasTransition(false);
      }
    };
  }, []);
  let hasExited;
  if (!hasTransition) {
    hasExited = !requestEnter;
  } else if (requestEnter) {
    hasExited = false;
  } else {
    hasExited = !hasPendingExitTransition.current && exitTransitionFinished;
  }
  const contextValue = reactExports.useMemo(() => ({
    requestedEnter: requestEnter,
    onExited: handleExited,
    registerTransition,
    hasExited
  }), [handleExited, requestEnter, registerTransition, hasExited]);
  return {
    contextValue,
    hasExited
  };
}
__name(useTransitionTrigger, "useTransitionTrigger");
const PopupContext = /* @__PURE__ */ reactExports.createContext(null);
const _excluded$h = ["anchor", "children", "container", "disablePortal", "keepMounted", "middleware", "offset", "open", "placement", "slotProps", "slots", "strategy"];
function useUtilityClasses$a(ownerState) {
  const {
    open: open2
  } = ownerState;
  const slots = {
    root: ["root", open2 && "open"]
  };
  return composeClasses(slots, useClassNamesOverride(getPopupUtilityClass));
}
__name(useUtilityClasses$a, "useUtilityClasses$a");
function resolveAnchor(anchor) {
  return typeof anchor === "function" ? anchor() : anchor;
}
__name(resolveAnchor, "resolveAnchor");
const Popup = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Popup2(props, forwardedRef) {
  var _slots$root;
  const {
    anchor: anchorProp,
    children,
    container,
    disablePortal = false,
    keepMounted = false,
    middleware: middleware2,
    offset: offsetProp = 0,
    open: open2 = false,
    placement = "bottom",
    slotProps = {},
    slots = {},
    strategy = "absolute"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$h);
  const {
    refs,
    elements,
    floatingStyles,
    update,
    placement: finalPlacement
  } = useFloating({
    elements: {
      reference: resolveAnchor(anchorProp)
    },
    open: open2,
    middleware: middleware2 != null ? middleware2 : [offset(offsetProp != null ? offsetProp : 0), flip(), shift()],
    placement,
    strategy,
    whileElementsMounted: !keepMounted ? autoUpdate : void 0
  });
  const handleRef = useForkRef(refs.setFloating, forwardedRef);
  useEnhancedEffect(() => {
    if (keepMounted && open2 && elements.reference && elements.floating) {
      const cleanup = autoUpdate(elements.reference, elements.floating, update);
      return cleanup;
    }
    return void 0;
  }, [keepMounted, open2, elements, update]);
  const ownerState = _extends$4({}, props, {
    disablePortal,
    keepMounted,
    offset,
    open: open2,
    placement,
    finalPlacement,
    strategy
  });
  const {
    contextValue,
    hasExited: hasTransitionExited
  } = useTransitionTrigger(open2);
  const visibility = keepMounted && hasTransitionExited ? "hidden" : void 0;
  const classes2 = useUtilityClasses$a(ownerState);
  const Root = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : "div";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    ownerState,
    className: classes2.root,
    additionalProps: {
      ref: handleRef,
      role: "tooltip",
      style: _extends$4({}, floatingStyles, {
        visibility
      })
    }
  });
  const popupContextValue = reactExports.useMemo(() => ({
    placement: finalPlacement
  }), [finalPlacement]);
  const shouldRender = keepMounted || !hasTransitionExited;
  if (!shouldRender) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    disablePortal,
    container,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopupContext.Provider, {
      value: popupContextValue,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionContext.Provider, {
        value: contextValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$4({}, rootProps, {
          children
        }))
      })
    })
  });
}, "Popup2"));
const _excluded$g = ["actions", "anchor", "children", "onItemsChange", "slotProps", "slots"];
function useUtilityClasses$9(ownerState) {
  const {
    open: open2
  } = ownerState;
  const slots = {
    root: ["root", open2 && "expanded"],
    listbox: ["listbox", open2 && "expanded"]
  };
  return composeClasses(slots, useClassNamesOverride(getMenuUtilityClass));
}
__name(useUtilityClasses$9, "useUtilityClasses$9");
const Menu = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Menu22(props, forwardedRef) {
  var _slots$root, _slots$listbox;
  const {
    actions,
    anchor: anchorProp,
    children,
    onItemsChange,
    slotProps = {},
    slots = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$g);
  const {
    contextValue,
    getListboxProps,
    dispatch,
    open: open2,
    triggerElement
  } = useMenu({
    onItemsChange,
    componentName: "Menu"
  });
  const anchor = anchorProp != null ? anchorProp : triggerElement;
  reactExports.useImperativeHandle(actions, () => ({
    dispatch,
    resetHighlight: () => dispatch({
      type: ListActionTypes.resetHighlight,
      event: null
    })
  }), [dispatch]);
  const ownerState = _extends$4({}, props, {
    open: open2
  });
  const classes2 = useUtilityClasses$9(ownerState);
  const Root = (_slots$root = slots.root) != null ? _slots$root : "div";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref: forwardedRef,
      role: void 0
    },
    className: classes2.root,
    ownerState
  });
  const Listbox = (_slots$listbox = slots.listbox) != null ? _slots$listbox : "ul";
  const listboxProps = useSlotProps({
    elementType: Listbox,
    getSlotProps: getListboxProps,
    externalSlotProps: slotProps.listbox,
    className: classes2.listbox,
    ownerState
  });
  if (open2 === true && anchor == null) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$4({}, rootProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Listbox, _extends$4({}, listboxProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuProvider, {
          value: contextValue,
          children
        })
      }))
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Popup, _extends$4({
    keepMounted: true
  }, rootProps, {
    open: open2,
    anchor,
    slots: {
      root: Root
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Listbox, _extends$4({}, listboxProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuProvider, {
        value: contextValue,
        children
      })
    }))
  }));
}, "Menu2"));
var ArrowDropDown = {};
var _interopRequireDefault$w = interopRequireDefaultExports;
Object.defineProperty(ArrowDropDown, "__esModule", {
  value: true
});
var default_1$r = ArrowDropDown.default = void 0;
var _createSvgIcon$r = _interopRequireDefault$w(requireCreateSvgIcon());
var _jsxRuntime$r = jsxRuntimeExports;
default_1$r = ArrowDropDown.default = (0, _createSvgIcon$r.default)(/* @__PURE__ */ (0, _jsxRuntime$r.jsx)("path", {
  d: "m7 10 5 5 5-5z"
}), "ArrowDropDown");
const DeleteRequisitionItemModal = /* @__PURE__ */ __name(({
  deleteItemModal,
  setDeleteItemModal,
  setExecuteSelectedAction,
  setIsMenuActionsOpen
}) => {
  const handleYes = /* @__PURE__ */ __name(() => {
    setIsMenuActionsOpen(false);
    setExecuteSelectedAction("delete");
    setDeleteItemModal(false);
  }, "handleYes");
  const handleNo = /* @__PURE__ */ __name(() => {
    setDeleteItemModal(false);
    setIsMenuActionsOpen(false);
  }, "handleNo");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: deleteItemModal,
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: {
              xs: 300,
              sm: 400
            },
            bgcolor: "background.paper",
            boxShadow: 24,
            pt: 2,
            px: 4,
            pb: 3
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading2, children: "Tem certeza que deseja excluir os items selecionado?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, sx: { justifyContent: "center" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  sx: {
                    ...BaseButtonStyles,
                    backgroundColor: green[500],
                    ":hover": { backgroundColor: green[900] }
                  },
                  onClick: handleYes,
                  children: "Sim"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  sx: {
                    ...BaseButtonStyles,
                    backgroundColor: red[500],
                    ":hover": { backgroundColor: red[900] }
                  },
                  onClick: handleNo,
                  variant: "outlined",
                  children: "No"
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, "DeleteRequisitionItemModal");
function useButton(parameters = {}) {
  const {
    disabled = false,
    focusableWhenDisabled,
    href,
    rootRef: externalRef,
    tabIndex,
    to,
    type,
    rootElementName: rootElementNameProp
  } = parameters;
  const buttonRef = reactExports.useRef();
  const [active, setActive] = reactExports.useState(false);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && !focusableWhenDisabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useEffect(() => {
    isFocusVisibleRef.current = focusVisible;
  }, [focusVisible, isFocusVisibleRef]);
  const [rootElementName, updateRootElementName] = useRootElementName({
    rootElementName: rootElementNameProp != null ? rootElementNameProp : href || to ? "a" : void 0,
    componentName: "Button"
  });
  const createHandleMouseLeave = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    if (focusVisible) {
      event.preventDefault();
    }
    (_otherHandlers$onMous = otherHandlers.onMouseLeave) == null || _otherHandlers$onMous.call(otherHandlers, event);
  }, "createHandleMouseLeave");
  const createHandleBlur = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null || _otherHandlers$onBlur.call(otherHandlers, event);
  }, "createHandleBlur");
  const createHandleFocus = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onFocu2;
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      var _otherHandlers$onFocu;
      setFocusVisible(true);
      (_otherHandlers$onFocu = otherHandlers.onFocusVisible) == null || _otherHandlers$onFocu.call(otherHandlers, event);
    }
    (_otherHandlers$onFocu2 = otherHandlers.onFocus) == null || _otherHandlers$onFocu2.call(otherHandlers, event);
  }, "createHandleFocus");
  const isNativeButton = /* @__PURE__ */ __name(() => {
    const button = buttonRef.current;
    return rootElementName === "BUTTON" || rootElementName === "INPUT" && ["button", "submit", "reset"].includes(button == null ? void 0 : button.type) || rootElementName === "A" && (button == null ? void 0 : button.href);
  }, "isNativeButton");
  const createHandleClick = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    if (!disabled) {
      var _otherHandlers$onClic;
      (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
    }
  }, "createHandleClick");
  const createHandleMouseDown = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onMous2;
    if (!disabled) {
      setActive(true);
      document.addEventListener("mouseup", () => {
        setActive(false);
      }, {
        once: true
      });
    }
    (_otherHandlers$onMous2 = otherHandlers.onMouseDown) == null || _otherHandlers$onMous2.call(otherHandlers, event);
  }, "createHandleMouseDown");
  const createHandleKeyDown = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.target === event.currentTarget && !isNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (event.target === event.currentTarget && event.key === " " && !disabled) {
      setActive(true);
    }
    if (event.target === event.currentTarget && !isNativeButton() && event.key === "Enter" && !disabled) {
      var _otherHandlers$onClic2;
      (_otherHandlers$onClic2 = otherHandlers.onClick) == null || _otherHandlers$onClic2.call(otherHandlers, event);
      event.preventDefault();
    }
  }, "createHandleKeyDown");
  const createHandleKeyUp = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyU;
    if (event.target === event.currentTarget) {
      setActive(false);
    }
    (_otherHandlers$onKeyU = otherHandlers.onKeyUp) == null || _otherHandlers$onKeyU.call(otherHandlers, event);
    if (event.target === event.currentTarget && !isNativeButton() && !disabled && event.key === " " && !event.defaultMuiPrevented) {
      var _otherHandlers$onClic3;
      (_otherHandlers$onClic3 = otherHandlers.onClick) == null || _otherHandlers$onClic3.call(otherHandlers, event);
    }
  }, "createHandleKeyUp");
  const handleRef = useForkRef(updateRootElementName, externalRef, focusVisibleRef, buttonRef);
  const buttonProps = {};
  if (tabIndex !== void 0) {
    buttonProps.tabIndex = tabIndex;
  }
  if (rootElementName === "BUTTON") {
    buttonProps.type = type != null ? type : "button";
    if (focusableWhenDisabled) {
      buttonProps["aria-disabled"] = disabled;
    } else {
      buttonProps.disabled = disabled;
    }
  } else if (rootElementName === "INPUT") {
    if (type && ["button", "submit", "reset"].includes(type)) {
      if (focusableWhenDisabled) {
        buttonProps["aria-disabled"] = disabled;
      } else {
        buttonProps.disabled = disabled;
      }
    }
  } else if (rootElementName !== "") {
    if (!href && !to) {
      buttonProps.role = "button";
      buttonProps.tabIndex = tabIndex != null ? tabIndex : 0;
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
      buttonProps.tabIndex = focusableWhenDisabled ? tabIndex != null ? tabIndex : 0 : -1;
    }
  }
  const getRootProps = /* @__PURE__ */ __name((externalProps = {}) => {
    const externalEventHandlers = _extends$4({}, extractEventHandlers(parameters), extractEventHandlers(externalProps));
    const props = _extends$4({
      type
    }, externalEventHandlers, buttonProps, externalProps, {
      onBlur: createHandleBlur(externalEventHandlers),
      onClick: createHandleClick(externalEventHandlers),
      onFocus: createHandleFocus(externalEventHandlers),
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      onKeyUp: createHandleKeyUp(externalEventHandlers),
      onMouseDown: createHandleMouseDown(externalEventHandlers),
      onMouseLeave: createHandleMouseLeave(externalEventHandlers),
      ref: handleRef
    });
    delete props.onFocusVisible;
    return props;
  }, "getRootProps");
  return {
    getRootProps,
    focusVisible,
    setFocusVisible,
    active,
    rootRef: handleRef
  };
}
__name(useButton, "useButton");
function useMenuButton(parameters = {}) {
  const {
    disabled = false,
    focusableWhenDisabled,
    rootRef: externalRef
  } = parameters;
  const menuContext = reactExports.useContext(DropdownContext);
  if (menuContext === null) {
    throw new Error("useMenuButton: no menu context available.");
  }
  const {
    state,
    dispatch,
    registerTrigger,
    popupId
  } = menuContext;
  const {
    getRootProps: getButtonRootProps,
    rootRef: buttonRootRef,
    active
  } = useButton({
    disabled,
    focusableWhenDisabled,
    rootRef: externalRef
  });
  const handleRef = useForkRef(buttonRootRef, registerTrigger);
  const createHandleClick = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    dispatch({
      type: DropdownActionTypes.toggle,
      event
    });
  }, "createHandleClick");
  const createHandleKeyDown = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.key === "ArrowDown" || event.key === "ArrowUp") {
      event.preventDefault();
      dispatch({
        type: DropdownActionTypes.open,
        event
      });
    }
  }, "createHandleKeyDown");
  const getOwnRootProps = /* @__PURE__ */ __name((otherHandlers = {}) => ({
    onClick: createHandleClick(otherHandlers),
    onKeyDown: createHandleKeyDown(otherHandlers)
  }), "getOwnRootProps");
  const getRootProps = /* @__PURE__ */ __name((externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    const getCombinedProps = combineHooksSlotProps(getOwnRootProps, getButtonRootProps);
    return _extends$4({
      "aria-haspopup": "menu",
      "aria-expanded": state.open,
      "aria-controls": popupId
    }, externalProps, externalEventHandlers, getCombinedProps(externalEventHandlers), {
      tabIndex: 0,
      // this is needed to make the button focused after click in Safari
      ref: handleRef
    });
  }, "getRootProps");
  return {
    active,
    getRootProps,
    open: state.open,
    rootRef: handleRef
  };
}
__name(useMenuButton, "useMenuButton");
const COMPONENT_NAME$2 = "MenuButton";
function getMenuButtonUtilityClass(slot) {
  return generateUtilityClass(COMPONENT_NAME$2, slot);
}
__name(getMenuButtonUtilityClass, "getMenuButtonUtilityClass");
generateUtilityClasses(COMPONENT_NAME$2, ["root", "active", "disabled", "expanded"]);
const _excluded$f = ["children", "disabled", "label", "slots", "slotProps", "focusableWhenDisabled"];
const useUtilityClasses$8 = /* @__PURE__ */ __name((ownerState) => {
  const {
    active,
    disabled,
    open: open2
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", active && "active", open2 && "expanded"]
  };
  return composeClasses(slots, useClassNamesOverride(getMenuButtonUtilityClass));
}, "useUtilityClasses$8");
const MenuButton = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function MenuButton2(props, forwardedRef) {
  const {
    children,
    disabled = false,
    slots = {},
    slotProps = {},
    focusableWhenDisabled = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$f);
  const {
    getRootProps,
    open: open2,
    active
  } = useMenuButton({
    disabled,
    focusableWhenDisabled,
    rootRef: forwardedRef
  });
  const ownerState = _extends$4({}, props, {
    open: open2,
    active,
    disabled,
    focusableWhenDisabled
  });
  const classes2 = useUtilityClasses$8(ownerState);
  const Root = slots.root || "button";
  const rootProps = useSlotProps({
    elementType: Root,
    getSlotProps: getRootProps,
    externalForwardedProps: other,
    externalSlotProps: slotProps.root,
    additionalProps: {
      ref: forwardedRef,
      type: "button"
    },
    ownerState,
    className: classes2.root
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$4({}, rootProps, {
    children
  }));
}, "MenuButton2"));
const COMPONENT_NAME$1 = "MenuItem";
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass(COMPONENT_NAME$1, slot);
}
__name(getMenuItemUtilityClass, "getMenuItemUtilityClass");
const menuItemClasses = generateUtilityClasses(COMPONENT_NAME$1, ["root", "disabled", "focusVisible"]);
function idGenerator(existingKeys) {
  return `menu-item-${existingKeys.size}`;
}
__name(idGenerator, "idGenerator");
const FALLBACK_MENU_CONTEXT = {
  dispatch: () => {
  },
  popupId: "",
  registerPopup: () => {
  },
  registerTrigger: () => {
  },
  state: {
    open: true,
    changeReason: null
  },
  triggerElement: null
};
function useMenuItem(params) {
  var _React$useContext;
  const {
    disabled = false,
    id: idParam,
    rootRef: externalRef,
    label,
    disableFocusOnHover = false
  } = params;
  const id2 = useId(idParam);
  const itemRef = reactExports.useRef(null);
  const itemMetadata = reactExports.useMemo(() => ({
    disabled,
    id: id2 != null ? id2 : "",
    label,
    ref: itemRef
  }), [disabled, id2, label]);
  const {
    dispatch
  } = (_React$useContext = reactExports.useContext(DropdownContext)) != null ? _React$useContext : FALLBACK_MENU_CONTEXT;
  const {
    getRootProps: getListRootProps,
    highlighted
  } = useListItem({
    item: id2,
    handlePointerOverEvents: !disableFocusOnHover
  });
  const {
    index: index2,
    totalItemCount
  } = useCompoundItem(id2 != null ? id2 : idGenerator, itemMetadata);
  const {
    getRootProps: getButtonProps,
    focusVisible,
    rootRef: buttonRefHandler
  } = useButton({
    disabled,
    focusableWhenDisabled: true
  });
  const handleRef = useForkRef(buttonRefHandler, externalRef, itemRef);
  reactExports.useDebugValue({
    id: id2,
    highlighted,
    disabled,
    label
  });
  const createHandleClick = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    dispatch({
      type: DropdownActionTypes.close,
      event
    });
  }, "createHandleClick");
  const getOwnHandlers = /* @__PURE__ */ __name((otherHandlers = {}) => _extends$4({}, otherHandlers, {
    onClick: createHandleClick(otherHandlers)
  }), "getOwnHandlers");
  function getRootProps(externalProps = {}) {
    const externalEventHandlers = extractEventHandlers(externalProps);
    const getCombinedRootProps = combineHooksSlotProps(getOwnHandlers, combineHooksSlotProps(getButtonProps, getListRootProps));
    return _extends$4({}, externalProps, externalEventHandlers, getCombinedRootProps(externalEventHandlers), {
      id: id2,
      ref: handleRef,
      role: "menuitem"
    });
  }
  __name(getRootProps, "getRootProps");
  if (id2 === void 0) {
    return {
      getRootProps,
      disabled: false,
      focusVisible,
      highlighted: false,
      index: -1,
      totalItemCount: 0,
      rootRef: handleRef
    };
  }
  return {
    getRootProps,
    disabled,
    focusVisible,
    highlighted,
    index: index2,
    totalItemCount,
    rootRef: handleRef
  };
}
__name(useMenuItem, "useMenuItem");
function useMenuItemContextStabilizer(id2) {
  const listContext = reactExports.useContext(ListContext);
  if (!listContext) {
    throw new Error("MenuItem: ListContext was not found.");
  }
  const itemId = useId(id2);
  const {
    getItemState,
    dispatch
  } = listContext;
  let itemState;
  if (itemId != null) {
    itemState = getItemState(itemId);
  } else {
    itemState = {
      focusable: true,
      highlighted: false,
      selected: false
    };
  }
  const {
    highlighted,
    selected,
    focusable
  } = itemState;
  const localGetItemState = reactExports.useCallback((itemValue) => {
    if (itemValue !== itemId) {
      throw new Error(["Base UI MenuItem: Tried to access the state of another MenuItem.", `itemValue: ${itemValue} | id: ${itemId}`, "This is unsupported when the MenuItem uses the MenuItemContextStabilizer as a performance optimization."].join("/n"));
    }
    return {
      highlighted,
      selected,
      focusable
    };
  }, [highlighted, selected, focusable, itemId]);
  const localContextValue = reactExports.useMemo(() => ({
    dispatch,
    getItemState: localGetItemState
  }), [dispatch, localGetItemState]);
  return {
    contextValue: localContextValue,
    id: itemId
  };
}
__name(useMenuItemContextStabilizer, "useMenuItemContextStabilizer");
const _excluded$e = ["children", "disabled", "label", "id", "slotProps", "slots"];
function useUtilityClasses$7(ownerState) {
  const {
    disabled,
    focusVisible
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  return composeClasses(slots, useClassNamesOverride(getMenuItemUtilityClass));
}
__name(useUtilityClasses$7, "useUtilityClasses$7");
const InnerMenuItem = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function MenuItem3(props, forwardedRef) {
  var _slots$root;
  const {
    children,
    disabled: disabledProp = false,
    label,
    id: id2,
    slotProps = {},
    slots = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$e);
  const {
    getRootProps,
    disabled,
    focusVisible,
    highlighted
  } = useMenuItem({
    id: id2,
    disabled: disabledProp,
    rootRef: forwardedRef,
    label
  });
  const ownerState = _extends$4({}, props, {
    disabled,
    focusVisible,
    highlighted
  });
  const classes2 = useUtilityClasses$7(ownerState);
  const Root = (_slots$root = slots.root) != null ? _slots$root : "li";
  const rootProps = useSlotProps({
    elementType: Root,
    getSlotProps: getRootProps,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    className: classes2.root,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$4({}, rootProps, {
    children
  }));
}, "MenuItem")));
const MenuItem22 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function MenuItem32(props, ref) {
  const {
    id: idProp
  } = props;
  const {
    contextValue,
    id: id2
  } = useMenuItemContextStabilizer(idProp);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(InnerMenuItem, _extends$4({}, props, {
      id: id2,
      ref
    }))
  });
}, "MenuItem3"));
const _excluded$d = ["children", "className", "lastTransitionedPropertyOnExit", "enterClassName", "exitClassName"];
const CssTransition = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function CssTransition2(props, forwardedRef) {
  const {
    children,
    className,
    lastTransitionedPropertyOnExit,
    enterClassName,
    exitClassName
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$d);
  const {
    requestedEnter,
    onExited
  } = useTransitionStateManager();
  const [isEntering, setIsEntering] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (requestedEnter) {
      requestAnimationFrame(() => {
        setIsEntering(true);
      });
    } else {
      setIsEntering(false);
    }
  }, [requestedEnter]);
  const handleTransitionEnd = reactExports.useCallback((event) => {
    if (!requestedEnter && (lastTransitionedPropertyOnExit == null || event.propertyName === lastTransitionedPropertyOnExit)) {
      onExited();
    }
  }, [onExited, requestedEnter, lastTransitionedPropertyOnExit]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends$4({
    onTransitionEnd: handleTransitionEnd,
    className: clsx(className, isEntering ? enterClassName : exitClassName)
  }, other, {
    ref: forwardedRef,
    children
  }));
}, "CssTransition2"));
const useItemActions = /* @__PURE__ */ __name((handleCopyContent, handleCancelItems, handleActivateItems, selectedItems, handleDelete) => {
  const [deleteItemModal, setDeleteItemModal] = React$1.useState(false);
  const [executeSelectedAction, setExecuteSelectedAction] = React$1.useState("");
  const [open2, setOpen] = React$1.useState(false);
  const handleOpenChange = /* @__PURE__ */ __name((isOpen) => {
    console.log("open change: ", isOpen);
    setOpen(isOpen);
  }, "handleOpenChange");
  const menuActions = [
    {
      label: "Excluir",
      onClick: () => {
        setDeleteItemModal(true);
      }
    },
    {
      label: "Copiar",
      onClick: () => handleCopyContent(selectedItems)
    },
    {
      label: "Inativar",
      onClick: () => handleCancelItems(selectedItems)
    },
    {
      label: "Ativar",
      onClick: () => handleActivateItems(selectedItems)
    },
    {
      label: "Gerar cotao",
      onClick: () => {
      }
    }
  ];
  const Listbox = styled$1("ul")(
    ({ theme: theme2 }) => `
  font-family: 'IBM Plex Sans', sans-serif;
  font-size: 0.875rem;
  box-sizing: border-box;
  padding: 6px;
  margin: 12px 0;
  min-width: 200px;
  border-radius: 12px;
  overflow: auto;
  outline: 0px;
  background: ${theme2.palette.mode === "dark" ? grey$1[900] : "#fff"};
  border: 1px solid ${theme2.palette.mode === "dark" ? grey$1[700] : grey$1[200]};
  color: ${theme2.palette.mode === "dark" ? grey$1[300] : grey$1[900]};
  box-shadow: 0px 4px 30px ${theme2.palette.mode === "dark" ? grey$1[900] : grey$1[200]};
  z-index: 1;

  .closed & {
    opacity: 0;
    transform: scale(0.95, 0.8);
    transition: opacity 200ms ease-in, transform 200ms ease-in;
  }
  
  .open & {
    opacity: 1;
    transform: scale(1, 1);
    transition: opacity 100ms ease-out, transform 100ms cubic-bezier(0.43, 0.29, 0.37, 1.48);
  }

  .placement-top & {
    transform-origin: bottom;
  }

  .placement-bottom & {
    transform-origin: top;
  }
  `
  );
  const AnimatedListbox = React$1.forwardRef(/* @__PURE__ */ __name(function AnimatedListbox2(props, ref) {
    const { ownerState, ...other } = props;
    const popupContext = React$1.useContext(PopupContext);
    if (popupContext == null) {
      throw new Error(
        "The `AnimatedListbox` component cannot be rendered outside a `Popup` component"
      );
    }
    const verticalPlacement = popupContext.placement.split("-")[0];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CssTransition,
      {
        className: `placement-${verticalPlacement}`,
        enterClassName: "open",
        exitClassName: "closed",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Listbox, { ...other, ref })
      }
    );
  }, "AnimatedListbox2"));
  const MenuItem4 = styled$1(MenuItem22)(
    ({ theme: theme2 }) => `
  list-style: none;
  padding: 8px;
  border-radius: 8px;
  cursor: default;
  user-select: none;
  &:last-of-type {
    border-bottom: none;
  }

  &.${menuItemClasses.focusVisible} {
    outline: 3px solid ${theme2.palette.mode === "dark" ? blue[600] : blue[200]};
    background-color: ${theme2.palette.mode === "dark" ? grey$1[800] : grey$1[100]};
    color: ${theme2.palette.mode === "dark" ? grey$1[300] : grey$1[900]};
  }

  &.${menuItemClasses.disabled} {
    color: ${theme2.palette.mode === "dark" ? grey$1[700] : grey$1[400]};
  }

  &:hover:not(.${menuItemClasses.disabled}) {
    background-color: ${theme2.palette.mode === "dark" ? blue[900] : blue[50]};
    color: ${theme2.palette.mode === "dark" ? blue[100] : blue[900]};
  }
  `
  );
  const MenuButton$1 = styled$1(MenuButton)(() => {
    return { ...buttonStylesMobile, height: 35, width: 30 };
  });
  reactExports.useEffect(() => {
    if (executeSelectedAction === "delete") {
      handleDelete(selectedItems);
      setExecuteSelectedAction("");
    }
  }, [executeSelectedAction]);
  return {
    deleteItemModal,
    setDeleteItemModal,
    executeSelectedAction,
    setExecuteSelectedAction,
    menuActions,
    AnimatedListbox,
    MenuItem: MenuItem4,
    MenuButton: MenuButton$1,
    open: open2,
    setOpen,
    handleOpenChange
  };
}, "useItemActions");
const ItemActions = /* @__PURE__ */ __name(({
  handleCancelItems,
  handleActivateItems,
  handleCopyContent,
  handleDelete,
  selectedItems
}) => {
  const {
    deleteItemModal,
    setDeleteItemModal,
    setExecuteSelectedAction,
    menuActions,
    AnimatedListbox,
    MenuButton: MenuButton3,
    MenuItem: MenuItem4,
    setOpen,
    open: open2,
    handleOpenChange
  } = useItemActions(
    handleCopyContent,
    handleCancelItems,
    handleActivateItems,
    selectedItems,
    handleDelete
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DeleteRequisitionItemModal,
      {
        deleteItemModal,
        setDeleteItemModal,
        setExecuteSelectedAction,
        setIsMenuActionsOpen: setOpen
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dropdown,
      {
        display: open2 ? "block" : "none",
        open: open2,
        onOpenChange: (_event, open22) => handleOpenChange(open22),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuButton3, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$r, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, { slots: { listbox: AnimatedListbox }, children: open2 && menuActions.map((action, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem4, { onClick: action.onClick, children: action.label }, index2)) })
        ]
      }
    )
  ] });
}, "ItemActions");
const PUBLISH = 0;
const SUBSCRIBE = 1;
const RESET = 2;
const VALUE = 4;
function compose(a, b2) {
  return (arg) => a(b2(arg));
}
__name(compose, "compose");
function thrush(arg, proc) {
  return proc(arg);
}
__name(thrush, "thrush");
function curry2to1(proc, arg1) {
  return (arg2) => proc(arg1, arg2);
}
__name(curry2to1, "curry2to1");
function curry1to0(proc, arg) {
  return () => proc(arg);
}
__name(curry1to0, "curry1to0");
function tap(arg, proc) {
  proc(arg);
  return arg;
}
__name(tap, "tap");
function tup(...args) {
  return args;
}
__name(tup, "tup");
function call(proc) {
  proc();
}
__name(call, "call");
function always(value) {
  return () => value;
}
__name(always, "always");
function joinProc(...procs) {
  return () => {
    procs.map(call);
  };
}
__name(joinProc, "joinProc");
function isDefined(arg) {
  return arg !== void 0;
}
__name(isDefined, "isDefined");
function noop$1() {
}
__name(noop$1, "noop$1");
function subscribe(emitter, subscription) {
  return emitter(SUBSCRIBE, subscription);
}
__name(subscribe, "subscribe");
function publish(publisher, value) {
  publisher(PUBLISH, value);
}
__name(publish, "publish");
function reset(emitter) {
  emitter(RESET);
}
__name(reset, "reset");
function getValue(depot) {
  return depot(VALUE);
}
__name(getValue, "getValue");
function connect(emitter, publisher) {
  return subscribe(emitter, curry2to1(publisher, PUBLISH));
}
__name(connect, "connect");
function handleNext(emitter, subscription) {
  const unsub = emitter(SUBSCRIBE, (value) => {
    unsub();
    subscription(value);
  });
  return unsub;
}
__name(handleNext, "handleNext");
function stream() {
  const subscriptions = [];
  return (action, arg) => {
    switch (action) {
      case RESET:
        subscriptions.splice(0, subscriptions.length);
        return;
      case SUBSCRIBE:
        subscriptions.push(arg);
        return () => {
          const indexOf = subscriptions.indexOf(arg);
          if (indexOf > -1) {
            subscriptions.splice(indexOf, 1);
          }
        };
      case PUBLISH:
        subscriptions.slice().forEach((subscription) => {
          subscription(arg);
        });
        return;
      default:
        throw new Error(`unrecognized action ${action}`);
    }
  };
}
__name(stream, "stream");
function statefulStream(initial) {
  let value = initial;
  const innerSubject = stream();
  return (action, arg) => {
    switch (action) {
      case SUBSCRIBE:
        const subscription = arg;
        subscription(value);
        break;
      case PUBLISH:
        value = arg;
        break;
      case VALUE:
        return value;
    }
    return innerSubject(action, arg);
  };
}
__name(statefulStream, "statefulStream");
function eventHandler(emitter) {
  let unsub;
  let currentSubscription;
  const cleanup = /* @__PURE__ */ __name(() => unsub && unsub(), "cleanup");
  return function(action, subscription) {
    switch (action) {
      case SUBSCRIBE:
        if (subscription) {
          if (currentSubscription === subscription) {
            return;
          }
          cleanup();
          currentSubscription = subscription;
          unsub = subscribe(emitter, subscription);
          return unsub;
        } else {
          cleanup();
          return noop$1;
        }
      case RESET:
        cleanup();
        currentSubscription = null;
        return;
      default:
        throw new Error(`unrecognized action ${action}`);
    }
  };
}
__name(eventHandler, "eventHandler");
function streamFromEmitter(emitter) {
  return tap(stream(), (stream2) => connect(emitter, stream2));
}
__name(streamFromEmitter, "streamFromEmitter");
function statefulStreamFromEmitter(emitter, initial) {
  return tap(statefulStream(initial), (stream2) => connect(emitter, stream2));
}
__name(statefulStreamFromEmitter, "statefulStreamFromEmitter");
function combineOperators(...operators) {
  return (subscriber) => {
    return operators.reduceRight(thrush, subscriber);
  };
}
__name(combineOperators, "combineOperators");
function pipe(source, ...operators) {
  const project = combineOperators(...operators);
  return (action, subscription) => {
    switch (action) {
      case SUBSCRIBE:
        return subscribe(source, project(subscription));
      case RESET:
        reset(source);
        return;
    }
  };
}
__name(pipe, "pipe");
function defaultComparator(previous, next2) {
  return previous === next2;
}
__name(defaultComparator, "defaultComparator");
function distinctUntilChanged(comparator = defaultComparator) {
  let current;
  return (done) => (next2) => {
    if (!comparator(current, next2)) {
      current = next2;
      done(next2);
    }
  };
}
__name(distinctUntilChanged, "distinctUntilChanged");
function filter2(predicate) {
  return (done) => (value) => {
    predicate(value) && done(value);
  };
}
__name(filter2, "filter");
function map(project) {
  return (done) => compose(done, project);
}
__name(map, "map");
function mapTo(value) {
  return (done) => () => done(value);
}
__name(mapTo, "mapTo");
function scan(scanner, initial) {
  return (done) => (value) => done(initial = scanner(initial, value));
}
__name(scan, "scan");
function skip(times) {
  return (done) => (value) => {
    times > 0 ? times-- : done(value);
  };
}
__name(skip, "skip");
function throttleTime(interval) {
  let currentValue = null;
  let timeout;
  return (done) => (value) => {
    currentValue = value;
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      timeout = void 0;
      done(currentValue);
    }, interval);
  };
}
__name(throttleTime, "throttleTime");
function debounceTime(interval) {
  let currentValue;
  let timeout;
  return (done) => (value) => {
    currentValue = value;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      done(currentValue);
    }, interval);
  };
}
__name(debounceTime, "debounceTime");
function withLatestFrom(...sources) {
  const values2 = new Array(sources.length);
  let called = 0;
  let pendingCall = null;
  const allCalled = Math.pow(2, sources.length) - 1;
  sources.forEach((source, index2) => {
    const bit = Math.pow(2, index2);
    subscribe(source, (value) => {
      const prevCalled = called;
      called = called | bit;
      values2[index2] = value;
      if (prevCalled !== allCalled && called === allCalled && pendingCall) {
        pendingCall();
        pendingCall = null;
      }
    });
  });
  return (done) => (value) => {
    const call2 = /* @__PURE__ */ __name(() => done([value].concat(values2)), "call2");
    if (called === allCalled) {
      call2();
    } else {
      pendingCall = call2;
    }
  };
}
__name(withLatestFrom, "withLatestFrom");
function merge(...sources) {
  return function(action, subscription) {
    switch (action) {
      case SUBSCRIBE:
        return joinProc(...sources.map((source) => subscribe(source, subscription)));
      case RESET:
        return;
      default:
        throw new Error(`unrecognized action ${action}`);
    }
  };
}
__name(merge, "merge");
function duc(source, comparator = defaultComparator) {
  return pipe(source, distinctUntilChanged(comparator));
}
__name(duc, "duc");
function combineLatest(...emitters) {
  const innerSubject = stream();
  const values2 = new Array(emitters.length);
  let called = 0;
  const allCalled = Math.pow(2, emitters.length) - 1;
  emitters.forEach((source, index2) => {
    const bit = Math.pow(2, index2);
    subscribe(source, (value) => {
      values2[index2] = value;
      called = called | bit;
      if (called === allCalled) {
        publish(innerSubject, values2);
      }
    });
  });
  return function(action, subscription) {
    switch (action) {
      case SUBSCRIBE:
        if (called === allCalled) {
          subscription(values2);
        }
        return subscribe(innerSubject, subscription);
      case RESET:
        return reset(innerSubject);
      default:
        throw new Error(`unrecognized action ${action}`);
    }
  };
}
__name(combineLatest, "combineLatest");
function system(constructor, dependencies = [], { singleton } = { singleton: true }) {
  return {
    id: id(),
    constructor,
    dependencies,
    singleton
  };
}
__name(system, "system");
const id = /* @__PURE__ */ __name(() => Symbol(), "id");
function init(systemSpec) {
  const singletons = /* @__PURE__ */ new Map();
  const _init = /* @__PURE__ */ __name(({ id: id2, constructor, dependencies, singleton }) => {
    if (singleton && singletons.has(id2)) {
      return singletons.get(id2);
    }
    const system2 = constructor(dependencies.map((e2) => _init(e2)));
    if (singleton) {
      singletons.set(id2, system2);
    }
    return system2;
  }, "_init");
  return _init(systemSpec);
}
__name(init, "init");
function omit(keys, obj) {
  const result = {};
  const index2 = {};
  let idx = 0;
  const len = keys.length;
  while (idx < len) {
    index2[keys[idx]] = 1;
    idx += 1;
  }
  for (const prop in obj) {
    if (!index2.hasOwnProperty(prop)) {
      result[prop] = obj[prop];
    }
  }
  return result;
}
__name(omit, "omit");
const useIsomorphicLayoutEffect$2 = typeof document !== "undefined" ? React$1.useLayoutEffect : React$1.useEffect;
function systemToComponent(systemSpec, map2, Root) {
  const requiredPropNames = Object.keys(map2.required || {});
  const optionalPropNames = Object.keys(map2.optional || {});
  const methodNames = Object.keys(map2.methods || {});
  const eventNames = Object.keys(map2.events || {});
  const Context = React$1.createContext({});
  function applyPropsToSystem(system2, props) {
    if (system2["propsReady"]) {
      publish(system2["propsReady"], false);
    }
    for (const requiredPropName of requiredPropNames) {
      const stream2 = system2[map2.required[requiredPropName]];
      publish(stream2, props[requiredPropName]);
    }
    for (const optionalPropName of optionalPropNames) {
      if (optionalPropName in props) {
        const stream2 = system2[map2.optional[optionalPropName]];
        publish(stream2, props[optionalPropName]);
      }
    }
    if (system2["propsReady"]) {
      publish(system2["propsReady"], true);
    }
  }
  __name(applyPropsToSystem, "applyPropsToSystem");
  function buildMethods(system2) {
    return methodNames.reduce((acc, methodName) => {
      acc[methodName] = (value) => {
        const stream2 = system2[map2.methods[methodName]];
        publish(stream2, value);
      };
      return acc;
    }, {});
  }
  __name(buildMethods, "buildMethods");
  function buildEventHandlers(system2) {
    return eventNames.reduce((handlers, eventName) => {
      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);
      return handlers;
    }, {});
  }
  __name(buildEventHandlers, "buildEventHandlers");
  const Component = React$1.forwardRef((propsWithChildren, ref) => {
    const { children, ...props } = propsWithChildren;
    const [system2] = React$1.useState(() => {
      return tap(init(systemSpec), (system22) => applyPropsToSystem(system22, props));
    });
    const [handlers] = React$1.useState(curry1to0(buildEventHandlers, system2));
    useIsomorphicLayoutEffect$2(() => {
      for (const eventName of eventNames) {
        if (eventName in props) {
          subscribe(handlers[eventName], props[eventName]);
        }
      }
      return () => {
        Object.values(handlers).map(reset);
      };
    }, [props, handlers, system2]);
    useIsomorphicLayoutEffect$2(() => {
      applyPropsToSystem(system2, props);
    });
    React$1.useImperativeHandle(ref, always(buildMethods(system2)));
    return React$1.createElement(
      Context.Provider,
      { value: system2 },
      Root ? React$1.createElement(
        Root,
        omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props),
        children
      ) : children
    );
  });
  const usePublisher2 = /* @__PURE__ */ __name((key) => {
    return React$1.useCallback(curry2to1(publish, React$1.useContext(Context)[key]), [key]);
  }, "usePublisher2");
  const useEmitterValue18 = /* @__PURE__ */ __name((key) => {
    const system2 = React$1.useContext(Context);
    const source = system2[key];
    const cb2 = React$1.useCallback(
      (c2) => {
        return subscribe(source, c2);
      },
      [source]
    );
    return React$1.useSyncExternalStore(
      cb2,
      () => getValue(source),
      () => getValue(source)
    );
  }, "useEmitterValue18");
  const useEmitterValueLegacy = /* @__PURE__ */ __name((key) => {
    const system2 = React$1.useContext(Context);
    const source = system2[key];
    const [value, setValue] = React$1.useState(curry1to0(getValue, source));
    useIsomorphicLayoutEffect$2(
      () => subscribe(source, (next2) => {
        if (next2 !== value) {
          setValue(always(next2));
        }
      }),
      [source, value]
    );
    return value;
  }, "useEmitterValueLegacy");
  const useEmitterValue2 = React$1.version.startsWith("18") ? useEmitterValue18 : useEmitterValueLegacy;
  const useEmitter2 = /* @__PURE__ */ __name((key, callback) => {
    const context = React$1.useContext(Context);
    const source = context[key];
    useIsomorphicLayoutEffect$2(() => subscribe(source, callback), [callback, source]);
  }, "useEmitter2");
  return {
    Component,
    usePublisher: usePublisher2,
    useEmitterValue: useEmitterValue2,
    useEmitter: useEmitter2
  };
}
__name(systemToComponent, "systemToComponent");
const useIsomorphicLayoutEffect = typeof document !== "undefined" ? React$1.useLayoutEffect : React$1.useEffect;
const useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  return LogLevel2;
})(LogLevel || {});
const CONSOLE_METHOD_MAP = {
  [
    0
    /* DEBUG */
  ]: "debug",
  [
    1
    /* INFO */
  ]: "log",
  [
    2
    /* WARN */
  ]: "warn",
  [
    3
    /* ERROR */
  ]: "error"
};
const getGlobalThis = /* @__PURE__ */ __name(() => typeof globalThis === "undefined" ? window : globalThis, "getGlobalThis");
const loggerSystem = system(
  () => {
    const logLevel = statefulStream(
      3
      /* ERROR */
    );
    const log = statefulStream((label, message, level = 1) => {
      var _a2;
      const currentLevel = (_a2 = getGlobalThis()["VIRTUOSO_LOG_LEVEL"]) != null ? _a2 : getValue(logLevel);
      if (level >= currentLevel) {
        console[CONSOLE_METHOD_MAP[level]](
          "%creact-virtuoso: %c%s %o",
          "color: #0253b3; font-weight: bold",
          "color: initial",
          label,
          message
        );
      }
    });
    return {
      log,
      logLevel
    };
  },
  [],
  { singleton: true }
);
function useSizeWithElRef(callback, enabled, skipAnimationFrame) {
  const ref = React$1.useRef(null);
  let callbackRef = /* @__PURE__ */ __name((_el) => {
  }, "callbackRef");
  if (typeof ResizeObserver !== "undefined") {
    const observer = React$1.useMemo(() => {
      return new ResizeObserver((entries) => {
        const code = /* @__PURE__ */ __name(() => {
          const element = entries[0].target;
          if (element.offsetParent !== null) {
            callback(element);
          }
        }, "code");
        skipAnimationFrame ? code() : requestAnimationFrame(code);
      });
    }, [callback]);
    callbackRef = /* @__PURE__ */ __name((elRef) => {
      if (elRef && enabled) {
        observer.observe(elRef);
        ref.current = elRef;
      } else {
        if (ref.current) {
          observer.unobserve(ref.current);
        }
        ref.current = null;
      }
    }, "callbackRef");
  }
  return { ref, callbackRef };
}
__name(useSizeWithElRef, "useSizeWithElRef");
function useSize(callback, enabled, skipAnimationFrame) {
  return useSizeWithElRef(callback, enabled, skipAnimationFrame).callbackRef;
}
__name(useSize, "useSize");
function useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap2, customScrollParent, horizontalDirection, skipAnimationFrame) {
  const memoedCallback = React$1.useCallback(
    (el2) => {
      const ranges = getChangedChildSizes(el2.children, itemSize, "offsetHeight", log);
      let scrollableElement = el2.parentElement;
      while (!scrollableElement.dataset["virtuosoScroller"]) {
        scrollableElement = scrollableElement.parentElement;
      }
      const windowScrolling = scrollableElement.lastElementChild.dataset["viewportType"] === "window";
      const scrollTop = customScrollParent ? customScrollParent.scrollTop : windowScrolling ? window.pageYOffset || document.documentElement.scrollTop : scrollableElement.scrollTop;
      const scrollHeight = customScrollParent ? customScrollParent.scrollHeight : windowScrolling ? document.documentElement.scrollHeight : scrollableElement.scrollHeight;
      const viewportHeight = customScrollParent ? customScrollParent.offsetHeight : windowScrolling ? window.innerHeight : scrollableElement.offsetHeight;
      scrollContainerStateCallback({
        scrollTop: Math.max(scrollTop, 0),
        scrollHeight,
        viewportHeight
      });
      if (ranges !== null) {
        callback(ranges);
      }
    },
    [callback, itemSize, log, gap2, customScrollParent, scrollContainerStateCallback]
  );
  return useSizeWithElRef(memoedCallback, enabled, skipAnimationFrame);
}
__name(useChangedListContentsSizes, "useChangedListContentsSizes");
function getChangedChildSizes(children, itemSize, field, log) {
  const length2 = children.length;
  if (length2 === 0) {
    return null;
  }
  const results = [];
  for (let i = 0; i < length2; i++) {
    const child = children.item(i);
    if (!child || child.dataset.index === void 0) {
      continue;
    }
    const index2 = parseInt(child.dataset.index);
    const knownSize = parseFloat(child.dataset.knownSize);
    const size2 = itemSize(child, field);
    if (size2 === 0) {
      log("Zero-sized element, this should not happen", { child }, LogLevel.ERROR);
    }
    if (size2 === knownSize) {
      continue;
    }
    const lastResult = results[results.length - 1];
    if (results.length === 0 || lastResult.size !== size2 || lastResult.endIndex !== index2 - 1) {
      results.push({ startIndex: index2, endIndex: index2, size: size2 });
    } else {
      results[results.length - 1].endIndex++;
    }
  }
  return results;
}
__name(getChangedChildSizes, "getChangedChildSizes");
function correctItemSize(el2, dimension) {
  return Math.round(el2.getBoundingClientRect()[dimension]);
}
__name(correctItemSize, "correctItemSize");
function approximatelyEqual(num1, num2) {
  return Math.abs(num1 - num2) < 1.01;
}
__name(approximatelyEqual, "approximatelyEqual");
function useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop$1, customScrollParent, horizontalDirection) {
  const scrollerRef = React$1.useRef(null);
  const scrollTopTarget = React$1.useRef(null);
  const timeoutRef = React$1.useRef(null);
  const handler = React$1.useCallback(
    (ev) => {
      const el2 = ev.target;
      const windowScroll = el2 === window || el2 === document;
      const scrollTop = horizontalDirection ? windowScroll ? window.pageXOffset || document.documentElement.scrollLeft : el2.scrollLeft : windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el2.scrollTop;
      const scrollHeight = horizontalDirection ? windowScroll ? document.documentElement.scrollWidth : el2.scrollWidth : windowScroll ? document.documentElement.scrollHeight : el2.scrollHeight;
      const viewportHeight = horizontalDirection ? windowScroll ? window.innerWidth : el2.offsetWidth : windowScroll ? window.innerHeight : el2.offsetHeight;
      const call2 = /* @__PURE__ */ __name(() => {
        scrollContainerStateCallback({
          scrollTop: Math.max(scrollTop, 0),
          scrollHeight,
          viewportHeight
        });
      }, "call2");
      if (ev.suppressFlushSync) {
        call2();
      } else {
        ReactDOM.flushSync(call2);
      }
      if (scrollTopTarget.current !== null) {
        if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {
          scrollTopTarget.current = null;
          smoothScrollTargetReached(true);
          if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
          }
        }
      }
    },
    [scrollContainerStateCallback, smoothScrollTargetReached]
  );
  React$1.useEffect(() => {
    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;
    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);
    handler({ target: localRef, suppressFlushSync: true });
    localRef.addEventListener("scroll", handler, { passive: true });
    return () => {
      scrollerRefCallback(null);
      localRef.removeEventListener("scroll", handler);
    };
  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);
  function scrollToCallback(location) {
    const scrollerElement2 = scrollerRef.current;
    if (!scrollerElement2 || (horizontalDirection ? "offsetWidth" in scrollerElement2 && scrollerElement2.offsetWidth === 0 : "offsetHeight" in scrollerElement2 && scrollerElement2.offsetHeight === 0)) {
      return;
    }
    const isSmooth = location.behavior === "smooth";
    let offsetHeight;
    let scrollHeight;
    let scrollTop;
    if (scrollerElement2 === window) {
      scrollHeight = Math.max(
        correctItemSize(document.documentElement, horizontalDirection ? "width" : "height"),
        horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight
      );
      offsetHeight = horizontalDirection ? window.innerWidth : window.innerHeight;
      scrollTop = horizontalDirection ? document.documentElement.scrollLeft : document.documentElement.scrollTop;
    } else {
      scrollHeight = scrollerElement2[horizontalDirection ? "scrollWidth" : "scrollHeight"];
      offsetHeight = correctItemSize(scrollerElement2, horizontalDirection ? "width" : "height");
      scrollTop = scrollerElement2[horizontalDirection ? "scrollLeft" : "scrollTop"];
    }
    const maxScrollTop = scrollHeight - offsetHeight;
    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));
    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {
      scrollContainerStateCallback({ scrollTop, scrollHeight, viewportHeight: offsetHeight });
      if (isSmooth) {
        smoothScrollTargetReached(true);
      }
      return;
    }
    if (isSmooth) {
      scrollTopTarget.current = location.top;
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = setTimeout(() => {
        timeoutRef.current = null;
        scrollTopTarget.current = null;
        smoothScrollTargetReached(true);
      }, 1e3);
    } else {
      scrollTopTarget.current = null;
    }
    if (horizontalDirection) {
      location = { left: location.top, behavior: location.behavior };
    }
    scrollerElement2.scrollTo(location);
  }
  __name(scrollToCallback, "scrollToCallback");
  function scrollByCallback(location) {
    if (horizontalDirection) {
      location = { left: location.top, behavior: location.behavior };
    }
    scrollerRef.current.scrollBy(location);
  }
  __name(scrollByCallback, "scrollByCallback");
  return { scrollerRef, scrollByCallback, scrollToCallback };
}
__name(useScrollTop, "useScrollTop");
const domIOSystem = system(
  () => {
    const scrollContainerState = stream();
    const scrollTop = stream();
    const deviation = statefulStream(0);
    const smoothScrollTargetReached = stream();
    const statefulScrollTop = statefulStream(0);
    const viewportHeight = stream();
    const scrollHeight = stream();
    const headerHeight = statefulStream(0);
    const fixedHeaderHeight = statefulStream(0);
    const fixedFooterHeight = statefulStream(0);
    const footerHeight = statefulStream(0);
    const scrollTo = stream();
    const scrollBy = stream();
    const scrollingInProgress = statefulStream(false);
    const horizontalDirection = statefulStream(false);
    const skipAnimationFrameInResizeObserver = statefulStream(false);
    connect(
      pipe(
        scrollContainerState,
        map(({ scrollTop: scrollTop2 }) => scrollTop2)
      ),
      scrollTop
    );
    connect(
      pipe(
        scrollContainerState,
        map(({ scrollHeight: scrollHeight2 }) => scrollHeight2)
      ),
      scrollHeight
    );
    connect(scrollTop, statefulScrollTop);
    return {
      // input
      scrollContainerState,
      scrollTop,
      viewportHeight,
      headerHeight,
      fixedHeaderHeight,
      fixedFooterHeight,
      footerHeight,
      scrollHeight,
      smoothScrollTargetReached,
      horizontalDirection,
      skipAnimationFrameInResizeObserver,
      // signals
      scrollTo,
      scrollBy,
      // state
      statefulScrollTop,
      deviation,
      scrollingInProgress
    };
  },
  [],
  { singleton: true }
);
const NIL_NODE = { lvl: 0 };
function newAANode(k2, v2, lvl, l2 = NIL_NODE, r2 = NIL_NODE) {
  return { k: k2, v: v2, lvl, l: l2, r: r2 };
}
__name(newAANode, "newAANode");
function empty(node2) {
  return node2 === NIL_NODE;
}
__name(empty, "empty");
function newTree() {
  return NIL_NODE;
}
__name(newTree, "newTree");
function remove(node2, key) {
  if (empty(node2))
    return NIL_NODE;
  const { k: k2, l: l2, r: r2 } = node2;
  if (key === k2) {
    if (empty(l2)) {
      return r2;
    } else if (empty(r2)) {
      return l2;
    } else {
      const [lastKey, lastValue] = last(l2);
      return adjust(clone(node2, { k: lastKey, v: lastValue, l: deleteLast(l2) }));
    }
  } else if (key < k2) {
    return adjust(clone(node2, { l: remove(l2, key) }));
  } else {
    return adjust(clone(node2, { r: remove(r2, key) }));
  }
}
__name(remove, "remove");
function find(node2, key) {
  if (empty(node2)) {
    return;
  }
  if (key === node2.k) {
    return node2.v;
  } else if (key < node2.k) {
    return find(node2.l, key);
  } else {
    return find(node2.r, key);
  }
}
__name(find, "find");
function findMaxKeyValue(node2, value, field = "k") {
  if (empty(node2)) {
    return [-Infinity, void 0];
  }
  if (Number(node2[field]) === value) {
    return [node2.k, node2.v];
  }
  if (Number(node2[field]) < value) {
    const r2 = findMaxKeyValue(node2.r, value, field);
    if (r2[0] === -Infinity) {
      return [node2.k, node2.v];
    } else {
      return r2;
    }
  }
  return findMaxKeyValue(node2.l, value, field);
}
__name(findMaxKeyValue, "findMaxKeyValue");
function insert(node2, k2, v2) {
  if (empty(node2)) {
    return newAANode(k2, v2, 1);
  }
  if (k2 === node2.k) {
    return clone(node2, { k: k2, v: v2 });
  } else if (k2 < node2.k) {
    return rebalance(clone(node2, { l: insert(node2.l, k2, v2) }));
  } else {
    return rebalance(clone(node2, { r: insert(node2.r, k2, v2) }));
  }
}
__name(insert, "insert");
function walkWithin(node2, start2, end2) {
  if (empty(node2)) {
    return [];
  }
  const { k: k2, v: v2, l: l2, r: r2 } = node2;
  let result = [];
  if (k2 > start2) {
    result = result.concat(walkWithin(l2, start2, end2));
  }
  if (k2 >= start2 && k2 <= end2) {
    result.push({ k: k2, v: v2 });
  }
  if (k2 <= end2) {
    result = result.concat(walkWithin(r2, start2, end2));
  }
  return result;
}
__name(walkWithin, "walkWithin");
function walk(node2) {
  if (empty(node2)) {
    return [];
  }
  return [...walk(node2.l), { k: node2.k, v: node2.v }, ...walk(node2.r)];
}
__name(walk, "walk");
function last(node2) {
  return empty(node2.r) ? [node2.k, node2.v] : last(node2.r);
}
__name(last, "last");
function deleteLast(node2) {
  return empty(node2.r) ? node2.l : adjust(clone(node2, { r: deleteLast(node2.r) }));
}
__name(deleteLast, "deleteLast");
function clone(node2, args) {
  return newAANode(
    args.k !== void 0 ? args.k : node2.k,
    args.v !== void 0 ? args.v : node2.v,
    args.lvl !== void 0 ? args.lvl : node2.lvl,
    args.l !== void 0 ? args.l : node2.l,
    args.r !== void 0 ? args.r : node2.r
  );
}
__name(clone, "clone");
function isSingle(node2) {
  return empty(node2) || node2.lvl > node2.r.lvl;
}
__name(isSingle, "isSingle");
function rebalance(node2) {
  return split(skew(node2));
}
__name(rebalance, "rebalance");
function adjust(node2) {
  const { l: l2, r: r2, lvl } = node2;
  if (r2.lvl >= lvl - 1 && l2.lvl >= lvl - 1) {
    return node2;
  } else if (lvl > r2.lvl + 1) {
    if (isSingle(l2)) {
      return skew(clone(node2, { lvl: lvl - 1 }));
    } else {
      if (!empty(l2) && !empty(l2.r)) {
        return clone(l2.r, {
          l: clone(l2, { r: l2.r.l }),
          r: clone(node2, {
            l: l2.r.r,
            lvl: lvl - 1
          }),
          lvl
        });
      } else {
        throw new Error("Unexpected empty nodes");
      }
    }
  } else {
    if (isSingle(node2)) {
      return split(clone(node2, { lvl: lvl - 1 }));
    } else {
      if (!empty(r2) && !empty(r2.l)) {
        const rl2 = r2.l;
        const rlvl = isSingle(rl2) ? r2.lvl - 1 : r2.lvl;
        return clone(rl2, {
          l: clone(node2, {
            r: rl2.l,
            lvl: lvl - 1
          }),
          r: split(clone(r2, { l: rl2.r, lvl: rlvl })),
          lvl: rl2.lvl + 1
        });
      } else {
        throw new Error("Unexpected empty nodes");
      }
    }
  }
}
__name(adjust, "adjust");
function rangesWithin(node2, startIndex, endIndex) {
  if (empty(node2)) {
    return [];
  }
  const adjustedStart = findMaxKeyValue(node2, startIndex)[0];
  return toRanges(walkWithin(node2, adjustedStart, endIndex));
}
__name(rangesWithin, "rangesWithin");
function arrayToRanges(items, parser) {
  const length2 = items.length;
  if (length2 === 0) {
    return [];
  }
  let { index: start2, value } = parser(items[0]);
  const result = [];
  for (let i = 1; i < length2; i++) {
    const { index: nextIndex, value: nextValue } = parser(items[i]);
    result.push({ start: start2, end: nextIndex - 1, value });
    start2 = nextIndex;
    value = nextValue;
  }
  result.push({ start: start2, end: Infinity, value });
  return result;
}
__name(arrayToRanges, "arrayToRanges");
function toRanges(nodes) {
  return arrayToRanges(nodes, ({ k: index2, v: value }) => ({ index: index2, value }));
}
__name(toRanges, "toRanges");
function split(node2) {
  const { r: r2, lvl } = node2;
  return !empty(r2) && !empty(r2.r) && r2.lvl === lvl && r2.r.lvl === lvl ? clone(r2, { l: clone(node2, { r: r2.l }), lvl: lvl + 1 }) : node2;
}
__name(split, "split");
function skew(node2) {
  const { l: l2 } = node2;
  return !empty(l2) && l2.lvl === node2.lvl ? clone(l2, { r: clone(node2, { l: l2.r }) }) : node2;
}
__name(skew, "skew");
function findIndexOfClosestSmallerOrEqual(items, value, comparator, start2 = 0) {
  let end2 = items.length - 1;
  while (start2 <= end2) {
    const index2 = Math.floor((start2 + end2) / 2);
    const item = items[index2];
    const match2 = comparator(item, value);
    if (match2 === 0) {
      return index2;
    }
    if (match2 === -1) {
      if (end2 - start2 < 2) {
        return index2 - 1;
      }
      end2 = index2 - 1;
    } else {
      if (end2 === start2) {
        return index2;
      }
      start2 = index2 + 1;
    }
  }
  throw new Error(`Failed binary finding record in array - ${items.join(",")}, searched for ${value}`);
}
__name(findIndexOfClosestSmallerOrEqual, "findIndexOfClosestSmallerOrEqual");
function findClosestSmallerOrEqual(items, value, comparator) {
  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];
}
__name(findClosestSmallerOrEqual, "findClosestSmallerOrEqual");
function findRange(items, startValue, endValue, comparator) {
  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);
  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);
  return items.slice(startIndex, endIndex + 1);
}
__name(findRange, "findRange");
const recalcSystem = system(
  () => {
    const recalcInProgress = statefulStream(false);
    return { recalcInProgress };
  },
  [],
  { singleton: true }
);
function rangeIncludes(refRange) {
  const { size: size2, startIndex, endIndex } = refRange;
  return (range2) => {
    return range2.start === startIndex && (range2.end === endIndex || range2.end === Infinity) && range2.value === size2;
  };
}
__name(rangeIncludes, "rangeIncludes");
function affectedGroupCount(offset2, groupIndices) {
  let recognizedOffsetItems = 0;
  let groupIndex = 0;
  while (recognizedOffsetItems < offset2) {
    recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;
    groupIndex++;
  }
  const offsetIsExact = recognizedOffsetItems === offset2;
  return groupIndex - (offsetIsExact ? 0 : 1);
}
__name(affectedGroupCount, "affectedGroupCount");
function insertRanges(sizeTree, ranges) {
  let syncStart = empty(sizeTree) ? 0 : Infinity;
  for (const range2 of ranges) {
    const { size: size2, startIndex, endIndex } = range2;
    syncStart = Math.min(syncStart, startIndex);
    if (empty(sizeTree)) {
      sizeTree = insert(sizeTree, 0, size2);
      continue;
    }
    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);
    if (overlappingRanges.some(rangeIncludes(range2))) {
      continue;
    }
    let firstPassDone = false;
    let shouldInsert = false;
    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlappingRanges) {
      if (!firstPassDone) {
        shouldInsert = rangeValue !== size2;
        firstPassDone = true;
      } else {
        if (endIndex >= rangeStart || size2 === rangeValue) {
          sizeTree = remove(sizeTree, rangeStart);
        }
      }
      if (rangeEnd > endIndex && endIndex >= rangeStart) {
        if (rangeValue !== size2) {
          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);
        }
      }
    }
    if (shouldInsert) {
      sizeTree = insert(sizeTree, startIndex, size2);
    }
  }
  return [sizeTree, syncStart];
}
__name(insertRanges, "insertRanges");
function initialSizeState() {
  return {
    offsetTree: [],
    sizeTree: newTree(),
    groupOffsetTree: newTree(),
    lastIndex: 0,
    lastOffset: 0,
    lastSize: 0,
    groupIndices: []
  };
}
__name(initialSizeState, "initialSizeState");
function indexComparator({ index: itemIndex }, index2) {
  return index2 === itemIndex ? 0 : index2 < itemIndex ? -1 : 1;
}
__name(indexComparator, "indexComparator");
function offsetComparator({ offset: itemOffset }, offset2) {
  return offset2 === itemOffset ? 0 : offset2 < itemOffset ? -1 : 1;
}
__name(offsetComparator, "offsetComparator");
function offsetPointParser(point) {
  return { index: point.index, value: point };
}
__name(offsetPointParser, "offsetPointParser");
function rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {
  if (minStartIndex > 0) {
    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);
  }
  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);
}
__name(rangesWithinOffsets, "rangesWithinOffsets");
function createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap2) {
  let offsetTree = prevOffsetTree;
  let prevIndex = 0;
  let prevSize = 0;
  let prevOffset = 0;
  let startIndex = 0;
  if (syncStart !== 0) {
    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);
    const offsetInfo = offsetTree[startIndex];
    prevOffset = offsetInfo.offset;
    const kv = findMaxKeyValue(sizeTree, syncStart - 1);
    prevIndex = kv[0];
    prevSize = kv[1];
    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {
      startIndex -= 1;
    }
    offsetTree = offsetTree.slice(0, startIndex + 1);
  } else {
    offsetTree = [];
  }
  for (const { start: startIndex2, value } of rangesWithin(sizeTree, syncStart, Infinity)) {
    const indexOffset = startIndex2 - prevIndex;
    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap2;
    offsetTree.push({
      offset: aOffset,
      size: value,
      index: startIndex2
    });
    prevIndex = startIndex2;
    prevOffset = aOffset;
    prevSize = value;
  }
  return {
    offsetTree,
    lastIndex: prevIndex,
    lastOffset: prevOffset,
    lastSize: prevSize
  };
}
__name(createOffsetTree, "createOffsetTree");
function sizeStateReducer(state, [ranges, groupIndices, log, gap2]) {
  if (ranges.length > 0) {
    log("received item sizes", ranges, LogLevel.DEBUG);
  }
  const sizeTree = state.sizeTree;
  let newSizeTree = sizeTree;
  let syncStart = 0;
  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {
    const groupSize = ranges[0].size;
    const itemSize = ranges[1].size;
    newSizeTree = groupIndices.reduce((tree, groupIndex) => {
      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);
    }, newSizeTree);
  } else {
    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);
  }
  if (newSizeTree === sizeTree) {
    return state;
  }
  const { offsetTree: newOffsetTree, lastIndex, lastSize, lastOffset } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap2);
  return {
    sizeTree: newSizeTree,
    offsetTree: newOffsetTree,
    lastIndex,
    lastOffset,
    lastSize,
    groupOffsetTree: groupIndices.reduce((tree, index2) => {
      return insert(tree, index2, offsetOf(index2, newOffsetTree, gap2));
    }, newTree()),
    groupIndices
  };
}
__name(sizeStateReducer, "sizeStateReducer");
function offsetOf(index2, tree, gap2) {
  if (tree.length === 0) {
    return 0;
  }
  const { offset: offset2, index: startIndex, size: size2 } = findClosestSmallerOrEqual(tree, index2, indexComparator);
  const itemCount = index2 - startIndex;
  const top2 = size2 * itemCount + (itemCount - 1) * gap2 + offset2;
  return top2 > 0 ? top2 + gap2 : top2;
}
__name(offsetOf, "offsetOf");
function isGroupLocation(location) {
  return typeof location.groupIndex !== "undefined";
}
__name(isGroupLocation, "isGroupLocation");
function originalIndexFromLocation(location, sizes, lastIndex) {
  if (isGroupLocation(location)) {
    return sizes.groupIndices[location.groupIndex] + 1;
  } else {
    const numericIndex = location.index === "LAST" ? lastIndex : location.index;
    let result = originalIndexFromItemIndex(numericIndex, sizes);
    result = Math.max(0, result, Math.min(lastIndex, result));
    return result;
  }
}
__name(originalIndexFromLocation, "originalIndexFromLocation");
function originalIndexFromItemIndex(itemIndex, sizes) {
  if (!hasGroups(sizes)) {
    return itemIndex;
  }
  let groupOffset = 0;
  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {
    groupOffset++;
  }
  return itemIndex + groupOffset;
}
__name(originalIndexFromItemIndex, "originalIndexFromItemIndex");
function hasGroups(sizes) {
  return !empty(sizes.groupOffsetTree);
}
__name(hasGroups, "hasGroups");
function sizeTreeToRanges(sizeTree) {
  return walk(sizeTree).map(({ k: startIndex, v: size2 }, index2, sizeArray) => {
    const nextSize = sizeArray[index2 + 1];
    const endIndex = nextSize ? nextSize.k - 1 : Infinity;
    return { startIndex, endIndex, size: size2 };
  });
}
__name(sizeTreeToRanges, "sizeTreeToRanges");
const SIZE_MAP = {
  offsetHeight: "height",
  offsetWidth: "width"
};
const sizeSystem = system(
  ([{ log }, { recalcInProgress }]) => {
    const sizeRanges = stream();
    const totalCount = stream();
    const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);
    const unshiftWith = stream();
    const shiftWith = stream();
    const firstItemIndex = statefulStream(0);
    const groupIndices = statefulStream([]);
    const fixedItemSize = statefulStream(void 0);
    const defaultItemSize = statefulStream(void 0);
    const itemSize = statefulStream((el2, field) => correctItemSize(el2, SIZE_MAP[field]));
    const data = statefulStream(void 0);
    const gap2 = statefulStream(0);
    const initial = initialSizeState();
    const sizes = statefulStreamFromEmitter(
      pipe(sizeRanges, withLatestFrom(groupIndices, log, gap2), scan(sizeStateReducer, initial), distinctUntilChanged()),
      initial
    );
    const prevGroupIndices = statefulStreamFromEmitter(
      pipe(
        groupIndices,
        distinctUntilChanged(),
        scan((prev2, curr) => ({ prev: prev2.current, current: curr }), {
          prev: [],
          current: []
        }),
        map(({ prev: prev2 }) => prev2)
      ),
      []
    );
    connect(
      pipe(
        groupIndices,
        filter2((indexes) => indexes.length > 0),
        withLatestFrom(sizes, gap2),
        map(([groupIndices2, sizes2, gap22]) => {
          const groupOffsetTree = groupIndices2.reduce((tree, index2, idx) => {
            return insert(tree, index2, offsetOf(index2, sizes2.offsetTree, gap22) || idx);
          }, newTree());
          return {
            ...sizes2,
            groupIndices: groupIndices2,
            groupOffsetTree
          };
        })
      ),
      sizes
    );
    connect(
      pipe(
        totalCount,
        withLatestFrom(sizes),
        filter2(([totalCount2, { lastIndex }]) => {
          return totalCount2 < lastIndex;
        }),
        map(([totalCount2, { lastIndex, lastSize }]) => {
          return [
            {
              startIndex: totalCount2,
              endIndex: lastIndex,
              size: lastSize
            }
          ];
        })
      ),
      sizeRanges
    );
    connect(fixedItemSize, defaultItemSize);
    const trackItemSizes = statefulStreamFromEmitter(
      pipe(
        fixedItemSize,
        map((size2) => size2 === void 0)
      ),
      true
    );
    connect(
      pipe(
        defaultItemSize,
        filter2((value) => {
          return value !== void 0 && empty(getValue(sizes).sizeTree);
        }),
        map((size2) => [{ startIndex: 0, endIndex: 0, size: size2 }])
      ),
      sizeRanges
    );
    const listRefresh = streamFromEmitter(
      pipe(
        sizeRanges,
        withLatestFrom(sizes),
        scan(
          ({ sizes: oldSizes }, [_2, newSizes]) => {
            return {
              changed: newSizes !== oldSizes,
              sizes: newSizes
            };
          },
          { changed: false, sizes: initial }
        ),
        map((value) => value.changed)
      )
    );
    subscribe(
      pipe(
        firstItemIndex,
        scan(
          (prev2, next2) => {
            return { diff: prev2.prev - next2, prev: next2 };
          },
          { diff: 0, prev: 0 }
        ),
        map((val) => val.diff)
      ),
      (offset2) => {
        const { groupIndices: groupIndices2 } = getValue(sizes);
        if (offset2 > 0) {
          publish(recalcInProgress, true);
          publish(unshiftWith, offset2 + affectedGroupCount(offset2, groupIndices2));
        } else if (offset2 < 0) {
          const prevGroupIndicesValue = getValue(prevGroupIndices);
          if (prevGroupIndicesValue.length > 0) {
            offset2 -= affectedGroupCount(-offset2, prevGroupIndicesValue);
          }
          publish(shiftWith, offset2);
        }
      }
    );
    subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index2, log2]) => {
      if (index2 < 0) {
        log2(
          "`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
          { firstItemIndex },
          LogLevel.ERROR
        );
      }
    });
    const beforeUnshiftWith = streamFromEmitter(unshiftWith);
    connect(
      pipe(
        unshiftWith,
        withLatestFrom(sizes),
        map(([unshiftWith2, sizes2]) => {
          const groupedMode = sizes2.groupIndices.length > 0;
          const initialRanges = [];
          const defaultSize = sizes2.lastSize;
          if (groupedMode) {
            const firstGroupSize = find(sizes2.sizeTree, 0);
            let prependedGroupItemsCount = 0;
            let groupIndex = 0;
            while (prependedGroupItemsCount < unshiftWith2) {
              const theGroupIndex = sizes2.groupIndices[groupIndex];
              const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;
              initialRanges.push({
                startIndex: theGroupIndex,
                endIndex: theGroupIndex,
                size: firstGroupSize
              });
              initialRanges.push({
                startIndex: theGroupIndex + 1,
                endIndex: theGroupIndex + 1 + groupItemCount - 1,
                size: defaultSize
              });
              groupIndex++;
              prependedGroupItemsCount += groupItemCount + 1;
            }
            const sizeTreeKV = walk(sizes2.sizeTree);
            const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;
            if (firstGroupIsExpanded) {
              sizeTreeKV.shift();
            }
            return sizeTreeKV.reduce(
              (acc, { k: index2, v: size2 }) => {
                let ranges = acc.ranges;
                if (acc.prevSize !== 0) {
                  ranges = [
                    ...acc.ranges,
                    {
                      startIndex: acc.prevIndex,
                      endIndex: index2 + unshiftWith2 - 1,
                      size: acc.prevSize
                    }
                  ];
                }
                return {
                  ranges,
                  prevIndex: index2 + unshiftWith2,
                  prevSize: size2
                };
              },
              {
                ranges: initialRanges,
                prevIndex: unshiftWith2,
                prevSize: 0
              }
            ).ranges;
          }
          return walk(sizes2.sizeTree).reduce(
            (acc, { k: index2, v: size2 }) => {
              return {
                ranges: [...acc.ranges, { startIndex: acc.prevIndex, endIndex: index2 + unshiftWith2 - 1, size: acc.prevSize }],
                prevIndex: index2 + unshiftWith2,
                prevSize: size2
              };
            },
            {
              ranges: [],
              prevIndex: 0,
              prevSize: defaultSize
            }
          ).ranges;
        })
      ),
      sizeRanges
    );
    const shiftWithOffset = streamFromEmitter(
      pipe(
        shiftWith,
        withLatestFrom(sizes, gap2),
        map(([shiftWith2, { offsetTree }, gap22]) => {
          const newFirstItemIndex = -shiftWith2;
          return offsetOf(newFirstItemIndex, offsetTree, gap22);
        })
      )
    );
    connect(
      pipe(
        shiftWith,
        withLatestFrom(sizes, gap2),
        map(([shiftWith2, sizes2, gap22]) => {
          const groupedMode = sizes2.groupIndices.length > 0;
          if (groupedMode) {
            if (empty(sizes2.sizeTree)) {
              return sizes2;
            }
            let newSizeTree = newTree();
            const prevGroupIndicesValue = getValue(prevGroupIndices);
            let removedItemsCount = 0;
            let groupIndex = 0;
            let groupOffset = 0;
            while (removedItemsCount < -shiftWith2) {
              groupOffset = prevGroupIndicesValue[groupIndex];
              const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;
              groupIndex++;
              removedItemsCount += groupItemCount + 1;
            }
            newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k: k2, v: v2 }) => {
              return insert(acc, Math.max(0, k2 + shiftWith2), v2);
            }, newSizeTree);
            const aGroupIsShrunk = removedItemsCount !== -shiftWith2;
            if (aGroupIsShrunk) {
              const firstGroupSize = find(sizes2.sizeTree, groupOffset);
              newSizeTree = insert(newSizeTree, 0, firstGroupSize);
              const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];
              newSizeTree = insert(newSizeTree, 1, nextItemSize);
            }
            return {
              ...sizes2,
              sizeTree: newSizeTree,
              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap22)
            };
          } else {
            const newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k: k2, v: v2 }) => {
              return insert(acc, Math.max(0, k2 + shiftWith2), v2);
            }, newTree());
            return {
              ...sizes2,
              sizeTree: newSizeTree,
              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap22)
            };
          }
        })
      ),
      sizes
    );
    return {
      // input
      data,
      totalCount,
      sizeRanges,
      groupIndices,
      defaultItemSize,
      fixedItemSize,
      unshiftWith,
      shiftWith,
      shiftWithOffset,
      beforeUnshiftWith,
      firstItemIndex,
      gap: gap2,
      // output
      sizes,
      listRefresh,
      statefulTotalCount,
      trackItemSizes,
      itemSize
    };
  },
  tup(loggerSystem, recalcSystem),
  { singleton: true }
);
const SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== "undefined" && "scrollBehavior" in document.documentElement.style;
function normalizeIndexLocation(location) {
  const result = typeof location === "number" ? { index: location } : location;
  if (!result.align) {
    result.align = "start";
  }
  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {
    result.behavior = "auto";
  }
  if (!result.offset) {
    result.offset = 0;
  }
  return result;
}
__name(normalizeIndexLocation, "normalizeIndexLocation");
const scrollToIndexSystem = system(
  ([
    { sizes, totalCount, listRefresh, gap: gap2 },
    {
      scrollingInProgress,
      viewportHeight,
      scrollTo,
      smoothScrollTargetReached,
      headerHeight,
      footerHeight,
      fixedHeaderHeight,
      fixedFooterHeight
    },
    { log }
  ]) => {
    const scrollToIndex = stream();
    const scrollTargetReached = stream();
    const topListHeight = statefulStream(0);
    let unsubscribeNextListRefresh = null;
    let cleartTimeoutRef = null;
    let unsubscribeListRefresh = null;
    function cleanup() {
      if (unsubscribeNextListRefresh) {
        unsubscribeNextListRefresh();
        unsubscribeNextListRefresh = null;
      }
      if (unsubscribeListRefresh) {
        unsubscribeListRefresh();
        unsubscribeListRefresh = null;
      }
      if (cleartTimeoutRef) {
        clearTimeout(cleartTimeoutRef);
        cleartTimeoutRef = null;
      }
      publish(scrollingInProgress, false);
    }
    __name(cleanup, "cleanup");
    connect(
      pipe(
        scrollToIndex,
        withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log),
        withLatestFrom(gap2, fixedHeaderHeight, fixedFooterHeight),
        map(
          ([
            [location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2],
            gap22,
            fixedHeaderHeight2,
            fixedFooterHeight2
          ]) => {
            const normalLocation = normalizeIndexLocation(location);
            const { align, behavior, offset: offset2 } = normalLocation;
            const lastIndex = totalCount2 - 1;
            const index2 = originalIndexFromLocation(normalLocation, sizes2, lastIndex);
            let top2 = offsetOf(index2, sizes2.offsetTree, gap22) + headerHeight2;
            if (align === "end") {
              top2 += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index2)[1] - viewportHeight2 + fixedFooterHeight2;
              if (index2 === lastIndex) {
                top2 += footerHeight2;
              }
            } else if (align === "center") {
              top2 += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index2)[1] - viewportHeight2 + fixedFooterHeight2) / 2;
            } else {
              top2 -= topListHeight2;
            }
            if (offset2) {
              top2 += offset2;
            }
            const retry = /* @__PURE__ */ __name((listChanged) => {
              cleanup();
              if (listChanged) {
                log2("retrying to scroll to", { location }, LogLevel.DEBUG);
                publish(scrollToIndex, location);
              } else {
                publish(scrollTargetReached, true);
                log2("list did not change, scroll successful", {}, LogLevel.DEBUG);
              }
            }, "retry");
            cleanup();
            if (behavior === "smooth") {
              let listChanged = false;
              unsubscribeListRefresh = subscribe(listRefresh, (changed) => {
                listChanged = listChanged || changed;
              });
              unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {
                retry(listChanged);
              });
            } else {
              unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);
            }
            cleartTimeoutRef = setTimeout(() => {
              cleanup();
            }, 1200);
            publish(scrollingInProgress, true);
            log2("scrolling from index to", { index: index2, top: top2, behavior }, LogLevel.DEBUG);
            return { top: top2, behavior };
          }
        )
      ),
      scrollTo
    );
    return {
      scrollToIndex,
      scrollTargetReached,
      topListHeight
    };
  },
  tup(sizeSystem, domIOSystem, loggerSystem),
  { singleton: true }
);
function watchChangesFor(limit) {
  return (done) => {
    const timeoutRef = setTimeout(() => {
      done(false);
    }, limit);
    return (value) => {
      if (value) {
        done(true);
        clearTimeout(timeoutRef);
      }
    };
  };
}
__name(watchChangesFor, "watchChangesFor");
const UP = "up";
const DOWN = "down";
const NONE$1 = "none";
const INITIAL_BOTTOM_STATE = {
  atBottom: false,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollTop: 0,
    viewportHeight: 0,
    scrollHeight: 0
  }
};
const DEFAULT_AT_TOP_THRESHOLD = 0;
const stateFlagsSystem = system(([{ scrollContainerState, scrollTop, viewportHeight, headerHeight, footerHeight, scrollBy }]) => {
  const isAtBottom = statefulStream(false);
  const isAtTop = statefulStream(true);
  const atBottomStateChange = stream();
  const atTopStateChange = stream();
  const atBottomThreshold = statefulStream(4);
  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);
  const isScrolling = statefulStreamFromEmitter(
    pipe(
      merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))),
      distinctUntilChanged()
    ),
    false
  );
  const isScrollingBy = statefulStreamFromEmitter(
    pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()),
    false
  );
  connect(
    pipe(
      combineLatest(duc(scrollTop), duc(atTopThreshold)),
      map(([top2, atTopThreshold2]) => top2 <= atTopThreshold2),
      distinctUntilChanged()
    ),
    isAtTop
  );
  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);
  const atBottomState = streamFromEmitter(
    pipe(
      combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)),
      scan((current, [{ scrollTop: scrollTop2, scrollHeight }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {
        const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;
        const state = {
          viewportHeight: viewportHeight2,
          scrollTop: scrollTop2,
          scrollHeight
        };
        if (isAtBottom2) {
          let atBottomBecause;
          let scrollTopDelta;
          if (scrollTop2 > current.state.scrollTop) {
            atBottomBecause = "SCROLLED_DOWN";
            scrollTopDelta = current.state.scrollTop - scrollTop2;
          } else {
            atBottomBecause = "SIZE_DECREASED";
            scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;
          }
          return {
            atBottom: true,
            state,
            atBottomBecause,
            scrollTopDelta
          };
        }
        let notAtBottomBecause;
        if (state.scrollHeight > current.state.scrollHeight) {
          notAtBottomBecause = "SIZE_INCREASED";
        } else if (viewportHeight2 < current.state.viewportHeight) {
          notAtBottomBecause = "VIEWPORT_HEIGHT_DECREASING";
        } else if (scrollTop2 < current.state.scrollTop) {
          notAtBottomBecause = "SCROLLING_UPWARDS";
        } else {
          notAtBottomBecause = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM";
        }
        return {
          atBottom: false,
          notAtBottomBecause,
          state
        };
      }, INITIAL_BOTTOM_STATE),
      distinctUntilChanged((prev2, next2) => {
        return prev2 && prev2.atBottom === next2.atBottom;
      })
    )
  );
  const lastJumpDueToItemResize = statefulStreamFromEmitter(
    pipe(
      scrollContainerState,
      scan(
        (current, { scrollTop: scrollTop2, scrollHeight, viewportHeight: viewportHeight2 }) => {
          if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {
            const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;
            if (current.scrollTop !== scrollTop2 && atBottom) {
              return {
                scrollHeight,
                scrollTop: scrollTop2,
                jump: current.scrollTop - scrollTop2,
                changed: true
              };
            } else {
              return {
                scrollHeight,
                scrollTop: scrollTop2,
                jump: 0,
                changed: true
              };
            }
          } else {
            return {
              scrollTop: scrollTop2,
              scrollHeight,
              jump: 0,
              changed: false
            };
          }
        },
        { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }
      ),
      filter2((value) => value.changed),
      map((value) => value.jump)
    ),
    0
  );
  connect(
    pipe(
      atBottomState,
      map((state) => state.atBottom)
    ),
    isAtBottom
  );
  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);
  const scrollDirection = statefulStream(DOWN);
  connect(
    pipe(
      scrollContainerState,
      map(({ scrollTop: scrollTop2 }) => scrollTop2),
      distinctUntilChanged(),
      scan(
        (acc, scrollTop2) => {
          if (getValue(isScrollingBy)) {
            return { direction: acc.direction, prevScrollTop: scrollTop2 };
          }
          return { direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN, prevScrollTop: scrollTop2 };
        },
        { direction: DOWN, prevScrollTop: 0 }
      ),
      map((value) => value.direction)
    ),
    scrollDirection
  );
  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);
  const scrollVelocity = statefulStream(0);
  connect(
    pipe(
      isScrolling,
      filter2((value) => !value),
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      mapTo(0)
    ),
    scrollVelocity
  );
  connect(
    pipe(
      scrollTop,
      throttleTime(100),
      withLatestFrom(isScrolling),
      filter2(([_2, isScrolling2]) => !!isScrolling2),
      scan(([_2, prev2], [next2]) => [prev2, next2], [0, 0]),
      map(([prev2, next2]) => next2 - prev2)
    ),
    scrollVelocity
  );
  return {
    isScrolling,
    isAtTop,
    isAtBottom,
    atBottomState,
    atTopStateChange,
    atBottomStateChange,
    scrollDirection,
    atBottomThreshold,
    atTopThreshold,
    scrollVelocity,
    lastJumpDueToItemResize
  };
}, tup(domIOSystem));
const propsReadySystem = system(
  ([{ log }]) => {
    const propsReady = statefulStream(false);
    const didMount = streamFromEmitter(
      pipe(
        propsReady,
        filter2((ready) => ready),
        distinctUntilChanged()
      )
    );
    subscribe(propsReady, (value) => {
      value && getValue(log)("props updated", {}, LogLevel.DEBUG);
    });
    return { propsReady, didMount };
  },
  tup(loggerSystem),
  { singleton: true }
);
function skipFrames(frameCount, callback) {
  if (frameCount == 0) {
    callback();
  } else {
    requestAnimationFrame(() => skipFrames(frameCount - 1, callback));
  }
}
__name(skipFrames, "skipFrames");
function getInitialTopMostItemIndexNumber(location, totalCount) {
  const lastIndex = totalCount - 1;
  const index2 = typeof location === "number" ? location : location.index === "LAST" ? lastIndex : location.index;
  return index2;
}
__name(getInitialTopMostItemIndexNumber, "getInitialTopMostItemIndexNumber");
const initialTopMostItemIndexSystem = system(
  ([{ sizes, listRefresh, defaultItemSize }, { scrollTop }, { scrollToIndex, scrollTargetReached }, { didMount }]) => {
    const scrolledToInitialItem = statefulStream(true);
    const initialTopMostItemIndex = statefulStream(0);
    const initialItemFinalLocationReached = statefulStream(true);
    connect(
      pipe(
        didMount,
        withLatestFrom(initialTopMostItemIndex),
        filter2(([_2, location]) => !!location),
        mapTo(false)
      ),
      scrolledToInitialItem
    );
    connect(
      pipe(
        didMount,
        withLatestFrom(initialTopMostItemIndex),
        filter2(([_2, location]) => !!location),
        mapTo(false)
      ),
      initialItemFinalLocationReached
    );
    subscribe(
      pipe(
        combineLatest(listRefresh, didMount),
        withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, initialItemFinalLocationReached),
        filter2(([[, didMount2], scrolledToInitialItem2, { sizeTree }, defaultItemSize2, scrollScheduled]) => {
          return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled;
        }),
        withLatestFrom(initialTopMostItemIndex)
      ),
      ([, initialTopMostItemIndex2]) => {
        handleNext(scrollTargetReached, () => {
          publish(initialItemFinalLocationReached, true);
        });
        skipFrames(4, () => {
          handleNext(scrollTop, () => {
            publish(scrolledToInitialItem, true);
          });
          publish(scrollToIndex, initialTopMostItemIndex2);
        });
      }
    );
    return {
      scrolledToInitialItem,
      initialTopMostItemIndex,
      initialItemFinalLocationReached
    };
  },
  tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem),
  { singleton: true }
);
function normalizeFollowOutput(follow) {
  if (!follow) {
    return false;
  }
  return follow === "smooth" ? "smooth" : "auto";
}
__name(normalizeFollowOutput, "normalizeFollowOutput");
const behaviorFromFollowOutput = /* @__PURE__ */ __name((follow, isAtBottom) => {
  if (typeof follow === "function") {
    return normalizeFollowOutput(follow(isAtBottom));
  }
  return isAtBottom && normalizeFollowOutput(follow);
}, "behaviorFromFollowOutput");
const followOutputSystem = system(
  ([
    { totalCount, listRefresh },
    { isAtBottom, atBottomState },
    { scrollToIndex },
    { scrolledToInitialItem },
    { propsReady, didMount },
    { log },
    { scrollingInProgress }
  ]) => {
    const followOutput = statefulStream(false);
    const autoscrollToBottom = stream();
    let pendingScrollHandle = null;
    function scrollToBottom(followOutputBehavior) {
      publish(scrollToIndex, {
        index: "LAST",
        align: "end",
        behavior: followOutputBehavior
      });
    }
    __name(scrollToBottom, "scrollToBottom");
    subscribe(
      pipe(
        combineLatest(pipe(duc(totalCount), skip(1)), didMount),
        withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress),
        map(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {
          let shouldFollow = didMount2 && scrolledToInitialItem2;
          let followOutputBehavior = "auto";
          if (shouldFollow) {
            followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);
            shouldFollow = shouldFollow && !!followOutputBehavior;
          }
          return { totalCount: totalCount2, shouldFollow, followOutputBehavior };
        }),
        filter2(({ shouldFollow }) => shouldFollow)
      ),
      ({ totalCount: totalCount2, followOutputBehavior }) => {
        if (pendingScrollHandle) {
          pendingScrollHandle();
          pendingScrollHandle = null;
        }
        pendingScrollHandle = handleNext(listRefresh, () => {
          getValue(log)("following output to ", { totalCount: totalCount2 }, LogLevel.DEBUG);
          scrollToBottom(followOutputBehavior);
          pendingScrollHandle = null;
        });
      }
    );
    function trapNextSizeIncrease(followOutput2) {
      const cancel = handleNext(atBottomState, (state) => {
        if (followOutput2 && !state.atBottom && state.notAtBottomBecause === "SIZE_INCREASED" && !pendingScrollHandle) {
          getValue(log)("scrolling to bottom due to increased size", {}, LogLevel.DEBUG);
          scrollToBottom("auto");
        }
      });
      setTimeout(cancel, 100);
    }
    __name(trapNextSizeIncrease, "trapNextSizeIncrease");
    subscribe(
      pipe(
        combineLatest(duc(followOutput), totalCount, propsReady),
        filter2(([follow, , ready]) => follow && ready),
        scan(
          ({ value }, [, next2]) => {
            return { refreshed: value === next2, value: next2 };
          },
          { refreshed: false, value: 0 }
        ),
        filter2(({ refreshed }) => refreshed),
        withLatestFrom(followOutput, totalCount)
      ),
      ([, followOutput2]) => {
        if (getValue(scrolledToInitialItem)) {
          trapNextSizeIncrease(followOutput2 !== false);
        }
      }
    );
    subscribe(autoscrollToBottom, () => {
      trapNextSizeIncrease(getValue(followOutput) !== false);
    });
    subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {
      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING") {
        scrollToBottom("auto");
      }
    });
    return { followOutput, autoscrollToBottom };
  },
  tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem)
);
function groupCountsToIndicesAndCount(counts) {
  return counts.reduce(
    (acc, groupCount) => {
      acc.groupIndices.push(acc.totalCount);
      acc.totalCount += groupCount + 1;
      return acc;
    },
    {
      totalCount: 0,
      groupIndices: []
    }
  );
}
__name(groupCountsToIndicesAndCount, "groupCountsToIndicesAndCount");
const groupedListSystem = system(([{ totalCount, groupIndices, sizes }, { scrollTop, headerHeight }]) => {
  const groupCounts = stream();
  const topItemsIndexes = stream();
  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));
  connect(
    pipe(
      groupIndicesAndCount,
      map((value) => value.totalCount)
    ),
    totalCount
  );
  connect(
    pipe(
      groupIndicesAndCount,
      map((value) => value.groupIndices)
    ),
    groupIndices
  );
  connect(
    pipe(
      combineLatest(scrollTop, sizes, headerHeight),
      filter2(([_2, sizes2]) => hasGroups(sizes2)),
      map(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), "v")[0]),
      distinctUntilChanged(),
      map((index2) => [index2])
    ),
    topItemsIndexes
  );
  return { groupCounts, topItemsIndexes };
}, tup(sizeSystem, domIOSystem));
function tupleComparator(prev2, current) {
  return !!(prev2 && prev2[0] === current[0] && prev2[1] === current[1]);
}
__name(tupleComparator, "tupleComparator");
function rangeComparator(prev2, next2) {
  return !!(prev2 && prev2.startIndex === next2.startIndex && prev2.endIndex === next2.endIndex);
}
__name(rangeComparator, "rangeComparator");
const TOP = "top";
const BOTTOM = "bottom";
const NONE = "none";
function getOverscan(overscan, end2, direction) {
  if (typeof overscan === "number") {
    return direction === UP && end2 === TOP || direction === DOWN && end2 === BOTTOM ? overscan : 0;
  } else {
    if (direction === UP) {
      return end2 === TOP ? overscan.main : overscan.reverse;
    } else {
      return end2 === BOTTOM ? overscan.main : overscan.reverse;
    }
  }
}
__name(getOverscan, "getOverscan");
function getViewportIncrease(value, end2) {
  return typeof value === "number" ? value : value[end2] || 0;
}
__name(getViewportIncrease, "getViewportIncrease");
const sizeRangeSystem = system(
  ([{ scrollTop, viewportHeight, deviation, headerHeight, fixedHeaderHeight }]) => {
    const listBoundary = stream();
    const topListHeight = statefulStream(0);
    const increaseViewportBy = statefulStream(0);
    const overscan = statefulStream(0);
    const visibleRange = statefulStreamFromEmitter(
      pipe(
        combineLatest(
          duc(scrollTop),
          duc(viewportHeight),
          duc(headerHeight),
          duc(listBoundary, tupleComparator),
          duc(overscan),
          duc(topListHeight),
          duc(fixedHeaderHeight),
          duc(deviation),
          duc(increaseViewportBy)
        ),
        map(
          ([
            scrollTop2,
            viewportHeight2,
            headerHeight2,
            [listTop, listBottom],
            overscan2,
            topListHeight2,
            fixedHeaderHeight2,
            deviation2,
            increaseViewportBy2
          ]) => {
            const top2 = scrollTop2 - deviation2;
            const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;
            const headerVisible = Math.max(headerHeight2 - top2, 0);
            let direction = NONE;
            const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);
            const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);
            listTop -= deviation2;
            listTop += headerHeight2 + fixedHeaderHeight2;
            listBottom += headerHeight2 + fixedHeaderHeight2;
            listBottom -= deviation2;
            if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {
              direction = UP;
            }
            if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {
              direction = DOWN;
            }
            if (direction !== NONE) {
              return [
                Math.max(top2 - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0),
                top2 - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition
              ];
            }
            return null;
          }
        ),
        filter2((value) => value != null),
        distinctUntilChanged(tupleComparator)
      ),
      [0, 0]
    );
    return {
      // input
      listBoundary,
      overscan,
      topListHeight,
      increaseViewportBy,
      // output
      visibleRange
    };
  },
  tup(domIOSystem),
  { singleton: true }
);
function probeItemSet(index2, sizes, data) {
  if (hasGroups(sizes)) {
    const itemIndex = originalIndexFromItemIndex(index2, sizes);
    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];
    return [
      { index: groupIndex, size: 0, offset: 0 },
      { index: itemIndex, size: 0, offset: 0, data: data && data[0] }
    ];
  }
  return [{ index: index2, size: 0, offset: 0, data: data && data[0] }];
}
__name(probeItemSet, "probeItemSet");
const EMPTY_LIST_STATE = {
  items: [],
  topItems: [],
  offsetTop: 0,
  offsetBottom: 0,
  top: 0,
  bottom: 0,
  topListHeight: 0,
  totalCount: 0,
  firstItemIndex: 0
};
function transposeItems(items, sizes, firstItemIndex) {
  if (items.length === 0) {
    return [];
  }
  if (!hasGroups(sizes)) {
    return items.map((item) => ({ ...item, index: item.index + firstItemIndex, originalIndex: item.index }));
  }
  const startIndex = items[0].index;
  const endIndex = items[items.length - 1].index;
  const transposedItems = [];
  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);
  let currentRange = void 0;
  let currentGroupIndex = 0;
  for (const item of items) {
    if (!currentRange || currentRange.end < item.index) {
      currentRange = groupRanges.shift();
      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);
    }
    let transposedItem;
    if (item.index === currentRange.start) {
      transposedItem = {
        type: "group",
        index: currentGroupIndex
      };
    } else {
      transposedItem = {
        index: item.index - (currentGroupIndex + 1) + firstItemIndex,
        groupIndex: currentGroupIndex
      };
    }
    transposedItems.push({
      ...transposedItem,
      size: item.size,
      offset: item.offset,
      originalIndex: item.index,
      data: item.data
    });
  }
  return transposedItems;
}
__name(transposeItems, "transposeItems");
function buildListState(items, topItems, totalCount, gap2, sizes, firstItemIndex) {
  const { lastSize, lastOffset, lastIndex } = sizes;
  let offsetTop = 0;
  let bottom2 = 0;
  if (items.length > 0) {
    offsetTop = items[0].offset;
    const lastItem = items[items.length - 1];
    bottom2 = lastItem.offset + lastItem.size;
  }
  const itemCount = totalCount - lastIndex;
  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap2;
  const top2 = offsetTop;
  const offsetBottom = total - bottom2;
  return {
    items: transposeItems(items, sizes, firstItemIndex),
    topItems: transposeItems(topItems, sizes, firstItemIndex),
    topListHeight: topItems.reduce((height2, item) => item.size + height2, 0),
    offsetTop,
    offsetBottom,
    top: top2,
    bottom: bottom2,
    totalCount,
    firstItemIndex
  };
}
__name(buildListState, "buildListState");
function buildListStateFromItemCount(itemCount, initialTopMostItemIndex, sizes, firstItemIndex, gap2, data) {
  let includedGroupsCount = 0;
  if (sizes.groupIndices.length > 0) {
    for (const index2 of sizes.groupIndices) {
      if (index2 - includedGroupsCount >= itemCount) {
        break;
      }
      includedGroupsCount++;
    }
  }
  const adjustedCount = itemCount + includedGroupsCount;
  const initialTopMostItemIndexNumber = getInitialTopMostItemIndexNumber(initialTopMostItemIndex, adjustedCount);
  const items = Array.from({ length: adjustedCount }).map((_2, index2) => ({
    index: index2 + initialTopMostItemIndexNumber,
    size: 0,
    offset: 0,
    data: data[index2 + initialTopMostItemIndexNumber]
  }));
  return buildListState(items, [], adjustedCount, gap2, sizes, firstItemIndex);
}
__name(buildListStateFromItemCount, "buildListStateFromItemCount");
const listStateSystem = system(
  ([
    { sizes, totalCount, data, firstItemIndex, gap: gap2 },
    groupedListSystem2,
    { visibleRange, listBoundary, topListHeight: rangeTopListHeight },
    { scrolledToInitialItem, initialTopMostItemIndex },
    { topListHeight },
    stateFlags,
    { didMount },
    { recalcInProgress }
  ]) => {
    const topItemsIndexes = statefulStream([]);
    const initialItemCount = statefulStream(0);
    const itemsRendered = stream();
    connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);
    const listState = statefulStreamFromEmitter(
      pipe(
        combineLatest(
          didMount,
          recalcInProgress,
          duc(visibleRange, tupleComparator),
          duc(totalCount),
          duc(sizes),
          duc(initialTopMostItemIndex),
          scrolledToInitialItem,
          duc(topItemsIndexes),
          duc(firstItemIndex),
          duc(gap2),
          data
        ),
        filter2(([mount, recalcInProgress2, , totalCount2, , , , , , , data2]) => {
          const dataChangeInProgress = data2 && data2.length !== totalCount2;
          return mount && !recalcInProgress2 && !dataChangeInProgress;
        }),
        map(
          ([
            ,
            ,
            [startOffset, endOffset],
            totalCount2,
            sizes2,
            initialTopMostItemIndex2,
            scrolledToInitialItem2,
            topItemsIndexes2,
            firstItemIndex2,
            gap22,
            data2
          ]) => {
            const sizesValue = sizes2;
            const { sizeTree, offsetTree } = sizesValue;
            const initialItemCountValue = getValue(initialItemCount);
            if (totalCount2 === 0) {
              return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };
            }
            if (startOffset === 0 && endOffset === 0) {
              if (initialItemCountValue === 0) {
                return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };
              } else {
                return buildListStateFromItemCount(initialItemCountValue, initialTopMostItemIndex2, sizes2, firstItemIndex2, gap22, data2 || []);
              }
            }
            if (empty(sizeTree)) {
              if (initialItemCountValue > 0) {
                return null;
              }
              const state = buildListState(
                probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2),
                [],
                totalCount2,
                gap22,
                sizesValue,
                firstItemIndex2
              );
              return state;
            }
            const topItems = [];
            if (topItemsIndexes2.length > 0) {
              const startIndex = topItemsIndexes2[0];
              const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];
              let offset2 = 0;
              for (const range2 of rangesWithin(sizeTree, startIndex, endIndex)) {
                const size2 = range2.value;
                const rangeStartIndex = Math.max(range2.start, startIndex);
                const rangeEndIndex = Math.min(range2.end, endIndex);
                for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {
                  topItems.push({ index: i, size: size2, offset: offset2, data: data2 && data2[i] });
                  offset2 += size2;
                }
              }
            }
            if (!scrolledToInitialItem2) {
              return buildListState([], topItems, totalCount2, gap22, sizesValue, firstItemIndex2);
            }
            const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;
            const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);
            if (offsetPointRanges.length === 0) {
              return null;
            }
            const maxIndex = totalCount2 - 1;
            const items = tap([], (result) => {
              for (const range2 of offsetPointRanges) {
                const point = range2.value;
                let offset2 = point.offset;
                let rangeStartIndex = range2.start;
                const size2 = point.size;
                if (point.offset < startOffset) {
                  rangeStartIndex += Math.floor((startOffset - point.offset + gap22) / (size2 + gap22));
                  const itemCount = rangeStartIndex - range2.start;
                  offset2 += itemCount * size2 + itemCount * gap22;
                }
                if (rangeStartIndex < minStartIndex) {
                  offset2 += (minStartIndex - rangeStartIndex) * size2;
                  rangeStartIndex = minStartIndex;
                }
                const endIndex = Math.min(range2.end, maxIndex);
                for (let i = rangeStartIndex; i <= endIndex; i++) {
                  if (offset2 >= endOffset) {
                    break;
                  }
                  result.push({ index: i, size: size2, offset: offset2, data: data2 && data2[i] });
                  offset2 += size2 + gap22;
                }
              }
            });
            return buildListState(items, topItems, totalCount2, gap22, sizesValue, firstItemIndex2);
          }
        ),
        //@ts-expect-error filter needs to be fixed
        filter2((value) => value !== null),
        distinctUntilChanged()
      ),
      EMPTY_LIST_STATE
    );
    connect(
      pipe(
        data,
        filter2(isDefined),
        map((data2) => data2 == null ? void 0 : data2.length)
      ),
      totalCount
    );
    connect(
      pipe(
        listState,
        map((value) => value.topListHeight)
      ),
      topListHeight
    );
    connect(topListHeight, rangeTopListHeight);
    connect(
      pipe(
        listState,
        map((state) => [state.top, state.bottom])
      ),
      listBoundary
    );
    connect(
      pipe(
        listState,
        map((state) => state.items)
      ),
      itemsRendered
    );
    const endReached = streamFromEmitter(
      pipe(
        listState,
        filter2(({ items }) => items.length > 0),
        withLatestFrom(totalCount, data),
        filter2(([{ items }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1),
        map(([, totalCount2, data2]) => [totalCount2 - 1, data2]),
        distinctUntilChanged(tupleComparator),
        map(([count]) => count)
      )
    );
    const startReached = streamFromEmitter(
      pipe(
        listState,
        throttleTime(200),
        filter2(({ items, topItems }) => {
          return items.length > 0 && items[0].originalIndex === topItems.length;
        }),
        map(({ items }) => items[0].index),
        distinctUntilChanged()
      )
    );
    const rangeChanged = streamFromEmitter(
      pipe(
        listState,
        filter2(({ items }) => items.length > 0),
        map(({ items }) => {
          let startIndex = 0;
          let endIndex = items.length - 1;
          while (items[startIndex].type === "group" && startIndex < endIndex) {
            startIndex++;
          }
          while (items[endIndex].type === "group" && endIndex > startIndex) {
            endIndex--;
          }
          return {
            startIndex: items[startIndex].index,
            endIndex: items[endIndex].index
          };
        }),
        distinctUntilChanged(rangeComparator)
      )
    );
    return { listState, topItemsIndexes, endReached, startReached, rangeChanged, itemsRendered, initialItemCount, ...stateFlags };
  },
  tup(
    sizeSystem,
    groupedListSystem,
    sizeRangeSystem,
    initialTopMostItemIndexSystem,
    scrollToIndexSystem,
    stateFlagsSystem,
    propsReadySystem,
    recalcSystem
  ),
  { singleton: true }
);
const initialItemCountSystem = system(
  ([{ sizes, firstItemIndex, data, gap: gap2 }, { initialTopMostItemIndex }, { initialItemCount, listState }, { didMount }]) => {
    connect(
      pipe(
        didMount,
        withLatestFrom(initialItemCount),
        filter2(([, count]) => count !== 0),
        withLatestFrom(initialTopMostItemIndex, sizes, firstItemIndex, gap2, data),
        map(([[, count], initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap22, data2 = []]) => {
          return buildListStateFromItemCount(count, initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap22, data2);
        })
      ),
      listState
    );
    return {};
  },
  tup(sizeSystem, initialTopMostItemIndexSystem, listStateSystem, propsReadySystem),
  { singleton: true }
);
const scrollSeekSystem = system(
  ([{ scrollVelocity }]) => {
    const isSeeking = statefulStream(false);
    const rangeChanged = stream();
    const scrollSeekConfiguration = statefulStream(false);
    connect(
      pipe(
        scrollVelocity,
        withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged),
        filter2(([_2, config2]) => !!config2),
        map(([speed, config2, isSeeking2, range2]) => {
          const { exit, enter } = config2;
          if (isSeeking2) {
            if (exit(speed, range2)) {
              return false;
            }
          } else {
            if (enter(speed, range2)) {
              return true;
            }
          }
          return isSeeking2;
        }),
        distinctUntilChanged()
      ),
      isSeeking
    );
    subscribe(
      pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)),
      ([[isSeeking2, velocity, range2], config2]) => isSeeking2 && config2 && config2.change && config2.change(velocity, range2)
    );
    return { isSeeking, scrollSeekConfiguration, scrollVelocity, scrollSeekRangeChanged: rangeChanged };
  },
  tup(stateFlagsSystem),
  { singleton: true }
);
const topItemCountSystem = system(([{ topItemsIndexes }]) => {
  const topItemCount = statefulStream(0);
  connect(
    pipe(
      topItemCount,
      filter2((length2) => length2 > 0),
      map((length2) => Array.from({ length: length2 }).map((_2, index2) => index2))
    ),
    topItemsIndexes
  );
  return { topItemCount };
}, tup(listStateSystem));
const totalListHeightSystem = system(
  ([{ footerHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight }, { listState }]) => {
    const totalListHeightChanged = stream();
    const totalListHeight = statefulStreamFromEmitter(
      pipe(
        combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState),
        map(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {
          return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;
        })
      ),
      0
    );
    connect(duc(totalListHeight), totalListHeightChanged);
    return { totalListHeight, totalListHeightChanged };
  },
  tup(domIOSystem, listStateSystem),
  { singleton: true }
);
function simpleMemoize(func) {
  let called = false;
  let result;
  return () => {
    if (!called) {
      called = true;
      result = func();
    }
    return result;
  };
}
__name(simpleMemoize, "simpleMemoize");
const isMobileSafari = simpleMemoize(() => {
  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);
});
const upwardScrollFixSystem = system(
  ([
    { scrollBy, scrollTop, deviation, scrollingInProgress },
    { isScrolling, isAtBottom, scrollDirection, lastJumpDueToItemResize },
    { listState },
    { beforeUnshiftWith, shiftWithOffset, sizes, gap: gap2 },
    { log },
    { recalcInProgress }
  ]) => {
    const deviationOffset = streamFromEmitter(
      pipe(
        listState,
        withLatestFrom(lastJumpDueToItemResize),
        scan(
          ([, prevItems, prevTotalCount, prevTotalHeight], [{ items, totalCount, bottom: bottom2, offsetBottom }, lastJumpDueToItemResize2]) => {
            const totalHeight = bottom2 + offsetBottom;
            let newDev = 0;
            if (prevTotalCount === totalCount) {
              if (prevItems.length > 0 && items.length > 0) {
                const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;
                if (!atStart) {
                  newDev = totalHeight - prevTotalHeight;
                  if (newDev !== 0) {
                    newDev += lastJumpDueToItemResize2;
                  }
                }
              }
            }
            return [newDev, items, totalCount, totalHeight];
          },
          [0, [], 0, 0]
        ),
        filter2(([amount]) => amount !== 0),
        withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress),
        filter2(([, scrollTop2, scrollDirection2, scrollingInProgress2, , , recalcInProgress2]) => {
          return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;
        }),
        map(([[amount], , , , , log2]) => {
          log2("Upward scrolling compensation", { amount }, LogLevel.DEBUG);
          return amount;
        })
      )
    );
    function scrollByWith(offset2) {
      if (offset2 > 0) {
        publish(scrollBy, { top: -offset2, behavior: "auto" });
        publish(deviation, 0);
      } else {
        publish(deviation, 0);
        publish(scrollBy, { top: -offset2, behavior: "auto" });
      }
    }
    __name(scrollByWith, "scrollByWith");
    subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset2, deviationAmount, isScrolling2]) => {
      if (isScrolling2 && isMobileSafari()) {
        publish(deviation, deviationAmount - offset2);
      } else {
        scrollByWith(-offset2);
      }
    });
    subscribe(
      pipe(
        combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress),
        filter2(([is2, deviation2, recalc]) => !is2 && !recalc && deviation2 !== 0),
        map(([_2, deviation2]) => deviation2),
        throttleTime(1)
      ),
      scrollByWith
    );
    connect(
      pipe(
        shiftWithOffset,
        map((offset2) => {
          return { top: -offset2 };
        })
      ),
      scrollBy
    );
    subscribe(
      pipe(
        beforeUnshiftWith,
        withLatestFrom(sizes, gap2),
        map(([offset2, { lastSize: defaultItemSize, groupIndices, sizeTree }, gap22]) => {
          function getItemOffset(itemCount) {
            return itemCount * (defaultItemSize + gap22);
          }
          __name(getItemOffset, "getItemOffset");
          if (groupIndices.length === 0) {
            return getItemOffset(offset2);
          } else {
            let amount = 0;
            const defaultGroupSize = find(sizeTree, 0);
            let recognizedOffsetItems = 0;
            let groupIndex = 0;
            while (recognizedOffsetItems < offset2) {
              recognizedOffsetItems++;
              amount += defaultGroupSize;
              let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;
              if (recognizedOffsetItems + groupItemCount > offset2) {
                amount -= defaultGroupSize;
                groupItemCount = offset2 - recognizedOffsetItems + 1;
              }
              recognizedOffsetItems += groupItemCount;
              amount += getItemOffset(groupItemCount);
              groupIndex++;
            }
            return amount;
          }
        })
      ),
      (offset2) => {
        publish(deviation, offset2);
        requestAnimationFrame(() => {
          publish(scrollBy, { top: offset2 });
          requestAnimationFrame(() => {
            publish(deviation, 0);
            publish(recalcInProgress, false);
          });
        });
      }
    );
    return { deviation };
  },
  tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem)
);
const initialScrollTopSystem = system(
  ([{ didMount }, { scrollTo }, { listState }]) => {
    const initialScrollTop = statefulStream(0);
    subscribe(
      pipe(
        didMount,
        withLatestFrom(initialScrollTop),
        filter2(([, offset2]) => offset2 !== 0),
        map(([, offset2]) => ({ top: offset2 }))
      ),
      (location) => {
        handleNext(
          pipe(
            listState,
            skip(1),
            filter2((state) => state.items.length > 1)
          ),
          () => {
            requestAnimationFrame(() => {
              publish(scrollTo, location);
            });
          }
        );
      }
    );
    return {
      initialScrollTop
    };
  },
  tup(propsReadySystem, domIOSystem, listStateSystem),
  { singleton: true }
);
const alignToBottomSystem = system(
  ([{ viewportHeight }, { totalListHeight }]) => {
    const alignToBottom = statefulStream(false);
    const paddingTopAddition = statefulStreamFromEmitter(
      pipe(
        combineLatest(alignToBottom, viewportHeight, totalListHeight),
        filter2(([enabled]) => enabled),
        map(([, viewportHeight2, totalListHeight2]) => {
          return Math.max(0, viewportHeight2 - totalListHeight2);
        }),
        throttleTime(0),
        distinctUntilChanged()
      ),
      0
    );
    return { alignToBottom, paddingTopAddition };
  },
  tup(domIOSystem, totalListHeightSystem),
  { singleton: true }
);
const windowScrollerSystem = system(([{ scrollTo, scrollContainerState }]) => {
  const windowScrollContainerState = stream();
  const windowViewportRect = stream();
  const windowScrollTo = stream();
  const useWindowScroll = statefulStream(false);
  const customScrollParent = statefulStream(void 0);
  connect(
    pipe(
      combineLatest(windowScrollContainerState, windowViewportRect),
      map(([{ viewportHeight, scrollTop: windowScrollTop, scrollHeight }, { offsetTop }]) => {
        return {
          scrollTop: Math.max(0, windowScrollTop - offsetTop),
          scrollHeight,
          viewportHeight
        };
      })
    ),
    scrollContainerState
  );
  connect(
    pipe(
      scrollTo,
      withLatestFrom(windowViewportRect),
      map(([scrollTo2, { offsetTop }]) => {
        return {
          ...scrollTo2,
          top: scrollTo2.top + offsetTop
        };
      })
    ),
    windowScrollTo
  );
  return {
    // config
    useWindowScroll,
    customScrollParent,
    // input
    windowScrollContainerState,
    windowViewportRect,
    // signals
    windowScrollTo
  };
}, tup(domIOSystem));
const defaultCalculateViewLocation = /* @__PURE__ */ __name(({
  itemTop: itemTop2,
  itemBottom,
  viewportTop,
  viewportBottom,
  locationParams: { behavior, align, ...rest }
}) => {
  if (itemTop2 < viewportTop) {
    return { ...rest, behavior, align: align != null ? align : "start" };
  }
  if (itemBottom > viewportBottom) {
    return { ...rest, behavior, align: align != null ? align : "end" };
  }
  return null;
}, "defaultCalculateViewLocation");
const scrollIntoViewSystem = system(
  ([
    { sizes, totalCount, gap: gap2 },
    { scrollTop, viewportHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollingInProgress },
    { scrollToIndex }
  ]) => {
    const scrollIntoView2 = stream();
    connect(
      pipe(
        scrollIntoView2,
        withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop),
        withLatestFrom(gap2),
        map(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap22]) => {
          const { done, behavior, align, calculateViewLocation = defaultCalculateViewLocation, ...rest } = viewLocation;
          const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);
          const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap22) + headerHeight2 + fixedHeaderHeight2;
          const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];
          const viewportTop = scrollTop2 + fixedHeaderHeight2;
          const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;
          const location = calculateViewLocation({
            itemTop: itemTop2,
            itemBottom,
            viewportTop,
            viewportBottom,
            locationParams: { behavior, align, ...rest }
          });
          if (location) {
            done && handleNext(
              pipe(
                scrollingInProgress,
                filter2((value) => value === false),
                // skips the initial publish of false, and the cleanup call.
                // but if scrollingInProgress is true, we skip the initial publish.
                skip(getValue(scrollingInProgress) ? 1 : 2)
              ),
              done
            );
          } else {
            done && done();
          }
          return location;
        }),
        filter2((value) => value !== null)
      ),
      scrollToIndex
    );
    return {
      scrollIntoView: scrollIntoView2
    };
  },
  tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem),
  { singleton: true }
);
const stateLoadSystem = system(
  ([
    { sizes, sizeRanges },
    { scrollTop, headerHeight },
    { initialTopMostItemIndex },
    { didMount },
    { useWindowScroll, windowScrollContainerState, windowViewportRect }
  ]) => {
    const getState = stream();
    const restoreStateFrom = statefulStream(void 0);
    const statefulWindowScrollContainerState = statefulStream(null);
    const statefulWindowViewportRect = statefulStream(null);
    connect(windowScrollContainerState, statefulWindowScrollContainerState);
    connect(windowViewportRect, statefulWindowViewportRect);
    subscribe(
      pipe(
        getState,
        withLatestFrom(sizes, scrollTop, useWindowScroll, statefulWindowScrollContainerState, statefulWindowViewportRect, headerHeight)
      ),
      ([callback, sizes2, scrollTop2, useWindowScroll2, windowScrollContainerState2, windowViewportRect2, headerHeight2]) => {
        const ranges = sizeTreeToRanges(sizes2.sizeTree);
        if (useWindowScroll2 && windowScrollContainerState2 !== null && windowViewportRect2 !== null) {
          scrollTop2 = windowScrollContainerState2.scrollTop - windowViewportRect2.offsetTop;
        }
        scrollTop2 -= headerHeight2;
        callback({ ranges, scrollTop: scrollTop2 });
      }
    );
    connect(pipe(restoreStateFrom, filter2(isDefined), map(locationFromSnapshot)), initialTopMostItemIndex);
    connect(
      pipe(
        didMount,
        withLatestFrom(restoreStateFrom),
        filter2(([, state]) => state !== void 0),
        distinctUntilChanged(),
        map(([, snapshot]) => {
          return snapshot.ranges;
        })
      ),
      sizeRanges
    );
    return {
      getState,
      restoreStateFrom
    };
  },
  tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem, windowScrollerSystem)
);
function locationFromSnapshot(snapshot) {
  return { offset: snapshot.scrollTop, index: 0, align: "start" };
}
__name(locationFromSnapshot, "locationFromSnapshot");
const featureGroup1System = system(
  ([
    sizeRange,
    initialItemCount,
    propsReady,
    scrollSeek,
    totalListHeight,
    initialScrollTopSystem2,
    alignToBottom,
    windowScroller,
    scrollIntoView2,
    logger
  ]) => {
    return {
      ...sizeRange,
      ...initialItemCount,
      ...propsReady,
      ...scrollSeek,
      ...totalListHeight,
      ...initialScrollTopSystem2,
      ...alignToBottom,
      ...windowScroller,
      ...scrollIntoView2,
      ...logger
    };
  },
  tup(
    sizeRangeSystem,
    initialItemCountSystem,
    propsReadySystem,
    scrollSeekSystem,
    totalListHeightSystem,
    initialScrollTopSystem,
    alignToBottomSystem,
    windowScrollerSystem,
    scrollIntoViewSystem,
    loggerSystem
  )
);
const listSystem = system(
  ([
    {
      totalCount,
      sizeRanges,
      fixedItemSize,
      defaultItemSize,
      trackItemSizes,
      itemSize,
      data,
      firstItemIndex,
      groupIndices,
      statefulTotalCount,
      gap: gap2,
      sizes
    },
    { initialTopMostItemIndex, scrolledToInitialItem, initialItemFinalLocationReached },
    domIO,
    stateLoad,
    followOutput,
    { listState, topItemsIndexes, ...flags },
    { scrollToIndex },
    _2,
    { topItemCount },
    { groupCounts },
    featureGroup1
  ]) => {
    connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);
    connect(
      pipe(
        featureGroup1.windowViewportRect,
        map((value) => value.visibleHeight)
      ),
      domIO.viewportHeight
    );
    return {
      // input
      totalCount,
      data,
      firstItemIndex,
      sizeRanges,
      initialTopMostItemIndex,
      scrolledToInitialItem,
      initialItemFinalLocationReached,
      topItemsIndexes,
      topItemCount,
      groupCounts,
      fixedItemHeight: fixedItemSize,
      defaultItemHeight: defaultItemSize,
      gap: gap2,
      ...followOutput,
      // output
      statefulTotalCount,
      listState,
      scrollToIndex,
      trackItemSizes,
      itemSize,
      groupIndices,
      // exported from stateFlagsSystem
      ...flags,
      // the bag of IO from featureGroup1System
      ...featureGroup1,
      ...domIO,
      sizes,
      ...stateLoad
    };
  },
  tup(
    sizeSystem,
    initialTopMostItemIndexSystem,
    domIOSystem,
    stateLoadSystem,
    followOutputSystem,
    listStateSystem,
    scrollToIndexSystem,
    upwardScrollFixSystem,
    topItemCountSystem,
    groupedListSystem,
    featureGroup1System
  )
);
const WEBKIT_STICKY = "-webkit-sticky";
const STICKY = "sticky";
const positionStickyCssValue = simpleMemoize(() => {
  if (typeof document === "undefined") {
    return STICKY;
  }
  const node2 = document.createElement("div");
  node2.style.position = WEBKIT_STICKY;
  return node2.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;
});
function useWindowViewportRectRef(callback, customScrollParent, skipAnimationFrame) {
  const viewportInfo = React$1.useRef(null);
  const calculateInfo = React$1.useCallback(
    (element) => {
      if (element === null || !element.offsetParent) {
        return;
      }
      const rect = element.getBoundingClientRect();
      const visibleWidth = rect.width;
      let visibleHeight, offsetTop;
      if (customScrollParent) {
        const customScrollParentRect = customScrollParent.getBoundingClientRect();
        const deltaTop = rect.top - customScrollParentRect.top;
        visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);
        offsetTop = deltaTop + customScrollParent.scrollTop;
      } else {
        visibleHeight = window.innerHeight - Math.max(0, rect.top);
        offsetTop = rect.top + window.pageYOffset;
      }
      viewportInfo.current = {
        offsetTop,
        visibleHeight,
        visibleWidth
      };
      callback(viewportInfo.current);
    },
    [callback, customScrollParent]
  );
  const { callbackRef, ref } = useSizeWithElRef(calculateInfo, true, skipAnimationFrame);
  const scrollAndResizeEventHandler = React$1.useCallback(() => {
    calculateInfo(ref.current);
  }, [calculateInfo, ref]);
  React$1.useEffect(() => {
    if (customScrollParent) {
      customScrollParent.addEventListener("scroll", scrollAndResizeEventHandler);
      const observer = new ResizeObserver(() => {
        requestAnimationFrame(scrollAndResizeEventHandler);
      });
      observer.observe(customScrollParent);
      return () => {
        customScrollParent.removeEventListener("scroll", scrollAndResizeEventHandler);
        observer.unobserve(customScrollParent);
      };
    } else {
      window.addEventListener("scroll", scrollAndResizeEventHandler);
      window.addEventListener("resize", scrollAndResizeEventHandler);
      return () => {
        window.removeEventListener("scroll", scrollAndResizeEventHandler);
        window.removeEventListener("resize", scrollAndResizeEventHandler);
      };
    }
  }, [scrollAndResizeEventHandler, customScrollParent]);
  return callbackRef;
}
__name(useWindowViewportRectRef, "useWindowViewportRectRef");
const VirtuosoMockContext = React$1.createContext(void 0);
const VirtuosoGridMockContext = React$1.createContext(void 0);
function identity(value) {
  return value;
}
__name(identity, "identity");
({ position: positionStickyCssValue(), zIndex: 1, overflowAnchor: "none" });
const scrollerStyle = {
  height: "100%",
  outline: "none",
  overflowY: "auto",
  position: "relative",
  WebkitOverflowScrolling: "touch"
};
const horizontalScrollerStyle = {
  outline: "none",
  overflowX: "auto",
  position: "relative"
};
const viewportStyle = /* @__PURE__ */ __name((alignToBottom) => ({
  width: "100%",
  height: "100%",
  position: "absolute",
  top: 0,
  ...{}
}), "viewportStyle");
({
  width: "100%",
  position: positionStickyCssValue(),
  top: 0,
  zIndex: 1
});
function contextPropIfNotDomElement(element, context) {
  if (typeof element === "string") {
    return void 0;
  }
  return { context };
}
__name(contextPropIfNotDomElement, "contextPropIfNotDomElement");
function itemPropIfNotDomElement(element, item) {
  return { item: typeof element === "string" ? void 0 : item };
}
__name(itemPropIfNotDomElement, "itemPropIfNotDomElement");
function buildScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {
  const Scroller2 = React$1.memo(/* @__PURE__ */ __name(function VirtuosoScroller({ style: style2, children, ...props }) {
    const scrollContainerStateCallback = usePublisher2("scrollContainerState");
    const ScrollerComponent = useEmitterValue2("ScrollerComponent");
    const smoothScrollTargetReached = usePublisher2("smoothScrollTargetReached");
    const scrollerRefCallback = useEmitterValue2("scrollerRef");
    const context = useEmitterValue2("context");
    const horizontalDirection = useEmitterValue2("horizontalDirection") || false;
    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(
      scrollContainerStateCallback,
      smoothScrollTargetReached,
      ScrollerComponent,
      scrollerRefCallback,
      void 0,
      horizontalDirection
    );
    useEmitter2("scrollTo", scrollToCallback);
    useEmitter2("scrollBy", scrollByCallback);
    const defaultStyle = horizontalDirection ? horizontalScrollerStyle : scrollerStyle;
    return React$1.createElement(
      ScrollerComponent,
      {
        ref: scrollerRef,
        style: { ...defaultStyle, ...style2 },
        "data-testid": "virtuoso-scroller",
        "data-virtuoso-scroller": true,
        tabIndex: 0,
        ...props,
        ...contextPropIfNotDomElement(ScrollerComponent, context)
      },
      children
    );
  }, "VirtuosoScroller"));
  return Scroller2;
}
__name(buildScroller, "buildScroller");
function buildWindowScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {
  const Scroller2 = React$1.memo(/* @__PURE__ */ __name(function VirtuosoWindowScroller({ style: style2, children, ...props }) {
    const scrollContainerStateCallback = usePublisher2("windowScrollContainerState");
    const ScrollerComponent = useEmitterValue2("ScrollerComponent");
    const smoothScrollTargetReached = usePublisher2("smoothScrollTargetReached");
    const totalListHeight = useEmitterValue2("totalListHeight");
    const deviation = useEmitterValue2("deviation");
    const customScrollParent = useEmitterValue2("customScrollParent");
    const context = useEmitterValue2("context");
    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(
      scrollContainerStateCallback,
      smoothScrollTargetReached,
      ScrollerComponent,
      noop$1,
      customScrollParent
    );
    useIsomorphicLayoutEffect$1(() => {
      scrollerRef.current = customScrollParent ? customScrollParent : window;
      return () => {
        scrollerRef.current = null;
      };
    }, [scrollerRef, customScrollParent]);
    useEmitter2("windowScrollTo", scrollToCallback);
    useEmitter2("scrollBy", scrollByCallback);
    return React$1.createElement(
      ScrollerComponent,
      {
        style: { position: "relative", ...style2, ...totalListHeight !== 0 ? { height: totalListHeight + deviation } : {} },
        "data-virtuoso-scroller": true,
        ...props,
        ...contextPropIfNotDomElement(ScrollerComponent, context)
      },
      children
    );
  }, "VirtuosoWindowScroller"));
  return Scroller2;
}
__name(buildWindowScroller, "buildWindowScroller");
const INITIAL_GRID_STATE = {
  items: [],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  bottom: 0,
  itemHeight: 0,
  itemWidth: 0
};
const PROBE_GRID_STATE = {
  items: [{ index: 0 }],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  bottom: 0,
  itemHeight: 0,
  itemWidth: 0
};
const { round: round$1, ceil, floor, min, max } = Math;
function buildProbeGridState(items) {
  return {
    ...PROBE_GRID_STATE,
    items
  };
}
__name(buildProbeGridState, "buildProbeGridState");
function buildItems(startIndex, endIndex, data) {
  return Array.from({ length: endIndex - startIndex + 1 }).map((_2, i) => {
    const dataItem = data === null ? null : data[i + startIndex];
    return { index: i + startIndex, data: dataItem };
  });
}
__name(buildItems, "buildItems");
function gapComparator(prev2, next2) {
  return prev2 && prev2.column === next2.column && prev2.row === next2.row;
}
__name(gapComparator, "gapComparator");
function dimensionComparator(prev2, next2) {
  return prev2 && prev2.width === next2.width && prev2.height === next2.height;
}
__name(dimensionComparator, "dimensionComparator");
const gridSystem = /* @__PURE__ */ system(
  ([
    { overscan, visibleRange, listBoundary },
    { scrollTop, viewportHeight, scrollBy, scrollTo, smoothScrollTargetReached, scrollContainerState, footerHeight, headerHeight },
    stateFlags,
    scrollSeek,
    { propsReady, didMount },
    { windowViewportRect, useWindowScroll, customScrollParent, windowScrollContainerState, windowScrollTo },
    log
  ]) => {
    const totalCount = statefulStream(0);
    const initialItemCount = statefulStream(0);
    const gridState = statefulStream(INITIAL_GRID_STATE);
    const viewportDimensions = statefulStream({ height: 0, width: 0 });
    const itemDimensions = statefulStream({ height: 0, width: 0 });
    const scrollToIndex = stream();
    const scrollHeight = stream();
    const deviation = statefulStream(0);
    const data = statefulStream(null);
    const gap2 = statefulStream({ row: 0, column: 0 });
    const stateChanged = stream();
    const restoreStateFrom = stream();
    const stateRestoreInProgress = statefulStream(false);
    const initialTopMostItemIndex = statefulStream(0);
    const scrolledToInitialItem = statefulStream(true);
    const scrollScheduled = statefulStream(false);
    const horizontalDirection = statefulStream(false);
    subscribe(
      pipe(
        didMount,
        withLatestFrom(initialTopMostItemIndex),
        filter2(([_2, location]) => !!location)
      ),
      () => {
        publish(scrolledToInitialItem, false);
        publish(initialItemCount, 0);
      }
    );
    subscribe(
      pipe(
        combineLatest(didMount, scrolledToInitialItem, itemDimensions, viewportDimensions, initialTopMostItemIndex, scrollScheduled),
        filter2(([didMount2, scrolledToInitialItem2, itemDimensions2, viewportDimensions2, , scrollScheduled2]) => {
          return didMount2 && !scrolledToInitialItem2 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0 && !scrollScheduled2;
        })
      ),
      ([, , , , initialTopMostItemIndex2]) => {
        publish(scrollScheduled, true);
        skipFrames(1, () => {
          publish(scrollToIndex, initialTopMostItemIndex2);
        });
        handleNext(pipe(scrollTop), () => {
          publish(listBoundary, [0, 0]);
          publish(scrolledToInitialItem, true);
        });
      }
    );
    connect(
      pipe(
        restoreStateFrom,
        filter2((value) => value !== void 0 && value !== null && value.scrollTop > 0),
        mapTo(0)
      ),
      initialItemCount
    );
    subscribe(
      pipe(
        didMount,
        withLatestFrom(restoreStateFrom),
        filter2(([, snapshot]) => snapshot !== void 0 && snapshot !== null)
      ),
      ([, snapshot]) => {
        if (!snapshot) {
          return;
        }
        publish(viewportDimensions, snapshot.viewport), publish(itemDimensions, snapshot == null ? void 0 : snapshot.item);
        publish(gap2, snapshot.gap);
        if (snapshot.scrollTop > 0) {
          publish(stateRestoreInProgress, true);
          handleNext(pipe(scrollTop, skip(1)), (_value) => {
            publish(stateRestoreInProgress, false);
          });
          publish(scrollTo, { top: snapshot.scrollTop });
        }
      }
    );
    connect(
      pipe(
        viewportDimensions,
        map(({ height: height2 }) => height2)
      ),
      viewportHeight
    );
    connect(
      pipe(
        combineLatest(
          duc(viewportDimensions, dimensionComparator),
          duc(itemDimensions, dimensionComparator),
          duc(gap2, (prev2, next2) => prev2 && prev2.column === next2.column && prev2.row === next2.row),
          duc(scrollTop)
        ),
        map(([viewport2, item, gap22, scrollTop2]) => ({
          viewport: viewport2,
          item,
          gap: gap22,
          scrollTop: scrollTop2
        }))
      ),
      stateChanged
    );
    connect(
      pipe(
        combineLatest(
          duc(totalCount),
          visibleRange,
          duc(gap2, gapComparator),
          duc(itemDimensions, dimensionComparator),
          duc(viewportDimensions, dimensionComparator),
          duc(data),
          duc(initialItemCount),
          duc(stateRestoreInProgress),
          duc(scrolledToInitialItem),
          duc(initialTopMostItemIndex)
        ),
        filter2(([, , , , , , , stateRestoreInProgress2]) => {
          return !stateRestoreInProgress2;
        }),
        map(
          ([
            totalCount2,
            [startOffset, endOffset],
            gap22,
            item,
            viewport2,
            data2,
            initialItemCount2,
            ,
            scrolledToInitialItem2,
            initialTopMostItemIndex2
          ]) => {
            const { row: rowGap2, column: columnGap2 } = gap22;
            const { height: itemHeight, width: itemWidth } = item;
            const { width: viewportWidth } = viewport2;
            if (initialItemCount2 === 0 && (totalCount2 === 0 || viewportWidth === 0)) {
              return INITIAL_GRID_STATE;
            }
            if (itemWidth === 0) {
              const startIndex2 = getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2);
              const endIndex2 = startIndex2 === 0 ? Math.max(initialItemCount2 - 1, 0) : startIndex2;
              return buildProbeGridState(buildItems(startIndex2, endIndex2, data2));
            }
            const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap2);
            let startIndex;
            let endIndex;
            if (!scrolledToInitialItem2) {
              startIndex = 0;
              endIndex = -1;
            } else if (startOffset === 0 && endOffset === 0 && initialItemCount2 > 0) {
              startIndex = 0;
              endIndex = initialItemCount2 - 1;
            } else {
              startIndex = perRow * floor((startOffset + rowGap2) / (itemHeight + rowGap2));
              endIndex = perRow * ceil((endOffset + rowGap2) / (itemHeight + rowGap2)) - 1;
              endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));
              startIndex = min(endIndex, max(0, startIndex));
            }
            const items = buildItems(startIndex, endIndex, data2);
            const { top: top2, bottom: bottom2 } = gridLayout(viewport2, gap22, item, items);
            const rowCount = ceil(totalCount2 / perRow);
            const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap2;
            const offsetBottom = totalHeight - bottom2;
            return { items, offsetTop: top2, offsetBottom, top: top2, bottom: bottom2, itemHeight, itemWidth };
          }
        )
      ),
      gridState
    );
    connect(
      pipe(
        data,
        filter2((data2) => data2 !== null),
        map((data2) => data2.length)
      ),
      totalCount
    );
    connect(
      pipe(
        combineLatest(viewportDimensions, itemDimensions, gridState, gap2),
        filter2(([viewportDimensions2, itemDimensions2, { items }]) => {
          return items.length > 0 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0;
        }),
        map(([viewportDimensions2, itemDimensions2, { items }, gap22]) => {
          const { top: top2, bottom: bottom2 } = gridLayout(viewportDimensions2, gap22, itemDimensions2, items);
          return [top2, bottom2];
        }),
        distinctUntilChanged(tupleComparator)
      ),
      listBoundary
    );
    const hasScrolled = statefulStream(false);
    connect(
      pipe(
        scrollTop,
        withLatestFrom(hasScrolled),
        map(([scrollTop2, hasScrolled2]) => {
          return hasScrolled2 || scrollTop2 !== 0;
        })
      ),
      hasScrolled
    );
    const endReached = streamFromEmitter(
      pipe(
        duc(gridState),
        filter2(({ items }) => items.length > 0),
        withLatestFrom(totalCount, hasScrolled),
        filter2(([{ items }, totalCount2, hasScrolled2]) => hasScrolled2 && items[items.length - 1].index === totalCount2 - 1),
        map(([, totalCount2]) => totalCount2 - 1),
        distinctUntilChanged()
      )
    );
    const startReached = streamFromEmitter(
      pipe(
        duc(gridState),
        filter2(({ items }) => {
          return items.length > 0 && items[0].index === 0;
        }),
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        mapTo(0),
        distinctUntilChanged()
      )
    );
    const rangeChanged = streamFromEmitter(
      pipe(
        duc(gridState),
        withLatestFrom(stateRestoreInProgress),
        filter2(([{ items }, stateRestoreInProgress2]) => items.length > 0 && !stateRestoreInProgress2),
        map(([{ items }]) => {
          return {
            startIndex: items[0].index,
            endIndex: items[items.length - 1].index
          };
        }),
        distinctUntilChanged(rangeComparator),
        throttleTime(0)
      )
    );
    connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);
    connect(
      pipe(
        scrollToIndex,
        withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap2),
        map(([location, viewportDimensions2, itemDimensions2, totalCount2, gap22]) => {
          const normalLocation = normalizeIndexLocation(location);
          const { align, behavior, offset: offset2 } = normalLocation;
          let index2 = normalLocation.index;
          if (index2 === "LAST") {
            index2 = totalCount2 - 1;
          }
          index2 = max(0, index2, min(totalCount2 - 1, index2));
          let top2 = itemTop(viewportDimensions2, gap22, itemDimensions2, index2);
          if (align === "end") {
            top2 = round$1(top2 - viewportDimensions2.height + itemDimensions2.height);
          } else if (align === "center") {
            top2 = round$1(top2 - viewportDimensions2.height / 2 + itemDimensions2.height / 2);
          }
          if (offset2) {
            top2 += offset2;
          }
          return { top: top2, behavior };
        })
      ),
      scrollTo
    );
    const totalListHeight = statefulStreamFromEmitter(
      pipe(
        gridState,
        map((gridState2) => {
          return gridState2.offsetBottom + gridState2.bottom;
        })
      ),
      0
    );
    connect(
      pipe(
        windowViewportRect,
        map((viewportInfo) => ({ width: viewportInfo.visibleWidth, height: viewportInfo.visibleHeight }))
      ),
      viewportDimensions
    );
    return {
      // input
      data,
      totalCount,
      viewportDimensions,
      itemDimensions,
      scrollTop,
      scrollHeight,
      overscan,
      scrollBy,
      scrollTo,
      scrollToIndex,
      smoothScrollTargetReached,
      windowViewportRect,
      windowScrollTo,
      useWindowScroll,
      customScrollParent,
      windowScrollContainerState,
      deviation,
      scrollContainerState,
      footerHeight,
      headerHeight,
      initialItemCount,
      gap: gap2,
      restoreStateFrom,
      ...scrollSeek,
      initialTopMostItemIndex,
      horizontalDirection,
      // output
      gridState,
      totalListHeight,
      ...stateFlags,
      startReached,
      endReached,
      rangeChanged,
      stateChanged,
      propsReady,
      stateRestoreInProgress,
      ...log
    };
  },
  tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem)
);
function gridLayout(viewport2, gap2, item, items) {
  const { height: itemHeight } = item;
  if (itemHeight === void 0 || items.length === 0) {
    return { top: 0, bottom: 0 };
  }
  const top2 = itemTop(viewport2, gap2, item, items[0].index);
  const bottom2 = itemTop(viewport2, gap2, item, items[items.length - 1].index) + itemHeight;
  return { top: top2, bottom: bottom2 };
}
__name(gridLayout, "gridLayout");
function itemTop(viewport2, gap2, item, index2) {
  const perRow = itemsPerRow(viewport2.width, item.width, gap2.column);
  const rowCount = floor(index2 / perRow);
  const top2 = rowCount * item.height + max(0, rowCount - 1) * gap2.row;
  return top2 > 0 ? top2 + gap2.row : top2;
}
__name(itemTop, "itemTop");
function itemsPerRow(viewportWidth, itemWidth, gap2) {
  return max(1, floor((viewportWidth + gap2) / (floor(itemWidth) + gap2)));
}
__name(itemsPerRow, "itemsPerRow");
const gridComponentPropsSystem = /* @__PURE__ */ system(() => {
  const itemContent = statefulStream((index2) => `Item ${index2}`);
  const components = statefulStream({});
  const context = statefulStream(null);
  const itemClassName = statefulStream("virtuoso-grid-item");
  const listClassName = statefulStream("virtuoso-grid-list");
  const computeItemKey = statefulStream(identity);
  const headerFooterTag = statefulStream("div");
  const scrollerRef = statefulStream(noop$1);
  const distinctProp = /* @__PURE__ */ __name((propName, defaultValue = null) => {
    return statefulStreamFromEmitter(
      pipe(
        components,
        map((components2) => components2[propName]),
        distinctUntilChanged()
      ),
      defaultValue
    );
  }, "distinctProp");
  return {
    context,
    itemContent,
    components,
    computeItemKey,
    itemClassName,
    listClassName,
    headerFooterTag,
    scrollerRef,
    FooterComponent: distinctProp("Footer"),
    HeaderComponent: distinctProp("Header"),
    ListComponent: distinctProp("List", "div"),
    ItemComponent: distinctProp("Item", "div"),
    ScrollerComponent: distinctProp("Scroller", "div"),
    ScrollSeekPlaceholder: distinctProp("ScrollSeekPlaceholder", "div")
  };
});
const combinedSystem$1 = /* @__PURE__ */ system(([gridSystem2, gridComponentPropsSystem2]) => {
  return { ...gridSystem2, ...gridComponentPropsSystem2 };
}, tup(gridSystem, gridComponentPropsSystem));
const GridItems = /* @__PURE__ */ React$1.memo(/* @__PURE__ */ __name(function GridItems2() {
  const gridState = useEmitterValue$1("gridState");
  const listClassName = useEmitterValue$1("listClassName");
  const itemClassName = useEmitterValue$1("itemClassName");
  const itemContent = useEmitterValue$1("itemContent");
  const computeItemKey = useEmitterValue$1("computeItemKey");
  const isSeeking = useEmitterValue$1("isSeeking");
  const scrollHeightCallback = usePublisher$1("scrollHeight");
  const ItemComponent = useEmitterValue$1("ItemComponent");
  const ListComponent = useEmitterValue$1("ListComponent");
  const ScrollSeekPlaceholder = useEmitterValue$1("ScrollSeekPlaceholder");
  const context = useEmitterValue$1("context");
  const itemDimensions = usePublisher$1("itemDimensions");
  const gridGap = usePublisher$1("gap");
  const log = useEmitterValue$1("log");
  const stateRestoreInProgress = useEmitterValue$1("stateRestoreInProgress");
  const listRef = useSize(
    React$1.useMemo(
      () => (el2) => {
        const scrollHeight = el2.parentElement.parentElement.scrollHeight;
        scrollHeightCallback(scrollHeight);
        const firstItem = el2.firstChild;
        if (firstItem) {
          const { width: width2, height: height2 } = firstItem.getBoundingClientRect();
          itemDimensions({ width: width2, height: height2 });
        }
        gridGap({
          row: resolveGapValue("row-gap", getComputedStyle(el2).rowGap, log),
          column: resolveGapValue("column-gap", getComputedStyle(el2).columnGap, log)
        });
      },
      [scrollHeightCallback, itemDimensions, gridGap, log]
    ),
    true,
    false
  );
  if (stateRestoreInProgress) {
    return null;
  }
  return React$1.createElement(
    ListComponent,
    {
      ref: listRef,
      className: listClassName,
      ...contextPropIfNotDomElement(ListComponent, context),
      style: { paddingTop: gridState.offsetTop, paddingBottom: gridState.offsetBottom },
      "data-testid": "virtuoso-item-list"
    },
    gridState.items.map((item) => {
      const key = computeItemKey(item.index, item.data, context);
      return isSeeking ? React$1.createElement(ScrollSeekPlaceholder, {
        key,
        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),
        index: item.index,
        height: gridState.itemHeight,
        width: gridState.itemWidth
      }) : React$1.createElement(
        ItemComponent,
        { ...contextPropIfNotDomElement(ItemComponent, context), className: itemClassName, "data-index": item.index, key },
        itemContent(item.index, item.data, context)
      );
    })
  );
}, "GridItems2"));
const Header = React$1.memo(/* @__PURE__ */ __name(function VirtuosoHeader2() {
  const Header2 = useEmitterValue$1("HeaderComponent");
  const headerHeight = usePublisher$1("headerHeight");
  const headerFooterTag = useEmitterValue$1("headerFooterTag");
  const ref = useSize(
    React$1.useMemo(() => (el2) => headerHeight(correctItemSize(el2, "height")), [headerHeight]),
    true,
    false
  );
  const context = useEmitterValue$1("context");
  return Header2 ? React$1.createElement(headerFooterTag, { ref }, React$1.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;
}, "VirtuosoHeader2"));
const Footer = React$1.memo(/* @__PURE__ */ __name(function VirtuosoGridFooter() {
  const Footer2 = useEmitterValue$1("FooterComponent");
  const footerHeight = usePublisher$1("footerHeight");
  const headerFooterTag = useEmitterValue$1("headerFooterTag");
  const ref = useSize(
    React$1.useMemo(() => (el2) => footerHeight(correctItemSize(el2, "height")), [footerHeight]),
    true,
    false
  );
  const context = useEmitterValue$1("context");
  return Footer2 ? React$1.createElement(headerFooterTag, { ref }, React$1.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;
}, "VirtuosoGridFooter"));
const Viewport$1 = /* @__PURE__ */ __name(({ children }) => {
  const ctx = React$1.useContext(VirtuosoGridMockContext);
  const itemDimensions = usePublisher$1("itemDimensions");
  const viewportDimensions = usePublisher$1("viewportDimensions");
  const viewportRef = useSize(
    React$1.useMemo(
      () => (el2) => {
        viewportDimensions(el2.getBoundingClientRect());
      },
      [viewportDimensions]
    ),
    true,
    false
  );
  React$1.useEffect(() => {
    if (ctx) {
      viewportDimensions({ height: ctx.viewportHeight, width: ctx.viewportWidth });
      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });
    }
  }, [ctx, viewportDimensions, itemDimensions]);
  return /* @__PURE__ */ React$1.createElement("div", { style: viewportStyle(), ref: viewportRef }, children);
}, "Viewport$1");
const WindowViewport$1 = /* @__PURE__ */ __name(({ children }) => {
  const ctx = React$1.useContext(VirtuosoGridMockContext);
  const windowViewportRect = usePublisher$1("windowViewportRect");
  const itemDimensions = usePublisher$1("itemDimensions");
  const customScrollParent = useEmitterValue$1("customScrollParent");
  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent, false);
  React$1.useEffect(() => {
    if (ctx) {
      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });
      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: ctx.viewportWidth });
    }
  }, [ctx, windowViewportRect, itemDimensions]);
  return /* @__PURE__ */ React$1.createElement("div", { ref: viewportRef, style: viewportStyle() }, children);
}, "WindowViewport$1");
const GridRoot = /* @__PURE__ */ React$1.memo(/* @__PURE__ */ __name(function GridRoot22({ ...props }) {
  const useWindowScroll = useEmitterValue$1("useWindowScroll");
  const customScrollParent = useEmitterValue$1("customScrollParent");
  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;
  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;
  return /* @__PURE__ */ React$1.createElement(TheScroller, { ...props }, /* @__PURE__ */ React$1.createElement(TheViewport, null, /* @__PURE__ */ React$1.createElement(Header, null), /* @__PURE__ */ React$1.createElement(GridItems, null), /* @__PURE__ */ React$1.createElement(Footer, null)));
}, "GridRoot2"));
const {
  Component: Grid,
  usePublisher: usePublisher$1,
  useEmitterValue: useEmitterValue$1,
  useEmitter: useEmitter$1
} = /* @__PURE__ */ systemToComponent(
  combinedSystem$1,
  {
    optional: {
      context: "context",
      totalCount: "totalCount",
      overscan: "overscan",
      itemContent: "itemContent",
      components: "components",
      computeItemKey: "computeItemKey",
      data: "data",
      initialItemCount: "initialItemCount",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "headerFooterTag",
      listClassName: "listClassName",
      itemClassName: "itemClassName",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      restoreStateFrom: "restoreStateFrom",
      initialTopMostItemIndex: "initialTopMostItemIndex"
    },
    methods: {
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      scrollToIndex: "scrollToIndex"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      stateChanged: "stateChanged"
    }
  },
  GridRoot
);
const Scroller$1 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });
const WindowScroller$1 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });
function resolveGapValue(property, value, log) {
  if (value !== "normal" && !(value == null ? void 0 : value.endsWith("px"))) {
    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);
  }
  if (value === "normal") {
    return 0;
  }
  return parseInt(value != null ? value : "0", 10);
}
__name(resolveGapValue, "resolveGapValue");
const tableComponentPropsSystem = /* @__PURE__ */ system(() => {
  const itemContent = statefulStream((index2) => /* @__PURE__ */ React$1.createElement("td", null, "Item $", index2));
  const context = statefulStream(null);
  const fixedHeaderContent2 = statefulStream(null);
  const fixedFooterContent = statefulStream(null);
  const components = statefulStream({});
  const computeItemKey = statefulStream(identity);
  const scrollerRef = statefulStream(noop$1);
  const distinctProp = /* @__PURE__ */ __name((propName, defaultValue = null) => {
    return statefulStreamFromEmitter(
      pipe(
        components,
        map((components2) => components2[propName]),
        distinctUntilChanged()
      ),
      defaultValue
    );
  }, "distinctProp");
  return {
    context,
    itemContent,
    fixedHeaderContent: fixedHeaderContent2,
    fixedFooterContent,
    components,
    computeItemKey,
    scrollerRef,
    TableComponent: distinctProp("Table", "table"),
    TableHeadComponent: distinctProp("TableHead", "thead"),
    TableFooterComponent: distinctProp("TableFoot", "tfoot"),
    TableBodyComponent: distinctProp("TableBody", "tbody"),
    TableRowComponent: distinctProp("TableRow", "tr"),
    ScrollerComponent: distinctProp("Scroller", "div"),
    EmptyPlaceholder: distinctProp("EmptyPlaceholder"),
    ScrollSeekPlaceholder: distinctProp("ScrollSeekPlaceholder"),
    FillerRow: distinctProp("FillerRow")
  };
});
const combinedSystem = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {
  return { ...listSystem2, ...propsSystem };
}, tup(listSystem, tableComponentPropsSystem));
const DefaultScrollSeekPlaceholder = /* @__PURE__ */ __name(({ height: height2 }) => /* @__PURE__ */ React$1.createElement("tr", null, /* @__PURE__ */ React$1.createElement("td", { style: { height: height2 } })), "DefaultScrollSeekPlaceholder");
const DefaultFillerRow = /* @__PURE__ */ __name(({ height: height2 }) => /* @__PURE__ */ React$1.createElement("tr", null, /* @__PURE__ */ React$1.createElement("td", { style: { height: height2, padding: 0, border: 0 } })), "DefaultFillerRow");
const ITEM_STYLE = { overflowAnchor: "none" };
const Items = /* @__PURE__ */ React$1.memo(/* @__PURE__ */ __name(function VirtuosoItems2() {
  const listState = useEmitterValue("listState");
  const sizeRanges = usePublisher("sizeRanges");
  const useWindowScroll = useEmitterValue("useWindowScroll");
  const customScrollParent = useEmitterValue("customScrollParent");
  const windowScrollContainerStateCallback = usePublisher("windowScrollContainerState");
  const _scrollContainerStateCallback = usePublisher("scrollContainerState");
  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;
  const itemContent = useEmitterValue("itemContent");
  const trackItemSizes = useEmitterValue("trackItemSizes");
  const itemSize = useEmitterValue("itemSize");
  const log = useEmitterValue("log");
  const { callbackRef, ref } = useChangedListContentsSizes(
    sizeRanges,
    itemSize,
    trackItemSizes,
    scrollContainerStateCallback,
    log,
    void 0,
    customScrollParent,
    false,
    useEmitterValue("skipAnimationFrameInResizeObserver")
  );
  const [deviation, setDeviation] = React$1.useState(0);
  useEmitter("deviation", (value) => {
    if (deviation !== value) {
      ref.current.style.marginTop = `${value}px`;
      setDeviation(value);
    }
  });
  const EmptyPlaceholder = useEmitterValue("EmptyPlaceholder");
  const ScrollSeekPlaceholder = useEmitterValue("ScrollSeekPlaceholder") || DefaultScrollSeekPlaceholder;
  const FillerRow = useEmitterValue("FillerRow") || DefaultFillerRow;
  const TableBodyComponent = useEmitterValue("TableBodyComponent");
  const TableRowComponent = useEmitterValue("TableRowComponent");
  const computeItemKey = useEmitterValue("computeItemKey");
  const isSeeking = useEmitterValue("isSeeking");
  const paddingTopAddition = useEmitterValue("paddingTopAddition");
  const firstItemIndex = useEmitterValue("firstItemIndex");
  const statefulTotalCount = useEmitterValue("statefulTotalCount");
  const context = useEmitterValue("context");
  if (statefulTotalCount === 0 && EmptyPlaceholder) {
    return React$1.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));
  }
  const paddingTop = listState.offsetTop + paddingTopAddition + deviation;
  const paddingBottom = listState.offsetBottom;
  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */ React$1.createElement(FillerRow, { height: paddingTop, key: "padding-top", context }) : null;
  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */ React$1.createElement(FillerRow, { height: paddingBottom, key: "padding-bottom", context }) : null;
  const items = listState.items.map((item) => {
    const index2 = item.originalIndex;
    const key = computeItemKey(index2 + firstItemIndex, item.data, context);
    if (isSeeking) {
      return React$1.createElement(ScrollSeekPlaceholder, {
        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),
        key,
        index: item.index,
        height: item.size,
        type: item.type || "item"
      });
    }
    return React$1.createElement(
      TableRowComponent,
      {
        ...contextPropIfNotDomElement(TableRowComponent, context),
        ...itemPropIfNotDomElement(TableRowComponent, item.data),
        key,
        "data-index": index2,
        "data-known-size": item.size,
        "data-item-index": item.index,
        style: ITEM_STYLE
      },
      itemContent(item.index, item.data, context)
    );
  });
  return React$1.createElement(
    TableBodyComponent,
    { ref: callbackRef, "data-testid": "virtuoso-item-list", ...contextPropIfNotDomElement(TableBodyComponent, context) },
    [paddingTopEl, ...items, paddingBottomEl]
  );
}, "VirtuosoItems2"));
const Viewport = /* @__PURE__ */ __name(({ children }) => {
  const ctx = React$1.useContext(VirtuosoMockContext);
  const viewportHeight = usePublisher("viewportHeight");
  const fixedItemHeight = usePublisher("fixedItemHeight");
  const viewportRef = useSize(
    React$1.useMemo(() => compose(viewportHeight, (el2) => correctItemSize(el2, "height")), [viewportHeight]),
    true,
    useEmitterValue("skipAnimationFrameInResizeObserver")
  );
  React$1.useEffect(() => {
    if (ctx) {
      viewportHeight(ctx.viewportHeight);
      fixedItemHeight(ctx.itemHeight);
    }
  }, [ctx, viewportHeight, fixedItemHeight]);
  return /* @__PURE__ */ React$1.createElement("div", { style: viewportStyle(), ref: viewportRef, "data-viewport-type": "element" }, children);
}, "Viewport");
const WindowViewport = /* @__PURE__ */ __name(({ children }) => {
  const ctx = React$1.useContext(VirtuosoMockContext);
  const windowViewportRect = usePublisher("windowViewportRect");
  const fixedItemHeight = usePublisher("fixedItemHeight");
  const customScrollParent = useEmitterValue("customScrollParent");
  const viewportRef = useWindowViewportRectRef(
    windowViewportRect,
    customScrollParent,
    useEmitterValue("skipAnimationFrameInResizeObserver")
  );
  React$1.useEffect(() => {
    if (ctx) {
      fixedItemHeight(ctx.itemHeight);
      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });
    }
  }, [ctx, windowViewportRect, fixedItemHeight]);
  return /* @__PURE__ */ React$1.createElement("div", { ref: viewportRef, style: viewportStyle(), "data-viewport-type": "window" }, children);
}, "WindowViewport");
const TableRoot = /* @__PURE__ */ React$1.memo(/* @__PURE__ */ __name(function TableVirtuosoRoot(props) {
  const useWindowScroll = useEmitterValue("useWindowScroll");
  const customScrollParent = useEmitterValue("customScrollParent");
  const fixedHeaderHeight = usePublisher("fixedHeaderHeight");
  const fixedFooterHeight = usePublisher("fixedFooterHeight");
  const fixedHeaderContent2 = useEmitterValue("fixedHeaderContent");
  const fixedFooterContent = useEmitterValue("fixedFooterContent");
  const context = useEmitterValue("context");
  const theadRef = useSize(
    React$1.useMemo(() => compose(fixedHeaderHeight, (el2) => correctItemSize(el2, "height")), [fixedHeaderHeight]),
    true,
    useEmitterValue("skipAnimationFrameInResizeObserver")
  );
  const tfootRef = useSize(
    React$1.useMemo(() => compose(fixedFooterHeight, (el2) => correctItemSize(el2, "height")), [fixedFooterHeight]),
    true,
    useEmitterValue("skipAnimationFrameInResizeObserver")
  );
  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;
  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;
  const TheTable = useEmitterValue("TableComponent");
  const TheTHead = useEmitterValue("TableHeadComponent");
  const TheTFoot = useEmitterValue("TableFooterComponent");
  const theHead = fixedHeaderContent2 ? React$1.createElement(
    TheTHead,
    {
      key: "TableHead",
      style: { zIndex: 2, position: "sticky", top: 0 },
      ref: theadRef,
      ...contextPropIfNotDomElement(TheTHead, context)
    },
    fixedHeaderContent2()
  ) : null;
  const theFoot = fixedFooterContent ? React$1.createElement(
    TheTFoot,
    {
      key: "TableFoot",
      style: { zIndex: 1, position: "sticky", bottom: 0 },
      ref: tfootRef,
      ...contextPropIfNotDomElement(TheTFoot, context)
    },
    fixedFooterContent()
  ) : null;
  return /* @__PURE__ */ React$1.createElement(TheScroller, { ...props }, /* @__PURE__ */ React$1.createElement(TheViewport, null, React$1.createElement(
    TheTable,
    { style: { borderSpacing: 0, overflowAnchor: "none" }, ...contextPropIfNotDomElement(TheTable, context) },
    [theHead, /* @__PURE__ */ React$1.createElement(Items, { key: "TableBody" }), theFoot]
  )));
}, "TableVirtuosoRoot"));
const {
  Component: Table,
  usePublisher,
  useEmitterValue,
  useEmitter
} = /* @__PURE__ */ systemToComponent(
  combinedSystem,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      firstItemIndex: "firstItemIndex",
      itemContent: "itemContent",
      fixedHeaderContent: "fixedHeaderContent",
      fixedFooterContent: "fixedFooterContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      topItemCount: "topItemCount",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      groupCounts: "groupCounts",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  TableRoot
);
const Scroller = /* @__PURE__ */ buildScroller({ usePublisher, useEmitterValue, useEmitter });
const WindowScroller = /* @__PURE__ */ buildWindowScroller({ usePublisher, useEmitterValue, useEmitter });
const TableVirtuoso = Table;
var Close = {};
var _interopRequireDefault$v = interopRequireDefaultExports;
Object.defineProperty(Close, "__esModule", {
  value: true
});
var default_1$q = Close.default = void 0;
var _createSvgIcon$q = _interopRequireDefault$v(requireCreateSvgIcon());
var _jsxRuntime$q = jsxRuntimeExports;
default_1$q = Close.default = (0, _createSvgIcon$q.default)(/* @__PURE__ */ (0, _jsxRuntime$q.jsx)("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
var Add = {};
var _interopRequireDefault$u = interopRequireDefaultExports;
Object.defineProperty(Add, "__esModule", {
  value: true
});
var default_1$p = Add.default = void 0;
var _createSvgIcon$p = _interopRequireDefault$u(requireCreateSvgIcon());
var _jsxRuntime$p = jsxRuntimeExports;
default_1$p = Add.default = (0, _createSvgIcon$p.default)(/* @__PURE__ */ (0, _jsxRuntime$p.jsx)("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}), "Add");
var utc$1 = { exports: {} };
(function(module, exports) {
  !function(t2, i) {
    module.exports = i();
  }(commonjsGlobal, function() {
    var t2 = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e2 = /([+-]|\d\d)/g;
    return function(s, f2, n2) {
      var u2 = f2.prototype;
      n2.utc = function(t3) {
        var i2 = { date: t3, utc: true, args: arguments };
        return new f2(i2);
      }, u2.utc = function(i2) {
        var e3 = n2(this.toDate(), { locale: this.$L, utc: true });
        return i2 ? e3.add(this.utcOffset(), t2) : e3;
      }, u2.local = function() {
        return n2(this.toDate(), { locale: this.$L, utc: false });
      };
      var o = u2.parse;
      u2.parse = function(t3) {
        t3.utc && (this.$u = true), this.$utils().u(t3.$offset) || (this.$offset = t3.$offset), o.call(this, t3);
      };
      var r2 = u2.init;
      u2.init = function() {
        if (this.$u) {
          var t3 = this.$d;
          this.$y = t3.getUTCFullYear(), this.$M = t3.getUTCMonth(), this.$D = t3.getUTCDate(), this.$W = t3.getUTCDay(), this.$H = t3.getUTCHours(), this.$m = t3.getUTCMinutes(), this.$s = t3.getUTCSeconds(), this.$ms = t3.getUTCMilliseconds();
        } else
          r2.call(this);
      };
      var a = u2.utcOffset;
      u2.utcOffset = function(s2, f3) {
        var n3 = this.$utils().u;
        if (n3(s2))
          return this.$u ? 0 : n3(this.$offset) ? a.call(this) : this.$offset;
        if ("string" == typeof s2 && (s2 = function(t3) {
          void 0 === t3 && (t3 = "");
          var s3 = t3.match(i);
          if (!s3)
            return null;
          var f4 = ("" + s3[0]).match(e2) || ["-", 0, 0], n4 = f4[0], u4 = 60 * +f4[1] + +f4[2];
          return 0 === u4 ? 0 : "+" === n4 ? u4 : -u4;
        }(s2), null === s2))
          return this;
        var u3 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
        if (f3)
          return o2.$offset = u3, o2.$u = 0 === s2, o2;
        if (0 !== s2) {
          var r3 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (o2 = this.local().add(u3 + r3, t2)).$offset = u3, o2.$x.$localOffset = r3;
        } else
          o2 = this.utc();
        return o2;
      };
      var h2 = u2.format;
      u2.format = function(t3) {
        var i2 = t3 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return h2.call(this, i2);
      }, u2.valueOf = function() {
        var t3 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * t3;
      }, u2.isUTC = function() {
        return !!this.$u;
      }, u2.toISOString = function() {
        return this.toDate().toISOString();
      }, u2.toString = function() {
        return this.toDate().toUTCString();
      };
      var l2 = u2.toDate;
      u2.toDate = function(t3) {
        return "s" === t3 && this.$offset ? n2(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l2.call(this);
      };
      var c2 = u2.diff;
      u2.diff = function(t3, i2, e3) {
        if (t3 && this.$u === t3.$u)
          return c2.call(this, t3, i2, e3);
        var s2 = this.local(), f3 = n2(t3).local();
        return c2.call(s2, f3, i2, e3);
      };
    };
  });
})(utc$1);
var utcExports = utc$1.exports;
const utc = /* @__PURE__ */ getDefaultExportFromCjs(utcExports);
var timezone$1 = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, e2 = {};
    return function(n2, i, o) {
      var r2, a = /* @__PURE__ */ __name(function(t3, n3, i2) {
        void 0 === i2 && (i2 = {});
        var o2 = new Date(t3), r3 = function(t4, n4) {
          void 0 === n4 && (n4 = {});
          var i3 = n4.timeZoneName || "short", o3 = t4 + "|" + i3, r4 = e2[o3];
          return r4 || (r4 = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: t4, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i3 }), e2[o3] = r4), r4;
        }(n3, i2);
        return r3.formatToParts(o2);
      }, "a"), u2 = /* @__PURE__ */ __name(function(e3, n3) {
        for (var i2 = a(e3, n3), r3 = [], u3 = 0; u3 < i2.length; u3 += 1) {
          var f3 = i2[u3], s2 = f3.type, m2 = f3.value, c2 = t2[s2];
          c2 >= 0 && (r3[c2] = parseInt(m2, 10));
        }
        var d2 = r3[3], l2 = 24 === d2 ? 0 : d2, h2 = r3[0] + "-" + r3[1] + "-" + r3[2] + " " + l2 + ":" + r3[4] + ":" + r3[5] + ":000", v2 = +e3;
        return (o.utc(h2).valueOf() - (v2 -= v2 % 1e3)) / 6e4;
      }, "u"), f2 = i.prototype;
      f2.tz = function(t3, e3) {
        void 0 === t3 && (t3 = r2);
        var n3, i2 = this.utcOffset(), a2 = this.toDate(), u3 = a2.toLocaleString("en-US", { timeZone: t3 }), f3 = Math.round((a2 - new Date(u3)) / 1e3 / 60), s2 = 15 * -Math.round(a2.getTimezoneOffset() / 15) - f3;
        if (!Number(s2))
          n3 = this.utcOffset(0, e3);
        else if (n3 = o(u3, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(s2, true), e3) {
          var m2 = n3.utcOffset();
          n3 = n3.add(i2 - m2, "minute");
        }
        return n3.$x.$timezone = t3, n3;
      }, f2.offsetName = function(t3) {
        var e3 = this.$x.$timezone || o.tz.guess(), n3 = a(this.valueOf(), e3, { timeZoneName: t3 }).find(function(t4) {
          return "timezonename" === t4.type.toLowerCase();
        });
        return n3 && n3.value;
      };
      var s = f2.startOf;
      f2.startOf = function(t3, e3) {
        if (!this.$x || !this.$x.$timezone)
          return s.call(this, t3, e3);
        var n3 = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L });
        return s.call(n3, t3, e3).tz(this.$x.$timezone, true);
      }, o.tz = function(t3, e3, n3) {
        var i2 = n3 && e3, a2 = n3 || e3 || r2, f3 = u2(+o(), a2);
        if ("string" != typeof t3)
          return o(t3).tz(a2);
        var s2 = function(t4, e4, n4) {
          var i3 = t4 - 60 * e4 * 1e3, o2 = u2(i3, n4);
          if (e4 === o2)
            return [i3, e4];
          var r3 = u2(i3 -= 60 * (o2 - e4) * 1e3, n4);
          return o2 === r3 ? [i3, o2] : [t4 - 60 * Math.min(o2, r3) * 1e3, Math.max(o2, r3)];
        }(o.utc(t3, i2).valueOf(), f3, a2), m2 = s2[0], c2 = s2[1], d2 = o(m2).utcOffset(c2);
        return d2.$x.$timezone = a2, d2;
      }, o.tz.guess = function() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      }, o.tz.setDefault = function(t3) {
        r2 = t3;
      };
    };
  });
})(timezone$1);
var timezoneExports = timezone$1.exports;
const timezone = /* @__PURE__ */ getDefaultExportFromCjs(timezoneExports);
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s = "minute", u2 = "hour", a = "day", o = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
      return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m2 = /* @__PURE__ */ __name(function(t3, e3, n3) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
    }, "m"), v2 = { s: m2, z: function(t3) {
      var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: /* @__PURE__ */ __name(function t3(e3, n3) {
      if (e3.date() < n3.date())
        return -t3(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, c2), s2 = n3 - i2 < 0, u3 = e3.clone().add(r3 + (s2 ? -1 : 1), c2);
      return +(-(r3 + (n3 - i2) / (s2 ? i2 - u3 : u3 - i2)) || 0);
    }, "t"), a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h2, w: o, d: a, D: d2, h: u2, m: s, s: i, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = "$isDayjsObject", S2 = /* @__PURE__ */ __name(function(t3) {
      return t3 instanceof _2 || !(!t3 || !t3[p2]);
    }, "S"), w2 = /* @__PURE__ */ __name(function t3(e3, n3, r3) {
      var i2;
      if (!e3)
        return g2;
      if ("string" == typeof e3) {
        var s2 = e3.toLowerCase();
        D2[s2] && (i2 = s2), n3 && (D2[s2] = n3, i2 = s2);
        var u3 = e3.split("-");
        if (!i2 && u3.length > 1)
          return t3(u3[0]);
      } else {
        var a2 = e3.name;
        D2[a2] = e3, i2 = a2;
      }
      return !r3 && i2 && (g2 = i2), i2 || !r3 && g2;
    }, "t"), O2 = /* @__PURE__ */ __name(function(t3, e3) {
      if (S2(t3))
        return t3.clone();
      var n3 = "object" == typeof e3 ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _2(n3);
    }, "O"), b2 = v2;
    b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
      return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _2 = function() {
      function M3(t3) {
        this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
      }
      __name(M3, "M");
      var m3 = M3.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n3 = t4.utc;
          if (null === e3)
            return /* @__PURE__ */ new Date(NaN);
          if (b2.u(e3))
            return /* @__PURE__ */ new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($);
            if (r3) {
              var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return b2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t3, e3) {
        var n3 = O2(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return O2(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < O2(t3);
      }, m3.$g = function(t3, e3, n3) {
        return b2.u(t3) ? this[e3] : this.set(n3, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = /* @__PURE__ */ __name(function(t4, e4) {
          var i2 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r3 ? i2 : i2.endOf(a);
        }, "l"), $2 = /* @__PURE__ */ __name(function(t4, e4) {
          return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, "$"), y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M4) : l3(0, M4 + 1);
          case o:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
          case a:
          case d2:
            return $2(v3 + "Hours", 0);
          case u2:
            return $2(v3 + "Minutes", 1);
          case s:
            return $2(v3 + "Seconds", 2);
          case i:
            return $2(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n3, o2 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s] = f3 + "Minutes", n3[i] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o2], $2 = o2 === a ? this.$D + (e3 - this.$W) : e3;
        if (o2 === c2 || o2 === h2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($2);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[b2.p(t3)]();
      }, m3.add = function(r3, f3) {
        var d3, l3 = this;
        r3 = Number(r3);
        var $2 = b2.p(f3), y3 = /* @__PURE__ */ __name(function(t3) {
          var e3 = O2(l3);
          return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        }, "y");
        if ($2 === c2)
          return this.set(c2, this.$M + r3);
        if ($2 === h2)
          return this.set(h2, this.$y + r3);
        if ($2 === a)
          return y3(1);
        if ($2 === o)
          return y3(7);
        var M4 = (d3 = {}, d3[s] = e2, d3[u2] = n2, d3[i] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M4;
        return b2.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b2.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o2 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = /* @__PURE__ */ __name(function(t4, n4, i3, s3) {
          return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].slice(0, s3);
        }, "h"), d3 = /* @__PURE__ */ __name(function(t4) {
          return b2.s(s2 % 12 || 12, t4, "0");
        }, "d"), $2 = f3 || function(t4, e4, n4) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y2, function(t4, r4) {
          return r4 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b2.s(e3.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b2.s(a2 + 1, 2, "0");
              case "MMM":
                return h3(n3.monthsShort, a2, c3, 3);
              case "MMMM":
                return h3(c3, a2);
              case "D":
                return e3.$D;
              case "DD":
                return b2.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h3(n3.weekdaysMin, e3.$W, o2, 2);
              case "ddd":
                return h3(n3.weekdaysShort, e3.$W, o2, 3);
              case "dddd":
                return o2[e3.$W];
              case "H":
                return String(s2);
              case "HH":
                return b2.s(s2, 2, "0");
              case "h":
                return d3(1);
              case "hh":
                return d3(2);
              case "a":
                return $2(s2, u3, true);
              case "A":
                return $2(s2, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b2.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b2.s(e3.$s, 2, "0");
              case "SSS":
                return b2.s(e3.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t4) || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d3, l3) {
        var $2, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = /* @__PURE__ */ __name(function() {
          return b2.m(y3, m4);
        }, "D");
        switch (M4) {
          case h2:
            $2 = D3() / 12;
            break;
          case c2:
            $2 = D3();
            break;
          case f2:
            $2 = D3() / 3;
            break;
          case o:
            $2 = (g3 - v3) / 6048e5;
            break;
          case a:
            $2 = (g3 - v3) / 864e5;
            break;
          case u2:
            $2 = g3 / n2;
            break;
          case s:
            $2 = g3 / e2;
            break;
          case i:
            $2 = g3 / t2;
            break;
          default:
            $2 = g3;
        }
        return l3 ? $2 : b2.a($2);
      }, m3.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n3 = this.clone(), r3 = w2(t3, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m3.clone = function() {
        return b2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k2 = _2.prototype;
    return O2.prototype = k2, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u2], ["$W", a], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
      k2[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _2, O2), t3.$i = true), O2;
    }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
      return O2(1e3 * t3);
    }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
dayjs.extend(utc);
dayjs.extend(timezone);
const formatDate = /* @__PURE__ */ __name((value) => {
  if (typeof value === "string") {
    const brazilianDateTime = dayjs.utc(value);
    const formattedDate = brazilianDateTime.format("DD/MM/YYYY");
    const formattedTime = brazilianDateTime.format("HH:mm:ss");
    if (formattedTime === "00:00:00") {
      return `${formattedDate}`;
    }
    return `${formattedDate}, ${formattedTime}`;
  }
}, "formatDate");
const formatDateWithNoTime = /* @__PURE__ */ __name((value) => {
  if (typeof value === "string") {
    const brazilianDateTime = dayjs.utc(value);
    const formattedDate = brazilianDateTime.format("DD/MM/YYYY");
    return `${formattedDate}`;
  }
}, "formatDateWithNoTime");
const CloseModalButton = /* @__PURE__ */ __name(({ handleClose }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IconButton,
    {
      onClick: () => handleClose(),
      sx: { position: "absolute", top: 0, right: 0 },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, { sx: { color: "red" } })
    }
  );
}, "CloseModalButton");
const isPDF$1 = /* @__PURE__ */ __name((url) => {
  console.log({ url });
  if (/\.pdf$/i.test(url)) {
    return true;
  }
  return false;
}, "isPDF$1");
const Loader$1 = /* @__PURE__ */ __name(() => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      sx: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        display: "flex",
        justifyContent: "center",
        height: "100%",
        width: "100%",
        alignItems: "center",
        backgroundColor: "rgba(255, 255, 255, 0.7)",
        // Fundo semi-transparente
        zIndex: 1e3
        // Garante que o spinner fique acima de tudo
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {})
    }
  );
}, "Loader$1");
const useProductsTableModal = /* @__PURE__ */ __name((requisitionID) => {
  const { adding, toggleAdding, productIdList } = reactExports.useContext(ItemsContext);
  const [requisition, setRequisition] = reactExports.useState();
  const [products, setProducts] = reactExports.useState([]);
  const [alert2, setAlert] = reactExports.useState();
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [isSelecting, setIsSelecting] = reactExports.useState(false);
  const [selectedProducts, setSelectedProducts] = reactExports.useState([]);
  const [addedItems, setAddedItems] = reactExports.useState([]);
  const [isInsertingQuantity, setIsInsertingQuantity] = reactExports.useState(false);
  const displayAlert = /* @__PURE__ */ __name(async (severity, message) => {
    setTimeout(() => {
      setAlert(void 0);
    }, 3e3);
    setAlert({ severity, message });
    return;
  }, "displayAlert");
  const handleSelectionChange = /* @__PURE__ */ __name((rowSelectionModel, _details) => {
    if (rowSelectionModel.length > 0) {
      setIsSelecting(true);
      const localSelectedProducts = products.filter((product, _index) => rowSelectionModel.find((id2) => product.ID === id2));
      setSelectedProducts(localSelectedProducts);
      return;
    }
    setIsSelecting(false);
  }, "handleSelectionChange");
  const fetchProducts = /* @__PURE__ */ __name(async () => {
    if (requisition) {
      try {
        const products2 = await searchProducts(searchTerm, requisition.TIPO);
        setProducts(products2);
      } catch (e2) {
        displayAlert("error", e2.message);
      }
    }
  }, "fetchProducts");
  const fetchRequisition = /* @__PURE__ */ __name(async () => {
    try {
      const requisition2 = await fetchRequsitionById(requisitionID);
      setRequisition(requisition2);
      if (requisition2) {
        setRequisition(requisition2);
      }
    } catch (e2) {
      displayAlert("error", e2.message);
    }
  }, "fetchRequisition");
  const handleSearch = /* @__PURE__ */ __name((e2) => {
    const { value } = e2.target;
    if (e2.key === "Enter") {
      console.log("setting new searchTerm");
      const newSearchTerm = value.toUpperCase();
      console.log("newSearchTerm", newSearchTerm);
      setSearchTerm(newSearchTerm);
    }
  }, "handleSearch");
  const handleClose = /* @__PURE__ */ __name(() => {
    toggleAdding();
    setProducts([]);
    setSearchTerm("");
    setSelectedProducts([]);
  }, "handleClose");
  reactExports.useEffect(() => {
    console.log("useEffect search term");
    if (searchTerm !== "") {
      console.log("fetching products");
      fetchProducts();
      return;
    }
  }, [searchTerm, adding]);
  reactExports.useEffect(() => {
    fetchRequisition();
  }, [adding]);
  return {
    products,
    requisition,
    alert: alert2,
    handleSearch,
    adding,
    handleClose,
    searchTerm,
    selectedProducts,
    setSelectedProducts,
    isSelecting,
    setIsSelecting,
    handleSelectionChange,
    displayAlert,
    addedItems,
    setAddedItems,
    isInsertingQuantity,
    setIsInsertingQuantity,
    productIdList
  };
}, "useProductsTableModal");
const InsertQuantitiesModal = /* @__PURE__ */ __name(({
  addedItems,
  isInsertingQuantity,
  setIsInsertingQuantity,
  setAddedItems,
  setSelectedProducts
}) => {
  const { id: id2 } = useParams();
  const { toggleAdding } = reactExports.useContext(ItemsContext);
  const handleClose = /* @__PURE__ */ __name(() => {
    setIsInsertingQuantity(false);
    setAddedItems([]);
    setSelectedProducts([]);
    toggleAdding();
  }, "handleClose");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Modal$3, { open: isInsertingQuantity, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        width: "90%",
        height: "90%",
        bgcolor: "background.paper",
        boxShadow: 24,
        p: 1
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CloseModalButton, { handleClose }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: 2, sx: { height: "100%" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading2, children: "Insira as quantidades dos produtos adicionados!" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { height: "80%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            RequisitionItemsTable,
            {
              requisitionId: Number(id2),
              isInsertingQuantity,
              addedItems
            }
          ) })
        ] })
      ]
    }
  ) });
}, "InsertQuantitiesModal");
const FullScreenModalBox = styled(Box)(({ theme: theme2 }) => ({
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  padding: 6,
  width: "90vw",
  // 90% da largura da tela
  height: "95vh",
  // 90% da altura da tela
  backgroundColor: theme2.palette.background.paper,
  boxShadow: theme2.shadows[24],
  borderRadius: theme2.shape.borderRadius,
  outline: "none"
  // Remove a borda padro
}));
const columns$5 = [
  {
    headerName: "Nome",
    field: "nome_fantasia",
    width: 250
  },
  {
    headerName: "Codigo TOTVS",
    field: "codigo",
    width: 180
  }
];
const ProductsTableModal = /* @__PURE__ */ __name(({
  requisitionID
}) => {
  const {
    products,
    requisition,
    alert: alert2,
    handleSearch,
    adding,
    handleClose,
    isSelecting,
    setIsSelecting,
    selectedProducts,
    setSelectedProducts,
    handleSelectionChange,
    displayAlert,
    addedItems,
    setAddedItems,
    isInsertingQuantity,
    setIsInsertingQuantity,
    productIdList
  } = useProductsTableModal(requisitionID);
  const gridApiRef = useGridApiRef();
  const handleCancelSelecting = /* @__PURE__ */ __name(() => {
    setIsSelecting(false);
    setSelectedProducts([]);
    gridApiRef.current.setRowSelectionModel([]);
  }, "handleCancelSelecting");
  const filterNonRepeatedProducts = /* @__PURE__ */ __name(() => {
    return selectedProducts.map((product) => {
      if (!productIdList.includes(product.ID)) {
        return {
          ID: 0,
          QUANTIDADE: 0,
          ID_REQUISICAO: requisitionID,
          ID_PRODUTO: product.ID,
          OBSERVACAO: null,
          ATIVO: 1,
          OC: null
        };
      }
    }).filter((item) => item !== void 0);
  }, "filterNonRepeatedProducts");
  const handleSaveAddItems = /* @__PURE__ */ __name(async () => {
    const newProductItems = filterNonRepeatedProducts();
    console.log({ newProductItems });
    if (newProductItems.length) {
      try {
        const data = await postRequistionItems(
          requisitionID,
          newProductItems
        );
        setAddedItems(data.insertedItems);
        setIsInsertingQuantity(true);
      } catch (e2) {
        displayAlert("error", e2.message);
      }
    }
  }, "handleSaveAddItems");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: adding,
      "aria-labelledby": "child-modal-title",
      "aria-describedby": "child-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FullScreenModalBox, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CloseModalButton, { handleClose }),
        alert2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: alert2.severity, children: alert2.message }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { sx: { height: "100%", gap: 1, padding: 0.5 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              sx: {
                width: "100%",
                height: {
                  xs: "20%",
                  md: "5%"
                },
                display: "flex",
                alignItems: "center",
                flexDirection: {
                  xs: "column",
                  sm: "column",
                  md: "row"
                },
                gap: 1
              },
              children: [
                requisition && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { sx: typographyStyles.heading2, children: [
                  requisition.DESCRICAO,
                  " | ",
                  requisition.nome_tipo
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField,
                  {
                    variant: "outlined",
                    onKeyDown: handleSearch,
                    InputProps: {
                      sx: { borderRadius: 10, height: 40 },
                      placeholder: "busque por nome..."
                    }
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              sx: {
                height: {
                  xs: "70%",
                  md: "80%"
                }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                DataGrid,
                {
                  checkboxSelection: true,
                  sx: {
                    "& .MuiDataGrid-menuIconButton": {
                      display: "none"
                    }
                  },
                  slots: {
                    noRowsOverlay: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Box,
                      {
                        sx: {
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          justifyContent: "center",
                          gap: 2,
                          height: "100%"
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading2, children: "Pesquise o produto desejado" })
                      }
                    )
                  },
                  onRowSelectionModelChange: (rowSelectionModel, details) => handleSelectionChange(rowSelectionModel, details),
                  density: "compact",
                  getRowId: (row) => row.ID,
                  rows: products,
                  columns: columns$5,
                  apiRef: gridApiRef,
                  pageSizeOptions: [100]
                }
              )
            }
          ),
          isSelecting && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...alertAnimation, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Stack,
            {
              direction: "row",
              gap: 2,
              alignItems: "center",
              padding: 1,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { sx: BaseButtonStyles, onClick: handleSaveAddItems, children: "Adicionar items" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleCancelSelecting, sx: BaseButtonStyles, children: "Cancelar" })
              ]
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          InsertQuantitiesModal,
          {
            setAddedItems,
            addedItems,
            isInsertingQuantity,
            setIsInsertingQuantity,
            setSelectedProducts
          }
        )
      ] })
    }
  ) });
}, "ProductsTableModal");
const ItemsToolBar = /* @__PURE__ */ __name(({
  handleCancelItems,
  handleActivateItems,
  handleCopyContent,
  handleDelete,
  selectedRows
}) => {
  const { toggleAdding } = reactExports.useContext(ItemsContext);
  const { id: id2 } = useParams();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", sx: { height: 30, alignItems: "center", gap: 2 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ItemActions,
      {
        handleCancelItems,
        handleActivateItems,
        handleCopyContent,
        handleDelete,
        selectedItems: selectedRows
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: () => toggleAdding(),
        sx: { ...BaseButtonStyles, height: 30 },
        children: "Adicionar items"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ProductsTableModal, { requisitionID: Number(id2) })
  ] });
}, "ItemsToolBar");
const columns$4 = [
  {
    field: "nome_fantasia",
    headerName: "Nome Fantasia",
    editable: false,
    width: 300,
    renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { ...typographyStyles.bodyText }, children: params.value })
  },
  {
    field: "codigo",
    headerName: "Cdigo",
    width: 150,
    // Defina a largura desejada
    editable: false,
    renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { ...typographyStyles.bodyText }, children: params.value ? params.value : "Sem cdigo" })
  },
  {
    field: "OC",
    headerName: "OC",
    width: 100,
    // Defina a largura desejada
    type: "number",
    editable: true,
    renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { ...typographyStyles.bodyText }, children: params.value ?? "-" })
  },
  {
    field: "QUANTIDADE",
    headerName: "Quantidade",
    width: 120,
    // Defina a largura desejada
    type: "number",
    editable: true,
    renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { ...typographyStyles.bodyText, pointerEvents: "none" }, children: params.value })
  },
  {
    field: "UNIDADE",
    headerName: "Unidade",
    width: 100,
    // Defina a largura desejada
    editable: false,
    renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { ...typographyStyles.bodyText }, children: params.value ?? "-" })
  },
  {
    field: "OBSERVACAO",
    headerName: "Observao",
    width: 200,
    // Defina a largura desejada
    editable: true,
    renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { ...typographyStyles.bodyText }, children: params.value && params.value !== "null" ? params.value : "" })
  },
  {
    field: "ATIVO",
    headerName: "Ativo",
    width: 100,
    // Defina a largura desejada
    type: "number",
    editable: false,
    renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Typography,
      {
        sx: {
          ...typographyStyles.smallText,
          color: params.value ? "darkgreen" : "gray"
        },
        children: params.value ? "Sim" : "No"
      }
    )
  },
  {
    field: "ID",
    headerName: "ID",
    width: 100,
    // Defina a largura desejada
    type: "number",
    editable: false,
    renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { ...typographyStyles.bodyText }, children: params.value })
  },
  {
    field: "ID_PRODUTO",
    headerName: "ID Produto",
    width: 120,
    // Defina a largura desejada
    type: "number",
    editable: false,
    renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { ...typographyStyles.bodyText }, children: params.value })
  }
];
const RequisitionItemsTable = /* @__PURE__ */ __name(({
  requisitionId,
  addedItems,
  isInsertingQuantity
}) => {
  const {
    visibleItems,
    isEditing,
    alert: alert2,
    gridApiRef,
    handleRowModesModelChange,
    handleCancelEdition,
    processRowUpdate,
    handleSave,
    setIsEditing,
    handleChangeSelection,
    handleDelete,
    handleCancelItems,
    handleActivateItems,
    handleCopyContent,
    selectedRows
  } = useRequisitionItems(requisitionId, isInsertingQuantity, addedItems);
  const ReqItemsFooter = /* @__PURE__ */ __name((props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      GridFooterContainer,
      {
        sx: { ...props.style, ...styles$a.gridFooterContainer },
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: alert2 && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...alertAnimation, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: alert2.severity, children: alert2.message }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(GridFooter, {}),
          isEditing && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleSave, sx: BaseButtonStyles, children: "Salvar" }),
          isEditing && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleCancelEdition, sx: BaseButtonStyles, children: "Cancelar edio" })
        ]
      }
    );
  }, "ReqItemsFooter");
  const insertingQuantityColumns = columns$4.filter(
    (column2) => column2.field === "QUANTIDADE" || column2.field === "nome_fantasia" || column2.field === "UNIDADE"
  );
  const handleCellClick = /* @__PURE__ */ __name((params) => {
    console.log("handleCellClick");
    gridApiRef.current.startRowEditMode({ id: params.row.ID, fieldToFocus: params.colDef.field });
    if (!isEditing) {
      setIsEditing(true);
      return;
    }
  }, "handleCellClick");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { ...styles$a.container }, children: [
    !isInsertingQuantity && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ItemsToolBar,
      {
        handleCancelItems,
        handleActivateItems,
        handleCopyContent,
        handleDelete,
        selectedRows
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DataGrid,
      {
        density: isInsertingQuantity ? "comfortable" : "compact",
        rows: visibleItems,
        getRowId: (item) => item.ID,
        columns: isInsertingQuantity ? insertingQuantityColumns : columns$4,
        initialState: {
          pagination: {
            paginationModel: {
              pageSize: 100
            }
          }
        },
        apiRef: gridApiRef,
        editMode: "row",
        pageSizeOptions: [100],
        checkboxSelection: !isInsertingQuantity,
        onCellClick: handleCellClick,
        disableRowSelectionOnClick: true,
        onRowSelectionModelChange: handleChangeSelection,
        onRowEditStart: () => setIsEditing(true),
        processRowUpdate: (newRow, oldRow) => processRowUpdate(newRow, oldRow),
        sx: {
          "& .MuiDataGrid-cell": {
            display: "flex",
            alignItems: "center"
          },
          "& .MuiDataGrid-menuIconButton": {
            display: "none"
          }
        },
        slots: {
          footer: ReqItemsFooter
        },
        onRowModesModelChange: (rowModesModel) => handleRowModesModelChange(rowModesModel)
      }
    )
  ] });
}, "RequisitionItemsTable");
const AddedItemsModal = /* @__PURE__ */ __name(({ addedItems }) => {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const handleClose = /* @__PURE__ */ __name(() => {
    setIsOpen(false);
  }, "handleClose");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: () => setIsOpen(true),
        sx: {
          color: "#8dc6ff",
          "&:hover": { backgroundColor: "#f1b963" },
          backgroundColor: "#F7941E"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", textTransform: "capitalize", color: "white", children: "Items Adicionados" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog,
      {
        open: isOpen,
        onClose: handleClose,
        fullWidth: true,
        maxWidth: "md",
        sx: {
          "& .MuiPaper-root": {
            borderRadius: 2,
            padding: 2,
            backgroundColor: "#f8f8f8"
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Stack,
            {
              direction: "row",
              justifyContent: "space-between",
              alignItems: "center",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Items Adicionados" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleClose, sx: { color: "red" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {}) })
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { dividers: true, sx: { maxHeight: "70vh", overflowY: "auto" }, children: addedItems && /* @__PURE__ */ jsxRuntimeExports.jsx(
            RequisitionItemsTable,
            {
              requisitionId: addedItems[0].ID_REQUISICAO
            }
          ) })
        ]
      }
    )
  ] });
}, "AddedItemsModal");
const RequisitionContext = reactExports.createContext({
  creating: false,
  editingField: { isEditing: false, field: { label: "", key: "" } },
  refreshRequisition: false,
  changeActiveStep: () => {
  },
  handleChangeEditingField: () => {
  },
  seteditingField: () => {
  },
  toggleRefreshRequisition: () => {
  },
  toggleCreating: () => {
  },
  changeKanbanFilter: () => {
  },
  changeSubFilter: () => {
  }
  // Initialize changeSubFilter
});
const RequisitionContextProvider = /* @__PURE__ */ __name(({
  children
}) => {
  const [editingField, seteditingField] = reactExports.useState({ isEditing: false, field: { label: "", key: "" } });
  const [refreshRequisition, setRefreshRequisition] = reactExports.useState(false);
  const [creating, setCreating] = reactExports.useState(false);
  const [activeStep, setActiveStep] = reactExports.useState();
  const [currentKanbanFilter, setCurrentKanbanFilter] = reactExports.useState(
    JSON.parse(localStorage.getItem("currentKanbanFilter") || `{ "label": "" }`)
  );
  const [currentSubFilter, setCurrentSubFilter] = reactExports.useState(
    JSON.parse(localStorage.getItem("currentSubFilter") || `{ "label": "" }`)
  );
  const changeActiveStep = /* @__PURE__ */ __name((value) => {
    setActiveStep(value);
  }, "changeActiveStep");
  const changeKanbanFilter = /* @__PURE__ */ __name((filter3) => {
    setCurrentKanbanFilter(filter3);
  }, "changeKanbanFilter");
  const changeSubFilter = /* @__PURE__ */ __name((filter3) => {
    setCurrentSubFilter(filter3);
  }, "changeSubFilter");
  const handleChangeEditingField = /* @__PURE__ */ __name((item) => {
    console.log("editMode: ", { isEditing: true, field: item });
    seteditingField({ isEditing: true, field: item });
  }, "handleChangeEditingField");
  const toggleRefreshRequisition = /* @__PURE__ */ __name(() => {
    setRefreshRequisition(!refreshRequisition);
  }, "toggleRefreshRequisition");
  const toggleCreating = /* @__PURE__ */ __name(() => {
    console.log("toggleCreating - RequisitionContext: ");
    setCreating(!creating);
  }, "toggleCreating");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RequisitionContext.Provider,
    {
      value: {
        editingField,
        refreshRequisition,
        creating,
        currentKanbanFilter,
        currentSubFilter,
        // Provide currentSubFilter in context
        handleChangeEditingField,
        seteditingField,
        toggleRefreshRequisition,
        toggleCreating,
        changeKanbanFilter,
        changeSubFilter,
        // Provide changeSubFilter function in context
        activeStep,
        changeActiveStep
      },
      children
    }
  );
}, "RequisitionContextProvider");
const userContext = reactExports.createContext({
  logedIn: window.localStorage.getItem("token") ? true : false,
  toggleLogedIn: () => {
  },
  defineUser: () => {
  }
});
const UserContextProvider = /* @__PURE__ */ __name(({ children }) => {
  const [logedIn, setLogedIn] = reactExports.useState(
    window.localStorage.getItem("token") ? true : false
  );
  const [user, setUser] = reactExports.useState(
    window.localStorage.getItem("user") ? JSON.parse(window.localStorage.getItem("user") || "") : void 0
  );
  const toggleLogedIn = /* @__PURE__ */ __name((value) => {
    setLogedIn(value);
  }, "toggleLogedIn");
  const defineUser = /* @__PURE__ */ __name((user2) => {
    setUser(user2);
  }, "defineUser");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    userContext.Provider,
    {
      value: user ? { user, logedIn, toggleLogedIn, defineUser } : { logedIn, toggleLogedIn, defineUser },
      children
    }
  );
}, "UserContextProvider");
const AddRequisitionForm = /* @__PURE__ */ __name(() => {
  reactExports.useEffect(() => {
    async function performAsync() {
      const projectData = await fetchAllProjects();
      const typeData = await fetchAllTypes();
      if (projectData) {
        setProjects(projectData);
      }
      if (typeData) {
        setTypes(typeData);
      }
    }
    __name(performAsync, "performAsync");
    performAsync();
  }, []);
  const [fields2, setFields] = reactExports.useState({
    ID_RESPONSAVEL: 0,
    ID_PROJETO: 0,
    DESCRIPTION: "",
    TIPO: 0
  });
  const { user } = reactExports.useContext(userContext);
  const [projects, setProjects] = reactExports.useState([]);
  const [types, setTypes] = reactExports.useState([]);
  const [currentId, setCurrentId] = reactExports.useState(0);
  const { toggleAdding } = reactExports.useContext(ItemsContext);
  const handleSelect = /* @__PURE__ */ __name((event, value, reason, details) => {
    console.log("Selecionado:", value, event, reason, details);
    if (value) {
      console.log({
        ...fields2,
        ID_PROJETO: Number(value == null ? void 0 : value.id)
      });
      setFields({
        ...fields2,
        ID_PROJETO: Number(value == null ? void 0 : value.id)
      });
    }
  }, "handleSelect");
  const handleSelectType = /* @__PURE__ */ __name((event, value, reason, details) => {
    console.log("Selecionado:", value, event, reason, details);
    console.log({
      ...fields2,
      TIPO: Number(value == null ? void 0 : value.id)
    });
    setFields({
      ...fields2,
      TIPO: Number(value == null ? void 0 : value.id)
    });
  }, "handleSelectType");
  const renderTypeOptions = /* @__PURE__ */ __name(() => {
    const typesArray = [];
    types.forEach((type) => {
      typesArray.push({
        label: String(type.nome_tipo),
        id: type.id_tipo_requisicao
      });
    });
    return typesArray;
  }, "renderTypeOptions");
  const renderProjectOptions = /* @__PURE__ */ __name(() => {
    const projectsArray = [];
    projects.forEach((project) => {
      projectsArray.push({
        label: String(project.DESCRICAO),
        id: project.ID
      });
    });
    return projectsArray;
  }, "renderProjectOptions");
  const handleChange = /* @__PURE__ */ __name((e2) => {
    const { id: id2, value } = e2.target;
    setFields({
      ...fields2,
      [id2]: value
    });
  }, "handleChange");
  const handleSubmit = /* @__PURE__ */ __name(async (e2) => {
    e2.preventDefault();
    if (user) {
      if (currentId === 0) {
        const response = await postRequisition([
          {
            ...fields2,
            ["STATUS"]: "Em edio",
            ["ID_RESPONSAVEL"]: user.CODPESSOA
          }
        ]);
        if (response) {
          setCurrentId(Number(response.data));
        }
        toggleAdding();
      } else {
        toggleAdding();
      }
    }
  }, "handleSubmit");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "max-w-sm mx-auto mt-5 w-[90%]", onSubmit: handleSubmit, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: "mb-5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "label",
        {
          htmlFor: "repeat-password",
          className: "block mb-2 text-sm font-medium text-gray-900",
          children: "Projeto"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Autocomplete,
        {
          disablePortal: true,
          id: "selectProject",
          options: renderProjectOptions(),
          getOptionLabel: (option) => option.label,
          onChange: handleSelect,
          renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { ...params, label: "Projeto" })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: "mb-5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "label",
        {
          htmlFor: "repeat-password",
          className: "block mb-2 text-sm font-medium text-gray-900",
          children: "Tipo da Requisio"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Autocomplete,
        {
          disablePortal: true,
          id: "selectProject",
          options: renderTypeOptions(),
          getOptionLabel: (option) => option.label,
          onChange: handleSelectType,
          renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { ...params, label: "Tipo" })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: "mb-5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "label",
        {
          htmlFor: "repeat-password",
          className: "block mb-2 text-sm font-medium text-gray-900",
          children: "Descrio"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          multiline: true,
          sx: { width: "100%" },
          type: "text",
          id: "DESCRIPTION",
          placeholder: "Descrio...",
          required: true,
          onChange: handleChange
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => handleSubmit, type: "submit", children: "Seguir" }),
    currentId > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ProductsTableModal, { requisitionID: currentId })
  ] });
}, "AddRequisitionForm");
const style$c = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: "fit-content",
  bgcolor: "background.paper",
  border: "2px solid #000",
  boxShadow: 24,
  pt: 2,
  px: 2,
  pb: 3
};
const NestedModal = /* @__PURE__ */ __name(() => {
  const { creating, toggleCreating } = reactExports.useContext(RequisitionContext);
  const handleOpen = /* @__PURE__ */ __name(() => {
    toggleCreating();
  }, "handleOpen");
  const handleClose = /* @__PURE__ */ __name(() => {
    toggleCreating();
  }, "handleClose");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        sx: {
          backgroundColor: "#F7941E",
          "&:hover": { backgroundColor: "#f1b963" }
        },
        onClick: handleOpen,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$p, { sx: { color: "#2B3990" } })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Modal$3,
      {
        sx: { border: "none" },
        open: creating,
        onClose: handleClose,
        "aria-labelledby": "parent-modal-title",
        "aria-describedby": "parent-modal-description",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              ...style$c,
              width: {
                xs: 300,
                lg: 400
              },
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "center",
              border: "1px solid gray"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: handleClose,
                  sx: { position: "absolute", top: "10px", right: "0" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {})
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", id: "parent-modal-title", children: "Nova Requisio" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ItemsContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AddRequisitionForm, {}) })
            ]
          }
        )
      }
    )
  ] });
}, "NestedModal");
var FilterAlt = {};
var _interopRequireDefault$t = interopRequireDefaultExports;
Object.defineProperty(FilterAlt, "__esModule", {
  value: true
});
var default_1$o = FilterAlt.default = void 0;
var _createSvgIcon$o = _interopRequireDefault$t(requireCreateSvgIcon());
var _jsxRuntime$o = jsxRuntimeExports;
default_1$o = FilterAlt.default = (0, _createSvgIcon$o.default)(/* @__PURE__ */ (0, _jsxRuntime$o.jsx)("path", {
  d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61"
}), "FilterAlt");
const SearchAppBar$1 = /* @__PURE__ */ __name(({
  caller,
  handleSearch,
  addedItems,
  refreshToggler,
  setRefreshTooggler
}) => {
  const { currentKanbanFilter, changeKanbanFilter, changeSubFilter, currentSubFilter } = reactExports.useContext(RequisitionContext);
  const { user } = reactExports.useContext(userContext);
  const [availableKanbanFilters, setAvailableKanbanFilter] = reactExports.useState(
    []
  );
  const subFilters = [
    "Minhas",
    "Todas"
  ];
  const [filterMenu, setFilterMenu] = React$1.useState(
    null
  );
  const filterMenuOpen = Boolean(filterMenu);
  const { innerWidth: width2 } = window;
  const handleClickFilter = /* @__PURE__ */ __name((event) => {
    setFilterMenu(event.currentTarget);
  }, "handleClickFilter");
  const handleCloseFilter = /* @__PURE__ */ __name(() => {
    setFilterMenu(null);
  }, "handleCloseFilter");
  const handleSelectFilter = /* @__PURE__ */ __name(async (filter3) => {
    localStorage.setItem("currentSubFilter", JSON.stringify({ label: filter3 }));
    changeSubFilter({ label: filter3 });
  }, "handleSelectFilter");
  const defineAvailableKanbanFilters = /* @__PURE__ */ __name(() => {
    console.log("user: ", user);
    if ((user == null ? void 0 : user.PERM_COMPRADOR) && (user == null ? void 0 : user.PERM_COMPRADOR) > 0) {
      setAvailableKanbanFilter([...filterAvailableByUser.purchaser]);
      return;
    }
    setAvailableKanbanFilter([...filterAvailableByUser.nonPurchaser]);
  }, "defineAvailableKanbanFilters");
  reactExports.useEffect(() => {
    defineAvailableKanbanFilters();
  }, [currentKanbanFilter]);
  const handleChangeKanbanFilter = /* @__PURE__ */ __name((e2) => {
    localStorage.setItem(
      "currentKanbanFilter",
      JSON.stringify({ label: e2.currentTarget.id })
    );
    changeKanbanFilter({ label: e2.currentTarget.id });
  }, "handleChangeKanbanFilter");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexGrow: 1, width: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AppBar,
    {
      sx: {
        backgroundColor: "#2B3990",
        //  className="text-gray-[#2B3990]"
        height: "fit-content",
        display: "flex",
        // justifyContent: "center",
        // alignItems: "center",
        padding: "8px",
        boxShadow: "none"
      },
      position: "static",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Stack,
        {
          direction: "row",
          flexWrap: "wrap",
          width: "100%",
          justifyContent: "space-between",
          alignItems: "center",
          spacing: 2,
          className: "space-y-2",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Search$1, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIconWrapper$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$s, {}) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                StyledInputBase$1,
                {
                  placeholder: "Pesquisar...",
                  inputProps: { "aria-label": "search" },
                  onKeyDown: handleSearch
                }
              )
            ] }),
            caller == "ItemsTable" && width2 > 600 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              AddedItemsModal,
              {
                motionVariants: motionItemsVariants,
                addedItems,
                refreshToggler,
                setRefreshToggler: setRefreshTooggler
              }
            ),
            caller !== "ItemsTable" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Stack,
              {
                sx: {
                  flexDirection: {
                    xs: "column",
                    md: "row"
                  },
                  alignItems: "start",
                  gap: "0.5rem"
                },
                children: [
                  availableKanbanFilters.map((kanbanFilter) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      sx: {
                        backgroundColor: (currentKanbanFilter == null ? void 0 : currentKanbanFilter.label) === kanbanFilter ? "#f1b963" : "#F7941E",
                        "&:hover": {
                          backgroundColor: "#f1b963"
                        },
                        padding: "0.4rem",
                        borderRadius: "5px"
                      },
                      onClick: handleChangeKanbanFilter,
                      id: kanbanFilter,
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Typography,
                        {
                          color: "white",
                          sx: { textTransform: "underline" },
                          fontSize: "small",
                          children: kanbanFilter
                        }
                      )
                    }
                  )),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button,
                    {
                      id: "basic-button",
                      "aria-controls": filterMenuOpen ? "basic-menu" : void 0,
                      "aria-haspopup": "true",
                      "aria-expanded": filterMenuOpen ? "true" : void 0,
                      onClick: handleClickFilter,
                      sx: {
                        color: "white",
                        backgroundColor: "#F7941E",
                        "&:hover": {
                          backgroundColor: "#f1b963"
                        }
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { textTransform: "capitalize", children: "Filtros" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, { sx: { color: "white" } })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Menu$1,
                    {
                      id: "basic-menu",
                      anchorEl: filterMenu,
                      open: filterMenuOpen,
                      onClose: handleCloseFilter,
                      MenuListProps: {
                        "aria-labelledby": "basic-button"
                      },
                      children: subFilters.map((filter3) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        MenuItem,
                        {
                          sx: {
                            backgroundColor: filter3 === (currentSubFilter == null ? void 0 : currentSubFilter.label) ? "#e3e3e3" : "white"
                          },
                          onClick: () => handleSelectFilter(filter3),
                          children: filter3
                        },
                        filter3
                      ))
                    }
                  )
                ]
              }
            ),
            caller !== "ItemsTable" && /* @__PURE__ */ jsxRuntimeExports.jsx(NestedModal, {})
          ]
        }
      ) })
    }
  ) });
}, "SearchAppBar$1");
const Search$1 = styled("div")(({ theme: theme2 }) => ({
  position: "relative",
  borderRadius: theme2.shape.borderRadius,
  backgroundColor: alpha$2(theme2.palette.common.white, 0.15),
  "&:hover": {
    backgroundColor: alpha$2(theme2.palette.common.white, 0.25)
  },
  marginLeft: 0,
  width: "100%",
  [theme2.breakpoints.up("sm")]: {
    marginLeft: theme2.spacing(1),
    width: "auto"
  }
}));
const SearchIconWrapper$1 = styled("div")(({ theme: theme2 }) => ({
  padding: theme2.spacing(0, 2),
  height: "100%",
  position: "absolute",
  pointerEvents: "none",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
}));
const StyledInputBase$1 = styled(InputBase)(({ theme: theme2 }) => ({
  color: "inherit",
  width: "100%",
  "& .MuiInputBase-input": {
    padding: theme2.spacing(1, 1, 1, 0),
    // vertical padding + font size from searchIcon
    paddingLeft: `calc(1em + ${theme2.spacing(4)})`,
    transition: theme2.transitions.create("width"),
    [theme2.breakpoints.up("sm")]: {
      width: "12ch",
      "&:focus": {
        width: "20ch"
      }
    }
  }
}));
const filterAvailableByUser = {
  purchaser: ["A Fazer", "Fazendo", "Concludo", "Tudo"],
  nonPurchaser: ["Backlog", "Acompanhamento", "Tudo"]
};
function Loader() {
  const [open2, setOpen] = reactExports.useState(true);
  const handleClose = /* @__PURE__ */ __name(() => {
    setOpen(false);
  }, "handleClose");
  reactExports.useEffect(() => {
    console.log("loading");
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Backdrop$2,
    {
      sx: { color: "#fff", zIndex: (theme2) => theme2.zIndex.drawer + 1 },
      open: open2,
      onClick: handleClose,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { color: "inherit" })
    }
  ) });
}
__name(Loader, "Loader");
const style$b = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: {
    xs: "90%",
    sm: "80%",
    md: "70%",
    lg: "40%",
    xl: "30%"
  },
  height: "fit-content",
  bgcolor: "background.paper",
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  gap: "1rem",
  boxShadow: 24,
  p: 4
};
const DeleteRequisitionModal = /* @__PURE__ */ __name(({
  isDeleteRequisitionModalOpen,
  setIsDeleteRequisitionModalOpen,
  handleDelete,
  requisitionId
}) => {
  const handleClose = /* @__PURE__ */ __name(() => setIsDeleteRequisitionModalOpen(false), "handleClose");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: isDeleteRequisitionModalOpen,
      onClose: handleClose,
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { ...style$b, gap: "2rem" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Typography,
          {
            id: "modal-modal-title",
            variant: "h6",
            component: "h2",
            align: "center",
            children: [
              "Tem certeza que deseja excluir a requisio N ",
              requisitionId,
              "?"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 6, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => handleDelete(requisitionId),
              variant: "outlined",
              children: "Sim"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => setIsDeleteRequisitionModalOpen(false),
              color: "secondary",
              variant: "outlined",
              sx: {
                color: "red",
                border: "1px solid red",
                hover: "color:secondary"
              },
              children: "No"
            }
          )
        ] })
      ] })
    }
  ) });
}, "DeleteRequisitionModal");
const headCells = [
  {
    id: "DESCRIPTION",
    numeric: false,
    disablePadding: false,
    label: "Descrio"
  },
  {
    id: "STATUS",
    numeric: false,
    disablePadding: false,
    label: "Status"
  },
  {
    id: "ID_RESPONSAVEL",
    numeric: true,
    disablePadding: false,
    label: "Responsvel"
  },
  {
    id: "ID_REQUISICAO",
    numeric: true,
    disablePadding: false,
    label: "N"
  },
  {
    id: "CREATED_ON",
    numeric: false,
    disablePadding: false,
    label: "Data de Criao"
  },
  {
    id: "LAST_UPDATE_ON",
    numeric: false,
    disablePadding: false,
    label: "Ultima Alterao"
  },
  {
    id: "LAST_MODIFIED_BY_NAME",
    numeric: false,
    disablePadding: false,
    label: "Alterado Por"
  },
  {
    id: "ID_PROJETO",
    numeric: true,
    disablePadding: false,
    label: "Projeto"
  }
];
function EnhancedTableToolbar(props) {
  const { numSelected } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Toolbar,
    {
      sx: {
        display: "none",
        pl: { sm: 2 },
        pr: { xs: 1, sm: 1 },
        ...numSelected > 0 && {
          bgcolor: (theme2) => alpha$2(
            theme2.palette.primary.main,
            theme2.palette.action.activatedOpacity
          )
        }
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            OutlinedInput,
            {
              sx: { height: "30px", marginX: "1rem" },
              id: "outlined-adornment-weight",
              "aria-describedby": "outlined-weight-helper-text",
              placeholder: "Pesquisar",
              inputProps: {
                "aria-label": "weight"
              }
            }
          ),
          numSelected > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Typography,
            {
              sx: { flex: "1 1 100%" },
              color: "inherit",
              variant: "subtitle1",
              component: "div",
              children: [
                numSelected,
                " selected"
              ]
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$s, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 4, children: numSelected > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Delete", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$t, {}) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Filter list", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$u, {}) }) }) })
      ]
    }
  );
}
__name(EnhancedTableToolbar, "EnhancedTableToolbar");
function EnhancedTableHead(props) {
  const { order: order2, orderBy, onRequestSort } = props;
  const createSortHandler = /* @__PURE__ */ __name((property) => (event) => {
    onRequestSort(event, property);
  }, "createSortHandler");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { padding: "checkbox" }),
    headCells.map((headCell) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      TableCell,
      {
        align: "left",
        padding: "normal",
        sortDirection: orderBy === headCell.id ? order2 : false,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TableSortLabel,
          {
            active: orderBy === headCell.id,
            direction: orderBy === headCell.id ? order2 : "asc",
            onClick: headCell.label !== "Status" ? createSortHandler(headCell.id) : void 0,
            children: [
              headCell.label === "Status" ? "Status" : headCell.label,
              orderBy === headCell.id ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "span", sx: visuallyHidden, children: order2 === "desc" ? "sorted descending" : "sorted ascending" }) : null
            ]
          }
        )
      },
      headCell.id
    ))
  ] }) });
}
__name(EnhancedTableHead, "EnhancedTableHead");
function EnhancedTable() {
  const [currentSelectedId, setCurrentSelectedId] = reactExports.useState(-1);
  const [RefreshToggler, setRefreshToggler] = reactExports.useState(false);
  const [isDeleteRequisitionModalOpen, setIsDeleteRequisitionModalOpen] = reactExports.useState(false);
  const [order2, setOrder] = React$1.useState("asc");
  const [orderBy, setOrderBy] = React$1.useState("ID_REQUISICAO");
  const [selected, setSelected] = React$1.useState([]);
  const [page, setPage] = React$1.useState(0);
  const [dense, setDense] = React$1.useState(true);
  const [rowsPerPage, setRowsPerPage] = React$1.useState(50);
  const [filteredRows, setFilteredRows] = reactExports.useState([]);
  const navigate = useNavigate();
  const {
    refreshRequisition,
    currentKanbanFilter,
    toggleRefreshRequisition,
    currentSubFilter
  } = reactExports.useContext(RequisitionContext);
  const { user } = reactExports.useContext(userContext);
  const dateRenderer = /* @__PURE__ */ __name((value) => {
    if (typeof value === "string") {
      const date = value.substring(0, 10).replace(/-/g, "/");
      const time2 = value.substring(11, 19);
      let formatted = `${date}, ${time2}`;
      const localeDate = new Date(formatted).toLocaleDateString();
      formatted = `${localeDate}, ${time2}`;
      return formatted;
    }
  }, "dateRenderer");
  const fetchRequisitionData = reactExports.useCallback(async () => {
    if (user && currentKanbanFilter) {
      const data = await fecthRequisitions(user, currentKanbanFilter.label);
      if (data) {
        if ((currentSubFilter == null ? void 0 : currentSubFilter.label) === "Minhas" && currentKanbanFilter.label !== "A Fazer") {
          const filtered = data.filter(
            (requisition) => {
              var _a2;
              return requisition.LAST_MODIFIED_BY_NAME.toUpperCase() === ((_a2 = user.NOME) == null ? void 0 : _a2.toUpperCase());
            }
          );
          console.log("filtered ", filtered);
          setFilteredRows(filtered);
          return;
        }
        setFilteredRows(data);
      } else {
        setFilteredRows([]);
      }
    }
  }, [currentKanbanFilter, user, currentSubFilter]);
  reactExports.useEffect(() => {
    fetchRequisitionData();
  }, [refreshRequisition, currentKanbanFilter, fetchRequisitionData, currentSubFilter]);
  const handleOpenDeleteModal = /* @__PURE__ */ __name((id2) => {
    setCurrentSelectedId(id2);
    setIsDeleteRequisitionModalOpen(true);
  }, "handleOpenDeleteModal");
  const handleDelete = /* @__PURE__ */ __name(async (id2) => {
    await deleteRequisition(id2);
    setIsDeleteRequisitionModalOpen(false);
    toggleRefreshRequisition();
  }, "handleDelete");
  const handleSearch = /* @__PURE__ */ __name(async (e2) => {
    const { value } = e2.currentTarget;
    if (e2.key === "Enter" && user && currentKanbanFilter) {
      setFilteredRows(
        filteredRows.filter(
          (item) => item.NOME_RESPONSAVEL.toUpperCase().includes(value.toUpperCase()) || item.DESCRICAO.toUpperCase().includes(value.toUpperCase()) || item.DESCRIPTION.toUpperCase().includes(value.toUpperCase()) || item.ID_REQUISICAO === Number(value)
        )
      );
      return;
    } else if (e2.key === "Backspace" && user && currentKanbanFilter) {
      toggleRefreshRequisition();
    }
  }, "handleSearch");
  const handleRequestSort = /* @__PURE__ */ __name((_event, property) => {
    const isAsc = orderBy === property && order2 === "asc";
    setOrder(isAsc ? "desc" : "asc");
    setOrderBy(property);
  }, "handleRequestSort");
  const handleSelectAllClick = /* @__PURE__ */ __name((event) => {
    if (event.target.checked) {
      const newSelected = filteredRows.map((n2) => n2.ID_REQUISICAO);
      setSelected(newSelected);
      return;
    }
    setSelected([]);
  }, "handleSelectAllClick");
  const handleClick = /* @__PURE__ */ __name((_event, id2) => {
    navigate(`requisitionDetail/${id2}`);
  }, "handleClick");
  const handleChangePage = /* @__PURE__ */ __name((_event, newPage) => {
    setPage(newPage);
  }, "handleChangePage");
  const handleChangeRowsPerPage = /* @__PURE__ */ __name((event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  }, "handleChangeRowsPerPage");
  const handleChangeDense = /* @__PURE__ */ __name((event) => {
    setDense(event.target.checked);
  }, "handleChangeDense");
  const isSelected = /* @__PURE__ */ __name((id2) => selected.indexOf(id2) !== -1, "isSelected");
  const emptyRows = page > 0 ? Math.max(0, (1 + page) * rowsPerPage - filteredRows.length) : 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { width: "100%" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: { width: "100%", mb: 2 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SearchAppBar$1,
        {
          filteredRows,
          setFilteredRows,
          caller: "requisitionTable",
          handleSearch,
          refreshToggler: RefreshToggler,
          setRefreshTooggler: setRefreshToggler
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Table$1,
        {
          sx: { minWidth: 750 },
          "aria-labelledby": "tableTitle",
          size: dense ? "small" : "medium",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              EnhancedTableHead,
              {
                numSelected: selected.length,
                order: order2,
                orderBy,
                onSelectAllClick: handleSelectAllClick,
                onRequestSort: handleRequestSort,
                rowCount: filteredRows.length,
                handleSearch
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(TableBody, { children: [
              filteredRows ? filteredRows.map((row, index2) => {
                const isItemSelected = isSelected(Number(row.ID_REQUISICAO));
                const labelId = `enhanced-table-checkbox-${index2}`;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  TableRow,
                  {
                    role: "checkbox",
                    "aria-checked": isItemSelected,
                    tabIndex: -1,
                    selected: isItemSelected,
                    sx: { cursor: "pointer" },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TableCell,
                        {
                          onClick: (event) => handleClick(event, Number(row.ID_REQUISICAO)),
                          padding: "checkbox"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TableCell,
                        {
                          onClick: (event) => handleClick(event, Number(row.ID_REQUISICAO)),
                          component: "th",
                          id: labelId,
                          scope: "row",
                          padding: "none",
                          align: "left",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "", textTransform: "capitalize", children: String(row.DESCRIPTION).toLowerCase() })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TableCell,
                        {
                          align: "left",
                          onClick: (event) => handleClick(event, Number(row.ID_REQUISICAO)),
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", textTransform: "capitalize", children: String(row.STATUS).toLowerCase() })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TableCell,
                        {
                          onClick: (event) => handleClick(event, Number(row.ID_REQUISICAO)),
                          align: "left",
                          sx: { textTransform: "lowercase" },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", textTransform: "capitalize", children: String(row.NOME_RESPONSAVEL).toLowerCase() })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TableCell,
                        {
                          onClick: (event) => handleClick(event, Number(row.ID_REQUISICAO)),
                          align: "left",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", children: row.ID_REQUISICAO })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TableCell,
                        {
                          onClick: (event) => handleClick(event, Number(row.ID_REQUISICAO)),
                          sx: {
                            fontSize: "12px",
                            textTransform: "capitalize"
                          },
                          align: "left",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", textTransform: "capitalize", children: dateRenderer(row.CREATED_ON) })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TableCell,
                        {
                          onClick: (event) => handleClick(event, Number(row.ID_REQUISICAO)),
                          sx: {
                            fontSize: "12px",
                            textTransform: "capitalize"
                          },
                          align: "left",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", children: dateRenderer(row.LAST_UPDATE_ON) })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TableCell,
                        {
                          onClick: (event) => handleClick(event, Number(row.ID_REQUISICAO)),
                          sx: {
                            fontSize: "12px",
                            textTransform: "capitalize"
                          },
                          align: "left",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", textTransform: "capitalize", children: String(row.LAST_MODIFIED_BY_NAME).toLowerCase() })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TableCell,
                        {
                          onClick: (event) => handleClick(event, Number(row.ID_REQUISICAO)),
                          sx: {
                            fontSize: "12px",
                            textTransform: "capitalize"
                          },
                          align: "left",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Typography,
                            {
                              fontSize: "small",
                              sx: { textTransform: "capitalize" },
                              children: row.DESCRICAO
                            }
                          )
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        IconButton,
                        {
                          id: String(row.ID_REQUISICAO),
                          onClick: () => handleOpenDeleteModal(Number(row.ID_REQUISICAO)),
                          className: "hover:bg-red-100 p-[2px]",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$t, { sx: { color: "#F7941E" } })
                        }
                      ) }) })
                    ]
                  },
                  row.ID_REQUISICAO
                );
              }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Loader, {}),
              emptyRows > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                TableRow,
                {
                  style: {
                    height: (dense ? 33 : 53) * emptyRows
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { colSpan: 6 })
                }
              )
            ] })
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TablePagination,
        {
          rowsPerPageOptions: [25, 40, 50],
          component: "div",
          count: filteredRows.length,
          rowsPerPage,
          page,
          onPageChange: handleChangePage,
          onRowsPerPageChange: handleChangeRowsPerPage
        }
      ),
      isDeleteRequisitionModalOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DeleteRequisitionModal,
        {
          isDeleteRequisitionModalOpen,
          setIsDeleteRequisitionModalOpen,
          handleDelete,
          requisitionId: currentSelectedId
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControlLabel,
      {
        control: /* @__PURE__ */ jsxRuntimeExports.jsx(Switch, { checked: dense, onChange: handleChangeDense }),
        label: "Linhas Finas"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EnhancedTableToolbar, { numSelected: 0 })
  ] });
}
__name(EnhancedTable, "EnhancedTable");
const logoUrl$1 = "/assets/logodolphin-CtvtokkP.jpg";
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
const ArrowLeftIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
}), "ArrowLeft");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), "ArrowRight");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
}), "Calendar");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
  children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Clock");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
}), "DateRange");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
  children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Time");
const ClearIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Clear");
const RequisitionHome = /* @__PURE__ */ __name(() => {
  const { logedIn } = reactExports.useContext(userContext);
  const navigate = useNavigate();
  reactExports.useEffect(() => {
    if (!logedIn)
      navigate("/");
  });
  const handleNavigateHome = /* @__PURE__ */ __name(() => {
    navigate("/home");
  }, "handleNavigateHome");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Card,
    {
      variant: "outlined",
      sx: { maxWidth: "96vw", padding: "0.5rem", marginX: "auto" },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "space-between" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, direction: "row", alignItems: "center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => navigate("/home"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftIcon, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              style: { cursor: "pointer" },
              onClick: () => handleNavigateHome(),
              src: logoUrl$1,
              alt: "logo Dolphin",
              width: "140px"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h6",
              sx: {
                display: {
                  xs: "none",
                  sm: "block"
                },
                color: "#2B3990"
              },
              children: "Requisies de materiais e servios"
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(EnhancedTable, {})
      ]
    }
  ) });
}, "RequisitionHome");
const steps = ["Em edio", "Requisitado", "Em cotao", "Cotado", "Concludo"];
const HorizontalLinearStepper = /* @__PURE__ */ __name(({
  requisitionData,
  setRequisitionData,
  items
}) => {
  const { user } = reactExports.useContext(userContext);
  const { toggleRefreshRequisition, changeActiveStep, refreshRequisition } = reactExports.useContext(RequisitionContext);
  const [nonPurchaserAlert, toggleNonPurchaserAlert] = reactExports.useState(false);
  const [nonRegisteredProductsAlert, toggleNonRegisteredProductsAlert] = reactExports.useState(false);
  const [activeStep, setActiveStep] = reactExports.useState(
    steps.indexOf(requisitionData.STATUS) === steps.length - 1 ? steps.length : steps.indexOf(requisitionData.STATUS)
  );
  reactExports.useEffect(() => {
    console.log("requisiton: ", requisitionData);
    changeActiveStep(activeStep);
  }, [activeStep, refreshRequisition]);
  const displayAlert = /* @__PURE__ */ __name((alertType) => {
    if (alertType === "nonPurchaser") {
      setTimeout(() => {
        toggleNonPurchaserAlert(false);
      }, 3 * 1e3);
      toggleNonPurchaserAlert(true);
      return;
    }
    if (alertType === "nonRegistreredProduct") {
      setTimeout(() => {
        toggleNonRegisteredProductsAlert(false);
      }, 3 * 1e3);
      toggleNonRegisteredProductsAlert(true);
      return;
    }
  }, "displayAlert");
  const [skipped] = reactExports.useState(/* @__PURE__ */ new Set());
  const isStepOptional = /* @__PURE__ */ __name((step) => {
    return step === -1;
  }, "isStepOptional");
  const isStepSkipped = /* @__PURE__ */ __name((step) => {
    return skipped.has(step);
  }, "isStepSkipped");
  const handleNext2 = /* @__PURE__ */ __name(async () => {
    const isPurchaser = user == null ? void 0 : user.PERM_COMPRADOR;
    if (!isPurchaser && activeStep > 0) {
      displayAlert("nonPurchaser");
      return;
    }
    const nextStep = activeStep + 1;
    if (isThereNonRegisteredProducts() && nextStep > 3) {
      displayAlert("nonRegistreredProduct");
      return;
    }
    setActiveStep((prevActiveStep) => prevActiveStep + 1);
    changeActiveStep(nextStep);
    if (nextStep < steps.length) {
      const editedRequisition = {
        ...requisitionData,
        ["STATUS"]: steps[activeStep + 1]
      };
      if (user) {
        console.log("editRequisition: ", editedRequisition);
        try {
          await updateRequisition(user.CODPESSOA, editedRequisition);
          setRequisitionData(editedRequisition);
          toggleRefreshRequisition();
        } catch (e2) {
          console.log(e2);
        }
      }
    }
  }, "handleNext");
  const isThereNonRegisteredProducts = /* @__PURE__ */ __name(() => {
    const nonRegisteredProducts = items == null ? void 0 : items.filter(
      (item) => productNotRegistered(item.nome_fantasia)
    );
    if (nonRegisteredProducts && nonRegisteredProducts.length) {
      return true;
    }
    return false;
  }, "isThereNonRegisteredProducts");
  const productNotRegistered = /* @__PURE__ */ __name((productName) => {
    return productName.toUpperCase() === "MATERIAL/SERVIO - NO CADASTRADO";
  }, "productNotRegistered");
  const handleBack = /* @__PURE__ */ __name(async () => {
    const isPurchaser = user == null ? void 0 : user.PERM_COMPRADOR;
    if (isPurchaser) {
      setActiveStep((prevActiveStep) => prevActiveStep - 1);
      const previousStep = activeStep - 1;
      changeActiveStep(previousStep);
      const editedRequisition = {
        ...requisitionData,
        ["STATUS"]: steps[activeStep - 1]
      };
      if (user) {
        try {
          await updateRequisition(user.CODPESSOA, editedRequisition);
          setRequisitionData(editedRequisition);
          toggleRefreshRequisition();
        } catch (e2) {
          console.log(e2);
        }
      }
    } else {
      displayAlert("nonPurchaser");
    }
  }, "handleBack");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { width: "100%", paddingX: "0.5rem" }, children: [
    nonPurchaserAlert && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Alert,
      {
        variant: "filled",
        className: "drop-shadow-lg",
        severity: "warning",
        sx: {
          width: "400px",
          position: "absolute",
          left: "50%",
          marginLeft: "-200px"
        },
        children: "Voc no tem permisso para alterar Status"
      }
    ),
    nonRegisteredProductsAlert && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Alert,
      {
        variant: "filled",
        className: "drop-shadow-lg",
        severity: "warning",
        sx: {
          width: "400px",
          position: "absolute",
          left: "50%",
          marginLeft: "-200px"
        },
        children: "H produtos no registrados, registre antes de prosseguir!"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Stepper, { sx: { flexWrap: "wrap", gap: "0.5rem" }, activeStep, children: steps.map((label, index2) => {
      const stepProps = {};
      const labelProps = {};
      if (isStepOptional(index2)) {
        labelProps.optional = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", children: "Optional" });
      }
      if (isStepSkipped(index2)) {
        stepProps.completed = false;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { ...stepProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepLabel, { ...labelProps, children: label }) }, label);
    }) }),
    activeStep === steps.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { mt: 2, mb: 1 }, children: "Requisio tratada!" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", flexDirection: "row", pt: 2 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          color: "inherit",
          disabled: activeStep === 0,
          onClick: handleBack,
          sx: { mr: 1, color: "#2B3990" },
          children: "Voltar"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flex: "1 1 auto" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleNext2, sx: { color: "#2B3990" }, children: activeStep === steps.length - 1 ? "Finalizar" : "Avanar" })
    ] }) })
  ] });
}, "HorizontalLinearStepper");
var ArrowCircleLeft = {};
var _interopRequireDefault$s = interopRequireDefaultExports;
Object.defineProperty(ArrowCircleLeft, "__esModule", {
  value: true
});
var default_1$n = ArrowCircleLeft.default = void 0;
var _createSvgIcon$n = _interopRequireDefault$s(requireCreateSvgIcon());
var _jsxRuntime$n = jsxRuntimeExports;
default_1$n = ArrowCircleLeft.default = (0, _createSvgIcon$n.default)(/* @__PURE__ */ (0, _jsxRuntime$n.jsx)("path", {
  d: "M2 12c0 5.52 4.48 10 10 10s10-4.48 10-10S17.52 2 12 2 2 6.48 2 12m10-1h4v2h-4v3l-4-4 4-4z"
}), "ArrowCircleLeft");
const styles$9 = {
  fieldsGridContainer: {
    display: "flex",
    flexDirection: "column",
    gap: 2,
    padding: 1,
    width: {
      xs: "100%",
      md: "80%"
    },
    border: "1px solid lightgray"
  },
  fieldsGrid: {
    display: "grid",
    gridTemplateColumns: {
      xs: "1fr",
      md: `1fr 1fr`,
      lg: `1fr 1fr 1fr 1fr`
    },
    gap: 1,
    rowGap: 2
  },
  autoComplete: {
    gridColumn: `span 2`
  },
  actionsStack: {
    alignItems: "center",
    gap: 2
  }
};
var _Error = {};
var _interopRequireDefault$r = interopRequireDefaultExports;
Object.defineProperty(_Error, "__esModule", {
  value: true
});
var default_1$m = _Error.default = void 0;
var _createSvgIcon$m = _interopRequireDefault$r(requireCreateSvgIcon());
var _jsxRuntime$m = jsxRuntimeExports;
default_1$m = _Error.default = (0, _createSvgIcon$m.default)(/* @__PURE__ */ (0, _jsxRuntime$m.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 15h-2v-2h2zm0-4h-2V7h2z"
}), "Error");
var CheckCircle = {};
var _interopRequireDefault$q = interopRequireDefaultExports;
Object.defineProperty(CheckCircle, "__esModule", {
  value: true
});
var default_1$l = CheckCircle.default = void 0;
var _createSvgIcon$l = _interopRequireDefault$q(requireCreateSvgIcon());
var _jsxRuntime$l = jsxRuntimeExports;
default_1$l = CheckCircle.default = (0, _createSvgIcon$l.default)(/* @__PURE__ */ (0, _jsxRuntime$l.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"
}), "CheckCircle");
dayjs.extend(utc);
dayjs.extend(timezone);
const toBeAproved = /* @__PURE__ */ __name((row) => {
  return row.realizado && !row.aprovado;
}, "toBeAproved");
const isTypeResponsable = /* @__PURE__ */ __name((checklist, user) => {
  return checklist.responsavel_tipo === (user == null ? void 0 : user.responsavel_tipo);
}, "isTypeResponsable");
const toBeDone = /* @__PURE__ */ __name((row) => {
  return !row.aprovado && !row.realizado;
}, "toBeDone");
const isLate = /* @__PURE__ */ __name((row) => {
  const creationDate = new Date(row.data_criacao);
  const today = /* @__PURE__ */ new Date();
  const threeDaysAgo = /* @__PURE__ */ new Date();
  threeDaysAgo.setDate(today.getDate() - 3);
  return creationDate < threeDaysAgo && !row.realizado;
}, "isLate");
const renderValue = /* @__PURE__ */ __name((column2, row, user) => {
  if (column2.dataKey === "aprovado") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      default_1$m,
      {
        sx: {
          color: toBeAproved(row) && isTypeResponsable(row, user) ? "#ff9a3c" : "gray"
        }
      }
    );
  }
  if (column2.dataKey === "realizado") {
    return toBeDone(row) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      default_1$m,
      {
        sx: {
          color: isLate(row) ? "red" : "#ff9a3c"
        }
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      default_1$l,
      {
        sx: {
          color: "green"
        }
      }
    );
  }
  if (column2.dataKey === "id_patrimonio") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/patrimony/item/${row.id_patrimonio}`, children: row.id_patrimonio });
  }
  return row[column2.dataKey];
}, "renderValue");
const getPatrimonyInfo = /* @__PURE__ */ __name(async (user, currentFilter) => {
  try {
    const response = await api.get(`/patrimony`, {
      params: { user, filter: currentFilter }
    });
    return response.data;
  } catch (e2) {
    console.log("error getPatrimonyInfo: ", e2);
  }
}, "getPatrimonyInfo");
const createAccessory = /* @__PURE__ */ __name(async (accessory) => {
  try {
    const response = await api.post("/accessory", accessory);
    return response.data;
  } catch (error) {
    throw new Error(`Failed to create accessory: ${error}`);
  }
}, "createAccessory");
const Search = styled("div")(({ theme: theme2 }) => ({
  position: "relative",
  borderRadius: theme2.shape.borderRadius,
  backgroundColor: alpha$2(theme2.palette.common.white, 0.15),
  "&:hover": {
    backgroundColor: alpha$2(theme2.palette.common.white, 0.25)
  },
  marginLeft: 0,
  width: "100%",
  [theme2.breakpoints.up("sm")]: {
    marginLeft: theme2.spacing(1),
    width: "auto"
  }
}));
const SearchIconWrapper = styled("div")(({ theme: theme2 }) => ({
  padding: theme2.spacing(0, 2),
  height: "100%",
  position: "absolute",
  pointerEvents: "none",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
}));
const StyledInputBase = styled(InputBase)(({ theme: theme2 }) => ({
  color: "inherit",
  width: "100%",
  "& .MuiInputBase-input": {
    padding: theme2.spacing(1, 1, 1, 0),
    paddingLeft: `calc(1em + ${theme2.spacing(4)})`,
    transition: theme2.transitions.create("width"),
    [theme2.breakpoints.up("sm")]: {
      width: "12ch",
      "&:focus": {
        width: "20ch"
      }
    }
  }
}));
const createPatrimonyAccessoryFile = /* @__PURE__ */ __name(async (id2, file) => {
  const config2 = {
    headers: {
      "Content-Type": "multipart/form-data"
    },
    data: file
  };
  try {
    const response = await api.post(`accessory/files/${id2}`, file, config2);
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "createPatrimonyAccessoryFile");
const deletePatrimonyAccessory = /* @__PURE__ */ __name(async (id2) => {
  try {
    const response = await api.delete(`accessory/${id2}`);
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "deletePatrimonyAccessory");
const getPatrimonyAccessoryFiles = /* @__PURE__ */ __name(async (id2) => {
  try {
    const response = await api.get(`accessory/files/${id2}`);
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getPatrimonyAccessoryFiles");
const getAccessoriesByPatrimonyId = /* @__PURE__ */ __name(async (id_patrimonio) => {
  try {
    const response = await api.get(
      `accessory/patrimony-accessory/${id_patrimonio}`
    );
    return response.data;
  } catch (error) {
    throw new Error(`Failed to get accessories by patrimony ID: ${error}`);
  }
}, "getAccessoriesByPatrimonyId");
const createPatrimony = /* @__PURE__ */ __name(async (newPatrimony) => {
  console.log("newPatrimony: ", newPatrimony);
  try {
    const response = await api.post(`/patrimony`, newPatrimony);
    return response.data.insertId;
  } catch (e2) {
    console.log(e2);
  }
}, "createPatrimony");
const dateTimeRenderer = /* @__PURE__ */ __name((value) => {
  if (typeof value === "string") {
    const brazilianDateTime = dayjs.utc(value);
    const formattedDate = brazilianDateTime.format("DD/MM/YYYY");
    const formattedTime = brazilianDateTime.format("HH:mm:ss");
    return `${formattedDate}, ${formattedTime}`;
  }
}, "dateTimeRenderer");
const deleteMultiplePatrimonies = /* @__PURE__ */ __name(async (selectedItems) => {
  try {
    Promise.all(
      selectedItems.map(
        async (item) => await api.delete(`patrimony/${item.id_patrimonio}`)
      )
    );
  } catch (e2) {
    console.log(e2);
  }
}, "deleteMultiplePatrimonies");
const getResponsableForPatrimony = /* @__PURE__ */ __name(async (patrimonyId) => {
  try {
    const response = await api.get(`/patrimony/responsable/${patrimonyId}`);
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getResponsableForPatrimony");
const getTypesOfPatrimony = /* @__PURE__ */ __name(async () => {
  try {
    const response = await api.get("/patrimony/types");
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getTypesOfPatrimony");
const getChecklistDataByPatrimonyId = /* @__PURE__ */ __name(async (id_patrimonio) => {
  try {
    const response = await api.get(`checklist/${id_patrimonio}`);
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getChecklistDataByPatrimonyId");
const getChecklistItems = /* @__PURE__ */ __name(async (id_patrimonio, id_movimentacao, id_checklist_movimentacao) => {
  try {
    const response = await api.get(
      `checklist/checklistItems/${id_patrimonio}/${id_movimentacao}/${id_checklist_movimentacao}`,
      {
        params: {
          cacheBuster: Date.now()
          // Parmetro para evitar cache
        },
        headers: {
          "Cache-Control": "no-cache, no-store, must-revalidate",
          Pragma: "no-cache",
          Expires: "0"
        }
      }
    );
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getChecklistItems");
const sendChecklistItems = /* @__PURE__ */ __name(async (checklistItems) => {
  try {
    const response = await api.put("/checklist/checklistItems", {
      checklistItems
    });
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "sendChecklistItems");
const getPatrimonyNotifications = /* @__PURE__ */ __name(async (user, currentStatusFilterSelected) => {
  console.log("currentStatusFilterSelected", currentStatusFilterSelected);
  try {
    const queryParams = new URLSearchParams({
      CODPESSOA: String(user.CODPESSOA),
      // Assuming `id` is a property of user
      status: currentStatusFilterSelected
    });
    const response = await api.get(
      `checklist/notifications?${queryParams.toString()}`
    );
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getPatrimonyNotifications");
const updateMultiplePatrimonies = /* @__PURE__ */ __name(async (selectedItems, options) => {
  try {
    if (options && options.active) {
      const response2 = await api.put(`/patrimony`, {
        selectedItems,
        active: options.active
      });
      return response2;
    }
    const response = await api.put(`/patrimony`, {
      selectedItems,
      active: false
    });
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "updateMultiplePatrimonies");
const createMovementationfile = /* @__PURE__ */ __name(async (movementationId, file) => {
  const config2 = {
    headers: {
      "Content-Type": "multipart/form-data"
    },
    data: file
  };
  try {
    const response = await api.post(
      `movementation/files/${movementationId}`,
      file,
      config2
    );
    if (response.data)
      return response;
  } catch (e2) {
    console.log(e2);
  }
}, "createMovementationfile");
const createMovementation = /* @__PURE__ */ __name(async (newMovementation) => {
  console.log("createMovementation - newMovementation: \n", newMovementation);
  try {
    const response = await api.post(`/movementation`, newMovementation);
    console.log("createMovementation - responsa.data: \n", response.data);
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "createMovementation");
const deletePatrimonyFileModal = /* @__PURE__ */ __name(async (patrimonyFileId, filename) => {
  console.log("deletePatrimonyFileModal");
  try {
    const response = await api.delete(
      `/patrimony/files/${filename}/${patrimonyFileId}`
    );
    console.log("response status: ", response.status);
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "deletePatrimonyFileModal");
const sendChecklist = /* @__PURE__ */ __name(async (checklist) => {
  try {
    const response = await api.post(`/checklist`, checklist);
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "sendChecklist");
const deleteMovementationFileModal = /* @__PURE__ */ __name(async (movementationFileId, filename) => {
  try {
    const response = await api.delete(
      `/movementation/files/${filename}/${movementationFileId}`
    );
    console.log("response status: ", response.status);
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "deleteMovementationFileModal");
const getMovementationsByPatrimonyId = /* @__PURE__ */ __name(async (patrimonyId) => {
  try {
    const response = await api.get(`movementation/${patrimonyId}`);
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getMovementationsByPatrimonyId");
const updateMovementation = /* @__PURE__ */ __name(async (editedMovementation) => {
  try {
    const response = await api.put(
      `movementation/${editedMovementation.id_movimentacao}`,
      editedMovementation
    );
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "updateMovementation");
const getSinglePatrimony = /* @__PURE__ */ __name(async (patrimonyId) => {
  try {
    const response = await api.get(`patrimony/${patrimonyId}`);
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getSinglePatrimony");
const uploadFileToChecklistItemFile = /* @__PURE__ */ __name(async (id_item_checklist_movimentacao, file) => {
  console.log("uploadFileToChecklistItemFile");
  try {
    const config2 = {
      headers: {
        "Content-Type": "multipart/form-data"
      },
      data: file
    };
    const response = await api.put(
      `/checklist/checklistItems/file/${id_item_checklist_movimentacao}`,
      file,
      config2
    );
    return response.data.fileUrl;
  } catch (e2) {
    console.log(e2);
  }
}, "uploadFileToChecklistItemFile");
const getPatrimonyFiles = /* @__PURE__ */ __name(async (patrimonyId) => {
  try {
    const response = await api.get(
      `patrimony/files/${patrimonyId}`
    );
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getPatrimonyFiles");
const createPatrimonyfile = /* @__PURE__ */ __name(async (patrimonyId, file) => {
  const config2 = {
    headers: {
      "Content-Type": "multipart/form-data"
    },
    data: file
  };
  try {
    const response = await api.post(
      `patrimony/files/${patrimonyId}`,
      file,
      config2
    );
    if (response.data)
      return response;
  } catch (e2) {
    console.log(e2);
  }
}, "createPatrimonyfile");
const upatePatrimony = /* @__PURE__ */ __name(async (patrimony) => {
  try {
    const response = await api.put(
      `patrimony/${patrimony.id_patrimonio}`,
      patrimony
    );
    console.log("reponse upatePatrimony: \n", response);
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "upatePatrimony");
const deleteMovementation = /* @__PURE__ */ __name(async (movimentationId, patrimonyId) => {
  try {
    const response = await api.delete(
      `movementation//${patrimonyId}/${movimentationId}`
    );
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "deleteMovementation");
const getMovementationFiles = /* @__PURE__ */ __name(async (movementationId) => {
  try {
    const response = await api.get(`movementation/files/${movementationId}`);
    if (response.data)
      return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getMovementationFiles");
const useRequisitionFields = /* @__PURE__ */ __name(() => {
  const { id: id2 } = useParams();
  const { user } = reactExports.useContext(userContext);
  const [isEditing, setIsEditing] = reactExports.useState(false);
  const [requisitionData, setRequisitionData] = reactExports.useState();
  const [optionsState, setOptionsState] = reactExports.useState();
  const [alert2, setAlert] = reactExports.useState();
  const fetchRequisitionData = /* @__PURE__ */ __name(async () => {
    const data = await fetchRequsitionById(Number(id2));
    if (data) {
      setRequisitionData({ ...data });
      setOptionsState({
        projectOption: data.projectOption,
        responsableOption: data.responsableOption,
        typeOption: data.typeOption,
        projectOptions: data.projectOptions,
        responsableOptions: data.responsableOptions,
        typeOptions: data.typeOptions
      });
    }
  }, "fetchRequisitionData");
  const userAllowedToEdit = /* @__PURE__ */ __name(() => {
    if ((requisitionData == null ? void 0 : requisitionData.STATUS) === "Em edio") {
      return (user == null ? void 0 : user.PERM_COMPRADOR) || (user == null ? void 0 : user.CODPESSOA) === (requisitionData == null ? void 0 : requisitionData.ID_RESPONSAVEL);
    }
    return user == null ? void 0 : user.PERM_COMPRADOR;
  }, "userAllowedToEdit");
  const displayAlert = /* @__PURE__ */ __name(async (severity, message) => {
    setTimeout(() => {
      setAlert(void 0);
    }, 3e3);
    setAlert({ severity, message });
    return;
  }, "displayAlert");
  const handleChangeAutoComplete = /* @__PURE__ */ __name((e2, value, field) => {
    console.log(e2);
    if (requisitionData) {
      if (field.key === "projectOption") {
        setOptionsState({
          ...optionsState,
          projectOption: value
        });
        setRequisitionData({
          ...requisitionData,
          ID_PROJETO: value.id
        });
        return;
      }
      if (field.key === "typeOption") {
        setOptionsState({
          ...optionsState,
          typeOption: value
        });
        setRequisitionData({
          ...requisitionData,
          TIPO: value.id
        });
        return;
      }
      if (field.key === "responsableOption") {
        setOptionsState({
          ...optionsState,
          responsableOption: value
        });
        setRequisitionData({
          ...requisitionData,
          ID_RESPONSAVEL: value.id
        });
        return;
      }
    }
  }, "handleChangeAutoComplete");
  const handleChangeTextField = /* @__PURE__ */ __name((e2, field) => {
    const { value } = e2.target;
    if (requisitionData) {
      setRequisitionData({
        ...requisitionData,
        [field.key]: value
      });
    }
  }, "handleChangeTextField");
  const renderAutoCompleteValue = /* @__PURE__ */ __name((field) => {
    const value = optionsState && optionsState[field.key];
    return value;
  }, "renderAutoCompleteValue");
  const renderOptions = /* @__PURE__ */ __name((field) => {
    if (optionsState) {
      const options = optionsState[field.optionName];
      return options;
    }
    return [{ label: "Sem opes", id: 0 }];
  }, "renderOptions");
  const handleSave = /* @__PURE__ */ __name(async () => {
    if (requisitionData && user) {
      setIsEditing(false);
      try {
        const response = await updateRequisition(user == null ? void 0 : user.CODPESSOA, requisitionData);
        if (response.status === 200) {
          displayAlert("success", "Requisio atualizada com sucesso!");
        }
      } catch (e2) {
        displayAlert("warning", e2.message);
      }
    }
  }, "handleSave");
  const handleFocus = /* @__PURE__ */ __name(async (e2) => {
    const { target } = e2;
    if (userAllowedToEdit()) {
      setIsEditing(true);
      return;
    }
    await displayAlert("warning", "No  permitido editar a requisio");
    target.blur();
  }, "handleFocus");
  const renderValue2 = /* @__PURE__ */ __name((field) => {
    if (field.type === "date" && requisitionData) {
      return dateTimeRenderer(requisitionData[field.key]);
    }
    if (field.autoComplete) {
      return "autocomplete";
    }
    return requisitionData && requisitionData[field.key];
  }, "renderValue");
  const handleCancelEditing = /* @__PURE__ */ __name(() => {
    setIsEditing(false);
    fetchRequisitionData();
  }, "handleCancelEditing");
  reactExports.useEffect(() => {
    fetchRequisitionData();
  }, []);
  return {
    isEditing,
    requisitionData,
    optionsState,
    alert: alert2,
    handleChangeAutoComplete,
    handleChangeTextField,
    renderAutoCompleteValue,
    renderOptions,
    handleSave,
    handleFocus,
    handleCancelEditing,
    renderValue: renderValue2
  };
}, "useRequisitionFields");
const fields = [
  { label: "Descrio", key: "DESCRIPTION", type: "text", autoComplete: false },
  { label: "Observao", key: "OBSERVACAO", type: "text", autoComplete: false },
  { label: "Responsvel", key: "responsableOption", optionName: "responsableOptions", type: "text", autoComplete: true },
  { label: "Projeto", key: "projectOption", optionName: "projectOptions", type: "text", autoComplete: true },
  { label: "Tipo", key: "typeOption", optionName: "typeOptions", type: "text", autoComplete: true }
];
const RequisitionFields = /* @__PURE__ */ __name(() => {
  const {
    isEditing,
    requisitionData,
    optionsState,
    alert: alert2,
    handleChangeAutoComplete,
    handleChangeTextField,
    renderAutoCompleteValue,
    renderOptions,
    handleSave,
    handleFocus,
    handleCancelEditing,
    renderValue: renderValue2
  } = useRequisitionFields();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: styles$9.fieldsGridContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", gap: 2, alignItems: "center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading1, children: "Detalhes da requisio" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { sx: typographyStyles.heading2, children: [
        "Ultima atualizao: ",
        dateTimeRenderer(requisitionData == null ? void 0 : requisitionData.LAST_UPDATE_ON)
      ] }),
      "/",
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { sx: typographyStyles.heading2, children: [
        "Criada em: ",
        dateTimeRenderer(requisitionData == null ? void 0 : requisitionData.CREATED_ON)
      ] })
    ] }),
    requisitionData && optionsState && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: styles$9.fieldsGrid, children: fields.map((field) => {
      if (field.autoComplete) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Autocomplete,
          {
            onFocus: handleFocus,
            getOptionKey: (option) => option.id,
            onChange: (event, value) => handleChangeAutoComplete(event, value, field),
            disablePortal: true,
            sx: styles$9.autoComplete,
            options: renderOptions(field),
            value: renderAutoCompleteValue(field),
            renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { ...params, label: field.label })
          },
          field.key
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          label: field.label,
          multiline: true,
          value: renderValue2(field),
          onFocus: handleFocus,
          onChange: (e2) => handleChangeTextField(e2, field)
        },
        field.key
      );
    }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isEditing && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...alertAnimation, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", sx: styles$9.actionsStack, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleSave, sx: BaseButtonStyles, className: "shadow-md", children: "Salvar Alteraes" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleCancelEditing, sx: BaseButtonStyles, className: "shadow-md", children: "Cancelar edio" })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: alert2 && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...alertAnimation, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: alert2.severity, children: alert2.message }) }) })
  ] });
}, "RequisitionFields");
const styles$8 = {
  requisitionPageContainer: {
    width: "100%",
    border: "1px solid #d3d6db",
    height: "100%",
    backgroundColor: "white",
    margin: "auto"
  },
  alertEditionNotAllowed: {
    top: "10%",
    width: "400px",
    position: "absolute",
    left: "50%",
    marginLeft: "-200px"
  },
  alertProjectAltered: {
    top: "10%",
    width: "400px",
    position: "absolute",
    left: "50%",
    marginLeft: "-200px"
  },
  requisitionPageHeader: {
    padding: "1rem",
    display: "flex",
    alignItems: "center"
  },
  requisitionTitle: {
    fontSize: {
      xs: "12px",
      md: "16px"
    }
  },
  requisitionStepper: {
    padding: "0"
  },
  requisitionChilds: {
    border: "1px solid #e3e3e3"
  },
  actionsStack: {
    paddingX: "2rem",
    flexWrap: "wrap",
    direction: "row",
    justifyContent: "end"
  },
  materialsServicesButton: {
    border: "none",
    height: "30px",
    borderRadius: "0px",
    display: "flex",
    alignItems: "center",
    gap: "0.5rem"
  },
  materialsServicesText: {
    textDecoration: "underline",
    color: "#2B3990"
  },
  materialsServicesBadge: {
    color: "secondary"
  },
  requisitionContent: {
    flexWrap: "wrap",
    height: {
      xs: "1080px",
      sm: "800px",
      lg: "600px"
    }
  },
  requisitionDetails: {
    padding: "0.5rem",
    maxHeight: "60vh",
    overflowY: "auto",
    width: {
      xs: "100%",
      md: "50%",
      lg: "25%"
    },
    display: "flex",
    justifyContent: "space-around",
    alignItems: "flex-start"
  },
  detailsStack: {
    width: "100%",
    padding: "1rem"
  },
  detailsTitle: {},
  detailsField: {
    width: "100%"
  },
  fieldContainer: {
    padding: "4px",
    borderRadius: "4px"
  },
  projectAutocomplete: {
    width: "100%",
    outline: "none"
  },
  saveButton: {},
  fieldInput: {
    width: "100%",
    backgroundColor: "white",
    fontSize: "0.875rem",
    // equivalent to text-sm
    textTransform: "lowercase",
    focusOutline: "none"
  },
  editButton: {
    cursor: "pointer"
  },
  requisitionItemsTableContainer: {
    height: 500,
    width: "100%",
    border: "0.5px solid #e3e3e3",
    overflowY: "auto",
    display: "flex",
    flexDirection: "column",
    padding: 1,
    flexGrow: 1
  }
};
const RequisitionDetail = /* @__PURE__ */ __name(() => {
  const { id: id2 } = useParams();
  const [requisitionData, setRequisitionData] = reactExports.useState();
  const [requisitionItems, setRequisitionItems] = reactExports.useState([]);
  console.log(setRequisitionItems);
  const { refreshRequisition } = reactExports.useContext(RequisitionContext);
  const { logedIn } = reactExports.useContext(userContext);
  const navigate = useNavigate();
  const fetchRequisitionData = /* @__PURE__ */ __name(async () => {
    const data = await fetchRequsitionById(Number(id2));
    if (data) {
      const personData = await fetchPersonById(data.ID_RESPONSAVEL);
      if (personData) {
        setRequisitionData({ ...data, ["RESPONSAVEL"]: personData == null ? void 0 : personData.NOME });
      }
    }
  }, "fetchRequisitionData");
  reactExports.useEffect(() => {
    if (!logedIn)
      navigate("/");
  });
  reactExports.useEffect(() => {
    fetchRequisitionData();
  }, [refreshRequisition]);
  const handleNavigateHome = /* @__PURE__ */ __name(() => {
    navigate("/requisitions");
  }, "handleNavigateHome");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: styles$8.requisitionPageContainer,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: "req-page-header", sx: styles$8.requisitionPageHeader, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => handleNavigateHome(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$n, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Typography,
            {
              sx: {
                fontSize: {
                  xs: "12px",
                  md: "16px"
                }
              },
              children: [
                "N ",
                requisitionData == null ? void 0 : requisitionData.ID_REQUISICAO,
                " | ",
                requisitionData == null ? void 0 : requisitionData.DESCRIPTION,
                " | Projeto ",
                requisitionData == null ? void 0 : requisitionData.DESCRICAO
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: "stepper-container", sx: styles$8.requisitionStepper, children: requisitionData && /* @__PURE__ */ jsxRuntimeExports.jsx(
          HorizontalLinearStepper,
          {
            items: requisitionItems,
            requisitionData,
            setRequisitionData
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Stack,
          {
            className: "requsition-content",
            direction: "column",
            sx: {
              padding: 1,
              gap: 1,
              width: "100%",
              border: "1px solid lightgray"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(RequisitionFields, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  className: "req-items-table-container",
                  sx: styles$8.requisitionItemsTableContainer,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(RequisitionItemsTable, { requisitionId: Number(id2) })
                }
              )
            ]
          }
        )
      ]
    }
  );
}, "RequisitionDetail");
var LockOutlined = {};
var _interopRequireDefault$p = interopRequireDefaultExports;
Object.defineProperty(LockOutlined, "__esModule", {
  value: true
});
var default_1$k = LockOutlined.default = void 0;
var _createSvgIcon$k = _interopRequireDefault$p(requireCreateSvgIcon());
var _jsxRuntime$k = jsxRuntimeExports;
default_1$k = LockOutlined.default = (0, _createSvgIcon$k.default)(/* @__PURE__ */ (0, _jsxRuntime$k.jsx)("path", {
  d: "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2M9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9zm9 14H6V10h12zm-6-3c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2"
}), "LockOutlined");
function Copyright() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", align: "center", children: [
    "Copyright  Dolphin Engenharia ",
    (/* @__PURE__ */ new Date()).getFullYear(),
    "."
  ] });
}
__name(Copyright, "Copyright");
const defaultTheme = createTheme();
const SignIn = /* @__PURE__ */ __name(() => {
  const navigate = useNavigate();
  const { toggleLogedIn, defineUser } = reactExports.useContext(userContext);
  const [errorLogin, setErrorLogin] = reactExports.useState(false);
  const toggleErrorLogin = /* @__PURE__ */ __name(() => {
    console.log("errorLogin became: ", !errorLogin);
    setErrorLogin(!errorLogin);
  }, "toggleErrorLogin");
  const handleSubmit = /* @__PURE__ */ __name(async (event) => {
    event.preventDefault();
    const data = new FormData(event.currentTarget);
    const username = data.get("email") ? data.get("email") : "";
    const responseLogin = await logIn(String(username), String(data.get("password")));
    if (responseLogin.message === "Login Successful") {
      window.localStorage.setItem("token", responseLogin.token);
      window.localStorage.setItem("user", JSON.stringify(responseLogin.user));
      navigate("./home");
      toggleLogedIn(true);
      defineUser(responseLogin.user);
    } else {
      toggleErrorLogin();
    }
  }, "handleSubmit");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider2, { theme: defaultTheme, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { component: "main", maxWidth: "xs", children: [
    errorLogin && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Alert,
      {
        variant: "filled",
        severity: "error",
        className: "drop-shadow-lg",
        sx: {
          top: "10%",
          width: "400px",
          position: "absolute",
          left: "50%",
          marginLeft: "-200px",
          zIndex: 20
        },
        children: "Usurio e/ou senha incorretos"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CssBaseline, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          marginTop: 8,
          display: "flex",
          flexDirection: "column",
          alignItems: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { sx: { m: 1, bgcolor: "secondary.main" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$k, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { component: "h1", variant: "h5", children: "Faa seu Login" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              component: "form",
              onSubmit: handleSubmit,
              noValidate: true,
              sx: { mt: 1 },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField,
                  {
                    margin: "normal",
                    required: true,
                    fullWidth: true,
                    id: "email",
                    label: "Usurio",
                    name: "email",
                    autoComplete: "email",
                    autoFocus: true
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField,
                  {
                    margin: "normal",
                    required: true,
                    fullWidth: true,
                    name: "password",
                    label: "Senha",
                    type: "password",
                    id: "password",
                    autoComplete: "current-password"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "submit",
                    fullWidth: true,
                    variant: "contained",
                    sx: { mt: 3, mb: 2 },
                    children: "Entrar"
                  }
                )
              ]
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Copyright, {})
  ] }) });
}, "SignIn");
var AccountCircle = {};
var _interopRequireDefault$o = interopRequireDefaultExports;
Object.defineProperty(AccountCircle, "__esModule", {
  value: true
});
var default_1$j = AccountCircle.default = void 0;
var _createSvgIcon$j = _interopRequireDefault$o(requireCreateSvgIcon());
var _jsxRuntime$j = jsxRuntimeExports;
default_1$j = AccountCircle.default = (0, _createSvgIcon$j.default)(/* @__PURE__ */ (0, _jsxRuntime$j.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 4c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6m0 14c-2.03 0-4.43-.82-6.14-2.88C7.55 15.8 9.68 15 12 15s4.45.8 6.14 2.12C16.43 19.18 14.03 20 12 20"
}), "AccountCircle");
const modules = [
  {
    image: "https://firebasestorage.googleapis.com/v0/b/dolphin-8f800.appspot.com/o/_69f4380e-7447-4651-93ee-1d1529dd5c78.jpeg?alt=media&token=c3f35b95-f67b-47a9-901f-f6f16fedfe04",
    name: "Requisies",
    Info: "Realize solicitaes de materiais aplicados no projeto, materiais de consumo, EPI's, equipamentos do operacional ou TI, ferramentaseservios.",
    path: "/requisitions"
  },
  {
    image: "https://firebasestorage.googleapis.com/v0/b/dolphin-8f800.appspot.com/o/_6d46fa5a-0284-43eb-a5fb-bdc796ada67a.jpeg?alt=media&token=e1450447-7f7f-4610-87a7-f13b674a852d",
    name: "Controle de Patrimnios",
    Info: `Gerenciar a localizao;
            Responsvel pela guarda;
            Registro de movimentaes (Obra, sede e manuteno/calibrao).
            Controle dos acessrios (Cabos, bateriareserva)`,
    path: "/patrimony"
  },
  {
    image: "https://firebasestorage.googleapis.com/v0/b/dolphin-8f800.appspot.com/o/Wavy_Bus-17_Single-07.jpg?alt=media&token=0414fe18-af22-4d9b-a669-90153972fa9b",
    name: "CRM",
    Info: "Gerenciamneto e acompanhamento de Projetos",
    path: "/crm"
  }
];
const Home = /* @__PURE__ */ __name(() => {
  const navigate = useNavigate();
  const { logedIn, user, toggleLogedIn } = reactExports.useContext(userContext);
  reactExports.useEffect(() => {
    console.log("user: ", user);
    if (!logedIn) {
      navigate("/");
    }
  }, [logedIn]);
  const handleNavigateToModule = /* @__PURE__ */ __name((path) => {
    navigate(path);
  }, "handleNavigateToModule");
  const handleLogOut = /* @__PURE__ */ __name(() => {
    window.localStorage.removeItem("user");
    window.localStorage.removeItem("token");
    toggleLogedIn(false);
  }, "handleLogOut");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        backgroundRepeat: "no-repeat",
        backgroundSize: "contain",
        backgroundPosition: "center",
        width: "100%",
        height: "95vh"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              background: `url('${logoUrl$1}')`,
              backgroundPosition: "left",
              backgroundSize: "contain",
              backgroundRepeat: "no-repeat",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              width: "100%",
              height: "10%"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { sx: { position: "absolute", right: "1rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dropdown, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuButton, { children: [
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$j, { sx: { color: "#F7941E" } })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { sx: { marginTop: "0.5rem" }, onClick: () => handleLogOut(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", textTransform: "lowercase", color: "blue", children: "Sair" }) }) })
            ] }) })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              height: "100%",
              overflowY: "auto",
              display: "flex",
              flexDirection: "column",
              justifyContent: "start",
              gap: "2rem",
              alignItems: "center"
            },
            children: [
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Typography,
                {
                  sx: {
                    textAlign: "center",
                    fontWeight: "600",
                    color: "#2B3990",
                    fontSize: "2rem"
                  },
                  children: "Bem Vindo ao Dolphin Controle"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Stack,
                {
                  width: "100%",
                  direction: "row",
                  justifyContent: "center",
                  alignItems: "center",
                  gap: 6,
                  flexWrap: "wrap",
                  className: "space-y-2",
                  children: modules.map(
                    (module, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Card,
                      {
                        sx: {
                          width: 300,
                          height: "500px",
                          borderRadius: "30px",
                          boxShadow: "none"
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          CardActionArea,
                          {
                            onClick: () => handleNavigateToModule(module.path),
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                CardMedia,
                                {
                                  sx: {
                                    filter: index2 > 1 ? "grayscale(100%)" : "none"
                                  },
                                  component: "img",
                                  image: module.image,
                                  alt: "green iguana"
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                CardContent,
                                {
                                  style: {
                                    backgroundColor: "white",
                                    transform: "translateY(-100px)"
                                  },
                                  children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { gutterBottom: true, variant: "h5", component: "div", children: module.name }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: module.Info })
                                  ]
                                }
                              )
                            ]
                          }
                        )
                      },
                      index2
                    )
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
}, "Home");
const checklistContext = reactExports.createContext({
  refreshChecklist: false,
  toggleRefreshChecklist: () => {
  },
  deletingChecklist: [false],
  toggleDeletingChecklist: () => {
  },
  checklistItemsOpen: [false],
  toggleChecklistItemsOpen: () => {
  },
  deletingCheckListItem: false,
  toggleDeletingCheckListItem: () => {
  },
  checklistOpen: [false],
  toggleChecklistOpen: () => {
  },
  setChecklistOpen: () => {
  },
  currentColumnFilters: [],
  setCurrentColumnFilters: () => {
  },
  // Valores iniciais para os novos estados
  filteredNotificationsByUser: [],
  setFilteredNotificationsByUser: () => {
  },
  currentStatusFilterSelected: "",
  setCurrentStatusFilterSelected: () => {
  },
  currentFilteredByStatus: [],
  setCurrentFilteredByStatus: () => {
  }
});
const ChecklistContextProvider = /* @__PURE__ */ __name(({ children }) => {
  const [refreshChecklist, setRefreshChecklist] = reactExports.useState(false);
  const [deletingChecklist, setDeletingChecklist] = reactExports.useState([false]);
  const [checklistItemsOpen, setChecklistItemsOpen] = reactExports.useState([false]);
  const [deletingCheckListItem, setDeletingCheckListItem] = reactExports.useState(false);
  const [checklistOpen, setChecklistOpen] = reactExports.useState([false]);
  const [currentColumnFilters, setCurrentColumnFilters] = reactExports.useState([
    { dataKey: "id_patrimonio", filterValue: "" },
    // Valor inicial
    { dataKey: "data_criacao", filterValue: "" },
    { dataKey: "realizado", filterValue: "" },
    { dataKey: "data_realizado", filterValue: "" },
    { dataKey: "aprovado", filterValue: "" },
    { dataKey: "reprovado", filterValue: "" },
    { dataKey: "data_aprovado", filterValue: "" },
    { dataKey: "observacao", filterValue: "" },
    { dataKey: "nome", filterValue: "" },
    { dataKey: "nome_responsavel", filterValue: "" },
    { dataKey: "responsavel_tipo", filterValue: "" },
    { dataKey: "id_patrimonio", filterValue: "" },
    { dataKey: "responsavel_movimentacao", filterValue: "" },
    { dataKey: "nome_patrimonio", filterValue: "" },
    { dataKey: "descricao_projeto", filterValue: "" },
    { dataKey: "id_checklist_movimentacao", filterValue: "" },
    { dataKey: "id_movimentacao", filterValue: "" }
  ]);
  const [filteredNotificationsByUser, setFilteredNotificationsByUser] = reactExports.useState([]);
  const [currentStatusFilterSelected, setCurrentStatusFilterSelected] = reactExports.useState("");
  const [currentFilteredByStatus, setCurrentFilteredByStatus] = reactExports.useState([]);
  const toggleDeletingChecklist = /* @__PURE__ */ __name((checklist) => {
    if (checklist) {
      setDeletingChecklist([true, checklist]);
      return;
    }
    setDeletingChecklist([false]);
  }, "toggleDeletingChecklist");
  const toggleRefreshChecklist = /* @__PURE__ */ __name(() => {
    setRefreshChecklist(!refreshChecklist);
  }, "toggleRefreshChecklist");
  const toggleChecklistItemsOpen = /* @__PURE__ */ __name((checklist) => {
    if (checklist) {
      setChecklistItemsOpen([true, checklist]);
      return;
    }
    setChecklistItemsOpen([false]);
  }, "toggleChecklistItemsOpen");
  const toggleDeletingCheckListItem = /* @__PURE__ */ __name((checkListItem) => {
    if (checkListItem) {
      setDeletingCheckListItem(true);
      return;
    }
    setDeletingCheckListItem(false);
  }, "toggleDeletingCheckListItem");
  const toggleChecklistOpen = /* @__PURE__ */ __name((checklist) => {
    if (checklist) {
      setChecklistOpen([true, checklist]);
      return;
    }
    setChecklistOpen([false]);
  }, "toggleChecklistOpen");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    checklistContext.Provider,
    {
      value: {
        refreshChecklist,
        toggleRefreshChecklist,
        deletingChecklist,
        toggleDeletingChecklist,
        checklistItemsOpen,
        toggleChecklistItemsOpen,
        deletingCheckListItem,
        toggleDeletingCheckListItem,
        checklistOpen,
        toggleChecklistOpen,
        setChecklistOpen,
        currentColumnFilters,
        setCurrentColumnFilters,
        // Novos estados e funes
        filteredNotificationsByUser,
        setFilteredNotificationsByUser,
        currentStatusFilterSelected,
        setCurrentStatusFilterSelected,
        currentFilteredByStatus,
        setCurrentFilteredByStatus
      },
      children
    }
  );
}, "ChecklistContextProvider");
const PatrimonyInfoContext = reactExports.createContext({
  refreshPatrimonyInfo: false,
  refreshPatrimonyAccessory: false,
  refreshPatrimonyAccessoryFiles: false,
  // Inicialize o novo estado
  creatingPatrimonyInfo: [false],
  creatingPatrimonyAccessory: false,
  deletingPatrimonyAccessory: [false],
  deletingPatrimonyAccessoryFile: [false],
  currentFilter: "Todos",
  filteredRows: [],
  columnFilter: [
    { dataKey: "id_patrimonio", filterValue: "" },
    { dataKey: "nome", filterValue: "" },
    { dataKey: "nome_tipo", filterValue: "" },
    { dataKey: "descricao", filterValue: "" },
    { dataKey: "responsavel", filterValue: "" },
    { dataKey: "gerente", filterValue: "" },
    { dataKey: "projeto", filterValue: "" },
    { dataKey: "dataMovimentacao", filterValue: "" },
    { dataKey: "id_patrimonio", filterValue: "" }
  ],
  setFilteredRows: () => {
  },
  toggleRefreshPatrimonyInfo: () => {
  },
  toggleRefreshPatrimonyAccessory: () => {
  },
  toggleRefreshPatrimonyAccessoryFiles: () => {
  },
  // Inicialize a nova funo
  toggleCreatingPatrimonyInfo: () => {
  },
  changeCreatingPatrimonyInfo: () => {
  },
  setCurrentFilter: () => {
  },
  toggleCreatingPatrimonyAccessory: () => {
  },
  toggleDeletingPatrimonyAccessory: () => {
  },
  toggleDeletingPatrimonyAccessoryFile: () => {
  },
  changeColumnFilters: () => {
  }
});
const PatrimonyInfoContextProvider = /* @__PURE__ */ __name(({
  children
}) => {
  const [refreshPatrimonyInfo, setRefreshPatrimonyInfo] = reactExports.useState(false);
  const [refreshPatrimonyAccessory, setRefreshPatrimonyAccessory] = reactExports.useState(false);
  const [refreshPatrimonyAccessoryFiles, setRefreshPatrimonyAccessoryFiles] = (
    // Novo estado
    reactExports.useState(false)
  );
  const [creatingPatrimonyInfo, setCreatingPatrimonyInfo] = reactExports.useState([false]);
  const [creatingPatrimonyAccessory, setCreatingPatrimonyAccessory] = reactExports.useState(false);
  const [deletingPatrimonyAccessory, setDeletingPatrimonyAccessory] = reactExports.useState([false]);
  const [deletingPatrimonyAccessoryFile, setDeletingPatrimonyAccessoryFile] = reactExports.useState([false]);
  const [currentFilter, setCurrentFilter] = reactExports.useState(
    localStorage.getItem("currentFilter") || "Meus"
  );
  const [columnFilter, setCurrentColumnFilter] = reactExports.useState([
    { dataKey: "id_patrimonio", filterValue: "" },
    { dataKey: "nome", filterValue: "" },
    { dataKey: "nome_tipo", filterValue: "" },
    { dataKey: "descricao", filterValue: "" },
    { dataKey: "responsavel", filterValue: "" },
    { dataKey: "gerente", filterValue: "" },
    { dataKey: "projeto", filterValue: "" },
    { dataKey: "dataMovimentacao", filterValue: "" }
  ]);
  const [filteredRows, setFilteredRows] = reactExports.useState();
  const changeColumnFilters = /* @__PURE__ */ __name((columFilters) => {
    setCurrentColumnFilter([...columFilters]);
  }, "changeColumnFilters");
  const toggleCreatingPatrimonyInfo = /* @__PURE__ */ __name(() => {
    setCreatingPatrimonyInfo(creatingPatrimonyInfo[0] ? [false] : [true]);
  }, "toggleCreatingPatrimonyInfo");
  const changeCreatingPatrimonyInfo = /* @__PURE__ */ __name((patrimony) => {
    if (patrimony) {
      setCreatingPatrimonyInfo([true, patrimony]);
      return;
    }
    setCreatingPatrimonyInfo([true]);
  }, "changeCreatingPatrimonyInfo");
  const toggleRefreshPatrimonyInfo = /* @__PURE__ */ __name(() => {
    console.log("toggleRefreshPatrimonyInfo");
    setRefreshPatrimonyInfo((prev2) => !prev2);
  }, "toggleRefreshPatrimonyInfo");
  const toggleRefreshPatrimonyAccessory = /* @__PURE__ */ __name(() => {
    setRefreshPatrimonyAccessory((prev2) => !prev2);
  }, "toggleRefreshPatrimonyAccessory");
  const toggleRefreshPatrimonyAccessoryFiles = /* @__PURE__ */ __name(() => {
    setRefreshPatrimonyAccessoryFiles((prev2) => !prev2);
  }, "toggleRefreshPatrimonyAccessoryFiles");
  const toggleCreatingPatrimonyAccessory = /* @__PURE__ */ __name(() => {
    setCreatingPatrimonyAccessory((prev2) => !prev2);
  }, "toggleCreatingPatrimonyAccessory");
  const toggleDeletingPatrimonyAccessory = /* @__PURE__ */ __name((isDeleting, accessory) => {
    setDeletingPatrimonyAccessory([isDeleting, accessory]);
  }, "toggleDeletingPatrimonyAccessory");
  const toggleDeletingPatrimonyAccessoryFile = /* @__PURE__ */ __name((file) => {
    if (file) {
      setDeletingPatrimonyAccessoryFile([true, file]);
      return;
    }
    setDeletingPatrimonyAccessoryFile([false]);
  }, "toggleDeletingPatrimonyAccessoryFile");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    PatrimonyInfoContext.Provider,
    {
      value: {
        refreshPatrimonyInfo,
        refreshPatrimonyAccessory,
        refreshPatrimonyAccessoryFiles,
        // Prover o novo estado
        toggleRefreshPatrimonyInfo,
        toggleRefreshPatrimonyAccessory,
        toggleRefreshPatrimonyAccessoryFiles,
        // Prover a nova funo
        toggleCreatingPatrimonyInfo,
        creatingPatrimonyInfo,
        changeCreatingPatrimonyInfo,
        creatingPatrimonyAccessory,
        toggleCreatingPatrimonyAccessory,
        deletingPatrimonyAccessory,
        toggleDeletingPatrimonyAccessory,
        deletingPatrimonyAccessoryFile,
        toggleDeletingPatrimonyAccessoryFile,
        setFilteredRows,
        currentFilter,
        setCurrentFilter,
        changeColumnFilters,
        columnFilter,
        filteredRows
      },
      children
    }
  );
}, "PatrimonyInfoContextProvider");
var weekOfYear = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    var e2 = "week", t2 = "year";
    return function(i, n2, r2) {
      var f2 = n2.prototype;
      f2.week = function(i2) {
        if (void 0 === i2 && (i2 = null), null !== i2)
          return this.add(7 * (i2 - this.week()), "day");
        var n3 = this.$locale().yearStart || 1;
        if (11 === this.month() && this.date() > 25) {
          var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e2);
          if (f3.isBefore(s))
            return 1;
        }
        var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o = this.diff(a, e2, true);
        return o < 0 ? r2(this).startOf("week").week() : Math.ceil(o);
      }, f2.weeks = function(e3) {
        return void 0 === e3 && (e3 = null), this.week(e3);
      };
    };
  });
})(weekOfYear);
var weekOfYearExports = weekOfYear.exports;
const weekOfYearPlugin = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
var customParseFormat = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = /* @__PURE__ */ __name(function(e3) {
      return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
    }, "s");
    var a = /* @__PURE__ */ __name(function(e3) {
      return function(t3) {
        this[e3] = +t3;
      };
    }, "a"), f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
      (this.zone || (this.zone = {})).offset = function(e4) {
        if (!e4)
          return 0;
        if ("Z" === e4)
          return 0;
        var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
        return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
      }(e3);
    }], h2 = /* @__PURE__ */ __name(function(e3) {
      var t3 = o[e3];
      return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
    }, "h"), u2 = /* @__PURE__ */ __name(function(e3, t3) {
      var n3, r3 = o.meridiem;
      if (r3) {
        for (var i2 = 1; i2 <= 24; i2 += 1)
          if (e3.indexOf(r3(i2, 0, t3)) > -1) {
            n3 = i2 > 12;
            break;
          }
      } else
        n3 = e3 === (t3 ? "pm" : "PM");
      return n3;
    }, "u"), d2 = { A: [i, function(e3) {
      this.afternoon = u2(e3, false);
    }], a: [i, function(e3) {
      this.afternoon = u2(e3, true);
    }], S: [/\d/, function(e3) {
      this.milliseconds = 100 * +e3;
    }], SS: [n2, function(e3) {
      this.milliseconds = 10 * +e3;
    }], SSS: [/\d{3}/, function(e3) {
      this.milliseconds = +e3;
    }], s: [r2, a("seconds")], ss: [r2, a("seconds")], m: [r2, a("minutes")], mm: [r2, a("minutes")], H: [r2, a("hours")], h: [r2, a("hours")], HH: [r2, a("hours")], hh: [r2, a("hours")], D: [r2, a("day")], DD: [n2, a("day")], Do: [i, function(e3) {
      var t3 = o.ordinal, n3 = e3.match(/\d+/);
      if (this.day = n3[0], t3)
        for (var r3 = 1; r3 <= 31; r3 += 1)
          t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
    }], M: [r2, a("month")], MM: [n2, a("month")], MMM: [i, function(e3) {
      var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
        return e4.slice(0, 3);
      })).indexOf(e3) + 1;
      if (n3 < 1)
        throw new Error();
      this.month = n3 % 12 || n3;
    }], MMMM: [i, function(e3) {
      var t3 = h2("months").indexOf(e3) + 1;
      if (t3 < 1)
        throw new Error();
      this.month = t3 % 12 || t3;
    }], Y: [/[+-]?\d+/, a("year")], YY: [n2, function(e3) {
      this.year = s(e3);
    }], YYYY: [/\d{4}/, a("year")], Z: f2, ZZ: f2 };
    function c2(n3) {
      var r3, i2;
      r3 = n3, i2 = o && o.formats;
      for (var s2 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
        var o2 = r4 && r4.toUpperCase();
        return n4 || i2[r4] || e2[r4] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
          return t4 || n5.slice(1);
        });
      })).match(t2), a2 = s2.length, f3 = 0; f3 < a2; f3 += 1) {
        var h3 = s2[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
        s2[f3] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
      }
      return function(e3) {
        for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
          var i3 = s2[n4];
          if ("string" == typeof i3)
            r4 += i3.length;
          else {
            var o2 = i3.regex, f4 = i3.parser, h4 = e3.slice(r4), u4 = o2.exec(h4)[0];
            f4.call(t3, u4), e3 = e3.replace(u4, "");
          }
        }
        return function(e4) {
          var t4 = e4.afternoon;
          if (void 0 !== t4) {
            var n5 = e4.hours;
            t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
          }
        }(t3), t3;
      };
    }
    __name(c2, "c");
    return function(e3, t3, n3) {
      n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s = e3.parseTwoDigitYear);
      var r3 = t3.prototype, i2 = r3.parse;
      r3.parse = function(e4) {
        var t4 = e4.date, r4 = e4.utc, s2 = e4.args;
        this.$u = r4;
        var a2 = s2[1];
        if ("string" == typeof a2) {
          var f3 = true === s2[2], h3 = true === s2[3], u3 = f3 || h3, d3 = s2[2];
          h3 && (d3 = s2[2]), o = this.$locale(), !f3 && d3 && (o = n3.Ls[d3]), this.$d = function(e5, t5, n4) {
            try {
              if (["x", "X"].indexOf(t5) > -1)
                return new Date(("X" === t5 ? 1e3 : 1) * e5);
              var r5 = c2(t5)(e5), i3 = r5.year, o2 = r5.month, s3 = r5.day, a3 = r5.hours, f4 = r5.minutes, h4 = r5.seconds, u4 = r5.milliseconds, d4 = r5.zone, l3 = /* @__PURE__ */ new Date(), m3 = s3 || (i3 || o2 ? 1 : l3.getDate()), M3 = i3 || l3.getFullYear(), Y2 = 0;
              i3 && !o2 || (Y2 = o2 > 0 ? o2 - 1 : l3.getMonth());
              var p2 = a3 || 0, v2 = f4 || 0, D2 = h4 || 0, g2 = u4 || 0;
              return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2 + 60 * d4.offset * 1e3)) : n4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2)) : new Date(M3, Y2, m3, p2, v2, D2, g2);
            } catch (e6) {
              return /* @__PURE__ */ new Date("");
            }
          }(t4, a2, r4), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
        } else if (a2 instanceof Array)
          for (var l2 = a2.length, m2 = 1; m2 <= l2; m2 += 1) {
            s2[1] = a2[m2 - 1];
            var M2 = n3.apply(this, s2);
            if (M2.isValid()) {
              this.$d = M2.$d, this.$L = M2.$L, this.init();
              break;
            }
            m2 === l2 && (this.$d = /* @__PURE__ */ new Date(""));
          }
        else
          i2.call(this, e4);
      };
    };
  });
})(customParseFormat);
var customParseFormatExports = customParseFormat.exports;
const customParseFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
var localizedFormat = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
    return function(t2, o, n2) {
      var r2 = o.prototype, i = r2.format;
      n2.en.formats = e2, r2.format = function(t3) {
        void 0 === t3 && (t3 = "YYYY-MM-DDTHH:mm:ssZ");
        var o2 = this.$locale().formats, n3 = function(t4, o3) {
          return t4.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t5, n4, r3) {
            var i2 = r3 && r3.toUpperCase();
            return n4 || o3[r3] || e2[r3] || o3[i2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t6, o4) {
              return t6 || o4.slice(1);
            });
          });
        }(t3, void 0 === o2 ? {} : o2);
        return i.call(this, n3);
      };
    };
  });
})(localizedFormat);
var localizedFormatExports = localizedFormat.exports;
const localizedFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(localizedFormatExports);
var isBetween = { exports: {} };
(function(module, exports) {
  !function(e2, i) {
    module.exports = i();
  }(commonjsGlobal, function() {
    return function(e2, i, t2) {
      i.prototype.isBetween = function(e3, i2, s, f2) {
        var n2 = t2(e3), o = t2(i2), r2 = "(" === (f2 = f2 || "()")[0], u2 = ")" === f2[1];
        return (r2 ? this.isAfter(n2, s) : !this.isBefore(n2, s)) && (u2 ? this.isBefore(o, s) : !this.isAfter(o, s)) || (r2 ? this.isBefore(n2, s) : !this.isAfter(n2, s)) && (u2 ? this.isAfter(o, s) : !this.isBefore(o, s));
      };
    };
  });
})(isBetween);
var isBetweenExports = isBetween.exports;
const isBetweenPlugin = /* @__PURE__ */ getDefaultExportFromCjs(isBetweenExports);
var advancedFormat = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    return function(e2, t2) {
      var r2 = t2.prototype, n2 = r2.format;
      r2.format = function(e3) {
        var t3 = this, r3 = this.$locale();
        if (!this.isValid())
          return n2.bind(this)(e3);
        var s = this.$utils(), a = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
          switch (e4) {
            case "Q":
              return Math.ceil((t3.$M + 1) / 3);
            case "Do":
              return r3.ordinal(t3.$D);
            case "gggg":
              return t3.weekYear();
            case "GGGG":
              return t3.isoWeekYear();
            case "wo":
              return r3.ordinal(t3.week(), "W");
            case "w":
            case "ww":
              return s.s(t3.week(), "w" === e4 ? 1 : 2, "0");
            case "W":
            case "WW":
              return s.s(t3.isoWeek(), "W" === e4 ? 1 : 2, "0");
            case "k":
            case "kk":
              return s.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e4 ? 1 : 2, "0");
            case "X":
              return Math.floor(t3.$d.getTime() / 1e3);
            case "x":
              return t3.$d.getTime();
            case "z":
              return "[" + t3.offsetName() + "]";
            case "zzz":
              return "[" + t3.offsetName("long") + "]";
            default:
              return e4;
          }
        });
        return n2.bind(this)(a);
      };
    };
  });
})(advancedFormat);
var advancedFormatExports = advancedFormat.exports;
const advancedFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(advancedFormatExports);
dayjs.extend(localizedFormatPlugin);
dayjs.extend(weekOfYearPlugin);
dayjs.extend(isBetweenPlugin);
dayjs.extend(advancedFormatPlugin);
const formatTokenMap = {
  // Year
  YY: "year",
  YYYY: {
    sectionType: "year",
    contentType: "digit",
    maxLength: 4
  },
  // Month
  M: {
    sectionType: "month",
    contentType: "digit",
    maxLength: 2
  },
  MM: "month",
  MMM: {
    sectionType: "month",
    contentType: "letter"
  },
  MMMM: {
    sectionType: "month",
    contentType: "letter"
  },
  // Day of the month
  D: {
    sectionType: "day",
    contentType: "digit",
    maxLength: 2
  },
  DD: "day",
  Do: {
    sectionType: "day",
    contentType: "digit-with-letter"
  },
  // Day of the week
  d: {
    sectionType: "weekDay",
    contentType: "digit",
    maxLength: 2
  },
  dd: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  ddd: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  dddd: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  // Meridiem
  A: "meridiem",
  a: "meridiem",
  // Hours
  H: {
    sectionType: "hours",
    contentType: "digit",
    maxLength: 2
  },
  HH: "hours",
  h: {
    sectionType: "hours",
    contentType: "digit",
    maxLength: 2
  },
  hh: "hours",
  // Minutes
  m: {
    sectionType: "minutes",
    contentType: "digit",
    maxLength: 2
  },
  mm: "minutes",
  // Seconds
  s: {
    sectionType: "seconds",
    contentType: "digit",
    maxLength: 2
  },
  ss: "seconds"
};
const defaultFormats = {
  year: "YYYY",
  month: "MMMM",
  monthShort: "MMM",
  dayOfMonth: "D",
  dayOfMonthFull: "Do",
  weekday: "dddd",
  weekdayShort: "dd",
  hours24h: "HH",
  hours12h: "hh",
  meridiem: "A",
  minutes: "mm",
  seconds: "ss",
  fullDate: "ll",
  keyboardDate: "L",
  shortDate: "MMM D",
  normalDate: "D MMMM",
  normalDateWithWeekday: "ddd, MMM D",
  fullTime: "LT",
  fullTime12h: "hh:mm A",
  fullTime24h: "HH:mm",
  keyboardDateTime: "L LT",
  keyboardDateTime12h: "L hh:mm A",
  keyboardDateTime24h: "L HH:mm"
};
const MISSING_UTC_PLUGIN = ["Missing UTC plugin", "To be able to use UTC or timezones, you have to enable the `utc` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"].join("\n");
const MISSING_TIMEZONE_PLUGIN = ["Missing timezone plugin", "To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"].join("\n");
const withLocale = /* @__PURE__ */ __name((dayjs2, locale) => !locale ? dayjs2 : (...args) => dayjs2(...args).locale(locale), "withLocale");
const _AdapterDayjs = class _AdapterDayjs {
  constructor({
    locale: _locale,
    formats
  } = {}) {
    this.isMUIAdapter = true;
    this.isTimezoneCompatible = true;
    this.lib = "dayjs";
    this.dayjs = void 0;
    this.locale = void 0;
    this.formats = void 0;
    this.escapedCharacters = {
      start: "[",
      end: "]"
    };
    this.formatTokenMap = formatTokenMap;
    this.setLocaleToValue = (value) => {
      const expectedLocale = this.getCurrentLocaleCode();
      if (expectedLocale === value.locale()) {
        return value;
      }
      return value.locale(expectedLocale);
    };
    this.hasUTCPlugin = () => typeof dayjs.utc !== "undefined";
    this.hasTimezonePlugin = () => typeof dayjs.tz !== "undefined";
    this.isSame = (value, comparing, comparisonTemplate) => {
      const comparingInValueTimezone = this.setTimezone(comparing, this.getTimezone(value));
      return value.format(comparisonTemplate) === comparingInValueTimezone.format(comparisonTemplate);
    };
    this.cleanTimezone = (timezone2) => {
      switch (timezone2) {
        case "default": {
          return void 0;
        }
        case "system": {
          return dayjs.tz.guess();
        }
        default: {
          return timezone2;
        }
      }
    };
    this.createSystemDate = (value) => {
      if (this.hasUTCPlugin() && this.hasTimezonePlugin()) {
        const timezone2 = dayjs.tz.guess();
        if (timezone2 !== "UTC") {
          return dayjs.tz(value, timezone2);
        }
        return dayjs(value);
      }
      return dayjs(value);
    };
    this.createUTCDate = (value) => {
      if (!this.hasUTCPlugin()) {
        throw new Error(MISSING_UTC_PLUGIN);
      }
      return dayjs.utc(value);
    };
    this.createTZDate = (value, timezone2) => {
      if (!this.hasUTCPlugin()) {
        throw new Error(MISSING_UTC_PLUGIN);
      }
      if (!this.hasTimezonePlugin()) {
        throw new Error(MISSING_TIMEZONE_PLUGIN);
      }
      const keepLocalTime = value !== void 0 && !value.endsWith("Z");
      return dayjs(value).tz(this.cleanTimezone(timezone2), keepLocalTime);
    };
    this.getLocaleFormats = () => {
      const locales = dayjs.Ls;
      const locale = this.locale || "en";
      let localeObject = locales[locale];
      if (localeObject === void 0) {
        localeObject = locales.en;
      }
      return localeObject.formats;
    };
    this.adjustOffset = (value) => {
      if (!this.hasTimezonePlugin()) {
        return value;
      }
      const timezone2 = this.getTimezone(value);
      if (timezone2 !== "UTC") {
        const fixedValue = value.tz(this.cleanTimezone(timezone2), true);
        if (fixedValue.$offset === (value.$offset ?? 0)) {
          return value;
        }
        value.$offset = fixedValue.$offset;
      }
      return value;
    };
    this.date = (value, timezone2 = "default") => {
      if (value === null) {
        return null;
      }
      let parsedValue;
      if (timezone2 === "UTC") {
        parsedValue = this.createUTCDate(value);
      } else if (timezone2 === "system" || timezone2 === "default" && !this.hasTimezonePlugin()) {
        parsedValue = this.createSystemDate(value);
      } else {
        parsedValue = this.createTZDate(value, timezone2);
      }
      if (this.locale === void 0) {
        return parsedValue;
      }
      return parsedValue.locale(this.locale);
    };
    this.getInvalidDate = () => dayjs(/* @__PURE__ */ new Date("Invalid date"));
    this.getTimezone = (value) => {
      var _a2;
      if (this.hasTimezonePlugin()) {
        const zone = (_a2 = value.$x) == null ? void 0 : _a2.$timezone;
        if (zone) {
          return zone;
        }
      }
      if (this.hasUTCPlugin() && value.isUTC()) {
        return "UTC";
      }
      return "system";
    };
    this.setTimezone = (value, timezone2) => {
      if (this.getTimezone(value) === timezone2) {
        return value;
      }
      if (timezone2 === "UTC") {
        if (!this.hasUTCPlugin()) {
          throw new Error(MISSING_UTC_PLUGIN);
        }
        return value.utc();
      }
      if (timezone2 === "system") {
        return value.local();
      }
      if (!this.hasTimezonePlugin()) {
        if (timezone2 === "default") {
          return value;
        }
        throw new Error(MISSING_TIMEZONE_PLUGIN);
      }
      return dayjs.tz(value, this.cleanTimezone(timezone2));
    };
    this.toJsDate = (value) => {
      return value.toDate();
    };
    this.parse = (value, format) => {
      if (value === "") {
        return null;
      }
      return this.dayjs(value, format, this.locale, true);
    };
    this.getCurrentLocaleCode = () => {
      return this.locale || "en";
    };
    this.is12HourCycleInCurrentLocale = () => {
      return /A|a/.test(this.getLocaleFormats().LT || "");
    };
    this.expandFormat = (format) => {
      const localeFormats = this.getLocaleFormats();
      const t2 = /* @__PURE__ */ __name((formatBis) => formatBis.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (_2, a, b2) => a || b2.slice(1)), "t");
      return format.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (_2, a, b2) => {
        const B2 = b2 && b2.toUpperCase();
        return a || localeFormats[b2] || t2(localeFormats[B2]);
      });
    };
    this.isValid = (value) => {
      if (value == null) {
        return false;
      }
      return value.isValid();
    };
    this.format = (value, formatKey) => {
      return this.formatByString(value, this.formats[formatKey]);
    };
    this.formatByString = (value, formatString) => {
      return this.dayjs(value).format(formatString);
    };
    this.formatNumber = (numberToFormat) => {
      return numberToFormat;
    };
    this.isEqual = (value, comparing) => {
      if (value === null && comparing === null) {
        return true;
      }
      if (value === null || comparing === null) {
        return false;
      }
      return value.toDate().getTime() === comparing.toDate().getTime();
    };
    this.isSameYear = (value, comparing) => {
      return this.isSame(value, comparing, "YYYY");
    };
    this.isSameMonth = (value, comparing) => {
      return this.isSame(value, comparing, "YYYY-MM");
    };
    this.isSameDay = (value, comparing) => {
      return this.isSame(value, comparing, "YYYY-MM-DD");
    };
    this.isSameHour = (value, comparing) => {
      return value.isSame(comparing, "hour");
    };
    this.isAfter = (value, comparing) => {
      return value > comparing;
    };
    this.isAfterYear = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isAfter(comparing, "year");
      }
      return !this.isSameYear(value, comparing) && value.utc() > comparing.utc();
    };
    this.isAfterDay = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isAfter(comparing, "day");
      }
      return !this.isSameDay(value, comparing) && value.utc() > comparing.utc();
    };
    this.isBefore = (value, comparing) => {
      return value < comparing;
    };
    this.isBeforeYear = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isBefore(comparing, "year");
      }
      return !this.isSameYear(value, comparing) && value.utc() < comparing.utc();
    };
    this.isBeforeDay = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isBefore(comparing, "day");
      }
      return !this.isSameDay(value, comparing) && value.utc() < comparing.utc();
    };
    this.isWithinRange = (value, [start2, end2]) => {
      return value >= start2 && value <= end2;
    };
    this.startOfYear = (value) => {
      return this.adjustOffset(value.startOf("year"));
    };
    this.startOfMonth = (value) => {
      return this.adjustOffset(value.startOf("month"));
    };
    this.startOfWeek = (value) => {
      return this.adjustOffset(value.startOf("week"));
    };
    this.startOfDay = (value) => {
      return this.adjustOffset(value.startOf("day"));
    };
    this.endOfYear = (value) => {
      return this.adjustOffset(value.endOf("year"));
    };
    this.endOfMonth = (value) => {
      return this.adjustOffset(value.endOf("month"));
    };
    this.endOfWeek = (value) => {
      return this.adjustOffset(value.endOf("week"));
    };
    this.endOfDay = (value) => {
      return this.adjustOffset(value.endOf("day"));
    };
    this.addYears = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "year") : value.add(amount, "year"));
    };
    this.addMonths = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "month") : value.add(amount, "month"));
    };
    this.addWeeks = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "week") : value.add(amount, "week"));
    };
    this.addDays = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "day") : value.add(amount, "day"));
    };
    this.addHours = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "hour") : value.add(amount, "hour"));
    };
    this.addMinutes = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "minute") : value.add(amount, "minute"));
    };
    this.addSeconds = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "second") : value.add(amount, "second"));
    };
    this.getYear = (value) => {
      return value.year();
    };
    this.getMonth = (value) => {
      return value.month();
    };
    this.getDate = (value) => {
      return value.date();
    };
    this.getHours = (value) => {
      return value.hour();
    };
    this.getMinutes = (value) => {
      return value.minute();
    };
    this.getSeconds = (value) => {
      return value.second();
    };
    this.getMilliseconds = (value) => {
      return value.millisecond();
    };
    this.setYear = (value, year) => {
      return this.adjustOffset(value.set("year", year));
    };
    this.setMonth = (value, month) => {
      return this.adjustOffset(value.set("month", month));
    };
    this.setDate = (value, date) => {
      return this.adjustOffset(value.set("date", date));
    };
    this.setHours = (value, hours) => {
      return this.adjustOffset(value.set("hour", hours));
    };
    this.setMinutes = (value, minutes) => {
      return this.adjustOffset(value.set("minute", minutes));
    };
    this.setSeconds = (value, seconds) => {
      return this.adjustOffset(value.set("second", seconds));
    };
    this.setMilliseconds = (value, milliseconds) => {
      return this.adjustOffset(value.set("millisecond", milliseconds));
    };
    this.getDaysInMonth = (value) => {
      return value.daysInMonth();
    };
    this.getWeekArray = (value) => {
      const cleanValue = this.setLocaleToValue(value);
      const start2 = this.startOfWeek(this.startOfMonth(cleanValue));
      const end2 = this.endOfWeek(this.endOfMonth(cleanValue));
      let count = 0;
      let current = start2;
      const nestedWeeks = [];
      while (current < end2) {
        const weekNumber = Math.floor(count / 7);
        nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
        nestedWeeks[weekNumber].push(current);
        current = this.addDays(current, 1);
        count += 1;
      }
      return nestedWeeks;
    };
    this.getWeekNumber = (value) => {
      return value.week();
    };
    this.getYearRange = ([start2, end2]) => {
      const startDate = this.startOfYear(start2);
      const endDate = this.endOfYear(end2);
      const years = [];
      let current = startDate;
      while (this.isBefore(current, endDate)) {
        years.push(current);
        current = this.addYears(current, 1);
      }
      return years;
    };
    this.dayjs = withLocale(dayjs, _locale);
    this.locale = _locale;
    this.formats = _extends$4({}, defaultFormats, formats);
    dayjs.extend(customParseFormatPlugin);
  }
  getDayOfWeek(value) {
    return value.day() + 1;
  }
};
__name(_AdapterDayjs, "AdapterDayjs");
let AdapterDayjs = _AdapterDayjs;
const mergeDateAndTime = /* @__PURE__ */ __name((utils2, dateParam, timeParam) => {
  let mergedDate = dateParam;
  mergedDate = utils2.setHours(mergedDate, utils2.getHours(timeParam));
  mergedDate = utils2.setMinutes(mergedDate, utils2.getMinutes(timeParam));
  mergedDate = utils2.setSeconds(mergedDate, utils2.getSeconds(timeParam));
  return mergedDate;
}, "mergeDateAndTime");
const replaceInvalidDateByNull = /* @__PURE__ */ __name((utils2, value) => value == null || !utils2.isValid(value) ? null : value, "replaceInvalidDateByNull");
const applyDefaultDate = /* @__PURE__ */ __name((utils2, value, defaultValue) => {
  if (value == null || !utils2.isValid(value)) {
    return defaultValue;
  }
  return value;
}, "applyDefaultDate");
const areDatesEqual = /* @__PURE__ */ __name((utils2, a, b2) => {
  if (!utils2.isValid(a) && a != null && !utils2.isValid(b2) && b2 != null) {
    return true;
  }
  return utils2.isEqual(a, b2);
}, "areDatesEqual");
const getMonthsInYear = /* @__PURE__ */ __name((utils2, year) => {
  const firstMonth = utils2.startOfYear(year);
  const months = [firstMonth];
  while (months.length < 12) {
    const prevMonth = months[months.length - 1];
    months.push(utils2.addMonths(prevMonth, 1));
  }
  return months;
}, "getMonthsInYear");
const getTodayDate = /* @__PURE__ */ __name((utils2, timezone2, valueType) => valueType === "date" ? utils2.startOfDay(utils2.date(void 0, timezone2)) : utils2.date(void 0, timezone2), "getTodayDate");
const getSecondsInDay = /* @__PURE__ */ __name((date, utils2) => {
  return utils2.getHours(date) * 3600 + utils2.getMinutes(date) * 60 + utils2.getSeconds(date);
}, "getSecondsInDay");
const createIsAfterIgnoreDatePart = /* @__PURE__ */ __name((disableIgnoringDatePartForTimeValidation, utils2) => (dateLeft, dateRight) => {
  if (disableIgnoringDatePartForTimeValidation) {
    return utils2.isAfter(dateLeft, dateRight);
  }
  return getSecondsInDay(dateLeft, utils2) > getSecondsInDay(dateRight, utils2);
}, "createIsAfterIgnoreDatePart");
const SECTION_TYPE_GRANULARITY = {
  year: 1,
  month: 2,
  day: 3,
  hours: 4,
  minutes: 5,
  seconds: 6,
  milliseconds: 7
};
const getSectionTypeGranularity = /* @__PURE__ */ __name((sections) => Math.max(...sections.map((section) => SECTION_TYPE_GRANULARITY[section.type] ?? 1)), "getSectionTypeGranularity");
const roundDate = /* @__PURE__ */ __name((utils2, granularity, date) => {
  if (granularity === SECTION_TYPE_GRANULARITY.year) {
    return utils2.startOfYear(date);
  }
  if (granularity === SECTION_TYPE_GRANULARITY.month) {
    return utils2.startOfMonth(date);
  }
  if (granularity === SECTION_TYPE_GRANULARITY.day) {
    return utils2.startOfDay(date);
  }
  let roundedDate = date;
  if (granularity < SECTION_TYPE_GRANULARITY.minutes) {
    roundedDate = utils2.setMinutes(roundedDate, 0);
  }
  if (granularity < SECTION_TYPE_GRANULARITY.seconds) {
    roundedDate = utils2.setSeconds(roundedDate, 0);
  }
  if (granularity < SECTION_TYPE_GRANULARITY.milliseconds) {
    roundedDate = utils2.setMilliseconds(roundedDate, 0);
  }
  return roundedDate;
}, "roundDate");
const getDefaultReferenceDate = /* @__PURE__ */ __name(({
  props,
  utils: utils2,
  granularity,
  timezone: timezone2,
  getTodayDate: inGetTodayDate
}) => {
  let referenceDate = inGetTodayDate ? inGetTodayDate() : roundDate(utils2, granularity, getTodayDate(utils2, timezone2));
  if (props.minDate != null && utils2.isAfterDay(props.minDate, referenceDate)) {
    referenceDate = roundDate(utils2, granularity, props.minDate);
  }
  if (props.maxDate != null && utils2.isBeforeDay(props.maxDate, referenceDate)) {
    referenceDate = roundDate(utils2, granularity, props.maxDate);
  }
  const isAfter = createIsAfterIgnoreDatePart(props.disableIgnoringDatePartForTimeValidation ?? false, utils2);
  if (props.minTime != null && isAfter(props.minTime, referenceDate)) {
    referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.minTime : mergeDateAndTime(utils2, referenceDate, props.minTime));
  }
  if (props.maxTime != null && isAfter(referenceDate, props.maxTime)) {
    referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.maxTime : mergeDateAndTime(utils2, referenceDate, props.maxTime));
  }
  return referenceDate;
}, "getDefaultReferenceDate");
const getDateSectionConfigFromFormatToken = /* @__PURE__ */ __name((utils2, formatToken) => {
  const config2 = utils2.formatTokenMap[formatToken];
  if (config2 == null) {
    throw new Error([`MUI X: The token "${formatToken}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));
  }
  if (typeof config2 === "string") {
    return {
      type: config2,
      contentType: config2 === "meridiem" ? "letter" : "digit",
      maxLength: void 0
    };
  }
  return {
    type: config2.sectionType,
    contentType: config2.contentType,
    maxLength: config2.maxLength
  };
}, "getDateSectionConfigFromFormatToken");
const getDeltaFromKeyCode = /* @__PURE__ */ __name((keyCode) => {
  switch (keyCode) {
    case "ArrowUp":
      return 1;
    case "ArrowDown":
      return -1;
    case "PageUp":
      return 5;
    case "PageDown":
      return -5;
    default:
      return 0;
  }
}, "getDeltaFromKeyCode");
const getDaysInWeekStr = /* @__PURE__ */ __name((utils2, timezone2, format) => {
  const elements = [];
  const now2 = utils2.date(void 0, timezone2);
  const startDate = utils2.startOfWeek(now2);
  const endDate = utils2.endOfWeek(now2);
  let current = startDate;
  while (utils2.isBefore(current, endDate)) {
    elements.push(current);
    current = utils2.addDays(current, 1);
  }
  return elements.map((weekDay) => utils2.formatByString(weekDay, format));
}, "getDaysInWeekStr");
const getLetterEditingOptions = /* @__PURE__ */ __name((utils2, timezone2, sectionType, format) => {
  switch (sectionType) {
    case "month": {
      return getMonthsInYear(utils2, utils2.date(void 0, timezone2)).map((month) => utils2.formatByString(month, format));
    }
    case "weekDay": {
      return getDaysInWeekStr(utils2, timezone2, format);
    }
    case "meridiem": {
      const now2 = utils2.date(void 0, timezone2);
      return [utils2.startOfDay(now2), utils2.endOfDay(now2)].map((date) => utils2.formatByString(date, format));
    }
    default: {
      return [];
    }
  }
}, "getLetterEditingOptions");
const FORMAT_SECONDS_NO_LEADING_ZEROS = "s";
const NON_LOCALIZED_DIGITS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
const getLocalizedDigits = /* @__PURE__ */ __name((utils2) => {
  const today = utils2.date(void 0);
  const formattedZero = utils2.formatByString(utils2.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);
  if (formattedZero === "0") {
    return NON_LOCALIZED_DIGITS;
  }
  return Array.from({
    length: 10
  }).map((_2, index2) => utils2.formatByString(utils2.setSeconds(today, index2), FORMAT_SECONDS_NO_LEADING_ZEROS));
}, "getLocalizedDigits");
const removeLocalizedDigits = /* @__PURE__ */ __name((valueStr, localizedDigits) => {
  if (localizedDigits[0] === "0") {
    return valueStr;
  }
  const digits = [];
  let currentFormattedDigit = "";
  for (let i = 0; i < valueStr.length; i += 1) {
    currentFormattedDigit += valueStr[i];
    const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);
    if (matchingDigitIndex > -1) {
      digits.push(matchingDigitIndex.toString());
      currentFormattedDigit = "";
    }
  }
  return digits.join("");
}, "removeLocalizedDigits");
const applyLocalizedDigits = /* @__PURE__ */ __name((valueStr, localizedDigits) => {
  if (localizedDigits[0] === "0") {
    return valueStr;
  }
  return valueStr.split("").map((char2) => localizedDigits[Number(char2)]).join("");
}, "applyLocalizedDigits");
const isStringNumber = /* @__PURE__ */ __name((valueStr, localizedDigits) => {
  const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits);
  return nonLocalizedValueStr !== " " && !Number.isNaN(Number(nonLocalizedValueStr));
}, "isStringNumber");
const cleanLeadingZeros = /* @__PURE__ */ __name((valueStr, size2) => {
  let cleanValueStr = valueStr;
  cleanValueStr = Number(cleanValueStr).toString();
  while (cleanValueStr.length < size2) {
    cleanValueStr = `0${cleanValueStr}`;
  }
  return cleanValueStr;
}, "cleanLeadingZeros");
const cleanDigitSectionValue = /* @__PURE__ */ __name((utils2, value, sectionBoundaries, localizedDigits, section) => {
  if (section.type === "day" && section.contentType === "digit-with-letter") {
    const date = utils2.setDate(sectionBoundaries.longestMonth, value);
    return utils2.formatByString(date, section.format);
  }
  let valueStr = value.toString();
  if (section.hasLeadingZerosInInput) {
    valueStr = cleanLeadingZeros(valueStr, section.maxLength);
  }
  return applyLocalizedDigits(valueStr, localizedDigits);
}, "cleanDigitSectionValue");
const adjustSectionValue = /* @__PURE__ */ __name((utils2, timezone2, section, keyCode, sectionsValueBoundaries, localizedDigits, activeDate, stepsAttributes) => {
  const delta = getDeltaFromKeyCode(keyCode);
  const isStart = keyCode === "Home";
  const isEnd = keyCode === "End";
  const shouldSetAbsolute = section.value === "" || isStart || isEnd;
  const adjustDigitSection = /* @__PURE__ */ __name(() => {
    const sectionBoundaries = sectionsValueBoundaries[section.type]({
      currentDate: activeDate,
      format: section.format,
      contentType: section.contentType
    });
    const getCleanValue = /* @__PURE__ */ __name((value) => cleanDigitSectionValue(utils2, value, sectionBoundaries, localizedDigits, section), "getCleanValue");
    const step = section.type === "minutes" && (stepsAttributes == null ? void 0 : stepsAttributes.minutesStep) ? stepsAttributes.minutesStep : 1;
    const currentSectionValue = parseInt(removeLocalizedDigits(section.value, localizedDigits), 10);
    let newSectionValueNumber = currentSectionValue + delta * step;
    if (shouldSetAbsolute) {
      if (section.type === "year" && !isEnd && !isStart) {
        return utils2.formatByString(utils2.date(void 0, timezone2), section.format);
      }
      if (delta > 0 || isStart) {
        newSectionValueNumber = sectionBoundaries.minimum;
      } else {
        newSectionValueNumber = sectionBoundaries.maximum;
      }
    }
    if (newSectionValueNumber % step !== 0) {
      if (delta < 0 || isStart) {
        newSectionValueNumber += step - (step + newSectionValueNumber) % step;
      }
      if (delta > 0 || isEnd) {
        newSectionValueNumber -= newSectionValueNumber % step;
      }
    }
    if (newSectionValueNumber > sectionBoundaries.maximum) {
      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
    }
    if (newSectionValueNumber < sectionBoundaries.minimum) {
      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
    }
    return getCleanValue(newSectionValueNumber);
  }, "adjustDigitSection");
  const adjustLetterSection = /* @__PURE__ */ __name(() => {
    const options = getLetterEditingOptions(utils2, timezone2, section.type, section.format);
    if (options.length === 0) {
      return section.value;
    }
    if (shouldSetAbsolute) {
      if (delta > 0 || isStart) {
        return options[0];
      }
      return options[options.length - 1];
    }
    const currentOptionIndex = options.indexOf(section.value);
    const newOptionIndex = (currentOptionIndex + delta) % options.length;
    const clampedIndex = (newOptionIndex + options.length) % options.length;
    return options[clampedIndex];
  }, "adjustLetterSection");
  if (section.contentType === "digit" || section.contentType === "digit-with-letter") {
    return adjustDigitSection();
  }
  return adjustLetterSection();
}, "adjustSectionValue");
const getSectionVisibleValue = /* @__PURE__ */ __name((section, target, localizedDigits) => {
  let value = section.value || section.placeholder;
  const hasLeadingZeros = target === "non-input" ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;
  if (target === "non-input" && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {
    value = Number(removeLocalizedDigits(value, localizedDigits)).toString();
  }
  const shouldAddInvisibleSpace = ["input-rtl", "input-ltr"].includes(target) && section.contentType === "digit" && !hasLeadingZeros && value.length === 1;
  if (shouldAddInvisibleSpace) {
    value = `${value}`;
  }
  if (target === "input-rtl") {
    value = `${value}`;
  }
  return value;
}, "getSectionVisibleValue");
const changeSectionValueFormat = /* @__PURE__ */ __name((utils2, valueStr, currentFormat, newFormat) => {
  return utils2.formatByString(utils2.parse(valueStr, currentFormat), newFormat);
}, "changeSectionValueFormat");
const isFourDigitYearFormat = /* @__PURE__ */ __name((utils2, timezone2, format) => utils2.formatByString(utils2.date(void 0, timezone2), format).length === 4, "isFourDigitYearFormat");
const doesSectionFormatHaveLeadingZeros = /* @__PURE__ */ __name((utils2, timezone2, contentType, sectionType, format) => {
  if (contentType !== "digit") {
    return false;
  }
  const now2 = utils2.date(void 0, timezone2);
  switch (sectionType) {
    case "year": {
      if (isFourDigitYearFormat(utils2, timezone2, format)) {
        const formatted0001 = utils2.formatByString(utils2.setYear(now2, 1), format);
        return formatted0001 === "0001";
      }
      const formatted2001 = utils2.formatByString(utils2.setYear(now2, 2001), format);
      return formatted2001 === "01";
    }
    case "month": {
      return utils2.formatByString(utils2.startOfYear(now2), format).length > 1;
    }
    case "day": {
      return utils2.formatByString(utils2.startOfMonth(now2), format).length > 1;
    }
    case "weekDay": {
      return utils2.formatByString(utils2.startOfWeek(now2), format).length > 1;
    }
    case "hours": {
      return utils2.formatByString(utils2.setHours(now2, 1), format).length > 1;
    }
    case "minutes": {
      return utils2.formatByString(utils2.setMinutes(now2, 1), format).length > 1;
    }
    case "seconds": {
      return utils2.formatByString(utils2.setSeconds(now2, 1), format).length > 1;
    }
    default: {
      throw new Error("Invalid section type");
    }
  }
}, "doesSectionFormatHaveLeadingZeros");
const getDateFromDateSections = /* @__PURE__ */ __name((utils2, sections, localizedDigits) => {
  const shouldSkipWeekDays = sections.some((section) => section.type === "day");
  const sectionFormats = [];
  const sectionValues = [];
  for (let i = 0; i < sections.length; i += 1) {
    const section = sections[i];
    const shouldSkip = shouldSkipWeekDays && section.type === "weekDay";
    if (!shouldSkip) {
      sectionFormats.push(section.format);
      sectionValues.push(getSectionVisibleValue(section, "non-input", localizedDigits));
    }
  }
  const formatWithoutSeparator = sectionFormats.join(" ");
  const dateWithoutSeparatorStr = sectionValues.join(" ");
  return utils2.parse(dateWithoutSeparatorStr, formatWithoutSeparator);
}, "getDateFromDateSections");
const createDateStrForV7HiddenInputFromSections = /* @__PURE__ */ __name((sections) => sections.map((section) => {
  return `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`;
}).join(""), "createDateStrForV7HiddenInputFromSections");
const createDateStrForV6InputFromSections = /* @__PURE__ */ __name((sections, localizedDigits, isRtl) => {
  const formattedSections = sections.map((section) => {
    const dateValue = getSectionVisibleValue(section, isRtl ? "input-rtl" : "input-ltr", localizedDigits);
    return `${section.startSeparator}${dateValue}${section.endSeparator}`;
  });
  const dateStr = formattedSections.join("");
  if (!isRtl) {
    return dateStr;
  }
  return `${dateStr}`;
}, "createDateStrForV6InputFromSections");
const getSectionsBoundaries = /* @__PURE__ */ __name((utils2, localizedDigits, timezone2) => {
  const today = utils2.date(void 0, timezone2);
  const endOfYear = utils2.endOfYear(today);
  const endOfDay = utils2.endOfDay(today);
  const {
    maxDaysInMonth,
    longestMonth
  } = getMonthsInYear(utils2, today).reduce((acc, month) => {
    const daysInMonth = utils2.getDaysInMonth(month);
    if (daysInMonth > acc.maxDaysInMonth) {
      return {
        maxDaysInMonth: daysInMonth,
        longestMonth: month
      };
    }
    return acc;
  }, {
    maxDaysInMonth: 0,
    longestMonth: null
  });
  return {
    year: ({
      format
    }) => ({
      minimum: 0,
      maximum: isFourDigitYearFormat(utils2, timezone2, format) ? 9999 : 99
    }),
    month: () => ({
      minimum: 1,
      // Assumption: All years have the same amount of months
      maximum: utils2.getMonth(endOfYear) + 1
    }),
    day: ({
      currentDate
    }) => ({
      minimum: 1,
      maximum: currentDate != null && utils2.isValid(currentDate) ? utils2.getDaysInMonth(currentDate) : maxDaysInMonth,
      longestMonth
    }),
    weekDay: ({
      format,
      contentType
    }) => {
      if (contentType === "digit") {
        const daysInWeek = getDaysInWeekStr(utils2, timezone2, format).map(Number);
        return {
          minimum: Math.min(...daysInWeek),
          maximum: Math.max(...daysInWeek)
        };
      }
      return {
        minimum: 1,
        maximum: 7
      };
    },
    hours: ({
      format
    }) => {
      const lastHourInDay = utils2.getHours(endOfDay);
      const hasMeridiem = removeLocalizedDigits(utils2.formatByString(utils2.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString();
      if (hasMeridiem) {
        return {
          minimum: 1,
          maximum: Number(removeLocalizedDigits(utils2.formatByString(utils2.startOfDay(today), format), localizedDigits))
        };
      }
      return {
        minimum: 0,
        maximum: lastHourInDay
      };
    },
    minutes: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of minutes
      maximum: utils2.getMinutes(endOfDay)
    }),
    seconds: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of seconds
      maximum: utils2.getSeconds(endOfDay)
    }),
    meridiem: () => ({
      minimum: 0,
      maximum: 1
    }),
    empty: () => ({
      minimum: 0,
      maximum: 0
    })
  };
}, "getSectionsBoundaries");
const transferDateSectionValue = /* @__PURE__ */ __name((utils2, timezone2, section, dateToTransferFrom, dateToTransferTo) => {
  switch (section.type) {
    case "year": {
      return utils2.setYear(dateToTransferTo, utils2.getYear(dateToTransferFrom));
    }
    case "month": {
      return utils2.setMonth(dateToTransferTo, utils2.getMonth(dateToTransferFrom));
    }
    case "weekDay": {
      const formattedDaysInWeek = getDaysInWeekStr(utils2, timezone2, section.format);
      const dayInWeekStrOfActiveDate = utils2.formatByString(dateToTransferFrom, section.format);
      const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);
      const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);
      const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;
      return utils2.addDays(dateToTransferFrom, diff);
    }
    case "day": {
      return utils2.setDate(dateToTransferTo, utils2.getDate(dateToTransferFrom));
    }
    case "meridiem": {
      const isAM = utils2.getHours(dateToTransferFrom) < 12;
      const mergedDateHours = utils2.getHours(dateToTransferTo);
      if (isAM && mergedDateHours >= 12) {
        return utils2.addHours(dateToTransferTo, -12);
      }
      if (!isAM && mergedDateHours < 12) {
        return utils2.addHours(dateToTransferTo, 12);
      }
      return dateToTransferTo;
    }
    case "hours": {
      return utils2.setHours(dateToTransferTo, utils2.getHours(dateToTransferFrom));
    }
    case "minutes": {
      return utils2.setMinutes(dateToTransferTo, utils2.getMinutes(dateToTransferFrom));
    }
    case "seconds": {
      return utils2.setSeconds(dateToTransferTo, utils2.getSeconds(dateToTransferFrom));
    }
    default: {
      return dateToTransferTo;
    }
  }
}, "transferDateSectionValue");
const reliableSectionModificationOrder = {
  year: 1,
  month: 2,
  day: 3,
  weekDay: 4,
  hours: 5,
  minutes: 6,
  seconds: 7,
  meridiem: 8,
  empty: 9
};
const mergeDateIntoReferenceDate = /* @__PURE__ */ __name((utils2, timezone2, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => (
  // cloning sections before sort to avoid mutating it
  [...sections].sort((a, b2) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b2.type]).reduce((mergedDate, section) => {
    if (!shouldLimitToEditedSections || section.modified) {
      return transferDateSectionValue(utils2, timezone2, section, dateToTransferFrom, mergedDate);
    }
    return mergedDate;
  }, referenceDate)
), "mergeDateIntoReferenceDate");
const isAndroid = /* @__PURE__ */ __name(() => navigator.userAgent.toLowerCase().includes("android"), "isAndroid");
const getSectionOrder = /* @__PURE__ */ __name((sections, shouldApplyRTL) => {
  const neighbors = {};
  if (!shouldApplyRTL) {
    sections.forEach((_2, index2) => {
      const leftIndex = index2 === 0 ? null : index2 - 1;
      const rightIndex = index2 === sections.length - 1 ? null : index2 + 1;
      neighbors[index2] = {
        leftIndex,
        rightIndex
      };
    });
    return {
      neighbors,
      startIndex: 0,
      endIndex: sections.length - 1
    };
  }
  const rtl2ltr = {};
  const ltr2rtl = {};
  let groupedSectionsStart = 0;
  let groupedSectionsEnd = 0;
  let RTLIndex = sections.length - 1;
  while (RTLIndex >= 0) {
    groupedSectionsEnd = sections.findIndex(
      // eslint-disable-next-line @typescript-eslint/no-loop-func
      (section, index2) => {
        var _a2;
        return index2 >= groupedSectionsStart && ((_a2 = section.endSeparator) == null ? void 0 : _a2.includes(" ")) && // Special case where the spaces were not there in the initial input
        section.endSeparator !== " / ";
      }
    );
    if (groupedSectionsEnd === -1) {
      groupedSectionsEnd = sections.length - 1;
    }
    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {
      ltr2rtl[i] = RTLIndex;
      rtl2ltr[RTLIndex] = i;
      RTLIndex -= 1;
    }
    groupedSectionsStart = groupedSectionsEnd + 1;
  }
  sections.forEach((_2, index2) => {
    const rtlIndex = ltr2rtl[index2];
    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];
    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];
    neighbors[index2] = {
      leftIndex,
      rightIndex
    };
  });
  return {
    neighbors,
    startIndex: rtl2ltr[0],
    endIndex: rtl2ltr[sections.length - 1]
  };
}, "getSectionOrder");
const parseSelectedSections = /* @__PURE__ */ __name((selectedSections, sections) => {
  if (selectedSections == null) {
    return null;
  }
  if (selectedSections === "all") {
    return "all";
  }
  if (typeof selectedSections === "string") {
    return sections.findIndex((section) => section.type === selectedSections);
  }
  return selectedSections;
}, "parseSelectedSections");
const getSectionValueText = /* @__PURE__ */ __name((section, utils2) => {
  if (!section.value) {
    return void 0;
  }
  switch (section.type) {
    case "month": {
      if (section.contentType === "digit") {
        return utils2.format(utils2.setMonth(utils2.date(), Number(section.value) - 1), "month");
      }
      const parsedDate = utils2.parse(section.value, section.format);
      return parsedDate ? utils2.format(parsedDate, "month") : void 0;
    }
    case "day":
      return section.contentType === "digit" ? utils2.format(utils2.setDate(utils2.startOfYear(utils2.date()), Number(section.value)), "dayOfMonthFull") : section.value;
    case "weekDay":
      return void 0;
    default:
      return void 0;
  }
}, "getSectionValueText");
const getSectionValueNow = /* @__PURE__ */ __name((section, utils2) => {
  if (!section.value) {
    return void 0;
  }
  switch (section.type) {
    case "weekDay": {
      if (section.contentType === "letter") {
        return void 0;
      }
      return Number(section.value);
    }
    case "meridiem": {
      const parsedDate = utils2.parse(`01:00 ${section.value}`, `${utils2.formats.hours12h}:${utils2.formats.minutes} ${section.format}`);
      if (parsedDate) {
        return utils2.getHours(parsedDate) >= 12 ? 1 : 0;
      }
      return void 0;
    }
    case "day":
      return section.contentType === "digit-with-letter" ? parseInt(section.value, 10) : Number(section.value);
    case "month": {
      if (section.contentType === "digit") {
        return Number(section.value);
      }
      const parsedDate = utils2.parse(section.value, section.format);
      return parsedDate ? utils2.getMonth(parsedDate) + 1 : void 0;
    }
    default:
      return section.contentType !== "letter" ? Number(section.value) : void 0;
  }
}, "getSectionValueNow");
const _excluded$c = ["value", "referenceDate"];
const singleItemValueManager = {
  emptyValue: null,
  getTodayValue: getTodayDate,
  getInitialReferenceValue: (_ref) => {
    let {
      value,
      referenceDate
    } = _ref, params = _objectWithoutPropertiesLoose$1(_ref, _excluded$c);
    if (value != null && params.utils.isValid(value)) {
      return value;
    }
    if (referenceDate != null) {
      return referenceDate;
    }
    return getDefaultReferenceDate(params);
  },
  cleanValue: replaceInvalidDateByNull,
  areValuesEqual: areDatesEqual,
  isSameError: (a, b2) => a === b2,
  hasError: (error) => error != null,
  defaultErrorState: null,
  getTimezone: (utils2, value) => value == null || !utils2.isValid(value) ? null : utils2.getTimezone(value),
  setTimezone: (utils2, timezone2, value) => value == null ? null : utils2.setTimezone(value, timezone2)
};
const singleItemFieldValueManager = {
  updateReferenceValue: (utils2, value, prevReferenceValue) => value == null || !utils2.isValid(value) ? prevReferenceValue : value,
  getSectionsFromValue: (utils2, date, prevSections, getSectionsFromDate) => {
    const shouldReUsePrevDateSections = !utils2.isValid(date) && !!prevSections;
    if (shouldReUsePrevDateSections) {
      return prevSections;
    }
    return getSectionsFromDate(date);
  },
  getV7HiddenInputValueFromSections: createDateStrForV7HiddenInputFromSections,
  getV6InputValueFromSections: createDateStrForV6InputFromSections,
  getActiveDateManager: (utils2, state) => ({
    date: state.value,
    referenceDate: state.referenceValue,
    getSections: (sections) => sections,
    getNewValuesFromNewActiveDate: (newActiveDate) => ({
      value: newActiveDate,
      referenceValue: newActiveDate == null || !utils2.isValid(newActiveDate) ? state.referenceValue : newActiveDate
    })
  }),
  parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue)
};
const _excluded$b = ["localeText"];
const MuiPickersAdapterContext = /* @__PURE__ */ reactExports.createContext(null);
const LocalizationProvider = /* @__PURE__ */ __name(function LocalizationProvider2(inProps) {
  const {
    localeText: inLocaleText
  } = inProps, otherInProps = _objectWithoutPropertiesLoose$1(inProps, _excluded$b);
  const {
    utils: parentUtils,
    localeText: parentLocaleText
  } = reactExports.useContext(MuiPickersAdapterContext) ?? {
    utils: void 0,
    localeText: void 0
  };
  const props = useThemeProps({
    // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
    // We will then merge this theme value with our value manually
    props: otherInProps,
    name: "MuiLocalizationProvider"
  });
  const {
    children,
    dateAdapter: DateAdapter,
    dateFormats,
    dateLibInstance,
    adapterLocale,
    localeText: themeLocaleText
  } = props;
  const localeText = reactExports.useMemo(() => _extends$4({}, themeLocaleText, parentLocaleText, inLocaleText), [themeLocaleText, parentLocaleText, inLocaleText]);
  const utils2 = reactExports.useMemo(() => {
    if (!DateAdapter) {
      if (parentUtils) {
        return parentUtils;
      }
      return null;
    }
    const adapter = new DateAdapter({
      locale: adapterLocale,
      formats: dateFormats,
      instance: dateLibInstance
    });
    if (!adapter.isMUIAdapter) {
      throw new Error(["MUI X: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`", "For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`", "More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join(`
`));
    }
    return adapter;
  }, [DateAdapter, adapterLocale, dateFormats, dateLibInstance, parentUtils]);
  const defaultDates = reactExports.useMemo(() => {
    if (!utils2) {
      return null;
    }
    return {
      minDate: utils2.date("1900-01-01T00:00:00.000"),
      maxDate: utils2.date("2099-12-31T00:00:00.000")
    };
  }, [utils2]);
  const contextValue = reactExports.useMemo(() => {
    return {
      utils: utils2,
      defaultDates,
      localeText
    };
  }, [defaultDates, utils2, localeText]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MuiPickersAdapterContext.Provider, {
    value: contextValue,
    children
  });
}, "LocalizationProvider2");
const getPickersLocalization = /* @__PURE__ */ __name((pickersTranslations) => {
  return {
    components: {
      MuiLocalizationProvider: {
        defaultProps: {
          localeText: _extends$4({}, pickersTranslations)
        }
      }
    }
  };
}, "getPickersLocalization");
const enUSPickers = {
  // Calendar navigation
  previousMonth: "Previous month",
  nextMonth: "Next month",
  // View navigation
  openPreviousView: "Open previous view",
  openNextView: "Open next view",
  calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
  // DateRange labels
  start: "Start",
  end: "End",
  startDate: "Start date",
  startTime: "Start time",
  endDate: "End date",
  endTime: "End time",
  // Action bar
  cancelButtonLabel: "Cancel",
  clearButtonLabel: "Clear",
  okButtonLabel: "OK",
  todayButtonLabel: "Today",
  // Toolbar titles
  datePickerToolbarTitle: "Select date",
  dateTimePickerToolbarTitle: "Select date & time",
  timePickerToolbarTitle: "Select time",
  dateRangePickerToolbarTitle: "Select date range",
  // Clock labels
  clockLabelText: (view, time2, adapter) => `Select ${view}. ${time2 === null ? "No time selected" : `Selected time is ${adapter.format(time2, "fullTime")}`}`,
  hoursClockNumberText: (hours) => `${hours} hours`,
  minutesClockNumberText: (minutes) => `${minutes} minutes`,
  secondsClockNumberText: (seconds) => `${seconds} seconds`,
  // Digital clock labels
  selectViewText: (view) => `Select ${view}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Week number",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (weekNumber) => `Week ${weekNumber}`,
  calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
  // Open picker labels
  openDatePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose date, selected date is ${utils2.format(value, "fullDate")}` : "Choose date",
  openTimePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose time, selected time is ${utils2.format(value, "fullTime")}` : "Choose time",
  fieldClearLabel: "Clear value",
  // Table labels
  timeTableLabel: "pick time",
  dateTableLabel: "pick date",
  // Field section placeholders
  fieldYearPlaceholder: (params) => "Y".repeat(params.digitAmount),
  fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "DD",
  fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "EEEE" : "EE",
  fieldHoursPlaceholder: () => "hh",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa",
  // View names
  year: "Year",
  month: "Month",
  day: "Day",
  weekDay: "Week day",
  hours: "Hours",
  minutes: "Minutes",
  seconds: "Seconds",
  meridiem: "Meridiem",
  // Common
  empty: "Empty"
};
const DEFAULT_LOCALE = enUSPickers;
getPickersLocalization(enUSPickers);
const useLocalizationContext = /* @__PURE__ */ __name(() => {
  const localization = reactExports.useContext(MuiPickersAdapterContext);
  if (localization === null) {
    throw new Error(["MUI X: Can not find the date and time pickers localization context.", "It looks like you forgot to wrap your component in LocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join("\n"));
  }
  if (localization.utils === null) {
    throw new Error(["MUI X: Can not find the date and time pickers adapter from its localization context.", "It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join("\n"));
  }
  const localeText = reactExports.useMemo(() => _extends$4({}, DEFAULT_LOCALE, localization.localeText), [localization.localeText]);
  return reactExports.useMemo(() => _extends$4({}, localization, {
    localeText
  }), [localization, localeText]);
}, "useLocalizationContext");
const useUtils = /* @__PURE__ */ __name(() => useLocalizationContext().utils, "useUtils");
const useDefaultDates = /* @__PURE__ */ __name(() => useLocalizationContext().defaultDates, "useDefaultDates");
function useValidation(props, validate, isSameError, defaultErrorState) {
  const {
    value,
    onError
  } = props;
  const adapter = useLocalizationContext();
  const previousValidationErrorRef = reactExports.useRef(defaultErrorState);
  const validationError = validate({
    adapter,
    value,
    props
  });
  reactExports.useEffect(() => {
    if (onError && !isSameError(validationError, previousValidationErrorRef.current)) {
      onError(validationError, value);
    }
    previousValidationErrorRef.current = validationError;
  }, [isSameError, onError, previousValidationErrorRef, validationError, value]);
  return validationError;
}
__name(useValidation, "useValidation");
const usePickersTranslations = /* @__PURE__ */ __name(() => useLocalizationContext().localeText, "usePickersTranslations");
const expandFormat = /* @__PURE__ */ __name(({
  utils: utils2,
  format
}) => {
  let formatExpansionOverflow = 10;
  let prevFormat = format;
  let nextFormat = utils2.expandFormat(format);
  while (nextFormat !== prevFormat) {
    prevFormat = nextFormat;
    nextFormat = utils2.expandFormat(prevFormat);
    formatExpansionOverflow -= 1;
    if (formatExpansionOverflow < 0) {
      throw new Error("MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.");
    }
  }
  return nextFormat;
}, "expandFormat");
const getEscapedPartsFromFormat = /* @__PURE__ */ __name(({
  utils: utils2,
  expandedFormat
}) => {
  const escapedParts = [];
  const {
    start: startChar,
    end: endChar
  } = utils2.escapedCharacters;
  const regExp = new RegExp(`(\\${startChar}[^\\${endChar}]*\\${endChar})+`, "g");
  let match2 = null;
  while (match2 = regExp.exec(expandedFormat)) {
    escapedParts.push({
      start: match2.index,
      end: regExp.lastIndex - 1
    });
  }
  return escapedParts;
}, "getEscapedPartsFromFormat");
const getSectionPlaceholder = /* @__PURE__ */ __name((utils2, timezone2, localeText, sectionConfig, sectionFormat) => {
  switch (sectionConfig.type) {
    case "year": {
      return localeText.fieldYearPlaceholder({
        digitAmount: utils2.formatByString(utils2.date(void 0, timezone2), sectionFormat).length,
        format: sectionFormat
      });
    }
    case "month": {
      return localeText.fieldMonthPlaceholder({
        contentType: sectionConfig.contentType,
        format: sectionFormat
      });
    }
    case "day": {
      return localeText.fieldDayPlaceholder({
        format: sectionFormat
      });
    }
    case "weekDay": {
      return localeText.fieldWeekDayPlaceholder({
        contentType: sectionConfig.contentType,
        format: sectionFormat
      });
    }
    case "hours": {
      return localeText.fieldHoursPlaceholder({
        format: sectionFormat
      });
    }
    case "minutes": {
      return localeText.fieldMinutesPlaceholder({
        format: sectionFormat
      });
    }
    case "seconds": {
      return localeText.fieldSecondsPlaceholder({
        format: sectionFormat
      });
    }
    case "meridiem": {
      return localeText.fieldMeridiemPlaceholder({
        format: sectionFormat
      });
    }
    default: {
      return sectionFormat;
    }
  }
}, "getSectionPlaceholder");
const createSection = /* @__PURE__ */ __name(({
  utils: utils2,
  timezone: timezone2,
  date,
  shouldRespectLeadingZeros,
  localeText,
  localizedDigits,
  now: now2,
  token: token2,
  startSeparator
}) => {
  if (token2 === "") {
    throw new Error("MUI X: Should not call `commitToken` with an empty token");
  }
  const sectionConfig = getDateSectionConfigFromFormatToken(utils2, token2);
  const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils2, timezone2, sectionConfig.contentType, sectionConfig.type, token2);
  const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === "digit";
  const isValidDate = date != null && utils2.isValid(date);
  let sectionValue = isValidDate ? utils2.formatByString(date, token2) : "";
  let maxLength = null;
  if (hasLeadingZerosInInput) {
    if (hasLeadingZerosInFormat) {
      maxLength = sectionValue === "" ? utils2.formatByString(now2, token2).length : sectionValue.length;
    } else {
      if (sectionConfig.maxLength == null) {
        throw new Error(`MUI X: The token ${token2} should have a 'maxDigitNumber' property on it's adapter`);
      }
      maxLength = sectionConfig.maxLength;
      if (isValidDate) {
        sectionValue = applyLocalizedDigits(cleanLeadingZeros(removeLocalizedDigits(sectionValue, localizedDigits), maxLength), localizedDigits);
      }
    }
  }
  return _extends$4({}, sectionConfig, {
    format: token2,
    maxLength,
    value: sectionValue,
    placeholder: getSectionPlaceholder(utils2, timezone2, localeText, sectionConfig, token2),
    hasLeadingZerosInFormat,
    hasLeadingZerosInInput,
    startSeparator,
    endSeparator: "",
    modified: false
  });
}, "createSection");
const buildSections = /* @__PURE__ */ __name((params) => {
  var _a2;
  const {
    utils: utils2,
    expandedFormat,
    escapedParts
  } = params;
  const now2 = utils2.date(void 0);
  const sections = [];
  let startSeparator = "";
  const validTokens = Object.keys(utils2.formatTokenMap).sort((a, b2) => b2.length - a.length);
  const regExpFirstWordInFormat = /^([a-zA-Z]+)/;
  const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join("|")})*$`);
  const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join("|")})`);
  const getEscapedPartOfCurrentChar = /* @__PURE__ */ __name((i2) => escapedParts.find((escapeIndex) => escapeIndex.start <= i2 && escapeIndex.end >= i2), "getEscapedPartOfCurrentChar");
  let i = 0;
  while (i < expandedFormat.length) {
    const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i);
    const isEscapedChar = escapedPartOfCurrentChar != null;
    const firstWordInFormat = (_a2 = regExpFirstWordInFormat.exec(expandedFormat.slice(i))) == null ? void 0 : _a2[1];
    if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {
      let word = firstWordInFormat;
      while (word.length > 0) {
        const firstWord = regExpFirstTokenInWord.exec(word)[1];
        word = word.slice(firstWord.length);
        sections.push(createSection(_extends$4({}, params, {
          now: now2,
          token: firstWord,
          startSeparator
        })));
        startSeparator = "";
      }
      i += firstWordInFormat.length;
    } else {
      const char2 = expandedFormat[i];
      const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;
      if (!isEscapeBoundary) {
        if (sections.length === 0) {
          startSeparator += char2;
        } else {
          sections[sections.length - 1].endSeparator += char2;
        }
      }
      i += 1;
    }
  }
  if (sections.length === 0 && startSeparator.length > 0) {
    sections.push({
      type: "empty",
      contentType: "letter",
      maxLength: null,
      format: "",
      value: "",
      placeholder: "",
      hasLeadingZerosInFormat: false,
      hasLeadingZerosInInput: false,
      startSeparator,
      endSeparator: "",
      modified: false
    });
  }
  return sections;
}, "buildSections");
const postProcessSections = /* @__PURE__ */ __name(({
  isRtl,
  formatDensity,
  sections
}) => {
  return sections.map((section) => {
    const cleanSeparator = /* @__PURE__ */ __name((separator) => {
      let cleanedSeparator = separator;
      if (isRtl && cleanedSeparator !== null && cleanedSeparator.includes(" ")) {
        cleanedSeparator = `${cleanedSeparator}`;
      }
      if (formatDensity === "spacious" && ["/", ".", "-"].includes(cleanedSeparator)) {
        cleanedSeparator = ` ${cleanedSeparator} `;
      }
      return cleanedSeparator;
    }, "cleanSeparator");
    section.startSeparator = cleanSeparator(section.startSeparator);
    section.endSeparator = cleanSeparator(section.endSeparator);
    return section;
  });
}, "postProcessSections");
const buildSectionsFromFormat = /* @__PURE__ */ __name((params) => {
  let expandedFormat = expandFormat(params);
  if (params.isRtl && params.enableAccessibleFieldDOMStructure) {
    expandedFormat = expandedFormat.split(" ").reverse().join(" ");
  }
  const escapedParts = getEscapedPartsFromFormat(_extends$4({}, params, {
    expandedFormat
  }));
  const sections = buildSections(_extends$4({}, params, {
    expandedFormat,
    escapedParts
  }));
  return postProcessSections(_extends$4({}, params, {
    sections
  }));
}, "buildSectionsFromFormat");
const useValueWithTimezone = /* @__PURE__ */ __name(({
  timezone: timezoneProp,
  value: valueProp,
  defaultValue,
  onChange,
  valueManager
}) => {
  const utils2 = useUtils();
  const firstDefaultValue = reactExports.useRef(defaultValue);
  const inputValue = valueProp ?? firstDefaultValue.current ?? valueManager.emptyValue;
  const inputTimezone = reactExports.useMemo(() => valueManager.getTimezone(utils2, inputValue), [utils2, valueManager, inputValue]);
  const setInputTimezone = useEventCallback((newValue) => {
    if (inputTimezone == null) {
      return newValue;
    }
    return valueManager.setTimezone(utils2, inputTimezone, newValue);
  });
  const timezoneToRender = timezoneProp ?? inputTimezone ?? "default";
  const valueWithTimezoneToRender = reactExports.useMemo(() => valueManager.setTimezone(utils2, timezoneToRender, inputValue), [valueManager, utils2, timezoneToRender, inputValue]);
  const handleValueChange = useEventCallback((newValue, ...otherParams) => {
    const newValueWithInputTimezone = setInputTimezone(newValue);
    onChange == null ? void 0 : onChange(newValueWithInputTimezone, ...otherParams);
  });
  return {
    value: valueWithTimezoneToRender,
    handleValueChange,
    timezone: timezoneToRender
  };
}, "useValueWithTimezone");
const useFieldState = /* @__PURE__ */ __name((params) => {
  const utils2 = useUtils();
  const translations = usePickersTranslations();
  const adapter = useLocalizationContext();
  const isRtl = useRtl();
  const {
    valueManager,
    fieldValueManager,
    valueType,
    validator: validator2,
    internalProps,
    internalProps: {
      value: valueProp,
      defaultValue,
      referenceDate: referenceDateProp,
      onChange,
      format,
      formatDensity = "dense",
      selectedSections: selectedSectionsProp,
      onSelectedSectionsChange,
      shouldRespectLeadingZeros = false,
      timezone: timezoneProp,
      enableAccessibleFieldDOMStructure = false
    }
  } = params;
  const {
    timezone: timezone2,
    value: valueFromTheOutside,
    handleValueChange
  } = useValueWithTimezone({
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager
  });
  const localizedDigits = reactExports.useMemo(() => getLocalizedDigits(utils2), [utils2]);
  const sectionsValueBoundaries = reactExports.useMemo(() => getSectionsBoundaries(utils2, localizedDigits, timezone2), [utils2, localizedDigits, timezone2]);
  const getSectionsFromValue = reactExports.useCallback((value, fallbackSections = null) => fieldValueManager.getSectionsFromValue(utils2, value, fallbackSections, (date) => buildSectionsFromFormat({
    utils: utils2,
    timezone: timezone2,
    localeText: translations,
    localizedDigits,
    format,
    date,
    formatDensity,
    shouldRespectLeadingZeros,
    enableAccessibleFieldDOMStructure,
    isRtl
  })), [fieldValueManager, format, translations, localizedDigits, isRtl, shouldRespectLeadingZeros, utils2, formatDensity, timezone2, enableAccessibleFieldDOMStructure]);
  const [state, setState] = reactExports.useState(() => {
    const sections = getSectionsFromValue(valueFromTheOutside);
    const stateWithoutReferenceDate = {
      sections,
      value: valueFromTheOutside,
      referenceValue: valueManager.emptyValue,
      tempValueStrAndroid: null
    };
    const granularity = getSectionTypeGranularity(sections);
    const referenceValue = valueManager.getInitialReferenceValue({
      referenceDate: referenceDateProp,
      value: valueFromTheOutside,
      utils: utils2,
      props: internalProps,
      granularity,
      timezone: timezone2
    });
    return _extends$4({}, stateWithoutReferenceDate, {
      referenceValue
    });
  });
  const [selectedSections, innerSetSelectedSections] = useControlled({
    controlled: selectedSectionsProp,
    default: null,
    name: "useField",
    state: "selectedSections"
  });
  const setSelectedSections = /* @__PURE__ */ __name((newSelectedSections) => {
    innerSetSelectedSections(newSelectedSections);
    onSelectedSectionsChange == null ? void 0 : onSelectedSectionsChange(newSelectedSections);
  }, "setSelectedSections");
  const parsedSelectedSections = reactExports.useMemo(() => parseSelectedSections(selectedSections, state.sections), [selectedSections, state.sections]);
  const activeSectionIndex = parsedSelectedSections === "all" ? 0 : parsedSelectedSections;
  const publishValue = /* @__PURE__ */ __name(({
    value,
    referenceValue,
    sections
  }) => {
    setState((prevState) => _extends$4({}, prevState, {
      sections,
      value,
      referenceValue,
      tempValueStrAndroid: null
    }));
    if (valueManager.areValuesEqual(utils2, state.value, value)) {
      return;
    }
    const context = {
      validationError: validator2({
        adapter,
        value,
        props: _extends$4({}, internalProps, {
          value,
          timezone: timezone2
        })
      })
    };
    handleValueChange(value, context);
  }, "publishValue");
  const setSectionValue = /* @__PURE__ */ __name((sectionIndex, newSectionValue) => {
    const newSections = [...state.sections];
    newSections[sectionIndex] = _extends$4({}, newSections[sectionIndex], {
      value: newSectionValue,
      modified: true
    });
    return newSections;
  }, "setSectionValue");
  const clearValue = /* @__PURE__ */ __name(() => {
    publishValue({
      value: valueManager.emptyValue,
      referenceValue: state.referenceValue,
      sections: getSectionsFromValue(valueManager.emptyValue)
    });
  }, "clearValue");
  const clearActiveSection = /* @__PURE__ */ __name(() => {
    if (activeSectionIndex == null) {
      return;
    }
    const activeSection = state.sections[activeSectionIndex];
    const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
    const nonEmptySectionCountBefore = activeDateManager.getSections(state.sections).filter((section) => section.value !== "").length;
    const hasNoOtherNonEmptySections = nonEmptySectionCountBefore === (activeSection.value === "" ? 0 : 1);
    const newSections = setSectionValue(activeSectionIndex, "");
    const newActiveDate = hasNoOtherNonEmptySections ? null : utils2.getInvalidDate();
    const newValues = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
    publishValue(_extends$4({}, newValues, {
      sections: newSections
    }));
  }, "clearActiveSection");
  const updateValueFromValueStr = /* @__PURE__ */ __name((valueStr) => {
    const parseDateStr = /* @__PURE__ */ __name((dateStr, referenceDate) => {
      const date = utils2.parse(dateStr, format);
      if (date == null || !utils2.isValid(date)) {
        return null;
      }
      const sections = buildSectionsFromFormat({
        utils: utils2,
        timezone: timezone2,
        localeText: translations,
        localizedDigits,
        format,
        date,
        formatDensity,
        shouldRespectLeadingZeros,
        enableAccessibleFieldDOMStructure,
        isRtl
      });
      return mergeDateIntoReferenceDate(utils2, timezone2, date, sections, referenceDate, false);
    }, "parseDateStr");
    const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);
    const newReferenceValue = fieldValueManager.updateReferenceValue(utils2, newValue, state.referenceValue);
    publishValue({
      value: newValue,
      referenceValue: newReferenceValue,
      sections: getSectionsFromValue(newValue, state.sections)
    });
  }, "updateValueFromValueStr");
  const updateSectionValue = /* @__PURE__ */ __name(({
    activeSection,
    newSectionValue,
    shouldGoToNextSection
  }) => {
    if (shouldGoToNextSection && activeSectionIndex < state.sections.length - 1) {
      setSelectedSections(activeSectionIndex + 1);
    }
    const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
    const newSections = setSectionValue(activeSectionIndex, newSectionValue);
    const newActiveDateSections = activeDateManager.getSections(newSections);
    const newActiveDate = getDateFromDateSections(utils2, newActiveDateSections, localizedDigits);
    let values2;
    let shouldPublish;
    if (newActiveDate != null && utils2.isValid(newActiveDate)) {
      const mergedDate = mergeDateIntoReferenceDate(utils2, timezone2, newActiveDate, newActiveDateSections, activeDateManager.referenceDate, true);
      values2 = activeDateManager.getNewValuesFromNewActiveDate(mergedDate);
      shouldPublish = true;
    } else {
      values2 = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
      shouldPublish = (newActiveDate != null && !utils2.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils2.isValid(activeDateManager.date));
    }
    if (shouldPublish) {
      return publishValue(_extends$4({}, values2, {
        sections: newSections
      }));
    }
    return setState((prevState) => _extends$4({}, prevState, values2, {
      sections: newSections,
      tempValueStrAndroid: null
    }));
  }, "updateSectionValue");
  const setTempAndroidValueStr = /* @__PURE__ */ __name((tempValueStrAndroid) => setState((prev2) => _extends$4({}, prev2, {
    tempValueStrAndroid
  })), "setTempAndroidValueStr");
  reactExports.useEffect(() => {
    const sections = getSectionsFromValue(state.value);
    setState((prevState) => _extends$4({}, prevState, {
      sections
    }));
  }, [format, utils2.locale, isRtl]);
  reactExports.useEffect(() => {
    let shouldUpdate;
    if (!valueManager.areValuesEqual(utils2, state.value, valueFromTheOutside)) {
      shouldUpdate = true;
    } else {
      shouldUpdate = valueManager.getTimezone(utils2, state.value) !== valueManager.getTimezone(utils2, valueFromTheOutside);
    }
    if (shouldUpdate) {
      setState((prevState) => _extends$4({}, prevState, {
        value: valueFromTheOutside,
        referenceValue: fieldValueManager.updateReferenceValue(utils2, valueFromTheOutside, prevState.referenceValue),
        sections: getSectionsFromValue(valueFromTheOutside)
      }));
    }
  }, [valueFromTheOutside]);
  return {
    state,
    activeSectionIndex,
    parsedSelectedSections,
    setSelectedSections,
    clearValue,
    clearActiveSection,
    updateSectionValue,
    updateValueFromValueStr,
    setTempAndroidValueStr,
    getSectionsFromValue,
    sectionsValueBoundaries,
    localizedDigits,
    timezone: timezone2
  };
}, "useFieldState");
const QUERY_LIFE_DURATION_MS = 5e3;
const isQueryResponseWithoutValue = /* @__PURE__ */ __name((response) => response.saveQuery != null, "isQueryResponseWithoutValue");
const useFieldCharacterEditing = /* @__PURE__ */ __name(({
  sections,
  updateSectionValue,
  sectionsValueBoundaries,
  localizedDigits,
  setTempAndroidValueStr,
  timezone: timezone2
}) => {
  const utils2 = useUtils();
  const [query, setQuery] = reactExports.useState(null);
  const resetQuery = useEventCallback(() => setQuery(null));
  reactExports.useEffect(() => {
    var _a2;
    if (query != null && ((_a2 = sections[query.sectionIndex]) == null ? void 0 : _a2.type) !== query.sectionType) {
      resetQuery();
    }
  }, [sections, query, resetQuery]);
  reactExports.useEffect(() => {
    if (query != null) {
      const timeout = setTimeout(() => resetQuery(), QUERY_LIFE_DURATION_MS);
      return () => {
        clearTimeout(timeout);
      };
    }
    return () => {
    };
  }, [query, resetQuery]);
  const applyQuery = /* @__PURE__ */ __name(({
    keyPressed,
    sectionIndex
  }, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {
    const cleanKeyPressed = keyPressed.toLowerCase();
    const activeSection = sections[sectionIndex];
    if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {
      const concatenatedQueryValue = `${query.value}${cleanKeyPressed}`;
      const queryResponse2 = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);
      if (!isQueryResponseWithoutValue(queryResponse2)) {
        setQuery({
          sectionIndex,
          value: concatenatedQueryValue,
          sectionType: activeSection.type
        });
        return queryResponse2;
      }
    }
    const queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);
    if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {
      resetQuery();
      return null;
    }
    setQuery({
      sectionIndex,
      value: cleanKeyPressed,
      sectionType: activeSection.type
    });
    if (isQueryResponseWithoutValue(queryResponse)) {
      return null;
    }
    return queryResponse;
  }, "applyQuery");
  const applyLetterEditing = /* @__PURE__ */ __name((params) => {
    const findMatchingOptions = /* @__PURE__ */ __name((format, options, queryValue) => {
      const matchingValues = options.filter((option) => option.toLowerCase().startsWith(queryValue));
      if (matchingValues.length === 0) {
        return {
          saveQuery: false
        };
      }
      return {
        sectionValue: matchingValues[0],
        shouldGoToNextSection: matchingValues.length === 1
      };
    }, "findMatchingOptions");
    const testQueryOnFormatAndFallbackFormat = /* @__PURE__ */ __name((queryValue, activeSection, fallbackFormat, formatFallbackValue) => {
      const getOptions = /* @__PURE__ */ __name((format) => getLetterEditingOptions(utils2, timezone2, activeSection.type, format), "getOptions");
      if (activeSection.contentType === "letter") {
        return findMatchingOptions(activeSection.format, getOptions(activeSection.format), queryValue);
      }
      if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils2, fallbackFormat).contentType === "letter") {
        const fallbackOptions = getOptions(fallbackFormat);
        const response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);
        if (isQueryResponseWithoutValue(response)) {
          return {
            saveQuery: false
          };
        }
        return _extends$4({}, response, {
          sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)
        });
      }
      return {
        saveQuery: false
      };
    }, "testQueryOnFormatAndFallbackFormat");
    const getFirstSectionValueMatchingWithQuery = /* @__PURE__ */ __name((queryValue, activeSection) => {
      switch (activeSection.type) {
        case "month": {
          const formatFallbackValue = /* @__PURE__ */ __name((fallbackValue) => changeSectionValueFormat(utils2, fallbackValue, utils2.formats.month, activeSection.format), "formatFallbackValue");
          return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils2.formats.month, formatFallbackValue);
        }
        case "weekDay": {
          const formatFallbackValue = /* @__PURE__ */ __name((fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString(), "formatFallbackValue");
          return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils2.formats.weekday, formatFallbackValue);
        }
        case "meridiem": {
          return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);
        }
        default: {
          return {
            saveQuery: false
          };
        }
      }
    }, "getFirstSectionValueMatchingWithQuery");
    return applyQuery(params, getFirstSectionValueMatchingWithQuery);
  }, "applyLetterEditing");
  const applyNumericEditing = /* @__PURE__ */ __name((params) => {
    const getNewSectionValue = /* @__PURE__ */ __name((queryValue, section) => {
      const cleanQueryValue = removeLocalizedDigits(queryValue, localizedDigits);
      const queryValueNumber = Number(cleanQueryValue);
      const sectionBoundaries = sectionsValueBoundaries[section.type]({
        currentDate: null,
        format: section.format,
        contentType: section.contentType
      });
      if (queryValueNumber > sectionBoundaries.maximum) {
        return {
          saveQuery: false
        };
      }
      if (queryValueNumber < sectionBoundaries.minimum) {
        return {
          saveQuery: true
        };
      }
      const shouldGoToNextSection = queryValueNumber * 10 > sectionBoundaries.maximum || cleanQueryValue.length === sectionBoundaries.maximum.toString().length;
      const newSectionValue = cleanDigitSectionValue(utils2, queryValueNumber, sectionBoundaries, localizedDigits, section);
      return {
        sectionValue: newSectionValue,
        shouldGoToNextSection
      };
    }, "getNewSectionValue");
    const getFirstSectionValueMatchingWithQuery = /* @__PURE__ */ __name((queryValue, activeSection) => {
      if (activeSection.contentType === "digit" || activeSection.contentType === "digit-with-letter") {
        return getNewSectionValue(queryValue, activeSection);
      }
      if (activeSection.type === "month") {
        const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils2, timezone2, "digit", "month", "MM");
        const response = getNewSectionValue(queryValue, {
          type: activeSection.type,
          format: "MM",
          hasLeadingZerosInFormat,
          hasLeadingZerosInInput: true,
          contentType: "digit",
          maxLength: 2
        });
        if (isQueryResponseWithoutValue(response)) {
          return response;
        }
        const formattedValue = changeSectionValueFormat(utils2, response.sectionValue, "MM", activeSection.format);
        return _extends$4({}, response, {
          sectionValue: formattedValue
        });
      }
      if (activeSection.type === "weekDay") {
        const response = getNewSectionValue(queryValue, activeSection);
        if (isQueryResponseWithoutValue(response)) {
          return response;
        }
        const formattedValue = getDaysInWeekStr(utils2, timezone2, activeSection.format)[Number(response.sectionValue) - 1];
        return _extends$4({}, response, {
          sectionValue: formattedValue
        });
      }
      return {
        saveQuery: false
      };
    }, "getFirstSectionValueMatchingWithQuery");
    return applyQuery(params, getFirstSectionValueMatchingWithQuery, (queryValue) => isStringNumber(queryValue, localizedDigits));
  }, "applyNumericEditing");
  const applyCharacterEditing = useEventCallback((params) => {
    const activeSection = sections[params.sectionIndex];
    const isNumericEditing = isStringNumber(params.keyPressed, localizedDigits);
    const response = isNumericEditing ? applyNumericEditing(_extends$4({}, params, {
      keyPressed: applyLocalizedDigits(params.keyPressed, localizedDigits)
    })) : applyLetterEditing(params);
    if (response == null) {
      setTempAndroidValueStr(null);
      return;
    }
    updateSectionValue({
      activeSection,
      newSectionValue: response.sectionValue,
      shouldGoToNextSection: response.shouldGoToNextSection
    });
  });
  return {
    applyCharacterEditing,
    resetCharacterQuery: resetQuery
  };
}, "useFieldCharacterEditing");
const getActiveElement = /* @__PURE__ */ __name((root2 = document) => {
  const activeEl = root2.activeElement;
  if (!activeEl) {
    return null;
  }
  if (activeEl.shadowRoot) {
    return getActiveElement(activeEl.shadowRoot);
  }
  return activeEl;
}, "getActiveElement");
const useFieldV7TextField = /* @__PURE__ */ __name((params) => {
  const {
    internalProps: {
      disabled,
      readOnly = false
    },
    forwardedProps: {
      sectionListRef: inSectionListRef,
      onBlur,
      onClick,
      onFocus,
      onInput,
      onPaste,
      focused: focusedProp,
      autoFocus = false
    },
    fieldValueManager,
    applyCharacterEditing,
    resetCharacterQuery,
    setSelectedSections,
    parsedSelectedSections,
    state,
    clearActiveSection,
    clearValue,
    updateSectionValue,
    updateValueFromValueStr,
    sectionOrder,
    areAllSectionsEmpty,
    sectionsValueBoundaries
  } = params;
  const sectionListRef = reactExports.useRef(null);
  const handleSectionListRef = useForkRef(inSectionListRef, sectionListRef);
  const translations = usePickersTranslations();
  const utils2 = useUtils();
  const id2 = useId();
  const [focused, setFocused] = reactExports.useState(false);
  const interactions = reactExports.useMemo(() => ({
    syncSelectionToDOM: () => {
      if (!sectionListRef.current) {
        return;
      }
      const selection = document.getSelection();
      if (!selection) {
        return;
      }
      if (parsedSelectedSections == null) {
        if (selection.rangeCount > 0 && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer)) {
          selection.removeAllRanges();
        }
        if (focused) {
          sectionListRef.current.getRoot().blur();
        }
        return;
      }
      if (!sectionListRef.current.getRoot().contains(getActiveElement(document))) {
        return;
      }
      const range2 = new window.Range();
      let target;
      if (parsedSelectedSections === "all") {
        target = sectionListRef.current.getRoot();
      } else {
        const section = state.sections[parsedSelectedSections];
        if (section.type === "empty") {
          target = sectionListRef.current.getSectionContainer(parsedSelectedSections);
        } else {
          target = sectionListRef.current.getSectionContent(parsedSelectedSections);
        }
      }
      range2.selectNodeContents(target);
      target.focus();
      selection.removeAllRanges();
      selection.addRange(range2);
    },
    getActiveSectionIndexFromDOM: () => {
      const activeElement = getActiveElement(document);
      if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {
        return null;
      }
      return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);
    },
    focusField: (newSelectedSections = 0) => {
      if (!sectionListRef.current) {
        return;
      }
      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);
      setFocused(true);
      sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();
    },
    setSelectedSections: (newSelectedSections) => {
      if (!sectionListRef.current) {
        return;
      }
      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);
      const newActiveSectionIndex = newParsedSelectedSections === "all" ? 0 : newParsedSelectedSections;
      setFocused(newActiveSectionIndex !== null);
      setSelectedSections(newSelectedSections);
    },
    isFieldFocused: () => {
      const activeElement = getActiveElement(document);
      return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);
    }
  }), [parsedSelectedSections, setSelectedSections, state.sections, focused]);
  const revertDOMSectionChange = useEventCallback((sectionIndex) => {
    if (!sectionListRef.current) {
      return;
    }
    const section = state.sections[sectionIndex];
    sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;
    interactions.syncSelectionToDOM();
  });
  const handleContainerClick = useEventCallback((event, ...args) => {
    if (event.isDefaultPrevented() || !sectionListRef.current) {
      return;
    }
    setFocused(true);
    onClick == null ? void 0 : onClick(event, ...args);
    if (parsedSelectedSections === "all") {
      setTimeout(() => {
        const cursorPosition2 = document.getSelection().getRangeAt(0).startOffset;
        if (cursorPosition2 === 0) {
          setSelectedSections(sectionOrder.startIndex);
          return;
        }
        let sectionIndex = 0;
        let cursorOnStartOfSection = 0;
        while (cursorOnStartOfSection < cursorPosition2 && sectionIndex < state.sections.length) {
          const section = state.sections[sectionIndex];
          sectionIndex += 1;
          cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;
        }
        setSelectedSections(sectionIndex - 1);
      });
    } else if (!focused) {
      setFocused(true);
      setSelectedSections(sectionOrder.startIndex);
    } else {
      const hasClickedOnASection = sectionListRef.current.getRoot().contains(event.target);
      if (!hasClickedOnASection) {
        setSelectedSections(sectionOrder.startIndex);
      }
    }
  });
  const handleContainerInput = useEventCallback((event) => {
    onInput == null ? void 0 : onInput(event);
    if (!sectionListRef.current || parsedSelectedSections !== "all") {
      return;
    }
    const target = event.target;
    const keyPressed = target.textContent ?? "";
    sectionListRef.current.getRoot().innerHTML = state.sections.map((section) => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join("");
    interactions.syncSelectionToDOM();
    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {
      resetCharacterQuery();
      clearValue();
      setSelectedSections("all");
    } else if (keyPressed.length > 1) {
      updateValueFromValueStr(keyPressed);
    } else {
      applyCharacterEditing({
        keyPressed,
        sectionIndex: 0
      });
    }
  });
  const handleContainerPaste = useEventCallback((event) => {
    onPaste == null ? void 0 : onPaste(event);
    if (readOnly || parsedSelectedSections !== "all") {
      event.preventDefault();
      return;
    }
    const pastedValue = event.clipboardData.getData("text");
    event.preventDefault();
    resetCharacterQuery();
    updateValueFromValueStr(pastedValue);
  });
  const handleContainerFocus = useEventCallback((...args) => {
    onFocus == null ? void 0 : onFocus(...args);
    if (focused || !sectionListRef.current) {
      return;
    }
    setFocused(true);
    const isFocusInsideASection = sectionListRef.current.getSectionIndexFromDOMElement(getActiveElement(document)) != null;
    if (!isFocusInsideASection) {
      setSelectedSections(sectionOrder.startIndex);
    }
  });
  const handleContainerBlur = useEventCallback((...args) => {
    onBlur == null ? void 0 : onBlur(...args);
    setTimeout(() => {
      if (!sectionListRef.current) {
        return;
      }
      const activeElement = getActiveElement(document);
      const shouldBlur = !sectionListRef.current.getRoot().contains(activeElement);
      if (shouldBlur) {
        setFocused(false);
        setSelectedSections(null);
      }
    });
  });
  const getInputContainerClickHandler = useEventCallback((sectionIndex) => (event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    setSelectedSections(sectionIndex);
  });
  const handleInputContentMouseUp = useEventCallback((event) => {
    event.preventDefault();
  });
  const getInputContentFocusHandler = useEventCallback((sectionIndex) => () => {
    setSelectedSections(sectionIndex);
  });
  const handleInputContentPaste = useEventCallback((event) => {
    event.preventDefault();
    if (readOnly || disabled || typeof parsedSelectedSections !== "number") {
      return;
    }
    const activeSection = state.sections[parsedSelectedSections];
    const pastedValue = event.clipboardData.getData("text");
    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
    const digitsOnly = /^[0-9]+$/.test(pastedValue);
    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);
    const isValidPastedValue = activeSection.contentType === "letter" && lettersOnly || activeSection.contentType === "digit" && digitsOnly || activeSection.contentType === "digit-with-letter" && digitsAndLetterOnly;
    if (isValidPastedValue) {
      resetCharacterQuery();
      updateSectionValue({
        activeSection,
        newSectionValue: pastedValue,
        shouldGoToNextSection: true
      });
    } else if (!lettersOnly && !digitsOnly) {
      resetCharacterQuery();
      updateValueFromValueStr(pastedValue);
    }
  });
  const handleInputContentDragOver = useEventCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = "none";
  });
  const handleInputContentInput = useEventCallback((event) => {
    if (!sectionListRef.current) {
      return;
    }
    const target = event.target;
    const keyPressed = target.textContent ?? "";
    const sectionIndex = sectionListRef.current.getSectionIndexFromDOMElement(target);
    const section = state.sections[sectionIndex];
    if (readOnly || !sectionListRef.current) {
      revertDOMSectionChange(sectionIndex);
      return;
    }
    if (keyPressed.length === 0) {
      if (section.value === "") {
        revertDOMSectionChange(sectionIndex);
        return;
      }
      const inputType = event.nativeEvent.inputType;
      if (inputType === "insertParagraph" || inputType === "insertLineBreak") {
        revertDOMSectionChange(sectionIndex);
        return;
      }
      resetCharacterQuery();
      clearActiveSection();
      return;
    }
    applyCharacterEditing({
      keyPressed,
      sectionIndex
    });
    revertDOMSectionChange(sectionIndex);
  });
  useEnhancedEffect(() => {
    if (!focused || !sectionListRef.current) {
      return;
    }
    if (parsedSelectedSections === "all") {
      sectionListRef.current.getRoot().focus();
    } else if (typeof parsedSelectedSections === "number") {
      const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);
      if (domElement) {
        domElement.focus();
      }
    }
  }, [parsedSelectedSections, focused]);
  const sectionBoundaries = reactExports.useMemo(() => {
    return state.sections.reduce((acc, next2) => {
      acc[next2.type] = sectionsValueBoundaries[next2.type]({
        currentDate: null,
        contentType: next2.contentType,
        format: next2.format
      });
      return acc;
    }, {});
  }, [sectionsValueBoundaries, state.sections]);
  const isContainerEditable = parsedSelectedSections === "all";
  const elements = reactExports.useMemo(() => {
    return state.sections.map((section, index2) => {
      const isEditable = !isContainerEditable && !disabled && !readOnly;
      return {
        container: {
          "data-sectionindex": index2,
          onClick: getInputContainerClickHandler(index2)
        },
        content: {
          tabIndex: isContainerEditable || index2 > 0 ? -1 : 0,
          contentEditable: !isContainerEditable && !disabled && !readOnly,
          role: "spinbutton",
          id: `${id2}-${section.type}`,
          "aria-labelledby": `${id2}-${section.type}`,
          "aria-readonly": readOnly,
          "aria-valuenow": getSectionValueNow(section, utils2),
          "aria-valuemin": sectionBoundaries[section.type].minimum,
          "aria-valuemax": sectionBoundaries[section.type].maximum,
          "aria-valuetext": section.value ? getSectionValueText(section, utils2) : translations.empty,
          "aria-label": translations[section.type],
          "aria-disabled": disabled,
          spellCheck: isEditable ? false : void 0,
          autoCapitalize: isEditable ? "off" : void 0,
          autoCorrect: isEditable ? "off" : void 0,
          [parseInt(reactExports.version, 10) >= 17 ? "enterKeyHint" : "enterkeyhint"]: isEditable ? "next" : void 0,
          children: section.value || section.placeholder,
          onInput: handleInputContentInput,
          onPaste: handleInputContentPaste,
          onFocus: getInputContentFocusHandler(index2),
          onDragOver: handleInputContentDragOver,
          onMouseUp: handleInputContentMouseUp,
          inputMode: section.contentType === "letter" ? "text" : "numeric"
        },
        before: {
          children: section.startSeparator
        },
        after: {
          children: section.endSeparator
        }
      };
    });
  }, [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, translations, utils2, sectionBoundaries, id2]);
  const handleValueStrChange = useEventCallback((event) => {
    updateValueFromValueStr(event.target.value);
  });
  const valueStr = reactExports.useMemo(() => areAllSectionsEmpty ? "" : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);
  reactExports.useEffect(() => {
    if (sectionListRef.current == null) {
      throw new Error(["MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`", "You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.", "", "If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:", "", "<DatePicker slots={{ textField: MyCustomTextField }} />", "", "Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element"].join("\n"));
    }
    if (autoFocus && sectionListRef.current) {
      sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();
    }
  }, []);
  return {
    interactions,
    returnedValue: {
      // Forwarded
      autoFocus,
      readOnly,
      focused: focusedProp ?? focused,
      sectionListRef: handleSectionListRef,
      onBlur: handleContainerBlur,
      onClick: handleContainerClick,
      onFocus: handleContainerFocus,
      onInput: handleContainerInput,
      onPaste: handleContainerPaste,
      // Additional
      enableAccessibleFieldDOMStructure: true,
      elements,
      // TODO v7: Try to set to undefined when there is a section selected.
      tabIndex: parsedSelectedSections === 0 ? -1 : 0,
      contentEditable: isContainerEditable,
      value: valueStr,
      onChange: handleValueStrChange,
      areAllSectionsEmpty
    }
  };
}, "useFieldV7TextField");
const cleanString = /* @__PURE__ */ __name((dirtyString) => dirtyString.replace(/[\u2066\u2067\u2068\u2069]/g, ""), "cleanString");
const addPositionPropertiesToSections = /* @__PURE__ */ __name((sections, localizedDigits, isRtl) => {
  let position2 = 0;
  let positionInInput = isRtl ? 1 : 0;
  const newSections = [];
  for (let i = 0; i < sections.length; i += 1) {
    const section = sections[i];
    const renderedValue = getSectionVisibleValue(section, isRtl ? "input-rtl" : "input-ltr", localizedDigits);
    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;
    const sectionLength = cleanString(sectionStr).length;
    const sectionLengthInInput = sectionStr.length;
    const cleanedValue = cleanString(renderedValue);
    const startInInput = positionInInput + (cleanedValue === "" ? 0 : renderedValue.indexOf(cleanedValue[0])) + section.startSeparator.length;
    const endInInput = startInInput + cleanedValue.length;
    newSections.push(_extends$4({}, section, {
      start: position2,
      end: position2 + sectionLength,
      startInInput,
      endInInput
    }));
    position2 += sectionLength;
    positionInInput += sectionLengthInInput;
  }
  return newSections;
}, "addPositionPropertiesToSections");
const useFieldV6TextField = /* @__PURE__ */ __name((params) => {
  const isRtl = useRtl();
  const focusTimeoutRef = reactExports.useRef();
  const selectionSyncTimeoutRef = reactExports.useRef();
  const {
    forwardedProps: {
      onFocus,
      onClick,
      onPaste,
      onBlur,
      inputRef: inputRefProp,
      placeholder: inPlaceholder
    },
    internalProps: {
      readOnly = false,
      disabled = false
    },
    parsedSelectedSections,
    activeSectionIndex,
    state,
    fieldValueManager,
    valueManager,
    applyCharacterEditing,
    resetCharacterQuery,
    updateSectionValue,
    updateValueFromValueStr,
    clearActiveSection,
    clearValue,
    setTempAndroidValueStr,
    setSelectedSections,
    getSectionsFromValue,
    areAllSectionsEmpty,
    localizedDigits
  } = params;
  const inputRef = reactExports.useRef(null);
  const handleRef = useForkRef(inputRefProp, inputRef);
  const sections = reactExports.useMemo(() => addPositionPropertiesToSections(state.sections, localizedDigits, isRtl), [state.sections, localizedDigits, isRtl]);
  const interactions = reactExports.useMemo(() => ({
    syncSelectionToDOM: () => {
      if (!inputRef.current) {
        return;
      }
      if (parsedSelectedSections == null) {
        if (inputRef.current.scrollLeft) {
          inputRef.current.scrollLeft = 0;
        }
        return;
      }
      if (inputRef.current !== getActiveElement(document)) {
        return;
      }
      const currentScrollTop = inputRef.current.scrollTop;
      if (parsedSelectedSections === "all") {
        inputRef.current.select();
      } else {
        const selectedSection = sections[parsedSelectedSections];
        const selectionStart = selectedSection.type === "empty" ? selectedSection.startInInput - selectedSection.startSeparator.length : selectedSection.startInInput;
        const selectionEnd = selectedSection.type === "empty" ? selectedSection.endInInput + selectedSection.endSeparator.length : selectedSection.endInInput;
        if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {
          if (inputRef.current === getActiveElement(document)) {
            inputRef.current.setSelectionRange(selectionStart, selectionEnd);
          }
        }
        clearTimeout(selectionSyncTimeoutRef.current);
        selectionSyncTimeoutRef.current = setTimeout(() => {
          if (inputRef.current && inputRef.current === getActiveElement(document) && // The section might loose all selection, where `selectionStart === selectionEnd`
          // https://github.com/mui/mui-x/pull/13652
          inputRef.current.selectionStart === inputRef.current.selectionEnd && (inputRef.current.selectionStart !== selectionStart || inputRef.current.selectionEnd !== selectionEnd)) {
            interactions.syncSelectionToDOM();
          }
        });
      }
      inputRef.current.scrollTop = currentScrollTop;
    },
    getActiveSectionIndexFromDOM: () => {
      const browserStartIndex = inputRef.current.selectionStart ?? 0;
      const browserEndIndex = inputRef.current.selectionEnd ?? 0;
      if (browserStartIndex === 0 && browserEndIndex === 0) {
        return null;
      }
      const nextSectionIndex = browserStartIndex <= sections[0].startInInput ? 1 : sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
      return nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;
    },
    focusField: (newSelectedSection = 0) => {
      var _a2;
      (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
      setSelectedSections(newSelectedSection);
    },
    setSelectedSections: (newSelectedSections) => setSelectedSections(newSelectedSections),
    isFieldFocused: () => inputRef.current === getActiveElement(document)
  }), [inputRef, parsedSelectedSections, sections, setSelectedSections]);
  const syncSelectionFromDOM = /* @__PURE__ */ __name(() => {
    const browserStartIndex = inputRef.current.selectionStart ?? 0;
    let nextSectionIndex;
    if (browserStartIndex <= sections[0].startInInput) {
      nextSectionIndex = 1;
    } else if (browserStartIndex >= sections[sections.length - 1].endInInput) {
      nextSectionIndex = 1;
    } else {
      nextSectionIndex = sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
    }
    const sectionIndex = nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;
    setSelectedSections(sectionIndex);
  }, "syncSelectionFromDOM");
  const handleInputFocus = useEventCallback((...args) => {
    onFocus == null ? void 0 : onFocus(...args);
    const input = inputRef.current;
    clearTimeout(focusTimeoutRef.current);
    focusTimeoutRef.current = setTimeout(() => {
      if (!input || input !== inputRef.current) {
        return;
      }
      if (activeSectionIndex != null) {
        return;
      }
      if (
        // avoid selecting all sections when focusing empty field without value
        input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length
      ) {
        setSelectedSections("all");
      } else {
        syncSelectionFromDOM();
      }
    });
  });
  const handleInputClick = useEventCallback((event, ...args) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    onClick == null ? void 0 : onClick(event, ...args);
    syncSelectionFromDOM();
  });
  const handleInputPaste = useEventCallback((event) => {
    onPaste == null ? void 0 : onPaste(event);
    event.preventDefault();
    if (readOnly || disabled) {
      return;
    }
    const pastedValue = event.clipboardData.getData("text");
    if (typeof parsedSelectedSections === "number") {
      const activeSection = state.sections[parsedSelectedSections];
      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
      const digitsOnly = /^[0-9]+$/.test(pastedValue);
      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);
      const isValidPastedValue = activeSection.contentType === "letter" && lettersOnly || activeSection.contentType === "digit" && digitsOnly || activeSection.contentType === "digit-with-letter" && digitsAndLetterOnly;
      if (isValidPastedValue) {
        resetCharacterQuery();
        updateSectionValue({
          activeSection,
          newSectionValue: pastedValue,
          shouldGoToNextSection: true
        });
        return;
      }
      if (lettersOnly || digitsOnly) {
        return;
      }
    }
    resetCharacterQuery();
    updateValueFromValueStr(pastedValue);
  });
  const handleContainerBlur = useEventCallback((...args) => {
    onBlur == null ? void 0 : onBlur(...args);
    setSelectedSections(null);
  });
  const handleInputChange = useEventCallback((event) => {
    if (readOnly) {
      return;
    }
    const targetValue = event.target.value;
    if (targetValue === "") {
      resetCharacterQuery();
      clearValue();
      return;
    }
    const eventData = event.nativeEvent.data;
    const shouldUseEventData = eventData && eventData.length > 1;
    const valueStr2 = shouldUseEventData ? eventData : targetValue;
    const cleanValueStr = cleanString(valueStr2);
    if (activeSectionIndex == null || shouldUseEventData) {
      updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);
      return;
    }
    let keyPressed;
    if (parsedSelectedSections === "all" && cleanValueStr.length === 1) {
      keyPressed = cleanValueStr;
    } else {
      const prevValueStr = cleanString(fieldValueManager.getV6InputValueFromSections(sections, localizedDigits, isRtl));
      let startOfDiffIndex = -1;
      let endOfDiffIndex = -1;
      for (let i = 0; i < prevValueStr.length; i += 1) {
        if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {
          startOfDiffIndex = i;
        }
        if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {
          endOfDiffIndex = i;
        }
      }
      const activeSection = sections[activeSectionIndex];
      const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;
      if (hasDiffOutsideOfActiveSection) {
        return;
      }
      const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || "").length;
      keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || "").length, activeSectionEndRelativeToNewValue);
    }
    if (keyPressed.length === 0) {
      if (isAndroid()) {
        setTempAndroidValueStr(valueStr2);
      }
      resetCharacterQuery();
      clearActiveSection();
      return;
    }
    applyCharacterEditing({
      keyPressed,
      sectionIndex: activeSectionIndex
    });
  });
  const placeholder = reactExports.useMemo(() => {
    if (inPlaceholder !== void 0) {
      return inPlaceholder;
    }
    return fieldValueManager.getV6InputValueFromSections(getSectionsFromValue(valueManager.emptyValue), localizedDigits, isRtl);
  }, [inPlaceholder, fieldValueManager, getSectionsFromValue, valueManager.emptyValue, localizedDigits, isRtl]);
  const valueStr = reactExports.useMemo(() => state.tempValueStrAndroid ?? fieldValueManager.getV6InputValueFromSections(state.sections, localizedDigits, isRtl), [state.sections, fieldValueManager, state.tempValueStrAndroid, localizedDigits, isRtl]);
  reactExports.useEffect(() => {
    if (inputRef.current && inputRef.current === getActiveElement(document)) {
      setSelectedSections("all");
    }
    return () => {
      clearTimeout(focusTimeoutRef.current);
      clearTimeout(selectionSyncTimeoutRef.current);
    };
  }, []);
  const inputMode = reactExports.useMemo(() => {
    if (activeSectionIndex == null) {
      return "text";
    }
    if (state.sections[activeSectionIndex].contentType === "letter") {
      return "text";
    }
    return "numeric";
  }, [activeSectionIndex, state.sections]);
  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);
  const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;
  return {
    interactions,
    returnedValue: {
      // Forwarded
      readOnly,
      onBlur: handleContainerBlur,
      onClick: handleInputClick,
      onFocus: handleInputFocus,
      onPaste: handleInputPaste,
      inputRef: handleRef,
      // Additional
      enableAccessibleFieldDOMStructure: false,
      placeholder,
      inputMode,
      autoComplete: "off",
      value: shouldShowPlaceholder ? "" : valueStr,
      onChange: handleInputChange
    }
  };
}, "useFieldV6TextField");
const useField = /* @__PURE__ */ __name((params) => {
  const utils2 = useUtils();
  const {
    internalProps,
    internalProps: {
      unstableFieldRef,
      minutesStep,
      enableAccessibleFieldDOMStructure = false,
      disabled = false,
      readOnly = false
    },
    forwardedProps: {
      onKeyDown,
      error,
      clearable,
      onClear
    },
    fieldValueManager,
    valueManager,
    validator: validator2
  } = params;
  const isRtl = useRtl();
  const stateResponse = useFieldState(params);
  const {
    state,
    activeSectionIndex,
    parsedSelectedSections,
    setSelectedSections,
    clearValue,
    clearActiveSection,
    updateSectionValue,
    setTempAndroidValueStr,
    sectionsValueBoundaries,
    localizedDigits,
    timezone: timezone2
  } = stateResponse;
  const characterEditingResponse = useFieldCharacterEditing({
    sections: state.sections,
    updateSectionValue,
    sectionsValueBoundaries,
    localizedDigits,
    setTempAndroidValueStr,
    timezone: timezone2
  });
  const {
    resetCharacterQuery
  } = characterEditingResponse;
  const areAllSectionsEmpty = valueManager.areValuesEqual(utils2, state.value, valueManager.emptyValue);
  const useFieldTextField = enableAccessibleFieldDOMStructure ? useFieldV7TextField : useFieldV6TextField;
  const sectionOrder = reactExports.useMemo(() => getSectionOrder(state.sections, isRtl && !enableAccessibleFieldDOMStructure), [state.sections, isRtl, enableAccessibleFieldDOMStructure]);
  const {
    returnedValue,
    interactions
  } = useFieldTextField(_extends$4({}, params, stateResponse, characterEditingResponse, {
    areAllSectionsEmpty,
    sectionOrder
  }));
  const handleContainerKeyDown = useEventCallback((event) => {
    onKeyDown == null ? void 0 : onKeyDown(event);
    if (disabled) {
      return;
    }
    switch (true) {
      case ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "a" && !event.shiftKey && !event.altKey): {
        event.preventDefault();
        setSelectedSections("all");
        break;
      }
      case event.key === "ArrowRight": {
        event.preventDefault();
        if (parsedSelectedSections == null) {
          setSelectedSections(sectionOrder.startIndex);
        } else if (parsedSelectedSections === "all") {
          setSelectedSections(sectionOrder.endIndex);
        } else {
          const nextSectionIndex = sectionOrder.neighbors[parsedSelectedSections].rightIndex;
          if (nextSectionIndex !== null) {
            setSelectedSections(nextSectionIndex);
          }
        }
        break;
      }
      case event.key === "ArrowLeft": {
        event.preventDefault();
        if (parsedSelectedSections == null) {
          setSelectedSections(sectionOrder.endIndex);
        } else if (parsedSelectedSections === "all") {
          setSelectedSections(sectionOrder.startIndex);
        } else {
          const nextSectionIndex = sectionOrder.neighbors[parsedSelectedSections].leftIndex;
          if (nextSectionIndex !== null) {
            setSelectedSections(nextSectionIndex);
          }
        }
        break;
      }
      case event.key === "Delete": {
        event.preventDefault();
        if (readOnly) {
          break;
        }
        if (parsedSelectedSections == null || parsedSelectedSections === "all") {
          clearValue();
        } else {
          clearActiveSection();
        }
        resetCharacterQuery();
        break;
      }
      case ["ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"].includes(event.key): {
        event.preventDefault();
        if (readOnly || activeSectionIndex == null) {
          break;
        }
        const activeSection = state.sections[activeSectionIndex];
        const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
        const newSectionValue = adjustSectionValue(utils2, timezone2, activeSection, event.key, sectionsValueBoundaries, localizedDigits, activeDateManager.date, {
          minutesStep
        });
        updateSectionValue({
          activeSection,
          newSectionValue,
          shouldGoToNextSection: false
        });
        break;
      }
    }
  });
  useEnhancedEffect(() => {
    interactions.syncSelectionToDOM();
  });
  const validationError = useValidation(_extends$4({}, internalProps, {
    value: state.value,
    timezone: timezone2
  }), validator2, valueManager.isSameError, valueManager.defaultErrorState);
  const inputError = reactExports.useMemo(() => {
    if (error !== void 0) {
      return error;
    }
    return valueManager.hasError(validationError);
  }, [valueManager, validationError, error]);
  reactExports.useEffect(() => {
    if (!inputError && activeSectionIndex == null) {
      resetCharacterQuery();
    }
  }, [state.referenceValue, activeSectionIndex, inputError]);
  reactExports.useEffect(() => {
    if (state.tempValueStrAndroid != null && activeSectionIndex != null) {
      resetCharacterQuery();
      clearActiveSection();
    }
  }, [state.sections]);
  reactExports.useImperativeHandle(unstableFieldRef, () => ({
    getSections: () => state.sections,
    getActiveSectionIndex: interactions.getActiveSectionIndexFromDOM,
    setSelectedSections: interactions.setSelectedSections,
    focusField: interactions.focusField,
    isFieldFocused: interactions.isFieldFocused
  }));
  const handleClearValue = useEventCallback((event, ...args) => {
    event.preventDefault();
    onClear == null ? void 0 : onClear(event, ...args);
    clearValue();
    if (!interactions.isFieldFocused()) {
      interactions.focusField(0);
    } else {
      setSelectedSections(sectionOrder.startIndex);
    }
  });
  const commonForwardedProps = {
    onKeyDown: handleContainerKeyDown,
    onClear: handleClearValue,
    error: inputError,
    clearable: Boolean(clearable && !areAllSectionsEmpty && !readOnly && !disabled)
  };
  const commonAdditionalProps = {
    disabled,
    readOnly
  };
  return _extends$4({}, params.forwardedProps, commonForwardedProps, commonAdditionalProps, returnedValue);
}, "useField");
const validateDate = /* @__PURE__ */ __name(({
  props,
  value,
  adapter
}) => {
  if (value === null) {
    return null;
  }
  const {
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    disablePast,
    disableFuture,
    timezone: timezone2
  } = props;
  const now2 = adapter.utils.date(void 0, timezone2);
  const minDate = applyDefaultDate(adapter.utils, props.minDate, adapter.defaultDates.minDate);
  const maxDate = applyDefaultDate(adapter.utils, props.maxDate, adapter.defaultDates.maxDate);
  switch (true) {
    case !adapter.utils.isValid(value):
      return "invalidDate";
    case Boolean(shouldDisableDate && shouldDisableDate(value)):
      return "shouldDisableDate";
    case Boolean(shouldDisableMonth && shouldDisableMonth(value)):
      return "shouldDisableMonth";
    case Boolean(shouldDisableYear && shouldDisableYear(value)):
      return "shouldDisableYear";
    case Boolean(disableFuture && adapter.utils.isAfterDay(value, now2)):
      return "disableFuture";
    case Boolean(disablePast && adapter.utils.isBeforeDay(value, now2)):
      return "disablePast";
    case Boolean(minDate && adapter.utils.isBeforeDay(value, minDate)):
      return "minDate";
    case Boolean(maxDate && adapter.utils.isAfterDay(value, maxDate)):
      return "maxDate";
    default:
      return null;
  }
}, "validateDate");
const DATE_VALIDATION_PROP_NAMES = ["disablePast", "disableFuture", "minDate", "maxDate", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear"];
const SHARED_FIELD_INTERNAL_PROP_NAMES = ["value", "defaultValue", "referenceDate", "format", "formatDensity", "onChange", "timezone", "onError", "shouldRespectLeadingZeros", "selectedSections", "onSelectedSectionsChange", "unstableFieldRef", "enableAccessibleFieldDOMStructure", "disabled", "readOnly", "dateSeparator"];
const splitFieldInternalAndForwardedProps = /* @__PURE__ */ __name((props, valueType) => {
  const forwardedProps = _extends$4({}, props);
  const internalProps = {};
  const extractProp = /* @__PURE__ */ __name((propName) => {
    if (forwardedProps.hasOwnProperty(propName)) {
      internalProps[propName] = forwardedProps[propName];
      delete forwardedProps[propName];
    }
  }, "extractProp");
  SHARED_FIELD_INTERNAL_PROP_NAMES.forEach(extractProp);
  {
    DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
  }
  return {
    forwardedProps,
    internalProps
  };
}, "splitFieldInternalAndForwardedProps");
const useDefaultizedDateField = /* @__PURE__ */ __name((props) => {
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  return _extends$4({}, props, {
    disablePast: props.disablePast ?? false,
    disableFuture: props.disableFuture ?? false,
    format: props.format ?? utils2.formats.keyboardDate,
    minDate: applyDefaultDate(utils2, props.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, props.maxDate, defaultDates.maxDate)
  });
}, "useDefaultizedDateField");
const useDateField = /* @__PURE__ */ __name((inProps) => {
  const props = useDefaultizedDateField(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props);
  return useField({
    forwardedProps,
    internalProps,
    valueManager: singleItemValueManager,
    fieldValueManager: singleItemFieldValueManager,
    validator: validateDate,
    valueType: "date"
  });
}, "useDateField");
const _excluded$a = ["clearable", "onClear", "InputProps", "sx", "slots", "slotProps"], _excluded2$1 = ["ownerState"];
const useClearableField = /* @__PURE__ */ __name((props) => {
  const translations = usePickersTranslations();
  const {
    clearable,
    onClear,
    InputProps,
    sx,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$a);
  const IconButton$1 = (slots == null ? void 0 : slots.clearButton) ?? IconButton;
  const _useSlotProps = useSlotProps$1({
    elementType: IconButton$1,
    externalSlotProps: slotProps == null ? void 0 : slotProps.clearButton,
    ownerState: {},
    className: "clearButton",
    additionalProps: {
      title: translations.fieldClearLabel
    }
  }), iconButtonProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2$1);
  const EndClearIcon = (slots == null ? void 0 : slots.clearIcon) ?? ClearIcon;
  const endClearIconProps = useSlotProps$1({
    elementType: EndClearIcon,
    externalSlotProps: slotProps == null ? void 0 : slotProps.clearIcon,
    ownerState: {}
  });
  return _extends$4({}, other, {
    InputProps: _extends$4({}, InputProps, {
      endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [clearable && /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment, {
          position: "end",
          sx: {
            marginRight: (InputProps == null ? void 0 : InputProps.endAdornment) ? -1 : -1.5
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, _extends$4({}, iconButtonProps, {
            onClick: onClear,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(EndClearIcon, _extends$4({
              fontSize: "small"
            }, endClearIconProps))
          }))
        }), InputProps == null ? void 0 : InputProps.endAdornment]
      })
    }),
    sx: [{
      "& .clearButton": {
        opacity: 1
      },
      "@media (pointer: fine)": {
        "& .clearButton": {
          opacity: 0
        },
        "&:hover, &:focus-within": {
          ".clearButton": {
            opacity: 1
          }
        }
      }
    }, ...Array.isArray(sx) ? sx : [sx]]
  });
}, "useClearableField");
function getPickersTextFieldUtilityClass(slot) {
  return generateUtilityClass$1("MuiPickersTextField", slot);
}
__name(getPickersTextFieldUtilityClass, "getPickersTextFieldUtilityClass");
const pickersTextFieldClasses = generateUtilityClasses$1("MuiPickersTextField", ["root", "focused", "disabled", "error", "required"]);
function getPickersInputBaseUtilityClass(slot) {
  return generateUtilityClass$1("MuiPickersInputBase", slot);
}
__name(getPickersInputBaseUtilityClass, "getPickersInputBaseUtilityClass");
const pickersInputBaseClasses = generateUtilityClasses$1("MuiPickersInputBase", ["root", "focused", "disabled", "error", "notchedOutline", "sectionContent", "sectionBefore", "sectionAfter", "adornedStart", "adornedEnd", "input"]);
function getPickersSectionListUtilityClass(slot) {
  return generateUtilityClass$1("MuiPickersSectionList", slot);
}
__name(getPickersSectionListUtilityClass, "getPickersSectionListUtilityClass");
const pickersSectionListClasses = generateUtilityClasses$1("MuiPickersSectionList", ["root", "section", "sectionContent"]);
const _excluded$9 = ["slots", "slotProps", "elements", "sectionListRef"];
const PickersSectionListRoot = styled("div", {
  name: "MuiPickersSectionList",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  direction: "ltr /*! @noflip */",
  outline: "none"
});
const PickersSectionListSection = styled("span", {
  name: "MuiPickersSectionList",
  slot: "Section",
  overridesResolver: (props, styles2) => styles2.section
})({});
const PickersSectionListSectionSeparator = styled("span", {
  name: "MuiPickersSectionList",
  slot: "SectionSeparator",
  overridesResolver: (props, styles2) => styles2.sectionSeparator
})({
  whiteSpace: "pre"
});
const PickersSectionListSectionContent = styled("span", {
  name: "MuiPickersSectionList",
  slot: "SectionContent",
  overridesResolver: (props, styles2) => styles2.sectionContent
})({
  outline: "none"
});
const useUtilityClasses$6 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    section: ["section"],
    sectionContent: ["sectionContent"]
  };
  return composeClasses(slots, getPickersSectionListUtilityClass, classes2);
}, "useUtilityClasses$6");
function PickersSection(props) {
  const {
    slots,
    slotProps,
    element,
    classes: classes2
  } = props;
  const Section = (slots == null ? void 0 : slots.section) ?? PickersSectionListSection;
  const sectionProps = useSlotProps$1({
    elementType: Section,
    externalSlotProps: slotProps == null ? void 0 : slotProps.section,
    externalForwardedProps: element.container,
    className: classes2.section,
    ownerState: {}
  });
  const SectionContent = (slots == null ? void 0 : slots.sectionContent) ?? PickersSectionListSectionContent;
  const sectionContentProps = useSlotProps$1({
    elementType: SectionContent,
    externalSlotProps: slotProps == null ? void 0 : slotProps.sectionContent,
    externalForwardedProps: element.content,
    additionalProps: {
      suppressContentEditableWarning: true
    },
    className: classes2.sectionContent,
    ownerState: {}
  });
  const SectionSeparator = (slots == null ? void 0 : slots.sectionSeparator) ?? PickersSectionListSectionSeparator;
  const sectionSeparatorBeforeProps = useSlotProps$1({
    elementType: SectionSeparator,
    externalSlotProps: slotProps == null ? void 0 : slotProps.sectionSeparator,
    externalForwardedProps: element.before,
    ownerState: {
      position: "before"
    }
  });
  const sectionSeparatorAfterProps = useSlotProps$1({
    elementType: SectionSeparator,
    externalSlotProps: slotProps == null ? void 0 : slotProps.sectionSeparator,
    externalForwardedProps: element.after,
    ownerState: {
      position: "after"
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, _extends$4({}, sectionProps, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SectionSeparator, _extends$4({}, sectionSeparatorBeforeProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(SectionContent, _extends$4({}, sectionContentProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(SectionSeparator, _extends$4({}, sectionSeparatorAfterProps))]
  }));
}
__name(PickersSection, "PickersSection");
const PickersSectionList = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function PickersSectionList2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersSectionList"
  });
  const {
    slots,
    slotProps,
    elements,
    sectionListRef
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$9);
  const classes2 = useUtilityClasses$6(props);
  const rootRef = reactExports.useRef(null);
  const handleRootRef = useForkRef(ref, rootRef);
  const getRoot = /* @__PURE__ */ __name((methodName) => {
    if (!rootRef.current) {
      throw new Error(`MUI X: Cannot call sectionListRef.${methodName} before the mount of the component.`);
    }
    return rootRef.current;
  }, "getRoot");
  reactExports.useImperativeHandle(sectionListRef, () => ({
    getRoot() {
      return getRoot("getRoot");
    },
    getSectionContainer(index2) {
      const root2 = getRoot("getSectionContainer");
      return root2.querySelector(`.${pickersSectionListClasses.section}[data-sectionindex="${index2}"]`);
    },
    getSectionContent(index2) {
      const root2 = getRoot("getSectionContent");
      return root2.querySelector(`.${pickersSectionListClasses.section}[data-sectionindex="${index2}"] .${pickersSectionListClasses.sectionContent}`);
    },
    getSectionIndexFromDOMElement(element) {
      const root2 = getRoot("getSectionIndexFromDOMElement");
      if (element == null || !root2.contains(element)) {
        return null;
      }
      let sectionContainer = null;
      if (element.classList.contains(pickersSectionListClasses.section)) {
        sectionContainer = element;
      } else if (element.classList.contains(pickersSectionListClasses.sectionContent)) {
        sectionContainer = element.parentElement;
      }
      if (sectionContainer == null) {
        return null;
      }
      return Number(sectionContainer.dataset.sectionindex);
    }
  }));
  const Root = (slots == null ? void 0 : slots.root) ?? PickersSectionListRoot;
  const rootProps = useSlotProps$1({
    elementType: Root,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref: handleRootRef,
      suppressContentEditableWarning: true
    },
    className: classes2.root,
    ownerState: {}
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$4({}, rootProps, {
    children: rootProps.contentEditable ? elements.map(({
      content,
      before,
      after
    }) => `${before.children}${content.children}${after.children}`).join("") : /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: elements.map((element, elementIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSection, {
        slots,
        slotProps,
        element,
        classes: classes2
      }, elementIndex))
    })
  }));
}, "PickersSectionList2"));
const _excluded$8 = ["elements", "areAllSectionsEmpty", "defaultValue", "label", "value", "onChange", "id", "autoFocus", "endAdornment", "startAdornment", "renderSuffix", "slots", "slotProps", "contentEditable", "tabIndex", "onInput", "onPaste", "onKeyDown", "fullWidth", "name", "readOnly", "inputProps", "inputRef", "sectionListRef"];
const round = /* @__PURE__ */ __name((value) => Math.round(value * 1e5) / 1e5, "round");
const PickersInputBaseRoot = styled("div", {
  name: "MuiPickersInputBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => _extends$4({}, theme2.typography.body1, {
  color: (theme2.vars || theme2).palette.text.primary,
  cursor: "text",
  padding: 0,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  letterSpacing: `${round(0.15 / 16)}em`,
  variants: [{
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }]
}));
const PickersInputBaseSectionsContainer = styled(PickersSectionListRoot, {
  name: "MuiPickersInputBase",
  slot: "SectionsContainer",
  overridesResolver: (props, styles2) => styles2.sectionsContainer
})(({
  theme: theme2
}) => ({
  padding: "4px 0 5px",
  fontFamily: theme2.typography.fontFamily,
  fontSize: "inherit",
  lineHeight: "1.4375em",
  // 23px
  flexGrow: 1,
  outline: "none",
  display: "flex",
  flexWrap: "nowrap",
  overflow: "hidden",
  letterSpacing: "inherit",
  // Baseline behavior
  width: "182px",
  variants: [{
    props: {
      isRtl: true
    },
    style: {
      textAlign: "right /*! @noflip */"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      paddingTop: 1
    }
  }, {
    props: {
      adornedStart: false,
      focused: false,
      filled: false
    },
    style: {
      color: "currentColor",
      opacity: 0
    }
  }, {
    // Can't use the object notation because label can be null or undefined
    props: ({
      adornedStart,
      focused,
      filled,
      label
    }) => !adornedStart && !focused && !filled && label == null,
    style: theme2.vars ? {
      opacity: theme2.vars.opacity.inputPlaceholder
    } : {
      opacity: theme2.palette.mode === "light" ? 0.42 : 0.5
    }
  }]
}));
const PickersInputBaseSection = styled(PickersSectionListSection, {
  name: "MuiPickersInputBase",
  slot: "Section",
  overridesResolver: (props, styles2) => styles2.section
})(({
  theme: theme2
}) => ({
  fontFamily: theme2.typography.fontFamily,
  fontSize: "inherit",
  letterSpacing: "inherit",
  lineHeight: "1.4375em",
  // 23px
  display: "flex"
}));
const PickersInputBaseSectionContent = styled(PickersSectionListSectionContent, {
  name: "MuiPickersInputBase",
  slot: "SectionContent",
  overridesResolver: (props, styles2) => styles2.content
})(({
  theme: theme2
}) => ({
  fontFamily: theme2.typography.fontFamily,
  lineHeight: "1.4375em",
  // 23px
  letterSpacing: "inherit",
  width: "fit-content",
  outline: "none"
}));
const PickersInputBaseSectionSeparator = styled(PickersSectionListSectionSeparator, {
  name: "MuiPickersInputBase",
  slot: "Separator",
  overridesResolver: (props, styles2) => styles2.separator
})(() => ({
  whiteSpace: "pre",
  letterSpacing: "inherit"
}));
const PickersInputBaseInput = styled("input", {
  name: "MuiPickersInputBase",
  slot: "Input",
  overridesResolver: (props, styles2) => styles2.hiddenInput
})(_extends$4({}, visuallyHidden));
const useUtilityClasses$5 = /* @__PURE__ */ __name((ownerState) => {
  const {
    focused,
    disabled,
    error,
    classes: classes2,
    fullWidth,
    readOnly,
    color: color2,
    size: size2,
    endAdornment,
    startAdornment
  } = ownerState;
  const slots = {
    root: ["root", focused && !disabled && "focused", disabled && "disabled", readOnly && "readOnly", error && "error", fullWidth && "fullWidth", `color${capitalize$1(color2)}`, size2 === "small" && "inputSizeSmall", Boolean(startAdornment) && "adornedStart", Boolean(endAdornment) && "adornedEnd"],
    notchedOutline: ["notchedOutline"],
    input: ["input"],
    sectionsContainer: ["sectionsContainer"],
    sectionContent: ["sectionContent"],
    sectionBefore: ["sectionBefore"],
    sectionAfter: ["sectionAfter"]
  };
  return composeClasses(slots, getPickersInputBaseUtilityClass, classes2);
}, "useUtilityClasses$5");
const PickersInputBase = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function PickersInputBase2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersInputBase"
  });
  const {
    elements,
    areAllSectionsEmpty,
    value,
    onChange,
    id: id2,
    endAdornment,
    startAdornment,
    renderSuffix,
    slots,
    slotProps,
    contentEditable,
    tabIndex,
    onInput,
    onPaste,
    onKeyDown,
    name,
    readOnly,
    inputProps,
    inputRef,
    sectionListRef
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$8);
  const rootRef = reactExports.useRef(null);
  const handleRootRef = useForkRef(ref, rootRef);
  const handleInputRef = useForkRef(inputProps == null ? void 0 : inputProps.ref, inputRef);
  const isRtl = useRtl();
  const muiFormControl = useFormControl();
  if (!muiFormControl) {
    throw new Error("MUI X: PickersInputBase should always be used inside a PickersTextField component");
  }
  const handleInputFocus = /* @__PURE__ */ __name((event) => {
    var _a2;
    if (muiFormControl.disabled) {
      event.stopPropagation();
      return;
    }
    (_a2 = muiFormControl.onFocus) == null ? void 0 : _a2.call(muiFormControl, event);
  }, "handleInputFocus");
  reactExports.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  reactExports.useEffect(() => {
    if (!muiFormControl) {
      return;
    }
    if (areAllSectionsEmpty) {
      muiFormControl.onEmpty();
    } else {
      muiFormControl.onFilled();
    }
  }, [muiFormControl, areAllSectionsEmpty]);
  const ownerState = _extends$4({}, props, muiFormControl, {
    isRtl
  });
  const classes2 = useUtilityClasses$5(ownerState);
  const InputRoot2 = (slots == null ? void 0 : slots.root) || PickersInputBaseRoot;
  const inputRootProps = useSlotProps$1({
    elementType: InputRoot2,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      "aria-invalid": muiFormControl.error,
      ref: handleRootRef
    },
    className: classes2.root,
    ownerState
  });
  const InputSectionsContainer = (slots == null ? void 0 : slots.input) || PickersInputBaseSectionsContainer;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(InputRoot2, _extends$4({}, inputRootProps, {
    children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSectionList, {
      sectionListRef,
      elements,
      contentEditable,
      tabIndex,
      className: classes2.sectionsContainer,
      onFocus: handleInputFocus,
      onBlur: muiFormControl.onBlur,
      onInput,
      onPaste,
      onKeyDown,
      slots: {
        root: InputSectionsContainer,
        section: PickersInputBaseSection,
        sectionContent: PickersInputBaseSectionContent,
        sectionSeparator: PickersInputBaseSectionSeparator
      },
      slotProps: {
        root: {
          ownerState
        },
        sectionContent: {
          className: pickersInputBaseClasses.sectionContent
        },
        sectionSeparator: ({
          position: position2
        }) => ({
          className: position2 === "before" ? pickersInputBaseClasses.sectionBefore : pickersInputBaseClasses.sectionAfter
        })
      }
    }), endAdornment, renderSuffix ? renderSuffix(_extends$4({}, muiFormControl)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBaseInput, _extends$4({
      name,
      className: classes2.input,
      value,
      onChange,
      id: id2,
      "aria-hidden": "true",
      tabIndex: -1,
      readOnly,
      required: muiFormControl.required,
      disabled: muiFormControl.disabled
    }, inputProps, {
      ref: handleInputRef
    }))]
  }));
}, "PickersInputBase2"));
function getPickersOutlinedInputUtilityClass(slot) {
  return generateUtilityClass$1("MuiPickersOutlinedInput", slot);
}
__name(getPickersOutlinedInputUtilityClass, "getPickersOutlinedInputUtilityClass");
const pickersOutlinedInputClasses = _extends$4({}, pickersInputBaseClasses, generateUtilityClasses$1("MuiPickersOutlinedInput", ["root", "notchedOutline", "input"]));
const _excluded$7 = ["children", "className", "label", "notched", "shrink"];
const OutlineRoot = styled("fieldset", {
  name: "MuiPickersOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (props, styles2) => styles2.notchedOutline
})(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%",
    borderColor: theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
  };
});
const OutlineLabel = styled("span")(({
  theme: theme2
}) => ({
  fontFamily: theme2.typography.fontFamily,
  fontSize: "inherit"
}));
const OutlineLegend = styled("legend")(({
  theme: theme2
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: {
      withLabel: false
    },
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: theme2.transitions.create("width", {
        duration: 150,
        easing: theme2.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      withLabel: true
    },
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: theme2.transitions.create("max-width", {
        duration: 50,
        easing: theme2.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: {
      withLabel: true,
      notched: true
    },
    style: {
      maxWidth: "100%",
      transition: theme2.transitions.create("max-width", {
        duration: 100,
        easing: theme2.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
}));
function Outline(props) {
  const {
    className,
    label
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$7);
  const withLabel = label != null && label !== "";
  const ownerState = _extends$4({}, props, {
    withLabel
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineRoot, _extends$4({
    "aria-hidden": true,
    className
  }, other, {
    ownerState,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineLabel, {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineLabel, {
          className: "notranslate",
          children: ""
        })
      )
    })
  }));
}
__name(Outline, "Outline");
const _excluded$6 = ["label", "autoFocus", "ownerState", "notched"];
const PickersOutlinedInputRoot = styled(PickersInputBaseRoot, {
  name: "MuiPickersOutlinedInput",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    padding: "0 14px",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    [`&:hover .${pickersOutlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${pickersOutlinedInputClasses.notchedOutline}`]: {
        borderColor: theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      }
    },
    [`&.${pickersOutlinedInputClasses.focused} .${pickersOutlinedInputClasses.notchedOutline}`]: {
      borderStyle: "solid",
      borderWidth: 2
    },
    [`&.${pickersOutlinedInputClasses.disabled}`]: {
      [`& .${pickersOutlinedInputClasses.notchedOutline}`]: {
        borderColor: (theme2.vars || theme2).palette.action.disabled
      },
      "*": {
        color: (theme2.vars || theme2).palette.action.disabled
      }
    },
    [`&.${pickersOutlinedInputClasses.error} .${pickersOutlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.error.main
    },
    variants: Object.keys((theme2.vars ?? theme2).palette).filter((key) => {
      var _a2;
      return ((_a2 = (theme2.vars ?? theme2).palette[key]) == null ? void 0 : _a2.main) ?? false;
    }).map((color2) => ({
      props: {
        color: color2
      },
      style: {
        [`&.${pickersOutlinedInputClasses.focused}:not(.${pickersOutlinedInputClasses.error}) .${pickersOutlinedInputClasses.notchedOutline}`]: {
          // @ts-ignore
          borderColor: (theme2.vars || theme2).palette[color2].main
        }
      }
    }))
  };
});
const PickersOutlinedInputSectionsContainer = styled(PickersInputBaseSectionsContainer, {
  name: "MuiPickersOutlinedInput",
  slot: "SectionsContainer",
  overridesResolver: (props, styles2) => styles2.sectionsContainer
})({
  padding: "16.5px 0",
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 0"
    }
  }]
});
const useUtilityClasses$4 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getPickersOutlinedInputUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$4");
const PickersOutlinedInput = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function PickersOutlinedInput2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersOutlinedInput"
  });
  const {
    label,
    ownerState: ownerStateProp,
    notched
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$6);
  const muiFormControl = useFormControl();
  const ownerState = _extends$4({}, props, ownerStateProp, muiFormControl, {
    color: (muiFormControl == null ? void 0 : muiFormControl.color) || "primary"
  });
  const classes2 = useUtilityClasses$4(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$4({
    slots: {
      root: PickersOutlinedInputRoot,
      input: PickersOutlinedInputSectionsContainer
    },
    renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(Outline, {
      shrink: Boolean(notched || state.adornedStart || state.focused || state.filled),
      notched: Boolean(notched || state.adornedStart || state.focused || state.filled),
      className: classes2.notchedOutline,
      label: label != null && label !== "" && (muiFormControl == null ? void 0 : muiFormControl.required) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, "", "*"]
      }) : label,
      ownerState
    })
  }, other, {
    label,
    classes: classes2,
    ref
  }));
}, "PickersOutlinedInput2"));
PickersOutlinedInput.muiName = "Input";
function getPickersFilledInputUtilityClass(slot) {
  return generateUtilityClass$1("MuiPickersFilledInput", slot);
}
__name(getPickersFilledInputUtilityClass, "getPickersFilledInputUtilityClass");
const pickersFilledInputClasses = _extends$4({}, pickersInputBaseClasses, generateUtilityClasses$1("MuiPickersFilledInput", ["root", "underline", "input"]));
const _excluded$5 = ["label", "autoFocus", "disableUnderline", "ownerState"];
const PickersFilledInputRoot = styled(PickersInputBaseRoot, {
  name: "MuiPickersFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root,
  shouldForwardProp: (prop) => shouldForwardProp$1(prop) && prop !== "disableUnderline"
})(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme2.vars || theme2).shape.borderRadius,
    borderTopRightRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create("background-color", {
      duration: theme2.transitions.duration.shorter,
      easing: theme2.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${pickersFilledInputClasses.focused}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${pickersFilledInputClasses.disabled}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.disabledBg : disabledBackground
    },
    variants: [...Object.keys((theme2.vars ?? theme2).palette).filter((key) => (theme2.vars ?? theme2).palette[key].main).map((color2) => {
      var _a2;
      return {
        props: {
          color: color2,
          disableUnderline: false
        },
        style: {
          "&::after": {
            // @ts-ignore
            borderBottom: `2px solid ${(_a2 = (theme2.vars || theme2).palette[color2]) == null ? void 0 : _a2.main}`
          }
        }
      };
    }), {
      props: {
        disableUnderline: false
      },
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme2.transitions.create("transform", {
            duration: theme2.transitions.duration.shorter,
            easing: theme2.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${pickersFilledInputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${pickersFilledInputClasses.error}`]: {
          "&:before, &:after": {
            borderBottomColor: (theme2.vars || theme2).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / ${theme2.vars.opacity.inputUnderline})` : bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme2.transitions.create("border-bottom-color", {
            duration: theme2.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${pickersFilledInputClasses.disabled}, .${pickersFilledInputClasses.error}):before`]: {
          borderBottom: `1px solid ${(theme2.vars || theme2).palette.text.primary}`
        },
        [`&.${pickersFilledInputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, {
      props: ({
        startAdornment
      }) => !!startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        endAdornment
      }) => !!endAdornment,
      style: {
        paddingRight: 12
      }
    }]
  };
});
const PickersFilledSectionsContainer = styled(PickersInputBaseSectionsContainer, {
  name: "MuiPickersFilledInput",
  slot: "sectionsContainer",
  overridesResolver: (props, styles2) => styles2.sectionsContainer
})({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      startAdornment
    }) => !!startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      endAdornment
    }) => !!endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: {
      hiddenLabel: true
    },
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: {
      hiddenLabel: true,
      size: "small"
    },
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }]
});
const useUtilityClasses$3 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getPickersFilledInputUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$3");
const PickersFilledInput = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function PickersFilledInput2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersFilledInput"
  });
  const {
    label,
    disableUnderline = false,
    ownerState: ownerStateProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$5);
  const muiFormControl = useFormControl();
  const ownerState = _extends$4({}, props, ownerStateProp, muiFormControl, {
    color: (muiFormControl == null ? void 0 : muiFormControl.color) || "primary"
  });
  const classes2 = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$4({
    slots: {
      root: PickersFilledInputRoot,
      input: PickersFilledSectionsContainer
    },
    slotProps: {
      root: {
        disableUnderline
      }
    }
  }, other, {
    label,
    classes: classes2,
    ref
  }));
}, "PickersFilledInput2"));
PickersFilledInput.muiName = "Input";
function getPickersInputUtilityClass(slot) {
  return generateUtilityClass$1("MuiPickersFilledInput", slot);
}
__name(getPickersInputUtilityClass, "getPickersInputUtilityClass");
const pickersInputClasses = _extends$4({}, pickersInputBaseClasses, generateUtilityClasses$1("MuiPickersInput", ["root", "input"]));
const _excluded$4 = ["label", "autoFocus", "disableUnderline", "ownerState"];
const PickersInputRoot = styled(PickersInputBaseRoot, {
  name: "MuiPickersInput",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme2.vars) {
    bottomLineColor = `rgba(${theme2.vars.palette.common.onBackgroundChannel} / ${theme2.vars.opacity.inputUnderline})`;
  }
  return {
    "label + &": {
      marginTop: 16
    },
    variants: [...Object.keys((theme2.vars ?? theme2).palette).filter((key) => (theme2.vars ?? theme2).palette[key].main).map((color2) => ({
      props: {
        color: color2
      },
      style: {
        "&::after": {
          // @ts-ignore
          borderBottom: `2px solid ${(theme2.vars || theme2).palette[color2].main}`
        }
      }
    })), {
      props: {
        disableUnderline: false
      },
      style: {
        "&::after": {
          background: "red",
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme2.transitions.create("transform", {
            duration: theme2.transitions.duration.shorter,
            easing: theme2.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${pickersInputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${pickersInputClasses.error}`]: {
          "&:before, &:after": {
            borderBottomColor: (theme2.vars || theme2).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme2.transitions.create("border-bottom-color", {
            duration: theme2.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${pickersInputClasses.disabled}, .${pickersInputClasses.error}):before`]: {
          borderBottom: `2px solid ${(theme2.vars || theme2).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${pickersInputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }]
  };
});
const useUtilityClasses$2 = /* @__PURE__ */ __name((ownerState) => {
  const {
    classes: classes2,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getPickersInputUtilityClass, classes2);
  return _extends$4({}, classes2, composedClasses);
}, "useUtilityClasses$2");
const PickersInput = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function PickersInput2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersInput"
  });
  const {
    label,
    disableUnderline = false,
    ownerState: ownerStateProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$4);
  const muiFormControl = useFormControl();
  const ownerState = _extends$4({}, props, ownerStateProp, muiFormControl, {
    disableUnderline,
    color: (muiFormControl == null ? void 0 : muiFormControl.color) || "primary"
  });
  const classes2 = useUtilityClasses$2(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$4({
    slots: {
      root: PickersInputRoot
    }
  }, other, {
    label,
    classes: classes2,
    ref
  }));
}, "PickersInput2"));
PickersInput.muiName = "Input";
const _excluded$3 = ["onFocus", "onBlur", "className", "color", "disabled", "error", "variant", "required", "InputProps", "inputProps", "inputRef", "sectionListRef", "elements", "areAllSectionsEmpty", "onClick", "onKeyDown", "onKeyUp", "onPaste", "onInput", "endAdornment", "startAdornment", "tabIndex", "contentEditable", "focused", "value", "onChange", "fullWidth", "id", "name", "helperText", "FormHelperTextProps", "label", "InputLabelProps"];
const VARIANT_COMPONENT = {
  standard: PickersInput,
  filled: PickersFilledInput,
  outlined: PickersOutlinedInput
};
const PickersTextFieldRoot = styled(FormControl, {
  name: "MuiPickersTextField",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const useUtilityClasses$1 = /* @__PURE__ */ __name((ownerState) => {
  const {
    focused,
    disabled,
    classes: classes2,
    required
  } = ownerState;
  const slots = {
    root: ["root", focused && !disabled && "focused", disabled && "disabled", required && "required"]
  };
  return composeClasses(slots, getPickersTextFieldUtilityClass, classes2);
}, "useUtilityClasses$1");
const PickersTextField = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function PickersTextField2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersTextField"
  });
  const {
    // Props used by FormControl
    onFocus,
    onBlur,
    className,
    color: color2 = "primary",
    disabled = false,
    error = false,
    variant = "outlined",
    required = false,
    // Props used by PickersInput
    InputProps,
    inputProps,
    inputRef,
    sectionListRef,
    elements,
    areAllSectionsEmpty,
    onClick,
    onKeyDown,
    onKeyUp,
    onPaste,
    onInput,
    endAdornment,
    startAdornment,
    tabIndex,
    contentEditable,
    focused,
    value,
    onChange,
    fullWidth,
    id: idProp,
    name,
    // Props used by FormHelperText
    helperText,
    FormHelperTextProps,
    // Props used by InputLabel
    label,
    InputLabelProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$3);
  const rootRef = reactExports.useRef(null);
  const handleRootRef = useForkRef(ref, rootRef);
  const id2 = useId(idProp);
  const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
  const inputLabelId = label && id2 ? `${id2}-label` : void 0;
  const ownerState = _extends$4({}, props, {
    color: color2,
    disabled,
    error,
    focused,
    required,
    variant
  });
  const classes2 = useUtilityClasses$1(ownerState);
  const PickersInputComponent = VARIANT_COMPONENT[variant];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersTextFieldRoot, _extends$4({
    className: clsx(classes2.root, className),
    ref: handleRootRef,
    focused,
    onFocus,
    onBlur,
    disabled,
    variant,
    error,
    color: color2,
    fullWidth,
    required,
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, _extends$4({
      htmlFor: id2,
      id: inputLabelId
    }, InputLabelProps, {
      children: label
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputComponent, _extends$4({
      elements,
      areAllSectionsEmpty,
      onClick,
      onKeyDown,
      onKeyUp,
      onInput,
      onPaste,
      endAdornment,
      startAdornment,
      tabIndex,
      contentEditable,
      value,
      onChange,
      id: id2,
      fullWidth,
      inputProps,
      inputRef,
      sectionListRef,
      label,
      name,
      role: "group",
      "aria-labelledby": inputLabelId
    }, InputProps)), helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText, _extends$4({
      id: helperTextId
    }, FormHelperTextProps, {
      children: helperText
    }))]
  }));
}, "PickersTextField2"));
const _excluded$2 = ["enableAccessibleFieldDOMStructure"], _excluded2 = ["InputProps", "readOnly"], _excluded3 = ["onPaste", "onKeyDown", "inputMode", "readOnly", "InputProps", "inputProps", "inputRef"];
const convertFieldResponseIntoMuiTextFieldProps = /* @__PURE__ */ __name((_ref) => {
  let {
    enableAccessibleFieldDOMStructure
  } = _ref, fieldResponse = _objectWithoutPropertiesLoose$1(_ref, _excluded$2);
  if (enableAccessibleFieldDOMStructure) {
    const {
      InputProps: InputProps2,
      readOnly: readOnly2
    } = fieldResponse, other2 = _objectWithoutPropertiesLoose$1(fieldResponse, _excluded2);
    return _extends$4({}, other2, {
      InputProps: _extends$4({}, InputProps2 ?? {}, {
        readOnly: readOnly2
      })
    });
  }
  const {
    onPaste,
    onKeyDown,
    inputMode,
    readOnly,
    InputProps,
    inputProps,
    inputRef
  } = fieldResponse, other = _objectWithoutPropertiesLoose$1(fieldResponse, _excluded3);
  return _extends$4({}, other, {
    InputProps: _extends$4({}, InputProps ?? {}, {
      readOnly
    }),
    inputProps: _extends$4({}, inputProps ?? {}, {
      inputMode,
      onPaste,
      onKeyDown,
      ref: inputRef
    })
  });
}, "convertFieldResponseIntoMuiTextFieldProps");
const _excluded$1 = ["slots", "slotProps", "InputProps", "inputProps"];
const DateField = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function DateField2(inProps, inRef) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiDateField"
  });
  const {
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose$1(themeProps, _excluded$1);
  const ownerState = themeProps;
  const TextField$1 = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField);
  const textFieldProps = useSlotProps$1({
    elementType: TextField$1,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    externalForwardedProps: other,
    additionalProps: {
      ref: inRef
    },
    ownerState
  });
  textFieldProps.inputProps = _extends$4({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends$4({}, InputProps, textFieldProps.InputProps);
  const fieldResponse = useDateField(textFieldProps);
  const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
  const processedFieldProps = useClearableField(_extends$4({}, convertedFieldResponse, {
    slots,
    slotProps
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, _extends$4({}, processedFieldProps));
}, "DateField2"));
const getChildTypeFromChildName = /* @__PURE__ */ __name((childName) => {
  if (childName.match(/^([A-Za-z]+)Range(Calendar|Clock)$/)) {
    return "multi-panel-UI-view";
  }
  if (childName.match(/^([A-Za-z]*)(DigitalClock)$/)) {
    return "Tall-UI-view";
  }
  if (childName.match(/^Static([A-Za-z]+)/) || childName.match(/^([A-Za-z]+)(Calendar|Clock)$/)) {
    return "UI-view";
  }
  if (childName.match(/^MultiInput([A-Za-z]+)RangeField$/) || childName.match(/^([A-Za-z]+)RangePicker$/)) {
    return "multi-input-range-field";
  }
  if (childName.match(/^SingleInput([A-Za-z]+)RangeField$/)) {
    return "single-input-range-field";
  }
  return "single-input-field";
}, "getChildTypeFromChildName");
const getSupportedSectionFromChildName = /* @__PURE__ */ __name((childName) => {
  if (childName.includes("DateTime")) {
    return "date-time";
  }
  if (childName.includes("Date")) {
    return "date";
  }
  return "time";
}, "getSupportedSectionFromChildName");
const isDemoItem = /* @__PURE__ */ __name((child) => {
  if (/* @__PURE__ */ reactExports.isValidElement(child) && typeof child.type !== "string") {
    return child.type.displayName === "DemoItem";
  }
  return false;
}, "isDemoItem");
function DemoContainer(props) {
  const {
    children,
    components,
    sx: sxProp
  } = props;
  const childrenTypes = /* @__PURE__ */ new Set();
  const childrenSupportedSections = /* @__PURE__ */ new Set();
  components.forEach((childName) => {
    childrenTypes.add(getChildTypeFromChildName(childName));
    childrenSupportedSections.add(getSupportedSectionFromChildName(childName));
  });
  const getSpacing = /* @__PURE__ */ __name((direction2) => {
    if (direction2 === "row") {
      return childrenTypes.has("UI-view") || childrenTypes.has("Tall-UI-view") ? 3 : 2;
    }
    return childrenTypes.has("UI-view") ? 4 : 3;
  }, "getSpacing");
  let direction;
  let spacing;
  let extraSx = {};
  let demoItemSx = {};
  const sx = _extends$4({
    overflow: "auto",
    // Add padding as overflow can hide the outline text field label.
    pt: 1
  }, sxProp);
  if (components.length > 2 || childrenTypes.has("multi-input-range-field") || childrenTypes.has("single-input-range-field") || childrenTypes.has("multi-panel-UI-view") || childrenTypes.has("UI-view") || childrenSupportedSections.has("date-time")) {
    direction = "column";
    spacing = getSpacing("column");
  } else {
    direction = {
      xs: "column",
      lg: "row"
    };
    spacing = {
      xs: getSpacing("column"),
      lg: getSpacing("row")
    };
  }
  if (childrenTypes.has("UI-view"))
    ;
  else if (childrenTypes.has("single-input-range-field")) {
    if (!childrenSupportedSections.has("date-time")) {
      extraSx = {
        [`& > .${textFieldClasses.root}, & > .${pickersTextFieldClasses.root}`]: {
          minWidth: 300
        }
      };
    } else {
      extraSx = {
        [`& > .${textFieldClasses.root}, & > .${pickersTextFieldClasses.root}`]: {
          minWidth: {
            xs: 300,
            // If demo also contains MultiInputDateTimeRangeField, increase width to avoid cutting off the value.
            md: childrenTypes.has("multi-input-range-field") ? 460 : 400
          }
        }
      };
    }
  } else if (childrenSupportedSections.has("date-time")) {
    extraSx = {
      [`& > .${textFieldClasses.root}, & > .${pickersTextFieldClasses.root}`]: {
        minWidth: 270
      }
    };
    if (childrenTypes.has("multi-input-range-field")) {
      demoItemSx = {
        [`& > .${stackClasses.root} > .${textFieldClasses.root}, & > .${stackClasses.root} > .${pickersTextFieldClasses.root}`]: {
          minWidth: 210
        }
      };
    }
  } else {
    extraSx = {
      [`& > .${textFieldClasses.root}, & > .${pickersTextFieldClasses.root}`]: {
        minWidth: 200
      }
    };
  }
  const finalSx = _extends$4({}, sx, extraSx);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, {
    direction,
    spacing,
    sx: finalSx,
    children: reactExports.Children.map(children, (child) => {
      if (/* @__PURE__ */ reactExports.isValidElement(child) && isDemoItem(child)) {
        return /* @__PURE__ */ reactExports.cloneElement(child, {
          sx: _extends$4({}, extraSx, demoItemSx)
        });
      }
      return child;
    })
  });
}
__name(DemoContainer, "DemoContainer");
var ArrowCircleRight = {};
var _interopRequireDefault$n = interopRequireDefaultExports;
Object.defineProperty(ArrowCircleRight, "__esModule", {
  value: true
});
var default_1$i = ArrowCircleRight.default = void 0;
var _createSvgIcon$i = _interopRequireDefault$n(requireCreateSvgIcon());
var _jsxRuntime$i = jsxRuntimeExports;
default_1$i = ArrowCircleRight.default = (0, _createSvgIcon$i.default)(/* @__PURE__ */ (0, _jsxRuntime$i.jsx)("path", {
  d: "M22 12c0-5.52-4.48-10-10-10S2 6.48 2 12s4.48 10 10 10 10-4.48 10-10m-10 1H8v-2h4V8l4 4-4 4z"
}), "ArrowCircleRight");
var AddCircle = {};
var _interopRequireDefault$m = interopRequireDefaultExports;
Object.defineProperty(AddCircle, "__esModule", {
  value: true
});
var default_1$h = AddCircle.default = void 0;
var _createSvgIcon$h = _interopRequireDefault$m(requireCreateSvgIcon());
var _jsxRuntime$h = jsxRuntimeExports;
default_1$h = AddCircle.default = (0, _createSvgIcon$h.default)(/* @__PURE__ */ (0, _jsxRuntime$h.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m5 11h-4v4h-2v-4H7v-2h4V7h2v4h4z"
}), "AddCircle");
var ptBr = { exports: {} };
(function(module, exports) {
  !function(e2, o) {
    module.exports = o(dayjs_minExports);
  }(commonjsGlobal, function(e2) {
    function o(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    __name(o, "o");
    var a = o(e2), s = { name: "pt-br", weekdays: "domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado".split("_"), weekdaysShort: "dom_seg_ter_qua_qui_sex_sb".split("_"), weekdaysMin: "Do_2_3_4_5_6_S".split("_"), months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), ordinal: function(e3) {
      return e3 + "";
    }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY [s] HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY [s] HH:mm" }, relativeTime: { future: "em %s", past: "h %s", s: "poucos segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um ms", MM: "%d meses", y: "um ano", yy: "%d anos" } };
    return a.default.locale(s, null, true), s;
  });
})(ptBr);
var Save = {};
var _interopRequireDefault$l = interopRequireDefaultExports;
Object.defineProperty(Save, "__esModule", {
  value: true
});
var default_1$g = Save.default = void 0;
var _createSvgIcon$g = _interopRequireDefault$l(requireCreateSvgIcon());
var _jsxRuntime$g = jsxRuntimeExports;
default_1$g = Save.default = (0, _createSvgIcon$g.default)(/* @__PURE__ */ (0, _jsxRuntime$g.jsx)("path", {
  d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3m3-10H5V5h10z"
}), "Save");
const MovimentationContext = reactExports.createContext({
  refreshMovimentation: false,
  editingMovementationObservation: [false],
  creatingMovementation: false,
  deletingMovementation: [false],
  acceptingMovimentation: void 0,
  toggleRefreshMovimentation: () => {
  },
  toggleCreatingMovementation: () => {
  },
  togglEditingMovementationObservation: () => {
  },
  toggleDeletingMovementation: () => {
  },
  toggleAcceptingMovimentation: () => {
  }
});
const MovimentationContextProvider = /* @__PURE__ */ __name(({
  children
}) => {
  const [refreshMovimentation, setRefreshMovimentation] = reactExports.useState(false);
  const [editingMovementationObservation, setEditingMovementationObservation] = reactExports.useState([false]);
  const [creatingMovementation, setCreatingMovementation] = reactExports.useState(false);
  const [deletingMovementation, setDeletingMovementation] = reactExports.useState([false]);
  const [acceptingMovimentation, setAcceptingMovimentation] = reactExports.useState(void 0);
  const toggleDeletingMovementation = /* @__PURE__ */ __name((movementation) => {
    setDeletingMovementation(movementation ? [true, movementation] : [false]);
  }, "toggleDeletingMovementation");
  const toggleCreatingMovementation = /* @__PURE__ */ __name(() => {
    setCreatingMovementation((prev2) => !prev2);
  }, "toggleCreatingMovementation");
  const togglEditingMovementationObservation = /* @__PURE__ */ __name((isEditing, movementation) => {
    setEditingMovementationObservation(
      isEditing ? [true, movementation] : [false]
    );
  }, "togglEditingMovementationObservation");
  const toggleRefreshMovimentation = /* @__PURE__ */ __name(() => {
    setRefreshMovimentation((prev2) => !prev2);
  }, "toggleRefreshMovimentation");
  const toggleAcceptingMovimentation = /* @__PURE__ */ __name((movementation) => {
    setAcceptingMovimentation(movementation);
  }, "toggleAcceptingMovimentation");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MovimentationContext.Provider,
    {
      value: {
        refreshMovimentation,
        deletingMovementation,
        creatingMovementation,
        editingMovementationObservation,
        acceptingMovimentation,
        toggleRefreshMovimentation,
        toggleDeletingMovementation,
        togglEditingMovementationObservation,
        toggleCreatingMovementation,
        toggleAcceptingMovimentation
      },
      children
    }
  );
}, "MovimentationContextProvider");
dayjs.locale("pt-br");
function CreateMovementation({
  handleSave,
  responsable
}) {
  const { id_patrimonio } = useParams();
  const {
    creatingPatrimonyInfo,
    toggleCreatingPatrimonyInfo,
    toggleRefreshPatrimonyInfo,
    changeCreatingPatrimonyInfo
  } = reactExports.useContext(PatrimonyInfoContext);
  const { user } = reactExports.useContext(userContext);
  const navigate = useNavigate();
  const {
    toggleRefreshMovimentation,
    toggleCreatingMovementation,
    creatingMovementation
  } = reactExports.useContext(MovimentationContext);
  const [projectOptions, setProjectOptions] = reactExports.useState([]);
  const [personOptions, setPersonOptions] = reactExports.useState();
  const [newMovementation, setNewMovementation] = reactExports.useState({
    id_movimentacao: 0,
    // Default value for number
    id_projeto: 0,
    id_patrimonio: 0,
    id_ultima_movimentacao: 0,
    // Default value for number
    data: "",
    // Default value for string
    id_responsavel: 0,
    // Default value for string
    numeroMovimentacao: 0,
    // Default value for number
    observacao: "",
    aceito: 0
  });
  const handleSaveMovementation = /* @__PURE__ */ __name(async () => {
    if (creatingPatrimonyInfo[0] && handleSave) {
      const insertIdPatrimony = await handleSave();
      if (insertIdPatrimony) {
        const insertIdMovementation = await createMovementation({
          ...newMovementation,
          ["id_patrimonio"]: insertIdPatrimony
        });
        if (insertIdMovementation) {
          navigate(`/patrimony/details/${insertIdPatrimony}`);
          toggleRefreshPatrimonyInfo();
          toggleCreatingPatrimonyInfo();
          return;
        }
      }
      return;
    }
    const response = await createMovementation({
      ...newMovementation,
      ["id_patrimonio"]: Number(id_patrimonio)
    });
    if ((response == null ? void 0 : response.status) === 200) {
      toggleRefreshPatrimonyInfo();
      toggleRefreshMovimentation();
      toggleCreatingMovementation();
      return;
    }
    console.log("response: ", response);
    alert("Houve um erro ao criar a movimentao: \n" + (response == null ? void 0 : response.data.message));
  }, "handleSaveMovementation");
  const handleOpen = /* @__PURE__ */ __name(() => {
    if (notAllowedToCreateMovementation()) {
      window.alert("Somente o resopnsvel pode movimentar!");
      return;
    }
    toggleCreatingMovementation();
  }, "handleOpen");
  const notAllowedToCreateMovementation = /* @__PURE__ */ __name(() => {
    return Number(responsable) !== Number(user == null ? void 0 : user.CODPESSOA) && !(user == null ? void 0 : user.PERM_ADMINISTRADOR);
  }, "notAllowedToCreateMovementation");
  const handleClose = /* @__PURE__ */ __name(() => {
    creatingPatrimonyInfo[0] ? changeCreatingPatrimonyInfo() : toggleCreatingMovementation();
  }, "handleClose");
  const renderProjectOptions = /* @__PURE__ */ __name(() => {
    const projectOptionsArray = [];
    projectOptions.forEach((project) => {
      projectOptionsArray.push({
        label: String(project.DESCRICAO),
        id: project.ID
      });
    });
    return projectOptionsArray;
  }, "renderProjectOptions");
  const renderPersonOptions = /* @__PURE__ */ __name(() => {
    const personOptionsArray = [];
    personOptions == null ? void 0 : personOptions.forEach((person) => {
      personOptionsArray.push({
        label: String(person.NOME),
        id: Number(person.CODPESSOA)
      });
    });
    return personOptionsArray;
  }, "renderPersonOptions");
  const handleSelectProject = /* @__PURE__ */ __name((_event, value, _reason, _details) => {
    if (value) {
      setNewMovementation({
        ...newMovementation,
        ["id_projeto"]: value == null ? void 0 : value.id
      });
    }
  }, "handleSelectProject");
  const handleSelectReponsable = /* @__PURE__ */ __name((_event, value, _reason, _details) => {
    if (value) {
      console.log({
        ...newMovementation,
        ["id_responsavel"]: value.id
      });
      setNewMovementation({
        ...newMovementation,
        ["id_responsavel"]: value.id
      });
    }
  }, "handleSelectReponsable");
  const handleChange = /* @__PURE__ */ __name((e2) => {
    const { id: id2, value } = e2.target;
    console.log({
      ...newMovementation,
      [id2]: value
    });
    setNewMovementation({
      ...newMovementation,
      [id2]: value
    });
  }, "handleChange");
  const getMovementationKeys = /* @__PURE__ */ __name(() => {
    return [
      { label: "Projeto", dataKey: "id_projeto" },
      { label: "Responsvel", dataKey: "id_responsavel" },
      { label: "Data da Movimentao", dataKey: "data" },
      { label: "Observao", dataKey: "observacao" }
    ];
  }, "getMovementationKeys");
  reactExports.useEffect(() => {
    async function setAutoCompleteOptions() {
      const projectData = await fetchAllProjects();
      if (projectData) {
        setProjectOptions(projectData);
      }
      const personData = await fetchPersons();
      if (personData) {
        setPersonOptions(personData);
      }
    }
    __name(setAutoCompleteOptions, "setAutoCompleteOptions");
    setAutoCompleteOptions();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        sx: { display: creatingPatrimonyInfo[0] ? "none" : "block" },
        onClick: handleOpen,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$h, { sx: { color: "#F7941E" } })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Modal$3,
      {
        open: creatingMovementation || creatingPatrimonyInfo[1] !== void 0,
        onClose: handleClose,
        "aria-labelledby": "modal-modal-title",
        "aria-describedby": "modal-modal-description",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            display: "flex",
            flexDirection: "column",
            gap: "1rem",
            sx: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              width: {
                xs: "85%",
                sm: "65%",
                md: "45%",
                lg: "25%",
                xl: "15%"
              },
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              flexShrink: 1,
              bgcolor: "background.paper",
              boxShadow: 24,
              p: 4
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "end", spacing: 2, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { id: "modal-modal-title", variant: "h6", component: "h2", children: "Nova Movimentao" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    onClick: handleClose,
                    sx: {
                      color: "red",
                      position: "absolute",
                      top: "10px",
                      right: "10px"
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {})
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
                getMovementationKeys().map(
                  (column2) => column2.dataKey === "id_projeto" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Autocomplete,
                    {
                      disablePortal: true,
                      id: "combo-box-demo",
                      options: renderProjectOptions(),
                      onChange: handleSelectProject,
                      renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { ...params, label: column2.label })
                    }
                  ) : column2.dataKey === "data" ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocalizationProvider, { dateAdapter: AdapterDayjs, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DemoContainer, { components: ["DateField"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DateField,
                    {
                      format: "DD/MM/YYYY",
                      disabled: true,
                      defaultValue: dayjs(/* @__PURE__ */ new Date()),
                      label: column2.label
                    }
                  ) }) }) : column2.dataKey === "id_responsavel" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Autocomplete,
                    {
                      disablePortal: true,
                      id: "combo-box-demo",
                      options: renderPersonOptions(),
                      onChange: handleSelectReponsable,
                      renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { ...params, label: column2.label })
                    }
                  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TextField,
                    {
                      onChange: handleChange,
                      id: column2.dataKey,
                      multiline: true,
                      placeholder: column2.label
                    }
                  )
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleSaveMovementation, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$g, {}) })
              ] })
            ]
          }
        )
      }
    )
  ] });
}
__name(CreateMovementation, "CreateMovementation");
const columns$3 = [
  {
    label: "Tipo",
    dataKey: "tipo",
    required: true
  },
  {
    label: "Data de Compra",
    dataKey: "data_compra",
    required: false
  },
  {
    label: "Valor de Compra",
    dataKey: "valor_compra",
    numeric: true,
    required: false
  },
  {
    label: "Nome",
    dataKey: "nome",
    required: true
  },
  {
    label: "Descrio",
    dataKey: "descricao",
    required: true
  },
  {
    label: "Nmero de Srie",
    dataKey: "nserie",
    numeric: false,
    required: false
  },
  {
    label: "Cdigo Patrimnio",
    dataKey: "pat_legado",
    required: false
  },
  {
    label: "Fabricante",
    dataKey: "fabricante",
    required: false
  }
];
function CreatePatrimonyInfoModal() {
  console.log("renderizou CreatePatrimonyInfoModal");
  const { creatingPatrimonyInfo, toggleCreatingPatrimonyInfo, changeCreatingPatrimonyInfo } = reactExports.useContext(PatrimonyInfoContext);
  const [patrimonyInfo, setPatrimonynInfo] = reactExports.useState({
    id_patrimonio: 0,
    tipo: 0,
    nome: "",
    data_compra: "",
    // This should be in ISO date string format, e.g., "2024-08-09"
    nserie: "",
    descricao: "",
    pat_legado: "",
    nome_tipo: "",
    ativo: 1,
    fabricante: "",
    valor_compra: 0
    // TODO: Add other fields as needed
  });
  const [typeOptions, setTypes] = reactExports.useState([]);
  const handleClose = /* @__PURE__ */ __name(() => toggleCreatingPatrimonyInfo(), "handleClose");
  const handleChange = /* @__PURE__ */ __name((e2, dataKey) => {
    const { value } = e2.target;
    console.log({
      ...patrimonyInfo,
      [dataKey]: value
    });
    setPatrimonynInfo({
      ...patrimonyInfo,
      [dataKey]: value
    });
  }, "handleChange");
  const handleSave = /* @__PURE__ */ __name(async () => {
    console.log("patrimonyInfo: ", patrimonyInfo);
    const insertId = await createPatrimony(patrimonyInfo);
    if (insertId) {
      return insertId;
    }
  }, "handleSave");
  const handleNext2 = /* @__PURE__ */ __name(async () => {
    const { data_compra, tipo } = patrimonyInfo;
    console.log("data_compra", data_compra);
    if (data_compra.length) {
      if (!data_compra || !dayjs(data_compra).isValid()) {
        alert("Por favor, insira uma data de compra vlida.");
        return;
      }
      if (!tipo) {
        alert("Por favor, selecione um tipo de patrimnio.");
        return;
      }
      if (dayjs(data_compra).isAfter(dayjs())) {
        alert("A data de compra no pode ser uma data futura.");
        return;
      }
    }
    changeCreatingPatrimonyInfo({
      ...patrimonyInfo
    });
  }, "handleNext");
  const handleChangeDate = /* @__PURE__ */ __name((day) => {
    console.log({
      ...patrimonyInfo,
      ["data_compra"]: day == null ? void 0 : day.toString()
    });
    if (day) {
      setPatrimonynInfo({
        ...patrimonyInfo,
        ["data_compra"]: day == null ? void 0 : day.toString()
      });
    }
  }, "handleChangeDate");
  const renderTypeOptions = /* @__PURE__ */ __name(() => {
    return typeOptions.map((type) => ({
      label: type.nome_tipo,
      id: type.id_tipo_patrimonio
    }));
  }, "renderTypeOptions");
  const handleSelectType = /* @__PURE__ */ __name((event, value) => {
    console.log(event);
    if (value) {
      console.log({
        ...patrimonyInfo,
        tipo: value.id
      });
      setPatrimonynInfo({
        ...patrimonyInfo,
        tipo: value.id
      });
    }
  }, "handleSelectType");
  const fetchTypeOptions = /* @__PURE__ */ __name(async () => {
    const types = await getTypesOfPatrimony();
    setTypes(types);
  }, "fetchTypeOptions");
  reactExports.useEffect(() => {
    fetchTypeOptions();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: creatingPatrimonyInfo[0],
      onClose: handleClose,
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: {
              xs: "90%",
              sm: "70%",
              md: "50%",
              lg: "30%",
              xl: "20%"
            },
            bgcolor: "background.paper",
            display: "flex",
            flexDirection: "column",
            gap: "1rem",
            alignItems: "center",
            flexSruink: 1,
            boxShadow: 24,
            p: 4
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CreateMovementation, { handleSave }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "end", spacing: 4, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Typography,
                {
                  id: "modal-modal-title",
                  variant: "h6",
                  component: "h2",
                  fontSize: "medium",
                  children: "Novo Patrimnio"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  onClick: toggleCreatingPatrimonyInfo,
                  sx: {
                    color: "red",
                    position: "absolute",
                    top: "10px",
                    right: "10px"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {})
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { onSubmit: handleNext2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "column", spacing: 1.6, children: columns$3.map(
                (column2) => column2.dataKey === "data_compra" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  LocalizationProvider,
                  {
                    dateAdapter: AdapterDayjs,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DemoContainer, { components: ["DateField"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DateField,
                      {
                        format: "DD/MM/YYYY",
                        onChange: (e2) => handleChangeDate(e2),
                        label: "Data de Compra"
                      }
                    ) })
                  },
                  column2.dataKey
                ) : column2.dataKey == "tipo" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Autocomplete,
                  {
                    disablePortal: true,
                    id: "combo-box-demo",
                    options: renderTypeOptions(),
                    onChange: handleSelectType,
                    renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { ...params, label: column2.label })
                  },
                  column2.dataKey
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField,
                  {
                    sx: {
                      width: "100%"
                    },
                    type: column2.numeric ? "number" : "text",
                    required: column2.required,
                    onChange: (e2) => handleChange(e2, column2.dataKey),
                    label: column2.label
                  },
                  column2.dataKey
                )
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "submit",
                  sx: { width: "1rem", marginX: "1rem", marginTop: "1rem" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$i, {})
                }
              )
            ] })
          ]
        }
      )
    }
  ) });
}
__name(CreatePatrimonyInfoModal, "CreatePatrimonyInfoModal");
var ArrowDropDownCircle = {};
var _interopRequireDefault$k = interopRequireDefaultExports;
Object.defineProperty(ArrowDropDownCircle, "__esModule", {
  value: true
});
var default_1$f = ArrowDropDownCircle.default = void 0;
var _createSvgIcon$f = _interopRequireDefault$k(requireCreateSvgIcon());
var _jsxRuntime$f = jsxRuntimeExports;
default_1$f = ArrowDropDownCircle.default = (0, _createSvgIcon$f.default)(/* @__PURE__ */ (0, _jsxRuntime$f.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 12-4-4h8z"
}), "ArrowDropDownCircle");
var Notifications = {};
var _interopRequireDefault$j = interopRequireDefaultExports;
Object.defineProperty(Notifications, "__esModule", {
  value: true
});
var default_1$e = Notifications.default = void 0;
var _createSvgIcon$e = _interopRequireDefault$j(requireCreateSvgIcon());
var _jsxRuntime$e = jsxRuntimeExports;
default_1$e = Notifications.default = (0, _createSvgIcon$e.default)(/* @__PURE__ */ (0, _jsxRuntime$e.jsx)("path", {
  d: "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2m6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1z"
}), "Notifications");
var GridView = {};
var _interopRequireDefault$i = interopRequireDefaultExports;
Object.defineProperty(GridView, "__esModule", {
  value: true
});
var default_1$d = GridView.default = void 0;
var _createSvgIcon$d = _interopRequireDefault$i(requireCreateSvgIcon());
var _jsxRuntime$d = jsxRuntimeExports;
default_1$d = GridView.default = (0, _createSvgIcon$d.default)(/* @__PURE__ */ (0, _jsxRuntime$d.jsx)("path", {
  fillRule: "evenodd",
  d: "M3 3v8h8V3zm6 6H5V5h4zm-6 4v8h8v-8zm6 6H5v-4h4zm4-16v8h8V3zm6 6h-4V5h4zm-6 4v8h8v-8zm6 6h-4v-4h4z"
}), "GridView");
var TableRows = {};
var _interopRequireDefault$h = interopRequireDefaultExports;
Object.defineProperty(TableRows, "__esModule", {
  value: true
});
var default_1$c = TableRows.default = void 0;
var _createSvgIcon$c = _interopRequireDefault$h(requireCreateSvgIcon());
var _jsxRuntime$c = jsxRuntimeExports;
default_1$c = TableRows.default = (0, _createSvgIcon$c.default)(/* @__PURE__ */ (0, _jsxRuntime$c.jsx)("path", {
  d: "M21 8H3V4h18zm0 2H3v4h18zm0 6H3v4h18z"
}), "TableRows");
const TableViewToggleButton = /* @__PURE__ */ __name(({
  isCardViewActive,
  setIsCardViewActive
}) => {
  const handleChangeView = /* @__PURE__ */ __name(() => {
    console.log({ isCardViewActive: !isCardViewActive });
    setIsCardViewActive(!isCardViewActive);
  }, "handleChangeView");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tooltip,
    {
      title: `Mudar para ${isCardViewActive ? "Tabela" : "Cards"}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          onClick: handleChangeView,
          sx: {
            ...buttonStylesMobile
          },
          children: isCardViewActive ? /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$d, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$c, {})
        }
      )
    }
  );
}, "TableViewToggleButton");
const PatrimonySearchAppBarButtons = React$1.memo(
  ({
    user,
    isMobile,
    actionsMenuOpen,
    actionsMenu,
    handleClickAction,
    handleCloseActions,
    handleOpenActionModal,
    filterMenuOpen,
    filterMenu,
    handleClickFilter,
    handleCloseFilter,
    handleSelectFilter,
    currentFilter,
    handleOpenChecklistTasks,
    notifications,
    setIsCardViewActive,
    isCardViewActive
  }) => {
    console.log("renderizou SerachAppBarButtons");
    const PatrimonyAppBarButtons = [
      {
        condition: user == null ? void 0 : user.PERM_ADMINISTRADOR,
        render: (index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              id: "basic-button",
              "aria-controls": actionsMenuOpen ? "basic-menu" : void 0,
              "aria-haspopup": "true",
              "aria-expanded": actionsMenuOpen ? "true" : void 0,
              onClick: handleClickAction,
              sx: isMobile ? { ...buttonStylesMobile } : { ...BaseButtonStyles },
              children: [
                !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { textTransform: "capitalize", children: "Aes" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$f, {})
              ]
            },
            index2
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Menu$1,
            {
              id: "basic-menu",
              anchorEl: actionsMenu,
              open: actionsMenuOpen,
              onClose: handleCloseActions,
              MenuListProps: { "aria-labelledby": "basic-button" },
              children: ["Inativar", "Ativar", "Excluir"].map((action) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                MenuItem,
                {
                  onClick: () => handleOpenActionModal(action),
                  children: action
                },
                action
              ))
            },
            index2 + 1
          )
        ] })
      },
      {
        render: (index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              id: "basic-button",
              "aria-controls": filterMenuOpen ? "basic-menu" : void 0,
              "aria-haspopup": "true",
              "aria-expanded": filterMenuOpen ? "true" : void 0,
              onClick: handleClickFilter,
              sx: isMobile ? { ...buttonStylesMobile } : { ...BaseButtonStyles },
              children: [
                !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { textTransform: "capitalize", children: "Filtros" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
              ]
            },
            index2
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Menu$1,
            {
              id: "basic-menu",
              anchorEl: filterMenu,
              open: filterMenuOpen,
              onClose: handleCloseFilter,
              MenuListProps: { "aria-labelledby": "basic-button" },
              children: ["Meus", "Todos"].map((filter3) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                MenuItem,
                {
                  onClick: () => handleSelectFilter(filter3),
                  sx: {
                    backgroundColor: currentFilter === filter3 ? "whitesmoke" : "white"
                  },
                  children: filter3
                },
                filter3
              ))
            }
          )
        ] })
      },
      {
        render: (index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            id: "basic-button",
            "aria-controls": filterMenuOpen ? "basic-menu" : void 0,
            "aria-haspopup": "true",
            "aria-expanded": filterMenuOpen ? "true" : void 0,
            onClick: handleOpenChecklistTasks,
            sx: isMobile ? { ...buttonStylesMobile } : { ...BaseButtonStyles },
            children: [
              !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { textTransform: "capitalize", children: "Checklists" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { badgeContent: notifications == null ? void 0 : notifications.length, color: "primary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$e, {}) })
            ]
          },
          index2
        )
      }
    ];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack,
      {
        className: "MenuList",
        flexWrap: "wrap",
        justifyContent: "start",
        direction: "row",
        alignItems: "center",
        gap: 2,
        padding: 0.5,
        children: [
          PatrimonyAppBarButtons.map(
            (buttonConfig, index2) => buttonConfig.condition !== void 0 ? buttonConfig.condition && buttonConfig.render(index2) : buttonConfig.render(index2)
          ),
          isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
            TableViewToggleButton,
            {
              setIsCardViewActive,
              isCardViewActive
            }
          )
        ]
      }
    );
  }
);
const SearchAppBar = React$1.memo(
  ({
    handleSearch,
    selectedItems,
    setSelectedItems,
    isCardViewActive,
    setIsCardViewActive
  }) => {
    console.log("renderizou SearchAppbar");
    const {
      toggleCreatingPatrimonyInfo,
      toggleRefreshPatrimonyInfo,
      setCurrentFilter,
      currentFilter
    } = reactExports.useContext(PatrimonyInfoContext);
    const navigate = useNavigate();
    const { toggleChecklistOpen } = reactExports.useContext(checklistContext);
    const { user } = reactExports.useContext(userContext);
    const [actionsMenu, setActionsMenu] = React$1.useState(
      null
    );
    const actionsMenuOpen = Boolean(actionsMenu);
    const [filterMenu, setFilterMenu] = React$1.useState(
      null
    );
    const filterMenuOpen = Boolean(filterMenu);
    const [notificationsMenu, setNotificationsMenu] = React$1.useState(null);
    const notificationsMenuOpen = Boolean(notificationsMenu);
    const [notifications, setNotifications] = reactExports.useState();
    const [openDeleteModal, setOpenDeleteModal] = React$1.useState(false);
    const [openInactivateModal, setOpenInactivateModal] = React$1.useState(false);
    const [openActivateModal, setOpenActivateModal] = React$1.useState(false);
    const [isMobile, setIsMobile] = React$1.useState(false);
    const handleOpenActivateModal = React$1.useCallback(
      () => setOpenActivateModal(true),
      []
    );
    const handleCloseActivateModal = React$1.useCallback(
      () => setOpenActivateModal(false),
      []
    );
    const handleOpenDeleteModal = React$1.useCallback(
      () => setOpenDeleteModal(true),
      []
    );
    const handleCloseDeleteModal = React$1.useCallback(
      () => setOpenDeleteModal(false),
      []
    );
    const handleOpenInactivateModal = React$1.useCallback(
      () => setOpenInactivateModal(true),
      []
    );
    const handleCloseInactivateModal = React$1.useCallback(
      () => setOpenInactivateModal(false),
      []
    );
    const handleClickAction = React$1.useCallback(
      (event) => {
        setActionsMenu(event.currentTarget);
      },
      []
    );
    const handleCloseActions = React$1.useCallback(
      () => setActionsMenu(null),
      []
    );
    const handleClickFilter = React$1.useCallback(
      (event) => {
        setFilterMenu(event.currentTarget);
      },
      []
    );
    const handleCloseFilter = React$1.useCallback(() => setFilterMenu(null), []);
    const handleCloseNotificationsMenu = React$1.useCallback(
      () => setNotificationsMenu(null),
      []
    );
    const handleOpenActionModal = React$1.useCallback(
      (action) => {
        if (action === "Excluir" && (selectedItems == null ? void 0 : selectedItems.length)) {
          handleOpenDeleteModal();
        } else if (action === "Inativar" && (selectedItems == null ? void 0 : selectedItems.length)) {
          handleOpenInactivateModal();
        } else if (action === "Ativar" && (selectedItems == null ? void 0 : selectedItems.length)) {
          handleOpenActivateModal();
        } else {
          alert("Selecione pelo menos um item");
        }
      },
      [
        selectedItems,
        handleOpenDeleteModal,
        handleOpenInactivateModal,
        handleOpenActivateModal
      ]
    );
    const handleSelectFilter = React$1.useCallback(
      async (filter3) => {
        handleCloseFilter();
        setCurrentFilter(filter3);
      },
      [handleCloseFilter, setCurrentFilter]
    );
    const handleDeletePatrimony = React$1.useCallback(async () => {
      if (selectedItems) {
        await deleteMultiplePatrimonies(selectedItems);
        setSelectedItems([]);
        toggleRefreshPatrimonyInfo();
        handleCloseDeleteModal();
        handleCloseActions();
      }
    }, [
      selectedItems,
      setSelectedItems,
      toggleRefreshPatrimonyInfo,
      handleCloseDeleteModal,
      handleCloseActions
    ]);
    const handleActivatePatrimony = React$1.useCallback(async () => {
      if (selectedItems) {
        const response = await updateMultiplePatrimonies(selectedItems, {
          active: true
        });
        if ((response == null ? void 0 : response.status) === 200) {
          setSelectedItems([]);
          toggleRefreshPatrimonyInfo();
          handleCloseActivateModal();
          handleCloseActions();
        }
      }
    }, [
      selectedItems,
      setSelectedItems,
      toggleRefreshPatrimonyInfo,
      handleCloseActivateModal,
      handleCloseActions
    ]);
    const handleInactivatePatrimony = React$1.useCallback(async () => {
      if (selectedItems) {
        const response = await updateMultiplePatrimonies(selectedItems);
        if ((response == null ? void 0 : response.status) === 200) {
          setSelectedItems([]);
          toggleRefreshPatrimonyInfo();
          handleCloseInactivateModal();
          handleCloseActions();
        }
      }
    }, [
      selectedItems,
      setSelectedItems,
      toggleRefreshPatrimonyInfo,
      handleCloseInactivateModal,
      handleCloseActions
    ]);
    const handleSelectNotification = React$1.useCallback(
      (checklist) => {
        toggleChecklistOpen(checklist);
        navigate(`checklist/${checklist.id_patrimonio}`);
      },
      [toggleChecklistOpen, navigate]
    );
    const getNotifications = React$1.useCallback(async () => {
      console.log("getNotifications");
      if (user) {
        const notifications2 = await getPatrimonyNotifications(user, "todos");
        setNotifications(notifications2);
      }
    }, [user]);
    const handleOpenChecklistTasks = React$1.useCallback(() => {
      navigate(`/tasks`);
    }, [navigate]);
    reactExports.useEffect(() => {
      setIsMobile(window.innerWidth <= 768);
      getNotifications();
    }, [user, getNotifications]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flexGrow: 1, width: "100%" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AppBar, { position: "static", sx: { ...basicAppbarStyles }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Toolbar, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CreatePatrimonyInfoModal, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Stack,
          {
            direction: "row",
            width: "100%",
            flexWrap: "wrap",
            justifyContent: "space-between",
            gap: 1,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Search, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIconWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$s, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  StyledInputBase,
                  {
                    placeholder: "Buscar...",
                    inputProps: { "aria-label": "search" },
                    onChange: handleSearch
                  }
                )
              ] }),
              user && notifications && /* @__PURE__ */ jsxRuntimeExports.jsx(
                PatrimonySearchAppBarButtons,
                {
                  setIsCardViewActive,
                  isCardViewActive,
                  user,
                  isMobile,
                  actionsMenuOpen,
                  actionsMenu,
                  handleClickAction,
                  handleCloseActions,
                  handleOpenActionModal,
                  filterMenuOpen,
                  filterMenu,
                  handleClickFilter,
                  handleCloseFilter,
                  handleSelectFilter,
                  currentFilter,
                  handleOpenChecklistTasks,
                  notifications
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", alignItems: "center", gap: 2, children: (user == null ? void 0 : user.PERM_CADASTRAR_PAT) && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Novo Patrimnio", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  onClick: toggleCreatingPatrimonyInfo,
                  sx: {
                    backgroundColor: "#F7941E",
                    color: "white",
                    "&:hover": { backgroundColor: "#f1b963" }
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$p, { sx: { color: "#2B3990" } })
                }
              ) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Menu$1,
                {
                  id: "basic-menu",
                  anchorEl: notificationsMenu,
                  open: notificationsMenuOpen,
                  onClose: handleCloseNotificationsMenu,
                  sx: {
                    marginTop: "0.4rem",
                    whiteSpace: "normal",
                    // Permite que o texto quebre
                    display: "block",
                    // Garante que o contedo fique em bloco no menu
                    width: "100%"
                    // Garante que o item ocupe toda a largura disponvel
                  },
                  MenuListProps: {
                    "aria-labelledby": "basic-button"
                  },
                  children: notifications && notifications.map((notification) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    MenuItem,
                    {
                      onClick: () => handleSelectNotification(notification),
                      sx: { overFlowX: "scroll" },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Typography,
                        {
                          fontSize: "small",
                          sx: {
                            maxWidth: "100%",
                            whiteSpace: "normal",
                            wordBreak: "break-word"
                          },
                          children: [
                            "Voc deve verificar ou realizar o checklist do patrimnio ",
                            notification.nome
                          ]
                        }
                      )
                    },
                    notification.id_checklist_movimentacao
                  ))
                }
              )
            ]
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal$3,
        {
          open: openDeleteModal,
          onClose: handleCloseDeleteModal,
          "aria-labelledby": "modal-modal-title",
          "aria-describedby": "modal-modal-description",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: style$a, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { id: "modal-modal-title", variant: "h6", component: "h2", children: "Tem certeza que deseja excluir os registros selecionados?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "center", spacing: 2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "primary",
                  sx: { borderColor: "blue", color: "blue" },
                  onClick: handleDeletePatrimony,
                  children: "Sim"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "error",
                  sx: { borderColor: "red", color: "red" },
                  onClick: handleCloseDeleteModal,
                  children: "No"
                }
              )
            ] })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal$3,
        {
          open: openInactivateModal,
          onClose: handleCloseInactivateModal,
          "aria-labelledby": "modal-modal-title",
          "aria-describedby": "modal-modal-description",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: style$a, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { id: "modal-modal-title", variant: "h6", component: "h2", children: "Tem certeza que deseja inativar os registros selecionados?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "center", spacing: 2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "primary",
                  sx: { borderColor: "blue", color: "blue" },
                  onClick: handleInactivatePatrimony,
                  children: "Sim"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "error",
                  sx: { borderColor: "red", color: "red" },
                  onClick: handleCloseInactivateModal,
                  children: "No"
                }
              )
            ] })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal$3,
        {
          open: openActivateModal,
          onClose: handleCloseActivateModal,
          "aria-labelledby": "modal-modal-title",
          "aria-describedby": "modal-modal-description",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: style$a, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { id: "modal-modal-title", variant: "h6", component: "h2", children: "Tem certeza que deseja ativar os registros selecionados?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "center", spacing: 2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "primary",
                  sx: { borderColor: "blue", color: "blue" },
                  onClick: handleActivatePatrimony,
                  children: "Sim"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "error",
                  sx: { borderColor: "red", color: "red" },
                  onClick: handleCloseActivateModal,
                  children: "No"
                }
              )
            ] })
          ] })
        }
      )
    ] });
  }
);
const style$a = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: 400,
  bgcolor: "background.paper",
  border: "2px solid #000",
  boxShadow: 24,
  p: 4
};
var Checklist = {};
var _interopRequireDefault$g = interopRequireDefaultExports;
Object.defineProperty(Checklist, "__esModule", {
  value: true
});
var default_1$b = Checklist.default = void 0;
var _createSvgIcon$b = _interopRequireDefault$g(requireCreateSvgIcon());
var _jsxRuntime$b = jsxRuntimeExports;
default_1$b = Checklist.default = (0, _createSvgIcon$b.default)(/* @__PURE__ */ (0, _jsxRuntime$b.jsx)("path", {
  d: "M22 7h-9v2h9zm0 8h-9v2h9zM5.54 11 2 7.46l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41zm0 8L2 15.46l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41z"
}), "Checklist");
var safeIsNaN = Number.isNaN || /* @__PURE__ */ __name(function ponyfill(value) {
  return typeof value === "number" && value !== value;
}, "ponyfill");
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
__name(isEqual, "isEqual");
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
__name(areInputsEqual, "areInputsEqual");
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      newArgs[_i2] = arguments[_i2];
    }
    if (calledOnce && lastThis === this && isEqual2(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  __name(memoized, "memoized");
  return memoized;
}
__name(memoizeOne, "memoizeOne");
var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
var now$1 = hasNativePerformanceNow ? function() {
  return performance.now();
} : function() {
  return Date.now();
};
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
__name(cancelTimeout, "cancelTimeout");
function requestTimeout(callback, delay2) {
  var start2 = now$1();
  function tick() {
    if (now$1() - start2 >= delay2) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }
  __name(tick, "tick");
  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}
__name(requestTimeout, "requestTimeout");
var size = -1;
function getScrollbarSize(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (size === -1 || recalculate) {
    var div = document.createElement("div");
    var style2 = div.style;
    style2.width = "50px";
    style2.height = "50px";
    style2.overflow = "scroll";
    document.body.appendChild(div);
    size = div.offsetWidth - div.clientWidth;
    document.body.removeChild(div);
  }
  return size;
}
__name(getScrollbarSize, "getScrollbarSize");
var cachedRTLResult = null;
function getRTLOffsetType(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (cachedRTLResult === null || recalculate) {
    var outerDiv = document.createElement("div");
    var outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    var innerDiv = document.createElement("div");
    var innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = "positive-descending";
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = "negative";
      } else {
        cachedRTLResult = "positive-ascending";
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
__name(getRTLOffsetType, "getRTLOffsetType");
var IS_SCROLLING_DEBOUNCE_INTERVAL = 150;
var defaultItemKey = /* @__PURE__ */ __name(function defaultItemKey2(_ref) {
  var columnIndex = _ref.columnIndex;
  _ref.data;
  var rowIndex = _ref.rowIndex;
  return rowIndex + ":" + columnIndex;
}, "defaultItemKey2");
function createGridComponent(_ref2) {
  var _class;
  var getColumnOffset3 = _ref2.getColumnOffset, getColumnStartIndexForOffset3 = _ref2.getColumnStartIndexForOffset, getColumnStopIndexForStartIndex3 = _ref2.getColumnStopIndexForStartIndex, getColumnWidth3 = _ref2.getColumnWidth, getEstimatedTotalHeight4 = _ref2.getEstimatedTotalHeight, getEstimatedTotalWidth4 = _ref2.getEstimatedTotalWidth, getOffsetForColumnAndAlignment3 = _ref2.getOffsetForColumnAndAlignment, getOffsetForRowAndAlignment3 = _ref2.getOffsetForRowAndAlignment, getRowHeight3 = _ref2.getRowHeight, getRowOffset3 = _ref2.getRowOffset, getRowStartIndexForOffset3 = _ref2.getRowStartIndexForOffset, getRowStopIndexForStartIndex3 = _ref2.getRowStopIndexForStartIndex, initInstanceProps5 = _ref2.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange, validateProps5 = _ref2.validateProps;
  return _class = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(Grid2, _PureComponent);
    function Grid2(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps5(_this.props, _assertThisInitialized$4(_this));
      _this._resetIsScrollingTimeoutId = null;
      _this._outerRef = void 0;
      _this.state = {
        instance: _assertThisInitialized$4(_this),
        isScrolling: false,
        horizontalScrollDirection: "forward",
        scrollLeft: typeof _this.props.initialScrollLeft === "number" ? _this.props.initialScrollLeft : 0,
        scrollTop: typeof _this.props.initialScrollTop === "number" ? _this.props.initialScrollTop : 0,
        scrollUpdateWasRequested: false,
        verticalScrollDirection: "forward"
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = memoizeOne(function(overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {
        return _this.props.onItemsRendered({
          overscanColumnStartIndex,
          overscanColumnStopIndex,
          overscanRowStartIndex,
          overscanRowStopIndex,
          visibleColumnStartIndex,
          visibleColumnStopIndex,
          visibleRowStartIndex,
          visibleRowStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = memoizeOne(function(scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          horizontalScrollDirection,
          scrollLeft,
          scrollTop,
          verticalScrollDirection,
          scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;
      _this._getItemStyle = function(rowIndex, columnIndex) {
        var _this$props = _this.props, columnWidth = _this$props.columnWidth, direction = _this$props.direction, rowHeight = _this$props.rowHeight;
        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);
        var key = rowIndex + ":" + columnIndex;
        var style2;
        if (itemStyleCache.hasOwnProperty(key)) {
          style2 = itemStyleCache[key];
        } else {
          var _offset = getColumnOffset3(_this.props, columnIndex, _this._instanceProps);
          var isRtl = direction === "rtl";
          itemStyleCache[key] = style2 = {
            position: "absolute",
            left: isRtl ? void 0 : _offset,
            right: isRtl ? _offset : void 0,
            top: getRowOffset3(_this.props, rowIndex, _this._instanceProps),
            height: getRowHeight3(_this.props, rowIndex, _this._instanceProps),
            width: getColumnWidth3(_this.props, columnIndex, _this._instanceProps)
          };
        }
        return style2;
      };
      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = memoizeOne(function(_2, __, ___) {
        return {};
      });
      _this._onScroll = function(event) {
        var _event$currentTarget = event.currentTarget, clientHeight = _event$currentTarget.clientHeight, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollTop = _event$currentTarget.scrollTop, scrollHeight = _event$currentTarget.scrollHeight, scrollWidth = _event$currentTarget.scrollWidth;
        _this.setState(function(prevState) {
          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {
            return null;
          }
          var direction = _this.props.direction;
          var calculatedScrollLeft = scrollLeft;
          if (direction === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                calculatedScrollLeft = -scrollLeft;
                break;
              case "positive-descending":
                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          }
          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));
          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? "forward" : "backward",
            scrollLeft: calculatedScrollLeft,
            scrollTop: calculatedScrollTop,
            verticalScrollDirection: prevState.scrollTop < scrollTop ? "forward" : "backward",
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._outerRefSetter = function(ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;
        if (typeof outerRef === "function") {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
          outerRef.current = ref;
        }
      };
      _this._resetIsScrollingDebounced = function() {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }
        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);
      };
      _this._resetIsScrolling = function() {
        _this._resetIsScrollingTimeoutId = null;
        _this.setState({
          isScrolling: false
        }, function() {
          _this._getItemStyleCache(-1);
        });
      };
      return _this;
    }
    __name(Grid2, "Grid");
    Grid2.getDerivedStateFromProps = /* @__PURE__ */ __name(function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps(nextProps, prevState);
      validateProps5(nextProps);
      return null;
    }, "getDerivedStateFromProps");
    var _proto = Grid2.prototype;
    _proto.scrollTo = /* @__PURE__ */ __name(function scrollTo(_ref3) {
      var scrollLeft = _ref3.scrollLeft, scrollTop = _ref3.scrollTop;
      if (scrollLeft !== void 0) {
        scrollLeft = Math.max(0, scrollLeft);
      }
      if (scrollTop !== void 0) {
        scrollTop = Math.max(0, scrollTop);
      }
      this.setState(function(prevState) {
        if (scrollLeft === void 0) {
          scrollLeft = prevState.scrollLeft;
        }
        if (scrollTop === void 0) {
          scrollTop = prevState.scrollTop;
        }
        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {
          return null;
        }
        return {
          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? "forward" : "backward",
          scrollLeft,
          scrollTop,
          scrollUpdateWasRequested: true,
          verticalScrollDirection: prevState.scrollTop < scrollTop ? "forward" : "backward"
        };
      }, this._resetIsScrollingDebounced);
    }, "scrollTo");
    _proto.scrollToItem = /* @__PURE__ */ __name(function scrollToItem(_ref4) {
      var _ref4$align = _ref4.align, align = _ref4$align === void 0 ? "auto" : _ref4$align, columnIndex = _ref4.columnIndex, rowIndex = _ref4.rowIndex;
      var _this$props2 = this.props, columnCount = _this$props2.columnCount, height2 = _this$props2.height, rowCount = _this$props2.rowCount, width2 = _this$props2.width;
      var _this$state = this.state, scrollLeft = _this$state.scrollLeft, scrollTop = _this$state.scrollTop;
      var scrollbarSize = getScrollbarSize();
      if (columnIndex !== void 0) {
        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));
      }
      if (rowIndex !== void 0) {
        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));
      }
      var estimatedTotalHeight = getEstimatedTotalHeight4(this.props, this._instanceProps);
      var estimatedTotalWidth = getEstimatedTotalWidth4(this.props, this._instanceProps);
      var horizontalScrollbarSize = estimatedTotalWidth > width2 ? scrollbarSize : 0;
      var verticalScrollbarSize = estimatedTotalHeight > height2 ? scrollbarSize : 0;
      this.scrollTo({
        scrollLeft: columnIndex !== void 0 ? getOffsetForColumnAndAlignment3(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,
        scrollTop: rowIndex !== void 0 ? getOffsetForRowAndAlignment3(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop
      });
    }, "scrollToItem");
    _proto.componentDidMount = /* @__PURE__ */ __name(function componentDidMount() {
      var _this$props3 = this.props, initialScrollLeft = _this$props3.initialScrollLeft, initialScrollTop = _this$props3.initialScrollTop;
      if (this._outerRef != null) {
        var outerRef = this._outerRef;
        if (typeof initialScrollLeft === "number") {
          outerRef.scrollLeft = initialScrollLeft;
        }
        if (typeof initialScrollTop === "number") {
          outerRef.scrollTop = initialScrollTop;
        }
      }
      this._callPropsCallbacks();
    }, "componentDidMount");
    _proto.componentDidUpdate = /* @__PURE__ */ __name(function componentDidUpdate() {
      var direction = this.props.direction;
      var _this$state2 = this.state, scrollLeft = _this$state2.scrollLeft, scrollTop = _this$state2.scrollTop, scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction === "rtl") {
          switch (getRTLOffsetType()) {
            case "negative":
              outerRef.scrollLeft = -scrollLeft;
              break;
            case "positive-ascending":
              outerRef.scrollLeft = scrollLeft;
              break;
            default:
              var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;
              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;
              break;
          }
        } else {
          outerRef.scrollLeft = Math.max(0, scrollLeft);
        }
        outerRef.scrollTop = Math.max(0, scrollTop);
      }
      this._callPropsCallbacks();
    }, "componentDidUpdate");
    _proto.componentWillUnmount = /* @__PURE__ */ __name(function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    }, "componentWillUnmount");
    _proto.render = /* @__PURE__ */ __name(function render() {
      var _this$props4 = this.props, children = _this$props4.children, className = _this$props4.className, columnCount = _this$props4.columnCount, direction = _this$props4.direction, height2 = _this$props4.height, innerRef = _this$props4.innerRef, innerElementType = _this$props4.innerElementType, innerTagName = _this$props4.innerTagName, itemData = _this$props4.itemData, _this$props4$itemKey = _this$props4.itemKey, itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey, outerElementType = _this$props4.outerElementType, outerTagName = _this$props4.outerTagName, rowCount = _this$props4.rowCount, style2 = _this$props4.style, useIsScrolling = _this$props4.useIsScrolling, width2 = _this$props4.width;
      var isScrolling = this.state.isScrolling;
      var _this$_getHorizontalR = this._getHorizontalRangeToRender(), columnStartIndex = _this$_getHorizontalR[0], columnStopIndex = _this$_getHorizontalR[1];
      var _this$_getVerticalRan = this._getVerticalRangeToRender(), rowStartIndex = _this$_getVerticalRan[0], rowStopIndex = _this$_getVerticalRan[1];
      var items = [];
      if (columnCount > 0 && rowCount) {
        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {
          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {
            items.push(reactExports.createElement(children, {
              columnIndex: _columnIndex,
              data: itemData,
              isScrolling: useIsScrolling ? isScrolling : void 0,
              key: itemKey({
                columnIndex: _columnIndex,
                data: itemData,
                rowIndex: _rowIndex
              }),
              rowIndex: _rowIndex,
              style: this._getItemStyle(_rowIndex, _columnIndex)
            }));
          }
        }
      }
      var estimatedTotalHeight = getEstimatedTotalHeight4(this.props, this._instanceProps);
      var estimatedTotalWidth = getEstimatedTotalWidth4(this.props, this._instanceProps);
      return reactExports.createElement(outerElementType || outerTagName || "div", {
        className,
        onScroll: this._onScroll,
        ref: this._outerRefSetter,
        style: _extends$4({
          position: "relative",
          height: height2,
          width: width2,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction
        }, style2)
      }, reactExports.createElement(innerElementType || innerTagName || "div", {
        children: items,
        ref: innerRef,
        style: {
          height: estimatedTotalHeight,
          pointerEvents: isScrolling ? "none" : void 0,
          width: estimatedTotalWidth
        }
      }));
    }, "render");
    _proto._callPropsCallbacks = /* @__PURE__ */ __name(function _callPropsCallbacks() {
      var _this$props5 = this.props, columnCount = _this$props5.columnCount, onItemsRendered = _this$props5.onItemsRendered, onScroll = _this$props5.onScroll, rowCount = _this$props5.rowCount;
      if (typeof onItemsRendered === "function") {
        if (columnCount > 0 && rowCount > 0) {
          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(), _overscanColumnStartIndex = _this$_getHorizontalR2[0], _overscanColumnStopIndex = _this$_getHorizontalR2[1], _visibleColumnStartIndex = _this$_getHorizontalR2[2], _visibleColumnStopIndex = _this$_getHorizontalR2[3];
          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(), _overscanRowStartIndex = _this$_getVerticalRan2[0], _overscanRowStopIndex = _this$_getVerticalRan2[1], _visibleRowStartIndex = _this$_getVerticalRan2[2], _visibleRowStopIndex = _this$_getVerticalRan2[3];
          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);
        }
      }
      if (typeof onScroll === "function") {
        var _this$state3 = this.state, _horizontalScrollDirection = _this$state3.horizontalScrollDirection, _scrollLeft = _this$state3.scrollLeft, _scrollTop = _this$state3.scrollTop, _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested, _verticalScrollDirection = _this$state3.verticalScrollDirection;
        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);
      }
    }, "_callPropsCallbacks");
    _proto._getHorizontalRangeToRender = /* @__PURE__ */ __name(function _getHorizontalRangeToRender() {
      var _this$props6 = this.props, columnCount = _this$props6.columnCount, overscanColumnCount = _this$props6.overscanColumnCount, overscanColumnsCount = _this$props6.overscanColumnsCount, overscanCount = _this$props6.overscanCount, rowCount = _this$props6.rowCount;
      var _this$state4 = this.state, horizontalScrollDirection = _this$state4.horizontalScrollDirection, isScrolling = _this$state4.isScrolling, scrollLeft = _this$state4.scrollLeft;
      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;
      if (columnCount === 0 || rowCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getColumnStartIndexForOffset3(this.props, scrollLeft, this._instanceProps);
      var stopIndex = getColumnStopIndexForStartIndex3(this.props, startIndex, scrollLeft, this._instanceProps);
      var overscanBackward = !isScrolling || horizontalScrollDirection === "backward" ? Math.max(1, overscanCountResolved) : 1;
      var overscanForward = !isScrolling || horizontalScrollDirection === "forward" ? Math.max(1, overscanCountResolved) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    }, "_getHorizontalRangeToRender");
    _proto._getVerticalRangeToRender = /* @__PURE__ */ __name(function _getVerticalRangeToRender() {
      var _this$props7 = this.props, columnCount = _this$props7.columnCount, overscanCount = _this$props7.overscanCount, overscanRowCount = _this$props7.overscanRowCount, overscanRowsCount = _this$props7.overscanRowsCount, rowCount = _this$props7.rowCount;
      var _this$state5 = this.state, isScrolling = _this$state5.isScrolling, verticalScrollDirection = _this$state5.verticalScrollDirection, scrollTop = _this$state5.scrollTop;
      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;
      if (columnCount === 0 || rowCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getRowStartIndexForOffset3(this.props, scrollTop, this._instanceProps);
      var stopIndex = getRowStopIndexForStartIndex3(this.props, startIndex, scrollTop, this._instanceProps);
      var overscanBackward = !isScrolling || verticalScrollDirection === "backward" ? Math.max(1, overscanCountResolved) : 1;
      var overscanForward = !isScrolling || verticalScrollDirection === "forward" ? Math.max(1, overscanCountResolved) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    }, "_getVerticalRangeToRender");
    return Grid2;
  }(reactExports.PureComponent), _class.defaultProps = {
    direction: "ltr",
    itemData: void 0,
    useIsScrolling: false
  }, _class;
}
__name(createGridComponent, "createGridComponent");
var validateSharedProps = /* @__PURE__ */ __name(function validateSharedProps2(_ref5, _ref6) {
  _ref5.children;
  _ref5.direction;
  _ref5.height;
  _ref5.innerTagName;
  _ref5.outerTagName;
  _ref5.overscanColumnsCount;
  _ref5.overscanCount;
  _ref5.overscanRowsCount;
  _ref5.width;
  _ref6.instance;
}, "validateSharedProps2");
var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
var defaultItemKey$1 = /* @__PURE__ */ __name(function defaultItemKey3(index2, data) {
  return index2;
}, "defaultItemKey3");
function createListComponent(_ref) {
  var _class;
  var getItemOffset3 = _ref.getItemOffset, getEstimatedTotalSize4 = _ref.getEstimatedTotalSize, getItemSize3 = _ref.getItemSize, getOffsetForIndexAndAlignment5 = _ref.getOffsetForIndexAndAlignment, getStartIndexForOffset3 = _ref.getStartIndexForOffset, getStopIndexForStartIndex3 = _ref.getStopIndexForStartIndex, initInstanceProps5 = _ref.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange, validateProps5 = _ref.validateProps;
  return _class = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(List3, _PureComponent);
    function List3(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps5(_this.props, _assertThisInitialized$4(_this));
      _this._outerRef = void 0;
      _this._resetIsScrollingTimeoutId = null;
      _this.state = {
        instance: _assertThisInitialized$4(_this),
        isScrolling: false,
        scrollDirection: "forward",
        scrollOffset: typeof _this.props.initialScrollOffset === "number" ? _this.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = memoizeOne(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
        return _this.props.onItemsRendered({
          overscanStartIndex,
          overscanStopIndex,
          visibleStartIndex,
          visibleStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = memoizeOne(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          scrollDirection,
          scrollOffset,
          scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;
      _this._getItemStyle = function(index2) {
        var _this$props = _this.props, direction = _this$props.direction, itemSize = _this$props.itemSize, layout2 = _this$props.layout;
        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout2, shouldResetStyleCacheOnItemSizeChange && direction);
        var style2;
        if (itemStyleCache.hasOwnProperty(index2)) {
          style2 = itemStyleCache[index2];
        } else {
          var _offset = getItemOffset3(_this.props, index2, _this._instanceProps);
          var size2 = getItemSize3(_this.props, index2, _this._instanceProps);
          var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
          var isRtl = direction === "rtl";
          var offsetHorizontal = isHorizontal ? _offset : 0;
          itemStyleCache[index2] = style2 = {
            position: "absolute",
            left: isRtl ? void 0 : offsetHorizontal,
            right: isRtl ? offsetHorizontal : void 0,
            top: !isHorizontal ? _offset : 0,
            height: !isHorizontal ? size2 : "100%",
            width: isHorizontal ? size2 : "100%"
          };
        }
        return style2;
      };
      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = memoizeOne(function(_2, __, ___) {
        return {};
      });
      _this._onScrollHorizontal = function(event) {
        var _event$currentTarget = event.currentTarget, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollWidth = _event$currentTarget.scrollWidth;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollLeft) {
            return null;
          }
          var direction = _this.props.direction;
          var scrollOffset = scrollLeft;
          if (direction === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                scrollOffset = -scrollLeft;
                break;
              case "positive-descending":
                scrollOffset = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          }
          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._onScrollVertical = function(event) {
        var _event$currentTarget2 = event.currentTarget, clientHeight = _event$currentTarget2.clientHeight, scrollHeight = _event$currentTarget2.scrollHeight, scrollTop = _event$currentTarget2.scrollTop;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollTop) {
            return null;
          }
          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._outerRefSetter = function(ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;
        if (typeof outerRef === "function") {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
          outerRef.current = ref;
        }
      };
      _this._resetIsScrollingDebounced = function() {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }
        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
      };
      _this._resetIsScrolling = function() {
        _this._resetIsScrollingTimeoutId = null;
        _this.setState({
          isScrolling: false
        }, function() {
          _this._getItemStyleCache(-1, null);
        });
      };
      return _this;
    }
    __name(List3, "List");
    List3.getDerivedStateFromProps = /* @__PURE__ */ __name(function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps$1(nextProps, prevState);
      validateProps5(nextProps);
      return null;
    }, "getDerivedStateFromProps");
    var _proto = List3.prototype;
    _proto.scrollTo = /* @__PURE__ */ __name(function scrollTo(scrollOffset) {
      scrollOffset = Math.max(0, scrollOffset);
      this.setState(function(prevState) {
        if (prevState.scrollOffset === scrollOffset) {
          return null;
        }
        return {
          scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
          scrollOffset,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    }, "scrollTo");
    _proto.scrollToItem = /* @__PURE__ */ __name(function scrollToItem(index2, align) {
      if (align === void 0) {
        align = "auto";
      }
      var _this$props2 = this.props, itemCount = _this$props2.itemCount, layout2 = _this$props2.layout;
      var scrollOffset = this.state.scrollOffset;
      index2 = Math.max(0, Math.min(index2, itemCount - 1));
      var scrollbarSize = 0;
      if (this._outerRef) {
        var outerRef = this._outerRef;
        if (layout2 === "vertical") {
          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
        } else {
          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
        }
      }
      this.scrollTo(getOffsetForIndexAndAlignment5(this.props, index2, align, scrollOffset, this._instanceProps, scrollbarSize));
    }, "scrollToItem");
    _proto.componentDidMount = /* @__PURE__ */ __name(function componentDidMount() {
      var _this$props3 = this.props, direction = _this$props3.direction, initialScrollOffset = _this$props3.initialScrollOffset, layout2 = _this$props3.layout;
      if (typeof initialScrollOffset === "number" && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction === "horizontal" || layout2 === "horizontal") {
          outerRef.scrollLeft = initialScrollOffset;
        } else {
          outerRef.scrollTop = initialScrollOffset;
        }
      }
      this._callPropsCallbacks();
    }, "componentDidMount");
    _proto.componentDidUpdate = /* @__PURE__ */ __name(function componentDidUpdate() {
      var _this$props4 = this.props, direction = _this$props4.direction, layout2 = _this$props4.layout;
      var _this$state = this.state, scrollOffset = _this$state.scrollOffset, scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction === "horizontal" || layout2 === "horizontal") {
          if (direction === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                outerRef.scrollLeft = -scrollOffset;
                break;
              case "positive-ascending":
                outerRef.scrollLeft = scrollOffset;
                break;
              default:
                var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;
                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                break;
            }
          } else {
            outerRef.scrollLeft = scrollOffset;
          }
        } else {
          outerRef.scrollTop = scrollOffset;
        }
      }
      this._callPropsCallbacks();
    }, "componentDidUpdate");
    _proto.componentWillUnmount = /* @__PURE__ */ __name(function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    }, "componentWillUnmount");
    _proto.render = /* @__PURE__ */ __name(function render() {
      var _this$props5 = this.props, children = _this$props5.children, className = _this$props5.className, direction = _this$props5.direction, height2 = _this$props5.height, innerRef = _this$props5.innerRef, innerElementType = _this$props5.innerElementType, innerTagName = _this$props5.innerTagName, itemCount = _this$props5.itemCount, itemData = _this$props5.itemData, _this$props5$itemKey = _this$props5.itemKey, itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey, layout2 = _this$props5.layout, outerElementType = _this$props5.outerElementType, outerTagName = _this$props5.outerTagName, style2 = _this$props5.style, useIsScrolling = _this$props5.useIsScrolling, width2 = _this$props5.width;
      var isScrolling = this.state.isScrolling;
      var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;
      var _this$_getRangeToRend = this._getRangeToRender(), startIndex = _this$_getRangeToRend[0], stopIndex = _this$_getRangeToRend[1];
      var items = [];
      if (itemCount > 0) {
        for (var _index = startIndex; _index <= stopIndex; _index++) {
          items.push(reactExports.createElement(children, {
            data: itemData,
            key: itemKey(_index, itemData),
            index: _index,
            isScrolling: useIsScrolling ? isScrolling : void 0,
            style: this._getItemStyle(_index)
          }));
        }
      }
      var estimatedTotalSize = getEstimatedTotalSize4(this.props, this._instanceProps);
      return reactExports.createElement(outerElementType || outerTagName || "div", {
        className,
        onScroll,
        ref: this._outerRefSetter,
        style: _extends$4({
          position: "relative",
          height: height2,
          width: width2,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction
        }, style2)
      }, reactExports.createElement(innerElementType || innerTagName || "div", {
        children: items,
        ref: innerRef,
        style: {
          height: isHorizontal ? "100%" : estimatedTotalSize,
          pointerEvents: isScrolling ? "none" : void 0,
          width: isHorizontal ? estimatedTotalSize : "100%"
        }
      }));
    }, "render");
    _proto._callPropsCallbacks = /* @__PURE__ */ __name(function _callPropsCallbacks() {
      if (typeof this.props.onItemsRendered === "function") {
        var itemCount = this.props.itemCount;
        if (itemCount > 0) {
          var _this$_getRangeToRend2 = this._getRangeToRender(), _overscanStartIndex = _this$_getRangeToRend2[0], _overscanStopIndex = _this$_getRangeToRend2[1], _visibleStartIndex = _this$_getRangeToRend2[2], _visibleStopIndex = _this$_getRangeToRend2[3];
          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
        }
      }
      if (typeof this.props.onScroll === "function") {
        var _this$state2 = this.state, _scrollDirection = _this$state2.scrollDirection, _scrollOffset = _this$state2.scrollOffset, _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
      }
    }, "_callPropsCallbacks");
    _proto._getRangeToRender = /* @__PURE__ */ __name(function _getRangeToRender() {
      var _this$props6 = this.props, itemCount = _this$props6.itemCount, overscanCount = _this$props6.overscanCount;
      var _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollDirection = _this$state3.scrollDirection, scrollOffset = _this$state3.scrollOffset;
      if (itemCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getStartIndexForOffset3(this.props, scrollOffset, this._instanceProps);
      var stopIndex = getStopIndexForStartIndex3(this.props, startIndex, scrollOffset, this._instanceProps);
      var overscanBackward = !isScrolling || scrollDirection === "backward" ? Math.max(1, overscanCount) : 1;
      var overscanForward = !isScrolling || scrollDirection === "forward" ? Math.max(1, overscanCount) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    }, "_getRangeToRender");
    return List3;
  }(reactExports.PureComponent), _class.defaultProps = {
    direction: "ltr",
    itemData: void 0,
    layout: "vertical",
    overscanCount: 2,
    useIsScrolling: false
  }, _class;
}
__name(createListComponent, "createListComponent");
var validateSharedProps$1 = /* @__PURE__ */ __name(function validateSharedProps3(_ref2, _ref3) {
  _ref2.children;
  _ref2.direction;
  _ref2.height;
  _ref2.layout;
  _ref2.innerTagName;
  _ref2.outerTagName;
  _ref2.width;
  _ref3.instance;
}, "validateSharedProps3");
var FixedSizeGrid = /* @__PURE__ */ createGridComponent({
  getColumnOffset: /* @__PURE__ */ __name(function getColumnOffset2(_ref, index2) {
    var columnWidth = _ref.columnWidth;
    return index2 * columnWidth;
  }, "getColumnOffset2"),
  getColumnWidth: /* @__PURE__ */ __name(function getColumnWidth2(_ref2, index2) {
    var columnWidth = _ref2.columnWidth;
    return columnWidth;
  }, "getColumnWidth2"),
  getRowOffset: /* @__PURE__ */ __name(function getRowOffset2(_ref3, index2) {
    var rowHeight = _ref3.rowHeight;
    return index2 * rowHeight;
  }, "getRowOffset2"),
  getRowHeight: /* @__PURE__ */ __name(function getRowHeight2(_ref4, index2) {
    var rowHeight = _ref4.rowHeight;
    return rowHeight;
  }, "getRowHeight2"),
  getEstimatedTotalHeight: /* @__PURE__ */ __name(function getEstimatedTotalHeight3(_ref5) {
    var rowCount = _ref5.rowCount, rowHeight = _ref5.rowHeight;
    return rowHeight * rowCount;
  }, "getEstimatedTotalHeight3"),
  getEstimatedTotalWidth: /* @__PURE__ */ __name(function getEstimatedTotalWidth3(_ref6) {
    var columnCount = _ref6.columnCount, columnWidth = _ref6.columnWidth;
    return columnWidth * columnCount;
  }, "getEstimatedTotalWidth3"),
  getOffsetForColumnAndAlignment: /* @__PURE__ */ __name(function getOffsetForColumnAndAlignment2(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {
    var columnCount = _ref7.columnCount, columnWidth = _ref7.columnWidth, width2 = _ref7.width;
    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width2);
    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);
    var minOffset = Math.max(0, columnIndex * columnWidth - width2 + scrollbarSize + columnWidth);
    if (align === "smart") {
      if (scrollLeft >= minOffset - width2 && scrollLeft <= maxOffset + width2) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(width2 / 2)) {
          return 0;
        } else if (middleOffset > lastColumnOffset + Math.floor(width2 / 2)) {
          return lastColumnOffset;
        } else {
          return middleOffset;
        }
      case "auto":
      default:
        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
          return scrollLeft;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollLeft < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  }, "getOffsetForColumnAndAlignment2"),
  getOffsetForRowAndAlignment: /* @__PURE__ */ __name(function getOffsetForRowAndAlignment2(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {
    var rowHeight = _ref8.rowHeight, height2 = _ref8.height, rowCount = _ref8.rowCount;
    var lastRowOffset = Math.max(0, rowCount * rowHeight - height2);
    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
    var minOffset = Math.max(0, rowIndex * rowHeight - height2 + scrollbarSize + rowHeight);
    if (align === "smart") {
      if (scrollTop >= minOffset - height2 && scrollTop <= maxOffset + height2) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(height2 / 2)) {
          return 0;
        } else if (middleOffset > lastRowOffset + Math.floor(height2 / 2)) {
          return lastRowOffset;
        } else {
          return middleOffset;
        }
      case "auto":
      default:
        if (scrollTop >= minOffset && scrollTop <= maxOffset) {
          return scrollTop;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollTop < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  }, "getOffsetForRowAndAlignment2"),
  getColumnStartIndexForOffset: /* @__PURE__ */ __name(function getColumnStartIndexForOffset2(_ref9, scrollLeft) {
    var columnWidth = _ref9.columnWidth, columnCount = _ref9.columnCount;
    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));
  }, "getColumnStartIndexForOffset2"),
  getColumnStopIndexForStartIndex: /* @__PURE__ */ __name(function getColumnStopIndexForStartIndex2(_ref10, startIndex, scrollLeft) {
    var columnWidth = _ref10.columnWidth, columnCount = _ref10.columnCount, width2 = _ref10.width;
    var left2 = startIndex * columnWidth;
    var numVisibleColumns = Math.ceil((width2 + scrollLeft - left2) / columnWidth);
    return Math.max(0, Math.min(
      columnCount - 1,
      startIndex + numVisibleColumns - 1
      // -1 is because stop index is inclusive
    ));
  }, "getColumnStopIndexForStartIndex2"),
  getRowStartIndexForOffset: /* @__PURE__ */ __name(function getRowStartIndexForOffset2(_ref11, scrollTop) {
    var rowHeight = _ref11.rowHeight, rowCount = _ref11.rowCount;
    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));
  }, "getRowStartIndexForOffset2"),
  getRowStopIndexForStartIndex: /* @__PURE__ */ __name(function getRowStopIndexForStartIndex2(_ref12, startIndex, scrollTop) {
    var rowHeight = _ref12.rowHeight, rowCount = _ref12.rowCount, height2 = _ref12.height;
    var top2 = startIndex * rowHeight;
    var numVisibleRows = Math.ceil((height2 + scrollTop - top2) / rowHeight);
    return Math.max(0, Math.min(
      rowCount - 1,
      startIndex + numVisibleRows - 1
      // -1 is because stop index is inclusive
    ));
  }, "getRowStopIndexForStartIndex2"),
  initInstanceProps: /* @__PURE__ */ __name(function initInstanceProps3(props) {
  }, "initInstanceProps3"),
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: /* @__PURE__ */ __name(function validateProps3(_ref13) {
    _ref13.columnWidth;
    _ref13.rowHeight;
  }, "validateProps3")
});
var FixedSizeList = /* @__PURE__ */ createListComponent({
  getItemOffset: /* @__PURE__ */ __name(function getItemOffset2(_ref, index2) {
    var itemSize = _ref.itemSize;
    return index2 * itemSize;
  }, "getItemOffset2"),
  getItemSize: /* @__PURE__ */ __name(function getItemSize2(_ref2, index2) {
    var itemSize = _ref2.itemSize;
    return itemSize;
  }, "getItemSize2"),
  getEstimatedTotalSize: /* @__PURE__ */ __name(function getEstimatedTotalSize3(_ref3) {
    var itemCount = _ref3.itemCount, itemSize = _ref3.itemSize;
    return itemSize * itemCount;
  }, "getEstimatedTotalSize3"),
  getOffsetForIndexAndAlignment: /* @__PURE__ */ __name(function getOffsetForIndexAndAlignment4(_ref4, index2, align, scrollOffset, instanceProps, scrollbarSize) {
    var direction = _ref4.direction, height2 = _ref4.height, itemCount = _ref4.itemCount, itemSize = _ref4.itemSize, layout2 = _ref4.layout, width2 = _ref4.width;
    var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
    var size2 = isHorizontal ? width2 : height2;
    var lastItemOffset = Math.max(0, itemCount * itemSize - size2);
    var maxOffset = Math.min(lastItemOffset, index2 * itemSize);
    var minOffset = Math.max(0, index2 * itemSize - size2 + itemSize + scrollbarSize);
    if (align === "smart") {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center": {
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(size2 / 2)) {
          return 0;
        } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
          return lastItemOffset;
        } else {
          return middleOffset;
        }
      }
      case "auto":
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  }, "getOffsetForIndexAndAlignment4"),
  getStartIndexForOffset: /* @__PURE__ */ __name(function getStartIndexForOffset2(_ref5, offset2) {
    var itemCount = _ref5.itemCount, itemSize = _ref5.itemSize;
    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset2 / itemSize)));
  }, "getStartIndexForOffset2"),
  getStopIndexForStartIndex: /* @__PURE__ */ __name(function getStopIndexForStartIndex2(_ref6, startIndex, scrollOffset) {
    var direction = _ref6.direction, height2 = _ref6.height, itemCount = _ref6.itemCount, itemSize = _ref6.itemSize, layout2 = _ref6.layout, width2 = _ref6.width;
    var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
    var offset2 = startIndex * itemSize;
    var size2 = isHorizontal ? width2 : height2;
    var numVisibleItems = Math.ceil((size2 + scrollOffset - offset2) / itemSize);
    return Math.max(0, Math.min(
      itemCount - 1,
      startIndex + numVisibleItems - 1
      // -1 is because stop index is inclusive
    ));
  }, "getStopIndexForStartIndex2"),
  initInstanceProps: /* @__PURE__ */ __name(function initInstanceProps4(props) {
  }, "initInstanceProps4"),
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: /* @__PURE__ */ __name(function validateProps4(_ref7) {
    _ref7.itemSize;
  }, "validateProps4")
});
dayjs.extend(utc);
dayjs.extend(timezone);
const fetchPersonList = /* @__PURE__ */ __name(async () => {
  try {
    const response = await api.get("/pessoa");
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "fetchPersonList");
const fetchManagers = /* @__PURE__ */ __name(async () => {
  try {
    const response = await api.get("/opportunity/manager");
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "fetchManagers");
const updateOpportunity = /* @__PURE__ */ __name(async (opportunity, user) => {
  try {
    const response = await api.put("opportunity/update", opportunity, {
      params: { user }
    });
    return response;
  } catch (error) {
    console.error(error);
    return null;
  }
}, "updateOpportunity");
const getOpportunities = /* @__PURE__ */ __name(async (finished, dateFilters, codpessoa) => {
  try {
    const response = await api.get("/opportunity", {
      params: { finished, dateFilters, codpessoa }
    });
    return response.data;
  } catch (error) {
    console.error(error);
    return [];
  }
}, "getOpportunities");
const fetchStatusList = /* @__PURE__ */ __name(async () => {
  try {
    const response = await api.get("/opportunity/status");
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "fetchStatusList");
const fetchSalers = /* @__PURE__ */ __name(async (projectId) => {
  try {
    const response = await api.get("/opportunity/saler", {
      params: {
        projectId
      }
    });
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "fetchSalers");
const getOpportunityById = /* @__PURE__ */ __name(async (oppId) => {
  try {
    console.log("getOpportunityById");
    const response = await api.get(`/opportunity/${oppId}`);
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "getOpportunityById");
const fetchAllClients = /* @__PURE__ */ __name(async (projectId) => {
  try {
    const respoonse = await api.get("/opportunity/client", {
      params: {
        projectId
      }
    });
    return respoonse.data;
  } catch (e2) {
    console.log("fetchAllClients: ", e2);
  }
}, "fetchAllClients");
const createOpportunity = /* @__PURE__ */ __name(async (opp) => {
  try {
    const response = await api.post(`opportunity/create`, { ...opp });
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "createOpportunity");
const createAdicional = /* @__PURE__ */ __name(async (opportunity) => {
  try {
    const response = await api.post(`opportunity/create`, opportunity);
    return response.data;
  } catch (e2) {
    console.log(e2);
  }
}, "createAdicional");
const patrimonyInfoColumns = [
  {
    width: 90,
    // Reduzi um pouco para economizar espao
    label: "Patrimnio",
    dataKey: "id_patrimonio"
  },
  {
    width: 90,
    // Mantive um tamanho razovel para a visualizao do nome
    label: "Nome",
    dataKey: "nome"
  },
  {
    width: 80,
    label: "Valor de Compra",
    dataKey: "valor_compra"
  },
  {
    width: 170,
    label: "Tipo",
    dataKey: "nome_tipo"
  },
  {
    width: 150,
    // Reduzi para economizar espao, mantendo a descrio legvel
    label: "Descrio",
    dataKey: "descricao"
  },
  {
    width: 100,
    // Mantido similar ao nome
    label: "Responsvel",
    dataKey: "responsavel"
  },
  {
    width: 100,
    // Mantido igual ao responsvel
    label: "Gerente",
    dataKey: "gerente"
  },
  {
    width: 150,
    // Projeto precisa de um pouco mais de espao
    label: "Projeto",
    dataKey: "projeto"
  },
  {
    width: 80,
    // Reduzido um pouco para ltima movimentao
    label: "Ultima Movimentao",
    dataKey: "dataMovimentacao"
  },
  {
    width: 70,
    // Coluna vazia para possveis aes, mantive um valor baixo
    label: "",
    dataKey: ""
  }
];
const createOpportunityFiles = /* @__PURE__ */ __name(async (oppId, files) => {
  const config2 = {
    headers: {
      "Content-Type": "multipart/form-data"
    },
    params: {
      oppId
    },
    data: files
  };
  try {
    const response = await api.post(`opportunity/files`, files, config2);
    return response;
  } catch (e2) {
    console.log(e2);
  }
}, "createOpportunityFiles");
const fetchClientFromFirstProjectOption = /* @__PURE__ */ __name(async (projectId) => {
  const clients = await fetchAllClients(projectId);
  const options = clients.map((client2) => ({
    label: client2.NOMEFANTASIA,
    id: client2.CODCLIENTE,
    object: "client",
    key: client2.CODCLIENTE
  }));
  const olyOptionAvailable = options.find(
    (option) => option.label !== "-"
  );
  return olyOptionAvailable;
}, "fetchClientFromFirstProjectOption");
const fetchResponsableForFirstProjectOption = /* @__PURE__ */ __name(async (projectId) => {
  const salers = await fetchSalers(Number(projectId));
  const options = salers.map((saler) => ({
    label: saler.NOME,
    id: saler.CODPESSOA,
    object: "saler",
    key: saler.CODPESSOA
  }));
  const onlyOptionAvailable = options.find(
    (option) => option.label !== "-"
  );
  return onlyOptionAvailable;
}, "fetchResponsableForFirstProjectOption");
const opportunityDefault = {
  codOs: 0,
  // Exemplo de cdigo de OS (AUTO_INCREMENT, no precisa definir)
  codTipoOs: 1,
  // Valor padro para o tipo de OS (campo com valor padro '1')
  codCCusto: null,
  // Opcional
  obra: null,
  // Opcional
  dataSolicitacao: null,
  // Data atual (pode ser null se no obrigatrio)
  dataNecessidade: null,
  // Data atual (pode ser null se no obrigatrio)
  docReferencia: null,
  // Opcional
  listaMateriais: null,
  // Opcional
  dataInicio: null,
  // Opcional
  dataPrevEntrega: null,
  // Opcional
  dataEntrega: null,
  // Opcional
  codStatus: 1,
  // Valor padro para o status (campo com valor padro '1')
  nome: "",
  // Nome obrigatrio
  descricao: "",
  // Opcional
  atividades: null,
  // Opcional
  prioridade: 0,
  // Valor padro (campo com valor padro '0')
  solicitante: 1,
  // Valor padro para o solicitante (campo com valor padro '1')
  responsavel: 1,
  // Valor padro para o responsvel (campo com valor padro '1')
  codDisciplina: 1,
  // Valor padro para o cdigo de disciplina (campo com valor padro '1')
  gut: 1,
  // Valor padro para o GUT (campo com valor padro '1')
  gravidade: 1,
  // Valor padro para a gravidade (campo com valor padro '1')
  urgencia: 1,
  // Valor padro para urgncia (campo com valor padro '1')
  tendencia: 1,
  // Valor padro para tendncia (campo com valor padro '1')
  dataLiberacao: null,
  // Opcional
  relacionamento: 1,
  // Valor padro para relacionamento (campo com valor padro '1')
  fkCodCliente: "-",
  // Valor padro (campo com valor padro '-')
  fkCodColigada: 0,
  // Valor padro para cdigo de coligada (campo com valor padro '0')
  valorFatDireto: 0,
  // Valor padro (campo com valor padro '0.00')
  valorServicoMO: 0,
  // Valor padro (campo com valor padro '0.00')
  valorServicoMatAplicado: 0,
  // Valor padro (campo com valor padro '0.00')
  valorMaterial: 0,
  // Valor padro (campo com valor padro '0.00')
  valorTotal: 0,
  // Valor padro (campo com valor padro '0.00')
  codSegmento: 1,
  // Valor padro para cdigo de segmento (campo com valor padro '1')
  codCidade: 0,
  // Valor padro para cdigo de cidade (campo com valor padro '0')
  valorLocacao: 0,
  // Valor padro (campo com valor padro '0.00')
  idAdicional: 0,
  // Valor padro (campo com valor padro '0')
  idProjeto: 0,
  // Valor padro (campo com valor padro '0')
  dataInteracao: null,
  // Valor padro (campo com valor padro '1111-11-11')
  valorFatDolphin: 0,
  // Valor padro para faturamento Dolphin (campo com valor padro '0.00')
  principal: true,
  // Valor padro (campo com valor padro '1')
  valorComissao: 0,
  // Valor obrigatrio
  idMotivoPerdido: 1,
  // Valor obrigatrio (campo no pode ser nulo)
  observacoes: "",
  // Opcional
  descricaoVenda: "",
  // Opcional
  emailVendaEnviado: false,
  // Valor padro (campo com valor padro '0')
  numeroAdicional: 0,
  // Valor padro com
  comentarios: [],
  seguidores: []
};
const PatrimonyInfoTableFooter = /* @__PURE__ */ __name(({
  filteredRows
}) => {
  if (!filteredRows || filteredRows.length === 0)
    return null;
  const totalValue = filteredRows.reduce(
    (total, row) => total + Number(row.valor_compra || 0),
    0
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      display: "flex",
      justifyContent: "flex-end",
      paddingY: 2,
      paddingX: "2rem",
      gap: 4,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "body2",
            color: "blue",
            fontWeight: "semibold",
            fontFamily: "Roboto",
            children: `Total: ${new Intl.NumberFormat("pt-BR", {
              style: "currency",
              currency: "BRL"
            }).format(totalValue)}`
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "body2",
            color: "blue",
            fontWeight: "semibold",
            fontFamily: "Roboto",
            children: `${filteredRows.length} Itens encontrados`
          }
        )
      ]
    }
  );
}, "PatrimonyInfoTableFooter");
const cardColumns$1 = [
  { label: "Valor de Compra", dataKey: "valor_compra" },
  { label: "Responsvel", dataKey: "responsavel" },
  { label: "Gerente", dataKey: "gerente" },
  { label: "Projeto", dataKey: "projeto" }
];
const PatrimonyInfoCard = /* @__PURE__ */ __name(({ props, filteredRows }) => {
  console.log("renderizou card");
  const { index: index2, style: style2 } = props;
  const navigate = useNavigate();
  const row = filteredRows[index2];
  const handleOpenPatrimonyDetails = /* @__PURE__ */ __name((patrimonyId) => {
    navigate(`/patrimony/details/${patrimonyId}`);
  }, "handleOpenPatrimonyDetails");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: filteredRows && /* @__PURE__ */ jsxRuntimeExports.jsx(
    Card,
    {
      style: {
        ...style2,
        ...basicCardStyles
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: basicCardContentStyles,
          className: "shadow-sm shadow-gray-600",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { sx: cardTitleStyle, children: [
              row.id_patrimonio,
              " - ",
              row.nome
            ] }),
            cardColumns$1.map((column2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                fontSize: "small",
                color: "textSecondary",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                    column2.label,
                    ":"
                  ] }),
                  " ",
                  row[column2.dataKey] || "N/A"
                ]
              },
              column2.dataKey
            )),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Stack,
              {
                direction: "row",
                spacing: 1,
                justifyContent: "flex-end",
                marginTop: 2,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: () => handleOpenPatrimonyDetails(row.id_patrimonio),
                    sx: { ...BaseButtonStyles },
                    children: "Detalhes"
                  }
                )
              }
            )
          ]
        }
      )
    },
    index2
  ) });
}, "PatrimonyInfoCard");
const PatrimonyInfoVirtuosoTableComponents = {
  Scroller: reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { component: Paper, ...props, ref })),
  Table: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Table$1,
    {
      ...props,
      sx: { borderCollapse: "separate", tableLayout: "fixed" }
    }
  ),
  TableHead: reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { ...props, ref })),
  TableRow,
  TableBody: reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { ...props, ref }))
};
function PatrimonyInfoTable() {
  console.log("Renderizou PatrimonyInfoTable");
  const {
    refreshPatrimonyInfo,
    currentFilter,
    changeColumnFilters,
    columnFilter,
    filteredRows,
    setFilteredRows
  } = reactExports.useContext(PatrimonyInfoContext);
  const { user } = reactExports.useContext(userContext);
  const [rows, setRows] = reactExports.useState();
  const [selectedItems, setSelectedItems] = reactExports.useState([]);
  const [isMobile, setIsMobile] = reactExports.useState(false);
  const [isCardViewActive, setIsCardViewActive] = reactExports.useState(false);
  const navigate = useNavigate();
  const fetchData = /* @__PURE__ */ __name(async () => {
    console.log("fetchData PatrimonyInfoTable.tsx");
    const patrimonyInfoData = user && await getPatrimonyInfo(user, currentFilter);
    console.log({ patrimonyInfoData });
    console.log({ currentFilter });
    if (currentFilter === "Todos") {
      if (patrimonyInfoData) {
        const activeFilters = columnFilter.filter(
          (filter3) => filter3.filterValue.trim() !== ""
        );
        if (activeFilters.length) {
          const filteredByColumns = filterByActiveColumnFilters(
            patrimonyInfoData,
            activeFilters
          );
          setFilteredRows(filteredByColumns);
          setRows(patrimonyInfoData);
          return;
        }
        setFilteredRows(patrimonyInfoData);
        setRows(patrimonyInfoData);
      }
      return;
    }
    if (currentFilter === "Meus") {
      if (patrimonyInfoData) {
        const activeFilters = columnFilter.filter(
          (filter3) => filter3.filterValue.trim() !== ""
        );
        if (activeFilters.length) {
          const filteredByColumns = filterByActiveColumnFilters(
            patrimonyInfoData,
            activeFilters
          );
          setFilteredRows(filteredByColumns);
          setRows(patrimonyInfoData);
          return;
        }
        setFilteredRows(patrimonyInfoData);
        setRows(patrimonyInfoData);
      }
      return;
    }
  }, "fetchData");
  const filterByActiveColumnFilters = /* @__PURE__ */ __name((patrimonyInfoData, activeFilters) => {
    return patrimonyInfoData.filter((patrimonyInfo) => {
      return activeFilters.every((filter3) => {
        const { dataKey, filterValue } = filter3;
        if (dataKey === "id_patrimonio") {
          console.log("coluna numrica");
          return String(patrimonyInfo[dataKey]) === String(filterValue);
        }
        if (dataKey === "dataMovimentacao") {
          const renderedDate = renderDateValue(dataKey, patrimonyInfo);
          return renderedDate == null ? void 0 : renderedDate.includes(filterValue);
        }
        return String(patrimonyInfo[dataKey]).toLowerCase().includes(filterValue.toLowerCase());
      });
    });
  }, "filterByActiveColumnFilters");
  const renderDateValue = /* @__PURE__ */ __name((dataKey, row) => {
    const date = dateTimeRenderer(row[dataKey] || "");
    return date === "Invalid Date, Invalid Date" ? "" : date;
  }, "renderDateValue");
  const handleOpenChecklists = /* @__PURE__ */ __name((row) => {
    navigate("/patrimony/checklist/" + row.id_patrimonio);
  }, "handleOpenChecklists");
  function RowContent2(_index, row, setSelectedItems2, selectedItems2) {
    const handleSelectItem = /* @__PURE__ */ __name((e2, row2) => {
      if (e2.target.checked) {
        const currentSelectedItems2 = [...selectedItems2];
        currentSelectedItems2.push(row2);
        setSelectedItems2([...currentSelectedItems2]);
        console.log("currentSelected: \n", currentSelectedItems2);
        return;
      }
      const currentSelectedItems = [...selectedItems2];
      currentSelectedItems.splice(currentSelectedItems.indexOf(row2), 1);
      setSelectedItems2([...currentSelectedItems]);
    }, "handleSelectItem");
    const handleOpenPatrimonyDetail = /* @__PURE__ */ __name((id_patrimonio) => {
      navigate(`/patrimony/details/${id_patrimonio}`);
    }, "handleOpenPatrimonyDetail");
    const isOnSelectedItems = /* @__PURE__ */ __name((row2) => {
      if (selectedItems2.find((item) => row2 === item)) {
        return true;
      }
      return false;
    }, "isOnSelectedItems");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: patrimonyInfoColumns.map(
      (column2) => column2.label !== "" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        TableCell,
        {
          onClick: () => handleOpenPatrimonyDetail(row.id_patrimonio),
          sx: {
            cursor: "pointer",
            paddingX: "0.2rem",
            paddingY: "0.1rem",
            textTransform: "capitalize"
          },
          align: column2.numeric ? "left" : "center",
          children: column2.dataKey === "dataMovimentacao" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", children: dateTimeRenderer(row[column2.dataKey]) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              fontSize: "12px",
              sx: {
                textAlign: column2.dataKey === "descricao" ? "left" : "center"
              },
              children: column2.dataKey === "projeto" ? String(row[column2.dataKey]) : column2.dataKey === "id_patrimonio" ? String(row[column2.dataKey]).padStart(6, "0") : column2.dataKey === "valor_compra" ? new Intl.NumberFormat("pt-BR", {
                style: "decimal",
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
              }).format(Number(row[column2.dataKey])) : String(
                row[column2.dataKey]
              ).toLowerCase()
            }
          )
        },
        column2.dataKey
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        TableCell,
        {
          sx: {
            cursor: "pointer",
            paddingX: "0.2",
            paddingY: "0.1rem",
            textTransform: "capitalize"
          },
          align: "center",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", children: [
            "",
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => handleOpenChecklists(row), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$b, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                checked: isOnSelectedItems(row),
                onChange: (e2) => handleSelectItem(e2, row),
                sx: { margin: "0", padding: "0" }
              }
            )
          ] })
        },
        column2.dataKey
      )
    ) });
  }
  __name(RowContent2, "RowContent");
  function fixedHeaderContent2() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: patrimonyInfoColumns.map((column2) => {
      var _a2;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TableCell,
        {
          variant: "head",
          align: column2.numeric ? "left" : "center",
          style: { width: column2.width },
          sx: {
            backgroundColor: "background.paper",
            padding: "0.2"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", sx: { fontWeight: "bold" }, children: column2.label }),
            column2.label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                id: "standard-basic",
                label: "",
                variant: "standard",
                sx: { fontSize: "10px", color: "red" },
                onChange: (e2) => handleFilterByColumn(e2, column2),
                value: (_a2 = columnFilter == null ? void 0 : columnFilter.find(
                  (filter3) => filter3.dataKey === column2.dataKey
                )) == null ? void 0 : _a2.filterValue
              }
            )
          ]
        },
        column2.dataKey
      );
    }) });
  }
  __name(fixedHeaderContent2, "fixedHeaderContent");
  const handleFilterByColumn = /* @__PURE__ */ __name((e2, column2) => {
    const { value } = e2.target;
    const activeFilters = getActiveFilters(column2, value);
    let newFilteredRows = rows && [...rows];
    if (activeFilters && newFilteredRows) {
      console.log("activeFilters: ", activeFilters);
      for (const filter3 of activeFilters) {
        if (filter3.dataKey === "id_patrimonio") {
          const numericValue = Number(filter3.filterValue);
          newFilteredRows = newFilteredRows.filter(
            (row) => Number(row[filter3.dataKey]) === numericValue
          );
          continue;
        }
        if (filter3.dataKey === "dataMovimentacao") {
          newFilteredRows = newFilteredRows.filter(
            (row) => {
              var _a2;
              return (_a2 = dateTimeRenderer(
                row[filter3.dataKey]
              )) == null ? void 0 : _a2.includes(filter3.filterValue);
            }
          );
          continue;
        }
        newFilteredRows = newFilteredRows.filter(
          (row) => String(row[filter3.dataKey]).toLowerCase().includes(filter3.filterValue.toLowerCase())
        );
      }
      setFilteredRows(newFilteredRows);
      return;
    }
    setFilteredRows(rows);
  }, "handleFilterByColumn");
  const getActiveFilters = /* @__PURE__ */ __name((column2, value) => {
    const updatedColumnFilters = columnFilter.map((currrentColumnFilter) => {
      if (currrentColumnFilter.dataKey === column2.dataKey) {
        return {
          ...currrentColumnFilter,
          filterValue: value
        };
      }
      return currrentColumnFilter;
    });
    changeColumnFilters(updatedColumnFilters);
    const activeFilters = [
      ...updatedColumnFilters.filter((filter3) => {
        if (filter3.filterValue !== "") {
          return filter3;
        }
      })
    ];
    return activeFilters;
  }, "getActiveFilters");
  const handleSearch = /* @__PURE__ */ __name((e2) => {
    console.log("handleSearch");
    const { value } = e2.currentTarget;
    const searchValue = value.toLowerCase();
    if (rows) {
      setFilteredRows(
        rows.filter(
          (moviment) => {
            var _a2;
            return moviment.nome.toLowerCase().includes(searchValue) || ((_a2 = moviment.nome_tipo) == null ? void 0 : _a2.toLowerCase().includes(searchValue)) || moviment.gerente.toLowerCase().includes(searchValue) || moviment.projeto.toLowerCase().includes(searchValue) || moviment.responsavel.toLowerCase().includes(searchValue) || moviment.id_patrimonio === Number(searchValue) || moviment.patrimonio.toLowerCase().includes(searchValue) || moviment.descricao.toLowerCase().includes(searchValue) || moviment.dataMovimentacao.toLowerCase().includes(searchValue);
          }
        )
      );
      return;
    }
    return;
  }, "handleSearch");
  reactExports.useEffect(() => {
    console.log({ currentFilter });
    console.log("USEFFECT PatrimonyInfoTable.tsx");
    fetchData();
    setIsMobile(window.innerWidth <= 768);
    setIsCardViewActive(window.innerWidth <= 768);
  }, [refreshPatrimonyInfo, currentFilter]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Paper,
    {
      style: {
        width: "100%",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        gap: 4,
        flexGrow: 1
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SearchAppBar,
          {
            isCardViewActive,
            setIsCardViewActive,
            setFilteredRows,
            selectedItems,
            handleSearch,
            setSelectedItems
          }
        ),
        filteredRows && !isCardViewActive && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableVirtuoso,
          {
            data: filteredRows,
            components: PatrimonyInfoVirtuosoTableComponents,
            fixedHeaderContent: fixedHeaderContent2,
            itemContent: (index2, row) => RowContent2(index2, row, setSelectedItems, selectedItems)
          }
        ),
        filteredRows && isCardViewActive && /* @__PURE__ */ jsxRuntimeExports.jsx(
          FixedSizeList,
          {
            height: 600,
            width: "100%",
            itemSize: 320,
            itemCount: filteredRows.length,
            overscanCount: 1,
            children: ({ index: index2, style: style2, data }) => {
              const cardStyle = { ...style2 };
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                PatrimonyInfoCard,
                {
                  props: { index: index2, style: cardStyle, data },
                  filteredRows
                }
              );
            }
          }
        ),
        filteredRows && !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(PatrimonyInfoTableFooter, { filteredRows })
      ]
    }
  );
}
__name(PatrimonyInfoTable, "PatrimonyInfoTable");
const logoUrl = "/assets/logodolphin-CtvtokkP.jpg";
const PatrimonyHome = React$1.memo(() => {
  console.log("renderizou PatrimonyHome");
  const isMobile = reactExports.useMemo(() => window.innerWidth <= 768, []);
  const navigate = useNavigate();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { display: "flex", flexDirection: "column", gap: 2, height: "100vh", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { padding: 1, height: "5%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", flexWrap: "wrap", alignItems: "center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => navigate("/home"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftIcon, {}) }),
      !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: logoUrl, width: "120px", alt: "Logo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "#2B3990", variant: "h6", children: "Controle de Patrimnios" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PatrimonyInfoTable, {})
  ] });
});
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
__name(isOverflowing, "isOverflowing");
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
__name(ariaHidden, "ariaHidden");
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
__name(getPaddingRight, "getPaddingRight");
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
__name(isAriaHiddenForbiddenOnElement, "isAriaHiddenForbiddenOnElement");
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, show);
    }
  });
}
__name(ariaHiddenSiblings, "ariaHiddenSiblings");
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index2) => {
    if (callback(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
__name(findIndexOf, "findIndexOf");
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize$1(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = /* @__PURE__ */ __name(() => {
    restoreStyle.forEach(({
      value,
      el: el2,
      property
    }) => {
      if (value) {
        el2.style.setProperty(property, value);
      } else {
        el2.style.removeProperty(property);
      }
    });
  }, "restore");
  return restore;
}
__name(handleContainer, "handleContainer");
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
__name(getHiddenSiblings, "getHiddenSiblings");
const _ModalManager = class _ModalManager {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
};
__name(_ModalManager, "ModalManager");
let ModalManager = _ModalManager;
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
__name(getContainer, "getContainer");
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
__name(getHasTransition, "getHasTransition");
const defaultManager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    // @ts-ignore internal logic - Base UI supports the manager as a prop too
    manager = defaultManager,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open: open2,
    rootRef
  } = parameters;
  const modal = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open2);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = /* @__PURE__ */ __name(() => ownerDocument(mountNodeRef.current), "getDoc");
  const getModal = /* @__PURE__ */ __name(() => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  }, "getModal");
  const handleMounted = /* @__PURE__ */ __name(() => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  }, "handleMounted");
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open2 && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp, manager]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open2) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open2, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  }, "createHandleKeyDown");
  const createHandleBackdropClick = /* @__PURE__ */ __name((otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  }, "createHandleBackdropClick");
  const getRootProps = /* @__PURE__ */ __name((otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = _extends$4({}, propsEventHandlers, otherHandlers);
    return _extends$4({
      role: "presentation"
    }, externalEventHandlers, {
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    });
  }, "getRootProps");
  const getBackdropProps = /* @__PURE__ */ __name((otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return _extends$4({
      "aria-hidden": true
    }, externalEventHandlers, {
      onClick: createHandleBackdropClick(externalEventHandlers),
      open: open2
    });
  }, "getBackdropProps");
  const getTransitionProps2 = /* @__PURE__ */ __name(() => {
    const handleEnter = /* @__PURE__ */ __name(() => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    }, "handleEnter");
    const handleExited = /* @__PURE__ */ __name(() => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    }, "handleExited");
    return {
      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
    };
  }, "getTransitionProps");
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
__name(useModal, "useModal");
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
__name(getTabIndex, "getTabIndex");
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = /* @__PURE__ */ __name((selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`), "getRadio");
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
__name(isNonTabbableRadio, "isNonTabbableRadio");
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
__name(isNodeMatchingSelectorFocusable, "isNodeMatchingSelectorFocusable");
function defaultGetTabbable(root2) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root2.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a, b2) => a.tabIndex === b2.tabIndex ? a.documentOrder - b2.documentOrder : a.tabIndex - b2.tabIndex).map((a) => a.node).concat(regularTabNodes);
}
__name(defaultGetTabbable, "defaultGetTabbable");
function defaultIsEnabled() {
  return true;
}
__name(defaultIsEnabled, "defaultIsEnabled");
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled: isEnabled2 = defaultIsEnabled,
    open: open2
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open2]);
  reactExports.useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open2]);
  reactExports.useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = /* @__PURE__ */ __name((nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled2() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    }, "loopFocus");
    const contain = /* @__PURE__ */ __name(() => {
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled2() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        var _lastKeydown$current, _lastKeydown$current2;
        const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    }, "contain");
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled2, open2, getTabbable]);
  const onFocus = /* @__PURE__ */ __name((event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  }, "onFocus");
  const handleFocusSentinel = /* @__PURE__ */ __name((event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  }, "handleFocusSentinel");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open2 ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open2 ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
__name(FocusTrap, "FocusTrap");
const COMPONENT_NAME = "Modal";
function getModalUtilityClass(slot) {
  return generateUtilityClass(COMPONENT_NAME, slot);
}
__name(getModalUtilityClass, "getModalUtilityClass");
generateUtilityClasses(COMPONENT_NAME, ["root", "hidden", "backdrop"]);
const _excluded = ["children", "closeAfterTransition", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"];
const useUtilityClasses = /* @__PURE__ */ __name((ownerState) => {
  const {
    open: open2,
    exited
  } = ownerState;
  const slots = {
    root: ["root", !open2 && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, useClassNamesOverride(getModalUtilityClass));
}, "useUtilityClasses");
const Modal$2 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function Modal22(props, forwardedRef) {
  var _slots$root;
  const {
    children,
    closeAfterTransition = false,
    container,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onBackdropClick,
    open: open2,
    slotProps = {},
    slots = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded);
  const propsWithDefaults = _extends$4({}, props, {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  });
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal(_extends$4({}, propsWithDefaults, {
    rootRef: forwardedRef
  }));
  const ownerState = _extends$4({}, propsWithDefaults, {
    exited,
    hasTransition
  });
  const classes2 = useUtilityClasses(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const Root = (_slots$root = slots.root) != null ? _slots$root : "div";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    getSlotProps: getRootProps,
    className: classes2.root,
    ownerState
  });
  const BackdropComponent = slots.backdrop;
  const backdropProps = useSlotProps({
    elementType: BackdropComponent,
    externalSlotProps: slotProps.backdrop,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps(_extends$4({}, otherHandlers, {
        onClick: (e2) => {
          if (onBackdropClick) {
            onBackdropClick(e2);
          }
          if (otherHandlers != null && otherHandlers.onClick) {
            otherHandlers.onClick(e2);
          }
        }
      }));
    },
    className: classes2.backdrop,
    ownerState
  });
  if (!keepMounted && !open2 && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$4({}, rootProps, {
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropComponent, _extends$4({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open: open2,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    }))
  });
}, "Modal2"));
var AttachFile = {};
var _interopRequireDefault$f = interopRequireDefaultExports;
Object.defineProperty(AttachFile, "__esModule", {
  value: true
});
var default_1$a = AttachFile.default = void 0;
var _createSvgIcon$a = _interopRequireDefault$f(requireCreateSvgIcon());
var _jsxRuntime$a = jsxRuntimeExports;
default_1$a = AttachFile.default = (0, _createSvgIcon$a.default)(/* @__PURE__ */ (0, _jsxRuntime$a.jsx)("path", {
  d: "M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6z"
}), "AttachFile");
var CloudUpload = {};
var _interopRequireDefault$e = interopRequireDefaultExports;
Object.defineProperty(CloudUpload, "__esModule", {
  value: true
});
var default_1$9 = CloudUpload.default = void 0;
var _createSvgIcon$9 = _interopRequireDefault$e(requireCreateSvgIcon());
var _jsxRuntime$9 = jsxRuntimeExports;
default_1$9 = CloudUpload.default = (0, _createSvgIcon$9.default)(/* @__PURE__ */ (0, _jsxRuntime$9.jsx)("path", {
  d: "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96M14 13v4h-4v-4H7l5-5 5 5z"
}), "CloudUpload");
const MovementationFileContext = reactExports.createContext({
  refreshMovementationFile: false,
  movementationFileOpen: [false],
  movementationFiles: [],
  toggleMovementationFileOpen: () => {
  },
  toggleRefreshMovementationFile: () => {
  },
  deletingMovimentationFile: [false],
  toggleDeletingMovimentationFile: () => {
  },
  changeMovementationFiles: () => {
  }
});
const MovementationFileContextProvider = /* @__PURE__ */ __name(({
  children
}) => {
  const [movementationFileOpen, setMovementationFileOpen] = reactExports.useState([false]);
  const [refreshMovementationFile, setRefreshMovementationFile] = reactExports.useState(false);
  const [deletingMovimentationFile, setDeletingMovimentationFile] = reactExports.useState([false]);
  const [movementationFiles, setMovementationFiles] = reactExports.useState([]);
  const changeMovementationFiles = /* @__PURE__ */ __name((files) => {
    setMovementationFiles([...files]);
  }, "changeMovementationFiles");
  const toggleMovementationFileOpen = /* @__PURE__ */ __name((momvementationId) => {
    setMovementationFileOpen(
      movementationFileOpen[0] ? [false] : [true, momvementationId]
    );
  }, "toggleMovementationFileOpen");
  const toggleDeletingMovimentationFile = /* @__PURE__ */ __name((isDeleting, movementationFile) => {
    setDeletingMovimentationFile(isDeleting ? [true, movementationFile] : [false]);
  }, "toggleDeletingMovimentationFile");
  const toggleRefreshMovementationFile = /* @__PURE__ */ __name(() => {
    setRefreshMovementationFile((prev2) => !prev2);
  }, "toggleRefreshMovementationFile");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MovementationFileContext.Provider,
    {
      value: {
        refreshMovementationFile,
        movementationFileOpen,
        deletingMovimentationFile,
        movementationFiles,
        changeMovementationFiles,
        toggleMovementationFileOpen,
        toggleRefreshMovementationFile,
        toggleDeletingMovimentationFile
      },
      children
    }
  );
}, "MovementationFileContextProvider");
const style$9 = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: "fit-content",
  bgcolor: "background.paper",
  boxShadow: 24,
  p: 4
};
function DeleteMovimentationFileModal() {
  const { toggleDeletingMovimentationFile, deletingMovimentationFile, toggleRefreshMovementationFile } = reactExports.useContext(MovementationFileContext);
  const handleClose = /* @__PURE__ */ __name(() => toggleDeletingMovimentationFile(false), "handleClose");
  const handleDelete = /* @__PURE__ */ __name(async () => {
    console.log("handleDelete");
    if (deletingMovimentationFile[0] && deletingMovimentationFile[1]) {
      const response = await deleteMovementationFileModal(
        deletingMovimentationFile[1].id_anexo_movimentacao,
        deletingMovimentationFile[1].nome_arquivo
      );
      console.log("response status: ", response == null ? void 0 : response.status);
      if (response && response.status === 200) {
        toggleRefreshMovementationFile();
        toggleDeletingMovimentationFile(false);
      }
    }
  }, "handleDelete");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: deletingMovimentationFile[0],
      onClose: handleClose,
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            ...style$9,
            display: "flex",
            flexDirection: "column",
            gap: "1rem"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { id: "modal-modal-title", variant: "h6", component: "h2", children: [
              "tem certeza que deseja deletar este anexo?",
              " "
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "center", spacing: 2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "primary",
                  sx: { borderColor: "blue", color: "blue" },
                  onClick: handleDelete,
                  children: "Sim"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "error",
                  sx: { borderColor: "red", color: "red" },
                  onClick: handleClose,
                  children: "No"
                }
              )
            ] })
          ]
        }
      )
    }
  ) });
}
__name(DeleteMovimentationFileModal, "DeleteMovimentationFileModal");
const VisuallyHiddenInput$2 = styled$1("input")({
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: 1,
  overflow: "hidden",
  position: "absolute",
  bottom: 0,
  left: 0,
  whiteSpace: "nowrap",
  width: 1
});
const StyledBadge = styled$1(Badge)(({ theme: theme2 }) => ({
  "& .MuiBadge-badge": {
    right: -3,
    top: 13,
    border: `2px solid ${theme2.palette.background.paper}`,
    padding: "0 4px"
  }
}));
const MovimentationFileModal = reactExports.memo(
  ({ movementationId }) => {
    console.log("renderizou MovimentationFileModal");
    const {
      toggleMovementationFileOpen,
      movementationFileOpen,
      refreshMovementationFile,
      toggleRefreshMovementationFile,
      toggleDeletingMovimentationFile
    } = reactExports.useContext(MovementationFileContext);
    const { user } = reactExports.useContext(userContext);
    const { id_patrimonio } = useParams();
    const handleOpen = /* @__PURE__ */ __name(() => toggleMovementationFileOpen(movementationId), "handleOpen");
    const handleClose = /* @__PURE__ */ __name(() => toggleMovementationFileOpen(), "handleClose");
    const [fileData, setFileData] = reactExports.useState();
    const [responsable, setResponsable] = reactExports.useState(0);
    const [isLoading, setIsLoading] = reactExports.useState(false);
    const fetchFileData = reactExports.useCallback(async () => {
      if (movementationId) {
        const fileData2 = await getMovementationFiles(movementationId);
        const responsable2 = await getResponsableForPatrimony(
          Number(id_patrimonio)
        );
        if (responsable2) {
          setResponsable(responsable2[0].id_responsavel);
        }
        if (fileData2) {
          setFileData(fileData2);
        }
      }
    }, [id_patrimonio, movementationId]);
    const handleUploadFile = /* @__PURE__ */ __name(async (e2) => {
      console.log("handleUploadFile");
      setIsLoading(true);
      if (movementationId && e2.target.files) {
        const file = e2.target.files[0];
        const formData = new FormData();
        formData.append("file", file);
        try {
          await createMovementationfile(movementationId, formData);
          toggleRefreshMovementationFile();
        } catch (error) {
          alert("Error uploading file: \n" + error);
        } finally {
          setIsLoading(false);
        }
      }
    }, "handleUploadFile");
    const allowedToAttachFile = /* @__PURE__ */ __name(() => {
      return (user == null ? void 0 : user.CODPESSOA) === responsable || (user == null ? void 0 : user.PERM_ADMINISTRADOR);
    }, "allowedToAttachFile");
    const isPDF2 = /* @__PURE__ */ __name((file) => {
      return /\.pdf$/i.test(file.arquivo);
    }, "isPDF");
    const isImage2 = /* @__PURE__ */ __name((file) => {
      return /\.(jpg|jpeg|png|gif)$/i.test(file.arquivo);
    }, "isImage");
    const handleOpenLink = /* @__PURE__ */ __name((url) => {
      window.open(url, "_blank");
    }, "handleOpenLink");
    reactExports.useEffect(() => {
      fetchFileData();
    }, [fetchFileData, refreshMovementationFile]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Anexos da movimentao", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { "aria-label": "cart", onClick: handleOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledBadge, { badgeContent: fileData == null ? void 0 : fileData.length, color: "secondary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$a, { sx: { color: "#F7941E" } }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal$1,
        {
          "aria-labelledby": "transition-modal-title",
          "aria-describedby": "transition-modal-description",
          open: movementationFileOpen[0] && movementationFileOpen[1] === Number(movementationId),
          onClose: handleClose,
          closeAfterTransition: true,
          slots: { backdrop: StyledBackdrop$1 },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, { in: movementationFileOpen[0], children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            ModalContent,
            {
              sx: {
                ...style$8,
                minWidth: "260px",
                width: {
                  xs: "260px",
                  sm: "400px",
                  md: "500px",
                  lg: "600px"
                }
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteMovimentationFileModal, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "center", padding: 0.6, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", textAlign: "center", children: "Anexos" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { children: [
                      "Movimentao: ",
                      movementationFileOpen[1]
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IconButton,
                    {
                      onClick: handleClose,
                      sx: {
                        color: "red",
                        position: "absolute",
                        right: "1rem",
                        top: "1rem"
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {})
                    }
                  )
                ] }),
                allowedToAttachFile() ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Button,
                  {
                    component: "label",
                    role: void 0,
                    variant: "contained",
                    tabIndex: -1,
                    startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$9, {}),
                    sx: BaseButtonStyles,
                    children: [
                      "Anexar",
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        VisuallyHiddenInput$2,
                        {
                          onChange: handleUploadFile,
                          type: "file"
                        }
                      )
                    ]
                  }
                ) : "",
                isLoading && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Stack,
                  {
                    direction: "row",
                    justifyContent: "center",
                    alignItems: "center",
                    sx: { mt: 2 },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { ml: 2 }, children: "Enviando..." })
                    ]
                  }
                ),
                fileData == null ? void 0 : fileData.map((file) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Box,
                  {
                    sx: { borderRadius: "10px" },
                    className: "border border-gray-300",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Stack,
                      {
                        direction: "row",
                        gap: 1,
                        flexWrap: "wrap",
                        padding: 1,
                        height: "fit-content",
                        sx: {
                          cursor: "pointer",
                          color: "blue",
                          textDecoration: "underline"
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Box,
                            {
                              sx: {
                                height: {
                                  xs: "100px",
                                  sm: "150px",
                                  md: "200px",
                                  lg: "300px"
                                },
                                borderRadius: "10px",
                                width: {
                                  xs: "100%",
                                  sm: "100%",
                                  lg: "100%"
                                },
                                background: isImage2(file) ? `url('${file.arquivo}')` : "none",
                                backgroundPosition: "center",
                                backgroundSize: "cover",
                                backgroundRepeat: "no-repeat"
                              },
                              children: isPDF2(file) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "object",
                                {
                                  data: file.arquivo,
                                  type: "application/pdf",
                                  width: "100%",
                                  height: "100%"
                                }
                              )
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            Box,
                            {
                              sx: {
                                borderRadius: "10px",
                                display: "flex",
                                flexDirection: "row",
                                alignItems: "center",
                                flexWrap: "wrap",
                                width: {
                                  xs: "100%",
                                  lg: "50%"
                                }
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  Typography,
                                  {
                                    onClick: () => handleOpenLink(file.arquivo),
                                    fontSize: "small",
                                    overflow: "hidden",
                                    children: file.nome_arquivo
                                  }
                                ),
                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  IconButton,
                                  {
                                    onClick: () => toggleDeletingMovimentationFile(true, file),
                                    sx: {
                                      color: "blue",
                                      textTransform: "underline",
                                      marginLeft: 1
                                    },
                                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$t, { sx: { color: "#F7941E" } })
                                  }
                                )
                              ]
                            }
                          )
                        ]
                      }
                    )
                  }
                ))
              ]
            }
          ) })
        }
      )
    ] });
  }
);
const Backdrop$1 = reactExports.forwardRef(
  (props, ref) => {
    const { open: open2, ...other } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, { in: open2, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, ...other }) });
  }
);
const grey = {
  50: "#F3F6F9",
  100: "#E5EAF2",
  200: "#DAE2ED",
  300: "#C7D0DD",
  400: "#B0B8C4",
  500: "#9DA8B7",
  600: "#6B7A90",
  700: "#434D5B",
  800: "#303740",
  900: "#1C2025"
};
const Modal$1 = styled$1(Modal$2)`
  position: fixed;
  z-index: 1300;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
`;
const StyledBackdrop$1 = styled$1(Backdrop$1)`
  z-index: -1;
  position: fixed;
  inset: 0;
  background-color: rgb(0 0 0 / 0.5);
  -webkit-tap-highlight-color: transparent;
`;
const style$8 = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  display: "flex",
  flexDirection: "column",
  gap: "1rem",
  overFlowX: "scroll"
};
const ModalContent = styled$1("div")(
  ({ theme: theme2 }) => css`
    font-family: "IBM Plex Sans", sans-serif;
    font-weight: 500;
    text-align: start;
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow: hidden;

    flex-shrink: 1;
    background-color: ${theme2.palette.mode === "dark" ? grey[900] : "#fff"};
    border-radius: 8px;
    border: 1px solid ${theme2.palette.mode === "dark" ? grey[700] : grey[200]};
    box-shadow: 0 4px 12px
      ${theme2.palette.mode === "dark" ? "rgb(0 0 0 / 0.5)" : "rgb(0 0 0 / 0.2)"};
    padding: 10px;
    color: ${theme2.palette.mode === "dark" ? grey[50] : grey[900]};
    & .modal-title {
      margin: 0;
      line-height: 1.5rem;
      margin-bottom: 8px;
    }

    & .modal-description {
      margin: 0;
      line-height: 1.5rem;
      font-weight: 400;
      color: ${theme2.palette.mode === "dark" ? grey[400] : grey[800]};
      margin-bottom: 4px;
    }
  `
);
var Edit = {};
var _interopRequireDefault$d = interopRequireDefaultExports;
Object.defineProperty(Edit, "__esModule", {
  value: true
});
var default_1$8 = Edit.default = void 0;
var _createSvgIcon$8 = _interopRequireDefault$d(requireCreateSvgIcon());
var _jsxRuntime$8 = jsxRuntimeExports;
default_1$8 = Edit.default = (0, _createSvgIcon$8.default)(/* @__PURE__ */ (0, _jsxRuntime$8.jsx)("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z"
}), "Edit");
const style$7 = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: "fit-content",
  bgcolor: "background.paper",
  boxShadow: 24,
  p: 4
};
function DeleteMovementationModal() {
  const {
    toggleDeletingMovementation,
    deletingMovementation,
    toggleRefreshMovimentation
  } = reactExports.useContext(MovimentationContext);
  const handleClose = /* @__PURE__ */ __name(() => toggleDeletingMovementation(), "handleClose");
  const handleDelete = /* @__PURE__ */ __name(async () => {
    if (deletingMovementation[0] && deletingMovementation[1]) {
      const response = await deleteMovementation(
        deletingMovementation[1].id_movimentacao,
        deletingMovementation[1].id_patrimonio
      );
      if (response && response.status === 200) {
        toggleRefreshMovimentation();
        toggleDeletingMovementation();
        return;
      }
      alert(response == null ? void 0 : response.data.message);
    }
  }, "handleDelete");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: deletingMovementation[0],
      onClose: handleClose,
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            ...style$7,
            display: "flex",
            flexDirection: "column",
            gap: "1rem"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { id: "modal-modal-title", variant: "h6", component: "h2", children: [
              "tem certeza de que deseja deletar esta Movimentao?",
              " "
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "center", spacing: 2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "primary",
                  sx: { borderColor: "blue", color: "blue" },
                  onClick: handleDelete,
                  children: "Sim"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "error",
                  sx: { borderColor: "red", color: "red" },
                  onClick: handleClose,
                  children: "No"
                }
              )
            ] })
          ]
        }
      )
    }
  ) });
}
__name(DeleteMovementationModal, "DeleteMovementationModal");
var Cancel = {};
var _interopRequireDefault$c = interopRequireDefaultExports;
Object.defineProperty(Cancel, "__esModule", {
  value: true
});
var default_1$7 = Cancel.default = void 0;
var _createSvgIcon$7 = _interopRequireDefault$c(requireCreateSvgIcon());
var _jsxRuntime$7 = jsxRuntimeExports;
default_1$7 = Cancel.default = (0, _createSvgIcon$7.default)(/* @__PURE__ */ (0, _jsxRuntime$7.jsx)("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2m5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12z"
}), "Cancel");
const style$6 = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: "fit-content",
  flexShrink: 1,
  display: "flex",
  flexDirection: "column",
  gap: "1rem",
  bgcolor: "background.paper",
  boxShadow: 24,
  p: 4
};
function EditMovimentationObservationModal() {
  var _a2, _b2;
  const {
    editingMovementationObservation,
    togglEditingMovementationObservation,
    toggleRefreshMovimentation
  } = reactExports.useContext(MovimentationContext);
  reactExports.useContext(userContext);
  const [observation, setObservation] = reactExports.useState(((_a2 = editingMovementationObservation[1]) == null ? void 0 : _a2.observacao) || "");
  const handleChange = /* @__PURE__ */ __name((e2) => {
    const { value } = e2.target;
    console.log("value: ", value);
    setObservation(value);
  }, "handleChange");
  const handleSave = /* @__PURE__ */ __name(async () => {
    if (editingMovementationObservation[1]) {
      const response = await updateMovementation({
        ...editingMovementationObservation[1],
        ["observacao"]: observation
      });
      if (response && response.status === 200) {
        toggleRefreshMovimentation();
        togglEditingMovementationObservation(false);
        return;
      }
    }
    window.alert("Erro ao editar Observao");
  }, "handleSave");
  const handleClose = /* @__PURE__ */ __name(() => togglEditingMovementationObservation(false), "handleClose");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: editingMovementationObservation[0],
      onClose: handleClose,
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: style$6, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            id: "modal-modal-title",
            variant: "h6",
            component: "h2",
            children: "Editar observao"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            multiline: true,
            onChange: handleChange,
            defaultValue: (_b2 = editingMovementationObservation[1]) == null ? void 0 : _b2.observacao,
            sx: { mt: 2 }
          }
        ),
        editingMovementationObservation[0] && editingMovementationObservation[1] && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outlined",
              onClick: handleSave,
              sx: { width: "1rem", marginX: "1rem" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$g, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outlined",
              onClick: () => togglEditingMovementationObservation(false),
              sx: {
                width: "1rem",
                marginX: "1rem",
                color: "red"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$7, {})
            }
          )
        ] })
      ] })
    }
  ) });
}
__name(EditMovimentationObservationModal, "EditMovimentationObservationModal");
const cardColumns = [
  { label: "Projeto", dataKey: "projeto" },
  { label: "Observao", dataKey: "observacao" },
  { label: "Data", dataKey: "data" },
  { label: "Responsvel", dataKey: "responsavel" },
  { label: "N Movimentao", dataKey: "id_movimentacao" }
];
const MovementationCard = /* @__PURE__ */ __name(({
  cardData,
  props,
  key
}) => {
  const { index: index2, style: style2, data } = props;
  console.log({ index: index2, style: style2, data });
  console.log(cardData);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { ...style2, ...basicCardStyles }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: basicCardContentStyles, className: "shadow-sm shadow-gray-600", children: [
    cardColumns.map((column2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { marginBottom: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", gap: 1, alignItems: "center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { fontSize: "small", fontWeight: "bold", color: "black", children: [
        column2.label,
        ":"
      ] }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", color: "textSecondary", children: cardData[column2.dataKey] })
    ] }) }, column2.dataKey)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MovimentationFileModal, { movementationId: cardData.id_movimentacao })
  ] }) }, key);
}, "MovementationCard");
const columns$2 = [
  { label: "Projeto", width: 190, dataKey: "projeto" },
  { label: "Observao", width: 200, dataKey: "observacao" },
  { label: "Data", width: 150, dataKey: "data" },
  { label: "Responsvel", width: 150, dataKey: "responsavel" },
  { label: "N Movimentao", width: 150, dataKey: "id_movimentacao" }
];
const VirtuosoTableComponents$1 = {
  Scroller: reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { component: Paper, ...props, ref })),
  Table: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Table$1,
    {
      ...props,
      sx: { borderCollapse: "separate", tableLayout: "fixed" }
    }
  ),
  TableHead: reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    TableHead,
    {
      sx: { boxShadow: "none", border: "none" },
      ...props,
      ref
    }
  )),
  TableRow,
  TableBody: reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { ...props, ref }))
};
function fixedHeaderContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: columns$2.map((column2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    TableCell,
    {
      sx: {
        width: column2.width,
        backgroundColor: "background.paper",
        border: "none"
      },
      children: column2.label
    },
    column2.dataKey
  )) });
}
__name(fixedHeaderContent, "fixedHeaderContent");
const RowContent = reactExports.memo(
  ({
    row,
    singleMovementation
  }) => {
    console.log("renderizou RowContent");
    const {
      togglEditingMovementationObservation,
      toggleDeletingMovementation
    } = reactExports.useContext(MovimentationContext);
    const { user } = reactExports.useContext(userContext);
    const handleClickDeleteMovimentation = /* @__PURE__ */ __name((row2) => {
      if (singleMovementation()) {
        alert("No  permitido excluir a nica movimentao!");
        return;
      }
      if (!isWhoCreated() && !(user == null ? void 0 : user.PERM_ADMINISTRADOR)) {
        alert(
          "Apenas quem criou ou o administrador pode excluir a movimentao!"
        );
        return;
      }
      toggleDeletingMovementation(row2);
    }, "handleClickDeleteMovimentation");
    const isWhoCreated = /* @__PURE__ */ __name(() => (user == null ? void 0 : user.CODPESSOA) === row.id_ultimo_responsavel, "isWhoCreated");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: columns$2.map((column2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      TableCell,
      {
        sx: {
          paddingY: "6px",
          border: "none",
          width: column2.width
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Stack,
          {
            direction: "row",
            spacing: 1,
            alignItems: "center",
            justifyContent: column2.dataKey === "id_movimentacao" ? "end" : "space-between",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { fontSize: "12px", textAlign: "left" }, children: column2.dataKey === "data" ? dateTimeRenderer(row.data) : row[column2.dataKey] || "-" }),
              column2.dataKey === "projeto" && /* @__PURE__ */ jsxRuntimeExports.jsx(MovimentationFileModal, { movementationId: row.id_movimentacao }),
              column2.dataKey === "observacao" && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Editar Observao", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  onClick: () => togglEditingMovementationObservation(true, row),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$8, { sx: { color: "#F7941E" } })
                }
              ) }),
              column2.dataKey === "id_movimentacao" && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Excluir Movimentao", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  onClick: () => handleClickDeleteMovimentation(row),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$t, { sx: { color: "#F7941E" } })
                }
              ) })
            ]
          }
        )
      },
      column2.dataKey
    )) });
  }
);
const MovimentationTable = reactExports.memo(() => {
  const { id_patrimonio } = useParams();
  const [movementations, setMovementations] = reactExports.useState(
    []
  );
  const [isMobile, setIsMobile] = reactExports.useState(false);
  const [isCardViewActive, setIsCardViewActive] = reactExports.useState(false);
  const { refreshMovimentation } = reactExports.useContext(MovimentationContext);
  const fetchMovementations = reactExports.useCallback(async () => {
    const movementationsData = await getMovementationsByPatrimonyId(
      Number(id_patrimonio)
    );
    if (movementationsData)
      setMovementations([...movementationsData]);
  }, [id_patrimonio]);
  const singleMovementation = /* @__PURE__ */ __name(() => movementations.length === 1, "singleMovementation");
  reactExports.useEffect(() => {
    fetchMovementations();
    setIsMobile(window.innerWidth <= 768);
    setIsCardViewActive(window.innerWidth <= 768);
  }, [fetchMovementations, refreshMovimentation]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        height: "90%",
        width: "100%",
        paddingRight: isMobile ? 1 : 0,
        boxShadow: "none"
      },
      children: [
        isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableViewToggleButton,
          {
            isCardViewActive,
            setIsCardViewActive
          }
        ),
        !isCardViewActive && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableVirtuoso,
          {
            style: { boxShadow: "none" },
            data: movementations,
            components: {
              ...VirtuosoTableComponents$1,
              TableRow: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                TableRow,
                {
                  ...props,
                  sx: {
                    cursor: "pointer",
                    "&:hover": { backgroundColor: "#e7eaf6" }
                  }
                }
              )
            },
            fixedHeaderContent,
            itemContent: (_index, row) => /* @__PURE__ */ jsxRuntimeExports.jsx(RowContent, { row, singleMovementation })
          }
        ),
        isCardViewActive && /* @__PURE__ */ jsxRuntimeExports.jsx(
          FixedSizeList,
          {
            height: 600,
            width: "100%",
            itemSize: 320,
            itemCount: movementations.length,
            overscanCount: 1,
            children: ({ index: index2, style: style2, data }) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                MovementationCard,
                {
                  props: { index: index2, style: style2, data },
                  cardData: movementations[index2]
                },
                index2
              );
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteMovementationModal, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(EditMovimentationObservationModal, {})
      ]
    }
  );
});
const PatrimonyFileContext = reactExports.createContext({
  refreshPatrimonyFile: false,
  patrimonyFileOpen: [false],
  patrimonyFiles: [],
  togglePatrimonyFileOpen: () => {
  },
  toggleRefreshPatrimonyFile: () => {
  },
  deletingPatrimonyFile: [false],
  toggleDeletingPatrimonyFile: () => {
  },
  changePatrimonyFiles: () => {
  }
});
const PatrimonyFileContextProvider = /* @__PURE__ */ __name(({
  children
}) => {
  const [patrimonyFileOpen, setPatrimonyFileOpen] = reactExports.useState([false]);
  const [refreshPatrimonyFile, setRefreshPatrimonyFile] = reactExports.useState(false);
  const [deletingPatrimonyFile, setDeletingPatrimonyFile] = reactExports.useState([false]);
  const [patrimonyFiles, setPatrimonyFiles] = reactExports.useState([]);
  const changePatrimonyFiles = /* @__PURE__ */ __name((files) => {
    setPatrimonyFiles([...files]);
  }, "changePatrimonyFiles");
  const togglePatrimonyFileOpen = /* @__PURE__ */ __name((patrimonyId) => {
    setPatrimonyFileOpen(patrimonyFileOpen[0] ? [false] : [true, patrimonyId]);
  }, "togglePatrimonyFileOpen");
  const toggleDeletingPatrimonyFile = /* @__PURE__ */ __name((isDeleting, patrimonyFile) => {
    console.log("toggleDeletingPatrimonyFile");
    setDeletingPatrimonyFile(isDeleting ? [true, patrimonyFile] : [false]);
  }, "toggleDeletingPatrimonyFile");
  const toggleRefreshPatrimonyFile = /* @__PURE__ */ __name(() => {
    setRefreshPatrimonyFile((prev2) => !prev2);
  }, "toggleRefreshPatrimonyFile");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    PatrimonyFileContext.Provider,
    {
      value: {
        refreshPatrimonyFile,
        patrimonyFileOpen,
        deletingPatrimonyFile,
        patrimonyFiles,
        changePatrimonyFiles,
        togglePatrimonyFileOpen,
        toggleRefreshPatrimonyFile,
        toggleDeletingPatrimonyFile
      },
      children
    }
  );
}, "PatrimonyFileContextProvider");
const style$5 = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: "fit-content",
  bgcolor: "background.paper",
  boxShadow: 24,
  p: 4
};
function DeletePatrimonyFileModal() {
  const {
    toggleDeletingPatrimonyFile,
    deletingPatrimonyFile,
    toggleRefreshPatrimonyFile
  } = reactExports.useContext(PatrimonyFileContext);
  const handleClose = /* @__PURE__ */ __name(() => toggleDeletingPatrimonyFile(false), "handleClose");
  const handleDelete = /* @__PURE__ */ __name(async () => {
    console.log("\nhandleDelete");
    if (deletingPatrimonyFile[0] && deletingPatrimonyFile[1]) {
      const response = await deletePatrimonyFileModal(
        deletingPatrimonyFile[1].id_anexo_patrimonio,
        deletingPatrimonyFile[1].nome_arquivo
      );
      if (response && response.status === 200) {
        toggleRefreshPatrimonyFile();
        toggleDeletingPatrimonyFile(false);
        return;
      }
    }
  }, "handleDelete");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: deletingPatrimonyFile[0],
      onClose: handleClose,
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            ...style$5,
            display: "flex",
            flexDirection: "column",
            gap: "1rem"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { id: "modal-modal-title", variant: "h6", component: "h2", children: "Tem certeza que deseja deletar este anexo?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "center", spacing: 2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "primary",
                  sx: { borderColor: "blue", color: "blue" },
                  onClick: handleDelete,
                  children: "Sim"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  color: "error",
                  sx: { borderColor: "red", color: "red" },
                  onClick: handleClose,
                  children: "No"
                }
              )
            ] })
          ]
        }
      )
    }
  ) });
}
__name(DeletePatrimonyFileModal, "DeletePatrimonyFileModal");
const styles$7 = {
  badge: {
    // Estilos para o Badge (se necessrio)
  },
  iconButton: {
    color: "#F7941E"
  },
  modalContent: {
    minWidth: "260px",
    overflowY: "scroll",
    backgroundColor: "white",
    ":: -webkit-scrollbar": {
      display: "none"
    },
    paddingY: 2,
    borderRadius: 5,
    minHeight: 500,
    maxHeight: 600,
    position: "relative",
    display: "flex",
    flexDirection: "column",
    gap: 2,
    width: {
      xs: "95%",
      sm: "400px",
      md: "500px",
      lg: "600px"
    }
  },
  modalHeader: {
    display: "flex",
    justifyContent: "start",
    alignItems: "start",
    gap: 1,
    top: 0,
    transform: "translateY(-1rem)",
    padding: 2,
    zIndex: 20,
    position: "sticky",
    backgroundColor: "white",
    width: "100%"
  },
  closeIconButton: {
    color: "red",
    position: "fixed",
    right: 0,
    top: 0,
    zIndex: 30
  },
  uploadButton: {
    // Estilos para o boto de upload (se necessrio)
  },
  loadingStack: {
    mt: 2,
    mx: "auto"
  },
  fileListStack: {
    gap: 1,
    padding: 1
  },
  card: {
    minHeight: 350,
    width: "100%"
  },
  cardMedia: (file) => ({
    height: 300,
    borderRadius: 5,
    width: "100%",
    background: isImage(file) ? `url('${file.arquivo}')` : "none",
    backgroundPosition: "center",
    backgroundSize: "cover",
    backgroundRepeat: "no-repeat"
  }),
  cardContent: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    flexWrap: "wrap",
    padding: 1
  },
  fileName: {
    cursor: "pointer",
    color: "blue",
    textDecoration: "underline",
    flex: 1,
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis"
  },
  deleteIconButton: {
    color: "#F7941E"
  },
  imageModal: {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: "90%",
    height: "90%",
    bgcolor: "background.paper",
    border: "1px solid #000",
    boxShadow: 24,
    p: 2
  },
  imageModalCloseIcon: {
    position: "absolute",
    top: 8,
    right: 8
  },
  imageModalBox: (fileSelected) => ({
    height: "100%",
    backgroundImage: `url('${fileSelected}')`,
    backgroundSize: "contain",
    backgroundRepeat: "no-repeat",
    backgroundPosition: "center"
  })
};
const isImage = /* @__PURE__ */ __name((file) => {
  return file.arquivo && !isPDF(file.arquivo);
}, "isImage");
const isPDF = /* @__PURE__ */ __name((arquivo) => {
  return arquivo == null ? void 0 : arquivo.endsWith(".pdf");
}, "isPDF");
const FileViewer = /* @__PURE__ */ __name(({
  fileViewerOpen,
  fileUrl,
  fileName,
  isPDF: isPDF2,
  handleCloseFileViewer
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: fileViewerOpen,
      sx: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            width: "90%",
            height: "90%",
            padding: 2,
            background: "#fff",
            position: "relative",
            borderRadius: "8px",
            boxShadow: "0px 2px 12px rgba(0, 0, 0, 0.3)",
            overflow: "hidden"
          },
          children: [
            fileUrl && isPDF2(fileName) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              Box,
              {
                width: "100%",
                component: "iframe",
                src: fileUrl,
                sx: {
                  height: "100%",
                  width: "100%",
                  objectFit: "fill"
                  // Fora a ocupar a largura total
                }
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Box,
              {
                component: "img",
                src: fileUrl || "",
                alt: "Selected",
                sx: {
                  width: "100%",
                  height: "100%",
                  objectFit: "contain",
                  background: "#fff"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                sx: {
                  backgroundColor: "white",
                  position: "absolute",
                  right: 0,
                  top: 0,
                  "&:hover": {
                    backgroundColor: "white"
                  }
                },
                onClick: handleCloseFileViewer,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, { sx: { color: "red" } })
              }
            )
          ]
        }
      )
    }
  );
}, "FileViewer");
FileViewer.displayName = "FileView";
const PatrimonyFileCard = /* @__PURE__ */ __name(({
  file
}) => {
  const [fileSelected, setFileSelected] = reactExports.useState();
  const { toggleDeletingPatrimonyFile } = reactExports.useContext(PatrimonyFileContext);
  const handleOpenLink = /* @__PURE__ */ __name((url) => {
    window.open(url, "_blank");
  }, "handleOpenLink");
  const openFile = /* @__PURE__ */ __name((file2) => {
    console.log({ isPd: isPDF2(file2.arquivo) });
    setFileSelected(file2.arquivo);
  }, "openFile");
  const isPDF2 = /* @__PURE__ */ __name((arquivo) => {
    return arquivo == null ? void 0 : arquivo.endsWith(".pdf");
  }, "isPDF");
  const truncateText = /* @__PURE__ */ __name((text, maxLength) => {
    if (text.length > maxLength) {
      return text.substring(0, maxLength) + "...";
    }
    return text;
  }, "truncateText");
  const handleCloseImageModal = /* @__PURE__ */ __name(() => {
    setFileSelected(null);
  }, "handleCloseImageModal");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Card,
    {
      sx: {
        ...basicCardContentStyles,
        minHeight: 350,
        width: "100%",
        gap: 2
      },
      className: "border border-gray-300",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative", width: "100%" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CardMedia,
            {
              component: isPDF2(file.arquivo) ? "object" : "div",
              data: isPDF2(file.arquivo) ? file.arquivo : void 0,
              src: isPDF2(file.arquivo) ? void 0 : file.arquivo,
              type: isPDF2(file.arquivo) ? "application/pdf" : void 0,
              sx: styles$7.cardMedia(file)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              onClick: () => openFile(file),
              style: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                cursor: "pointer",
                // Mostra que a rea  clicvel
                zIndex: 1
                // Garante que o overlay fique acima do <object>
              }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              onClick: () => handleOpenLink(file.arquivo),
              fontSize: "small",
              sx: styles$7.fileName,
              children: truncateText(file.nome_arquivo, 20)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              onClick: () => toggleDeletingPatrimonyFile(true, file),
              sx: styles$7.deleteIconButton,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$t, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            FileViewer,
            {
              fileViewerOpen: !!fileSelected,
              fileUrl: fileSelected || "",
              fileName: fileSelected || "",
              isPDF: isPDF2,
              handleCloseFileViewer: handleCloseImageModal
            }
          )
        ] })
      ]
    },
    file.id_anexo_patrimonio
  );
}, "PatrimonyFileCard");
const VisuallyHiddenInput$1 = styled$1("input")({
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: 1,
  overflow: "hidden",
  position: "absolute",
  bottom: 0,
  left: 0,
  whiteSpace: "nowrap",
  width: 1
});
function PatrimonyFileModal() {
  const { id_patrimonio } = useParams();
  const { user } = reactExports.useContext(userContext);
  const [open2, setOpen] = reactExports.useState(false);
  const handleOpen = /* @__PURE__ */ __name(() => setOpen(true), "handleOpen");
  const handleClose = /* @__PURE__ */ __name(() => setOpen(false), "handleClose");
  const [fileData, setFileData] = reactExports.useState();
  const { refreshPatrimonyFile, toggleRefreshPatrimonyFile } = reactExports.useContext(PatrimonyFileContext);
  reactExports.useContext(PatrimonyFileContext);
  const [responsable, setResponsable] = reactExports.useState();
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const modaleHeaderRef = reactExports.useRef(null);
  const fetchPatrimonyFiles = /* @__PURE__ */ __name(async () => {
    console.log("fetchPatrimonyFiles");
    const data = await getPatrimonyFiles(Number(id_patrimonio));
    const responsableData = await getResponsableForPatrimony(
      Number(id_patrimonio)
    );
    if (responsableData) {
      setResponsable(responsableData[0].id_responsavel);
    }
    if (data) {
      setFileData(data);
    }
  }, "fetchPatrimonyFiles");
  const handleUploadFile = /* @__PURE__ */ __name(async (e2) => {
    if (e2.target.files && id_patrimonio) {
      setIsLoading(true);
      const file = e2.target.files[0];
      const formData = new FormData();
      formData.append("file", file);
      const response = await createPatrimonyfile(
        Number(id_patrimonio),
        formData
      );
      if (response && response.status === 200) {
        setIsLoading(false);
        toggleRefreshPatrimonyFile();
        return;
      }
      window.alert("Erro ao fazer upload!");
      setIsLoading(false);
    }
  }, "handleUploadFile");
  const allowedToAttachFile = /* @__PURE__ */ __name(() => {
    return (user == null ? void 0 : user.CODPESSOA) === responsable || (user == null ? void 0 : user.PERM_ADMINISTRADOR);
  }, "allowedToAttachFile");
  reactExports.useEffect(() => {
    fetchPatrimonyFiles();
  }, [refreshPatrimonyFile]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { badgeContent: (fileData == null ? void 0 : fileData.length) || 0, color: "primary", sx: styles$7.badge, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Anexos do patrimnio", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleOpen, sx: styles$7.iconButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$a, {}) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Modal,
      {
        "aria-labelledby": "transition-modal-title",
        "aria-describedby": "transition-modal-description",
        open: open2,
        onClose: handleClose,
        closeAfterTransition: true,
        slots: { backdrop: StyledBackdrop },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, { in: open2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: styles$7.modalContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DeletePatrimonyFileModal, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { sx: styles$7.modalHeader, ref: modaleHeaderRef, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleClose, sx: styles$7.closeIconButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading2, children: "Anexos do patrimnio" }),
            allowedToAttachFile() && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                component: "label",
                role: void 0,
                variant: "contained",
                tabIndex: -1,
                startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$9, {}),
                sx: { ...BaseButtonStyles, width: 100 },
                children: [
                  "Anexar",
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    VisuallyHiddenInput$1,
                    {
                      accept: "image/*, application/pdf",
                      capture: "environment",
                      onChange: handleUploadFile,
                      type: "file",
                      sx: BaseButtonStyles
                    }
                  )
                ]
              }
            )
          ] }),
          isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { sx: styles$7.loadingStack, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}) }),
          modaleHeaderRef && /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { sx: { ...styles$7.fileListStack }, children: fileData == null ? void 0 : fileData.map((file) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            PatrimonyFileCard,
            {
              file
            }
          )) })
        ] }) })
      }
    )
  ] });
}
__name(PatrimonyFileModal, "PatrimonyFileModal");
const Backdrop = reactExports.forwardRef(
  (props, ref) => {
    const { open: open2, ...other } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, { in: open2, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, ...other }) });
  }
);
const Modal = styled$1(Modal$2)`
  position: fixed;
  z-index: 1300;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
`;
const StyledBackdrop = styled$1(Backdrop)`
  z-index: -1;
  position: fixed;
  inset: 0;
  background-color: rgb(0 0 0 / 0.5);
  -webkit-tap-highlight-color: transparent;
`;
var HomeRepairService = {};
var _interopRequireDefault$b = interopRequireDefaultExports;
Object.defineProperty(HomeRepairService, "__esModule", {
  value: true
});
var default_1$6 = HomeRepairService.default = void 0;
var _createSvgIcon$6 = _interopRequireDefault$b(requireCreateSvgIcon());
var _jsxRuntime$6 = jsxRuntimeExports;
default_1$6 = HomeRepairService.default = (0, _createSvgIcon$6.default)(/* @__PURE__ */ (0, _jsxRuntime$6.jsx)("path", {
  d: "M18 16h-2v-1H8v1H6v-1H2v5h20v-5h-4zm2-8h-3V6c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v4h4v-2h2v2h8v-2h2v2h4v-4c0-1.1-.9-2-2-2m-5 0H9V6h6z"
}), "HomeRepairService");
const style$4 = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: "fit-content",
  bgcolor: "background.paper",
  display: "flex",
  flexDirection: "column",
  flexShrink: 1,
  boxShadow: 24,
  p: 4
};
function CreatePatrimonyAccessoryModal() {
  const { creatingPatrimonyAccessory, toggleCreatingPatrimonyAccessory, toggleRefreshPatrimonyAccessory } = reactExports.useContext(PatrimonyInfoContext);
  const { id_patrimonio } = useParams();
  const [patrimonyAccessory, setPatrimonyAccessory] = reactExports.useState({
    descricao: "",
    id_acessorio_patrimonio: 0,
    nome: "",
    id_patrimonio: Number(id_patrimonio)
  });
  const handleClose = /* @__PURE__ */ __name(() => toggleCreatingPatrimonyAccessory(), "handleClose");
  const handleChange = /* @__PURE__ */ __name((e2, key) => {
    const { value } = e2.currentTarget;
    setPatrimonyAccessory({
      ...patrimonyAccessory,
      [key]: value
    });
  }, "handleChange");
  const clearState = /* @__PURE__ */ __name(() => {
    setPatrimonyAccessory({
      descricao: "",
      id_acessorio_patrimonio: 0,
      nome: "",
      id_patrimonio: Number(id_patrimonio)
    });
  }, "clearState");
  const handleSave = /* @__PURE__ */ __name(async () => {
    console.log("Saving patrimony accessory:", patrimonyAccessory);
    try {
      const response = await createAccessory(patrimonyAccessory);
      console.log("Accessory created successfully:", response);
      clearState();
      toggleRefreshPatrimonyAccessory();
      toggleCreatingPatrimonyAccessory();
    } catch (error) {
      console.error("Failed to create accessory:", error);
    }
  }, "handleSave");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { children: !open && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: toggleCreatingPatrimonyAccessory, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$6, { sx: { color: "#F7941E" } }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Modal$3,
      {
        open: creatingPatrimonyAccessory,
        onClose: handleClose,
        "aria-labelledby": "modal-modal-title",
        "aria-describedby": "modal-modal-description",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { ...style$4, gap: "1rem" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", spacing: 2, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { id: "modal-modal-title", variant: "h6", component: "h2", children: "Novo Acessrio de Patrimnio" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                onClick: toggleCreatingPatrimonyAccessory,
                sx: { color: "red" },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {})
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "column", spacing: 2, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                required: true,
                label: "Nome",
                value: patrimonyAccessory.nome,
                onChange: (e2) => handleChange(e2, "nome")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                required: true,
                label: "Descrio",
                value: patrimonyAccessory.descricao,
                onChange: (e2) => handleChange(e2, "descricao")
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: handleSave,
              sx: { width: "1rem", marginX: "1rem", marginTop: "1rem" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$g, {})
            }
          )
        ] })
      }
    )
  ] });
}
__name(CreatePatrimonyAccessoryModal, "CreatePatrimonyAccessoryModal");
const CameraFileLogo = "/assets/cameraFileLogo-Chy76Qi9-Chy76Qi9-Chy76Qi9.png";
const modalStyle = /* @__PURE__ */ __name((theme2) => ({
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: "90%",
  maxWidth: 600,
  maxHeight: 600,
  bgcolor: "background.paper",
  boxShadow: 24,
  display: "flex",
  flexDirection: "column",
  overflowY: "scroll",
  gap: "2rem",
  p: 4,
  [theme2.breakpoints.down("sm")]: {
    width: "100%",
    // Full width on mobile
    p: 2
  }
}), "modalStyle");
const style$3 = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: "fit-content",
  bgcolor: "background.paper",
  boxShadow: 24,
  p: 4
};
function PatrimonyAccessoryModal() {
  const { id_patrimonio } = useParams();
  const {
    deletingPatrimonyAccessory,
    refreshPatrimonyAccessory,
    refreshPatrimonyAccessoryFiles,
    toggleCreatingPatrimonyAccessory,
    toggleDeletingPatrimonyAccessory,
    toggleRefreshPatrimonyAccessory
  } = reactExports.useContext(PatrimonyInfoContext);
  const [accessories, setAccessories] = reactExports.useState([]);
  reactExports.useState(null);
  const [open2, setOpen] = reactExports.useState(false);
  const [accessoryFileMap, setAccessoryFileMap] = reactExports.useState();
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const theme2 = useTheme$1();
  const isMobile = useMediaQuery(theme2.breakpoints.down("sm"));
  const fetchPatrimonyAccessoryFiles = /* @__PURE__ */ __name(async (patrimonyAccessoryId) => {
    const data = await getPatrimonyAccessoryFiles(patrimonyAccessoryId);
    if (data) {
      return data;
    }
  }, "fetchPatrimonyAccessoryFiles");
  const setFilesAccordingToAccessory = /* @__PURE__ */ __name(async (data) => {
    const tempMap = new Map(accessoryFileMap);
    for (const accessory of data) {
      const files = await fetchPatrimonyAccessoryFiles(
        accessory.id_acessorio_patrimonio
      );
      if (files) {
        tempMap.set(accessory, files);
      }
    }
    setAccessoryFileMap(tempMap);
  }, "setFilesAccordingToAccessory");
  reactExports.useEffect(() => {
    const fetchData = /* @__PURE__ */ __name(async () => {
      const data = await getAccessoriesByPatrimonyId(Number(id_patrimonio));
      setAccessories(data);
      setFilesAccordingToAccessory(data);
    }, "fetchData");
    fetchData();
  }, [refreshPatrimonyAccessory, refreshPatrimonyAccessoryFiles]);
  const handleClose = /* @__PURE__ */ __name(() => setOpen(false), "handleClose");
  const handleOpenCreatePatrimonyAccessory = /* @__PURE__ */ __name(() => {
    toggleCreatingPatrimonyAccessory();
  }, "handleOpenCreatePatrimonyAccessory");
  const handleOpen = /* @__PURE__ */ __name(() => {
    setOpen(true);
  }, "handleOpen");
  const handleCloseDeletePatrimonyAccessory = /* @__PURE__ */ __name(() => {
    toggleDeletingPatrimonyAccessory(false);
  }, "handleCloseDeletePatrimonyAccessory");
  const handleDeletePatrimonyAccessory = /* @__PURE__ */ __name(async () => {
    var _a2;
    if (deletingPatrimonyAccessory[1]) {
      const response = await deletePatrimonyAccessory(
        (_a2 = deletingPatrimonyAccessory[1]) == null ? void 0 : _a2.id_acessorio_patrimonio
      );
      if (response && response.status === 200) {
        toggleRefreshPatrimonyAccessory();
        toggleDeletingPatrimonyAccessory(false);
      }
    }
  }, "handleDeletePatrimonyAccessory");
  const renderAcessoryImage = /* @__PURE__ */ __name((accessory) => {
    if (accessoryFileMap == null ? void 0 : accessoryFileMap.get(accessory)) {
      const files = accessoryFileMap == null ? void 0 : accessoryFileMap.get(accessory);
      if (files && files[0])
        return files[files.length - 1].arquivo;
      return CameraFileLogo;
    }
  }, "renderAcessoryImage");
  const handleUploadFile = /* @__PURE__ */ __name(async (e2, accessoryId) => {
    if (e2.target.files) {
      setIsLoading(true);
      const file = e2.target.files[0];
      const formData = new FormData();
      formData.append("file", file);
      const response = await createPatrimonyAccessoryFile(
        Number(accessoryId),
        formData
      );
      if (response && response.status === 200) {
        setIsLoading(false);
        toggleRefreshPatrimonyAccessory();
        return;
      }
      window.alert("Erro ao fazer upload!");
      setIsLoading(false);
    }
  }, "handleUploadFile");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { badgeContent: accessories.length, color: "primary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Acessrios", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$6, { sx: { color: "#F7941E" } }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Modal$3, { open: open2, onClose: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: modalStyle(theme2), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: isMobile ? "subtitle1" : "h6", component: "h2", children: "Acessrios do Patrimnio" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              sx: { color: "#F7941E" },
              onClick: handleOpenCreatePatrimonyAccessory,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$h, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { sx: { color: "red" }, onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {}) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "column", gap: "1rem", alignItems: "center", children: accessories && accessories.map((accessory, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: { borderRadius: "10px", width: 300 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CardMedia,
          {
            image: isLoading ? "" : renderAcessoryImage(accessory),
            sx: { height: 200 },
            children: isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Stack,
              {
                direction: "row",
                justifyContent: "center",
                alignItems: "center",
                sx: { mt: 2, height: "100%" },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {})
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Stack,
            {
              direction: "row",
              alignItems: "center",
              justifyContent: "space-between",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { textTransform: "capitalize", color: "blue", children: accessory.nome }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    onClick: () => toggleDeletingPatrimonyAccessory(
                      true,
                      accessories[index2]
                    ),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$t, { sx: { color: "#F7941E" } })
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              component: "label",
              variant: "contained",
              startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$9, {}),
              sx: {
                mt: 2,
                width: isMobile ? "100%" : "auto"
                // Responsividade no boto
              },
              children: [
                "Anexar",
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  VisuallyHiddenInput,
                  {
                    accept: "image/*,application/pdf",
                    onChange: (e2) => handleUploadFile(e2, accessory.id_acessorio_patrimonio),
                    sx: BaseButtonStyles,
                    type: "file"
                  }
                )
              ]
            }
          )
        ] })
      ] })) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CreatePatrimonyAccessoryModal, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal$3,
        {
          open: deletingPatrimonyAccessory[0],
          onClose: handleClose,
          "aria-labelledby": "modal-modal-title",
          "aria-describedby": "modal-modal-description",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              sx: {
                ...style$3,
                display: "flex",
                flexDirection: "column",
                gap: "1rem"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { id: "modal-modal-title", variant: "h6", component: "h2", children: [
                  "Tem erteza de que deseja deletar este acessrio?",
                  " "
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "center", spacing: 2, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "outlined",
                      color: "primary",
                      onClick: handleDeletePatrimonyAccessory,
                      sx: { borderColor: "blue", color: "blue" },
                      children: "Sim"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "outlined",
                      color: "error",
                      sx: { borderColor: "red", color: "red" },
                      onClick: handleCloseDeletePatrimonyAccessory,
                      children: "No"
                    }
                  )
                ] })
              ]
            }
          )
        }
      )
    ] }) })
  ] });
}
__name(PatrimonyAccessoryModal, "PatrimonyAccessoryModal");
const VisuallyHiddenInput = styled("input")({
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: 1,
  overflow: "hidden",
  position: "absolute",
  bottom: 0,
  left: 0,
  whiteSpace: "nowrap",
  width: 1
});
const PatrimonyDetails = /* @__PURE__ */ __name(() => {
  const { id_patrimonio } = useParams();
  const { refreshPatrimonyInfo, toggleRefreshPatrimonyInfo } = reactExports.useContext(PatrimonyInfoContext);
  const navigate = useNavigate();
  const [patrimonyData, setPatrimonyData] = reactExports.useState();
  const [editing, setEditing] = reactExports.useState([false]);
  const [responsable, setResponsable] = reactExports.useState();
  const handleChange = /* @__PURE__ */ __name((e2, key) => {
    setEditing([true, key]);
    const { value } = e2.currentTarget;
    console.log(value);
    if (patrimonyData) {
      if (key === "id_patrimonio") {
        window.alert("No  permitido editar o nmero do Patrimnio");
        return;
      }
      console.log({
        ...patrimonyData,
        [key]: value
      });
      setPatrimonyData({
        ...patrimonyData,
        [key]: value
      });
    }
  }, "handleChange");
  const handleCancelEdition = /* @__PURE__ */ __name(() => {
    setEditing([false]);
    toggleRefreshPatrimonyInfo();
  }, "handleCancelEdition");
  const fetchPatrimonyData = reactExports.useCallback(async () => {
    console.log("fetchPatrimonyData");
    const data = await getSinglePatrimony(Number(id_patrimonio));
    const responsable2 = await getResponsableForPatrimony(Number(id_patrimonio));
    if (data) {
      setResponsable(responsable2[0].id_responsavel);
      console.log("patrimonyData: ", data[0]);
      setPatrimonyData(data[0]);
    }
  }, [id_patrimonio]);
  const handleSave = /* @__PURE__ */ __name(async () => {
    if (patrimonyData) {
      const formattedValorCompra = patrimonyData.valor_compra ? parseFloat(
        patrimonyData.valor_compra.toString().replace(",", ".")
      ).toFixed(2) : null;
      const updatedData = {
        ...patrimonyData,
        valor_compra: formattedValorCompra ? Number(formattedValorCompra) : 0
      };
      const response = await upatePatrimony(updatedData);
      console.log("response update patrimonio: \n", response);
      if (response && response.status === 200) {
        toggleRefreshPatrimonyInfo();
        setEditing([false]);
      }
    }
    setEditing([false]);
  }, "handleSave");
  const renderLabel = /* @__PURE__ */ __name((key) => {
    switch (key) {
      case "id_patrimonio":
        return "N Patrimnio";
      case "nome":
        return "Nome";
      case "data_compra":
        return "Data de Compra";
      case "nserie":
        return "N de srie";
      case "descricao":
        return "Descrio";
      case "pat_legado":
        return "Cdigo Patrimnio";
      case "nome_tipo":
        return "Tipo";
      case "fabricante":
        return "Fabricante";
      case "valor_compra":
        return "Valor de Compra";
    }
  }, "renderLabel");
  const renderLabelValue = /* @__PURE__ */ __name((key) => {
    if (editing[0]) {
      return patrimonyData && `${patrimonyData[key]}`;
    }
    if (key === "id_patrimonio") {
      return patrimonyData && `000${patrimonyData[key]}`;
    }
    if (key === "valor_compra") {
      return patrimonyData && new Intl.NumberFormat("pt-BR", {
        style: "decimal",
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      }).format(Number(patrimonyData[key]));
    }
    return patrimonyData && `${patrimonyData[key]}`;
  }, "renderLabelValue");
  const handleChangeDate = /* @__PURE__ */ __name((day) => {
    if (day && patrimonyData) {
      setEditing([true, "data_compra"]);
      setPatrimonyData({
        ...patrimonyData,
        ["data_compra"]: day.toString()
      });
    }
  }, "handleChangeDate");
  const handleBack = /* @__PURE__ */ __name(() => {
    navigate("/patrimony");
  }, "handleBack");
  const handleActiveChange = /* @__PURE__ */ __name(async (event, checked) => {
    console.log(event);
    if (patrimonyData) {
      if (checked) {
        await upatePatrimony({
          ...patrimonyData,
          ["ativo"]: 1
        });
        toggleRefreshPatrimonyInfo();
        return;
      } else {
        await upatePatrimony({
          ...patrimonyData,
          ["ativo"]: 0
        });
        toggleRefreshPatrimonyInfo();
        return;
      }
    }
  }, "handleActiveChange");
  reactExports.useEffect(() => {
    console.log("USE EFFECT");
    fetchPatrimonyData();
  }, [refreshPatrimonyInfo, fetchPatrimonyData]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { height: "98vh", overflow: "auto", padding: 2 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        overflow: "auto",
        display: "flex",
        sx: {
          height: "fit-content",
          paddingX: "2rem",
          alignItems: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftIcon, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              textTransform: "capitalize",
              className: "text-gray-[#2B3990]",
              sx: {
                fontSize: {
                  xs: "16px",
                  sm: "16px",
                  md: "18px",
                  lg: "20px",
                  xl: "22px"
                }
              },
              fontFamily: "Roboto",
              children: patrimonyData == null ? void 0 : patrimonyData.nome
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", gap: 1, height: "90%", flexWrap: "wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          sx: { borderRadius: "15px", padding: 2 },
          className: "border border-slate-300",
          paddingY: "2rem",
          height: "100%",
          width: { xs: "100%", lg: "20%" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Stack,
            {
              direction: "column",
              justifyContent: "start",
              gap: "1rem",
              padding: "0.5rem",
              height: "100%",
              overflow: "auto",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    className: "text-gray-[#2B3990]",
                    variant: "h6",
                    textAlign: "center",
                    children: "Detalhes"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(PatrimonyFileModal, {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(PatrimonyAccessoryModal, {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Tooltip,
                    {
                      onClick: () => window.open(`/patrimony/checklist/${id_patrimonio}`),
                      title: "Checklists do patrimnio",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$b, { sx: { color: "#F7941E" } }) })
                    }
                  )
                ] }),
                patrimonyData && Object.keys(patrimonyData).map((key) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { display: "flex", flexDirection: "column", gap: "0.5rem", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Typography,
                    {
                      className: "text-gray-600",
                      textTransform: "capitalize",
                      children: renderLabel(key)
                    }
                  ),
                  key === "data_compra" ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocalizationProvider, { dateAdapter: AdapterDayjs, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DemoContainer, { components: ["DateField"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DateField,
                    {
                      format: "DD/MM/YYYY",
                      onChange: (e2) => handleChangeDate(e2),
                      defaultValue: dayjs.utc(patrimonyData[key]),
                      label: "Data de Compra"
                    }
                  ) }) }) : key === "ativo" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    FormControlLabel,
                    {
                      control: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Switch,
                        {
                          onChange: handleActiveChange,
                          defaultChecked: patrimonyData[key] > 0
                        }
                      ),
                      label: "Ativo"
                    }
                  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TextField,
                    {
                      onChange: (e2) => handleChange(e2, key),
                      disabled: key === "nome_tipo",
                      fullWidth: true,
                      id: "outlined-basic",
                      multiline: true,
                      value: renderLabelValue(key) === "null" ? "" : renderLabelValue(key),
                      variant: "outlined"
                    }
                  ),
                  editing[0] && editing[1] === key && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: "outlined",
                        onClick: () => handleSave(),
                        sx: { width: "1rem", marginX: "1rem" },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$g, {})
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: "outlined",
                        onClick: handleCancelEdition,
                        sx: {
                          width: "1rem",
                          marginX: "1rem",
                          color: "red"
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$7, {})
                      }
                    )
                  ] })
                ] }))
              ]
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          className: "border border-slate-300",
          sx: { borderRadius: "15px" },
          height: "100%",
          paddingX: "1rem",
          width: { xs: "100%", lg: "78%" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "column", height: "100%", overflow: "auto", spacing: 2, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { position: "relative", height: "5%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Stack,
              {
                direction: "row",
                justifyContent: "space-between",
                alignItems: "center",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Typography,
                    {
                      display: "flex",
                      fontSize: {
                        lg: "1.5rem",
                        sm: "1rem",
                        xs: "14px"
                      },
                      fontWeight: "bold",
                      className: "text-gray-[#2B3990]",
                      textAlign: "center",
                      children: "Histrico de Movimentaes"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CreateMovementation, { responsable })
                ]
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MovimentationTable, {})
          ] })
        }
      )
    ] })
  ] });
}, "PatrimonyDetails");
var lib = {};
var slider = {};
var innerSlider = {};
var initialState = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var initialState2 = {
    animating: false,
    autoplaying: null,
    currentDirection: 0,
    currentLeft: null,
    currentSlide: 0,
    direction: 1,
    dragging: false,
    edgeDragged: false,
    initialized: false,
    lazyLoadedList: [],
    listHeight: null,
    listWidth: null,
    scrolling: false,
    slideCount: null,
    slideHeight: null,
    slideWidth: null,
    swipeLeft: null,
    swiped: false,
    // used by swipeEvent. differentites between touch and swipe.
    swiping: false,
    touchObject: {
      startX: 0,
      startY: 0,
      curX: 0,
      curY: 0
    },
    trackStyle: {},
    trackWidth: 0,
    targetSlide: 0
  };
  exports["default"] = initialState2;
})(initialState);
var FUNC_ERROR_TEXT = "Expected a function";
var NAN = 0 / 0;
var symbolTag = "[object Symbol]";
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var nativeMax = Math.max, nativeMin = Math.min;
var now = /* @__PURE__ */ __name(function() {
  return root.Date.now();
}, "now");
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func.apply(thisArg, args);
    return result;
  }
  __name(invokeFunc, "invokeFunc");
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  __name(leadingEdge, "leadingEdge");
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, result2 = wait - timeSinceLastCall;
    return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
  }
  __name(remainingWait, "remainingWait");
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  __name(shouldInvoke, "shouldInvoke");
  function timerExpired() {
    var time2 = now();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  __name(timerExpired, "timerExpired");
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  __name(trailingEdge, "trailingEdge");
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  __name(cancel, "cancel");
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  __name(flush, "flush");
  function debounced() {
    var time2 = now(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  __name(debounced, "debounced");
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
__name(debounce, "debounce");
function isObject(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
__name(isObject, "isObject");
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
__name(isObjectLike, "isObjectLike");
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
__name(isSymbol, "isSymbol");
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, "");
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
__name(toNumber, "toNumber");
var lodash_debounce = debounce;
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
      var classes2 = "";
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg) {
          classes2 = appendClass(classes2, parseValue(arg));
        }
      }
      return classes2;
    }
    __name(classNames, "classNames");
    function parseValue(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        return arg;
      }
      if (typeof arg !== "object") {
        return "";
      }
      if (Array.isArray(arg)) {
        return classNames.apply(null, arg);
      }
      if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
        return arg.toString();
      }
      var classes2 = "";
      for (var key in arg) {
        if (hasOwn.call(arg, key) && arg[key]) {
          classes2 = appendClass(classes2, key);
        }
      }
      return classes2;
    }
    __name(parseValue, "parseValue");
    function appendClass(value, newClass) {
      if (!newClass) {
        return value;
      }
      if (value) {
        return value + " " + newClass;
      }
      return value + newClass;
    }
    __name(appendClass, "appendClass");
    if (module.exports) {
      classNames.default = classNames;
      module.exports = classNames;
    } else {
      window.classNames = classNames;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
var innerSliderUtils = {};
var defaultProps = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var _react2 = _interopRequireDefault2(reactExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  __name(_interopRequireDefault2, "_interopRequireDefault");
  var defaultProps2 = {
    accessibility: true,
    adaptiveHeight: false,
    afterChange: null,
    appendDots: /* @__PURE__ */ __name(function appendDots(dots2) {
      return /* @__PURE__ */ _react2["default"].createElement("ul", {
        style: {
          display: "block"
        }
      }, dots2);
    }, "appendDots"),
    arrows: true,
    autoplay: false,
    autoplaySpeed: 3e3,
    beforeChange: null,
    centerMode: false,
    centerPadding: "50px",
    className: "",
    cssEase: "ease",
    customPaging: /* @__PURE__ */ __name(function customPaging(i) {
      return /* @__PURE__ */ _react2["default"].createElement("button", null, i + 1);
    }, "customPaging"),
    dots: false,
    dotsClass: "slick-dots",
    draggable: true,
    easing: "linear",
    edgeFriction: 0.35,
    fade: false,
    focusOnSelect: false,
    infinite: true,
    initialSlide: 0,
    lazyLoad: null,
    nextArrow: null,
    onEdge: null,
    onInit: null,
    onLazyLoadError: null,
    onReInit: null,
    pauseOnDotsHover: false,
    pauseOnFocus: false,
    pauseOnHover: true,
    prevArrow: null,
    responsive: null,
    rows: 1,
    rtl: false,
    slide: "div",
    slidesPerRow: 1,
    slidesToScroll: 1,
    slidesToShow: 1,
    speed: 500,
    swipe: true,
    swipeEvent: null,
    swipeToSlide: false,
    touchMove: true,
    touchThreshold: 5,
    useCSS: true,
    useTransform: true,
    variableWidth: false,
    vertical: false,
    waitForAnimate: true,
    asNavFor: null
  };
  exports["default"] = defaultProps2;
})(defaultProps);
Object.defineProperty(innerSliderUtils, "__esModule", {
  value: true
});
innerSliderUtils.checkSpecKeys = innerSliderUtils.checkNavigable = innerSliderUtils.changeSlide = innerSliderUtils.canUseDOM = innerSliderUtils.canGoNext = void 0;
innerSliderUtils.clamp = clamp;
innerSliderUtils.extractObject = void 0;
innerSliderUtils.filterSettings = filterSettings;
innerSliderUtils.validSettings = innerSliderUtils.swipeStart = innerSliderUtils.swipeMove = innerSliderUtils.swipeEnd = innerSliderUtils.slidesOnRight = innerSliderUtils.slidesOnLeft = innerSliderUtils.slideHandler = innerSliderUtils.siblingDirection = innerSliderUtils.safePreventDefault = innerSliderUtils.lazyStartIndex = innerSliderUtils.lazySlidesOnRight = innerSliderUtils.lazySlidesOnLeft = innerSliderUtils.lazyEndIndex = innerSliderUtils.keyHandler = innerSliderUtils.initializedState = innerSliderUtils.getWidth = innerSliderUtils.getTrackLeft = innerSliderUtils.getTrackCSS = innerSliderUtils.getTrackAnimateCSS = innerSliderUtils.getTotalSlides = innerSliderUtils.getSwipeDirection = innerSliderUtils.getSlideCount = innerSliderUtils.getRequiredLazySlides = innerSliderUtils.getPreClones = innerSliderUtils.getPostClones = innerSliderUtils.getOnDemandLazySlides = innerSliderUtils.getNavigableIndexes = innerSliderUtils.getHeight = void 0;
var _react$4 = _interopRequireDefault$a(reactExports);
var _defaultProps = _interopRequireDefault$a(defaultProps);
function _interopRequireDefault$a(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
__name(_interopRequireDefault$a, "_interopRequireDefault$a");
function _typeof$4(o) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$4(o);
}
__name(_typeof$4, "_typeof$4");
function ownKeys$4(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
__name(ownKeys$4, "ownKeys$4");
function _objectSpread$4(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$4(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$4(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread$4, "_objectSpread$4");
function _defineProperty$4(obj, key, value) {
  key = _toPropertyKey$4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty$4, "_defineProperty$4");
function _toPropertyKey$4(t2) {
  var i = _toPrimitive$4(t2, "string");
  return "symbol" == _typeof$4(i) ? i : String(i);
}
__name(_toPropertyKey$4, "_toPropertyKey$4");
function _toPrimitive$4(t2, r2) {
  if ("object" != _typeof$4(t2) || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != _typeof$4(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
__name(_toPrimitive$4, "_toPrimitive$4");
function clamp(number2, lowerBound, upperBound) {
  return Math.max(lowerBound, Math.min(number2, upperBound));
}
__name(clamp, "clamp");
var safePreventDefault = innerSliderUtils.safePreventDefault = /* @__PURE__ */ __name(function safePreventDefault2(event) {
  var passiveEvents = ["onTouchStart", "onTouchMove", "onWheel"];
  if (!passiveEvents.includes(event._reactName)) {
    event.preventDefault();
  }
}, "safePreventDefault");
var getOnDemandLazySlides = innerSliderUtils.getOnDemandLazySlides = /* @__PURE__ */ __name(function getOnDemandLazySlides2(spec) {
  var onDemandSlides = [];
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {
      onDemandSlides.push(slideIndex);
    }
  }
  return onDemandSlides;
}, "getOnDemandLazySlides");
innerSliderUtils.getRequiredLazySlides = /* @__PURE__ */ __name(function getRequiredLazySlides(spec) {
  var requiredSlides = [];
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    requiredSlides.push(slideIndex);
  }
  return requiredSlides;
}, "getRequiredLazySlides");
var lazyStartIndex = innerSliderUtils.lazyStartIndex = /* @__PURE__ */ __name(function lazyStartIndex2(spec) {
  return spec.currentSlide - lazySlidesOnLeft(spec);
}, "lazyStartIndex");
var lazyEndIndex = innerSliderUtils.lazyEndIndex = /* @__PURE__ */ __name(function lazyEndIndex2(spec) {
  return spec.currentSlide + lazySlidesOnRight(spec);
}, "lazyEndIndex");
var lazySlidesOnLeft = innerSliderUtils.lazySlidesOnLeft = /* @__PURE__ */ __name(function lazySlidesOnLeft2(spec) {
  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
}, "lazySlidesOnLeft");
var lazySlidesOnRight = innerSliderUtils.lazySlidesOnRight = /* @__PURE__ */ __name(function lazySlidesOnRight2(spec) {
  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
}, "lazySlidesOnRight");
var getWidth = innerSliderUtils.getWidth = /* @__PURE__ */ __name(function getWidth2(elem) {
  return elem && elem.offsetWidth || 0;
}, "getWidth");
var getHeight = innerSliderUtils.getHeight = /* @__PURE__ */ __name(function getHeight2(elem) {
  return elem && elem.offsetHeight || 0;
}, "getHeight");
var getSwipeDirection = innerSliderUtils.getSwipeDirection = /* @__PURE__ */ __name(function getSwipeDirection2(touchObject) {
  var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var xDist, yDist, r2, swipeAngle;
  xDist = touchObject.startX - touchObject.curX;
  yDist = touchObject.startY - touchObject.curY;
  r2 = Math.atan2(yDist, xDist);
  swipeAngle = Math.round(r2 * 180 / Math.PI);
  if (swipeAngle < 0) {
    swipeAngle = 360 - Math.abs(swipeAngle);
  }
  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {
    return "left";
  }
  if (swipeAngle >= 135 && swipeAngle <= 225) {
    return "right";
  }
  if (verticalSwiping === true) {
    if (swipeAngle >= 35 && swipeAngle <= 135) {
      return "up";
    } else {
      return "down";
    }
  }
  return "vertical";
}, "getSwipeDirection");
var canGoNext = innerSliderUtils.canGoNext = /* @__PURE__ */ __name(function canGoNext2(spec) {
  var canGo = true;
  if (!spec.infinite) {
    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {
      canGo = false;
    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {
      canGo = false;
    }
  }
  return canGo;
}, "canGoNext");
innerSliderUtils.extractObject = /* @__PURE__ */ __name(function extractObject(spec, keys) {
  var newObject = {};
  keys.forEach(function(key) {
    return newObject[key] = spec[key];
  });
  return newObject;
}, "extractObject");
innerSliderUtils.initializedState = /* @__PURE__ */ __name(function initializedState(spec) {
  var slideCount = _react$4["default"].Children.count(spec.children);
  var listNode = spec.listRef;
  var listWidth = Math.ceil(getWidth(listNode));
  var trackNode = spec.trackRef && spec.trackRef.node;
  var trackWidth = Math.ceil(getWidth(trackNode));
  var slideWidth;
  if (!spec.vertical) {
    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
    if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") {
      centerPaddingAdj *= listWidth / 100;
    }
    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
  } else {
    slideWidth = listWidth;
  }
  var slideHeight = listNode && getHeight(listNode.querySelector('[data-index="0"]'));
  var listHeight = slideHeight * spec.slidesToShow;
  var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
  if (spec.rtl && spec.currentSlide === void 0) {
    currentSlide = slideCount - 1 - spec.initialSlide;
  }
  var lazyLoadedList = spec.lazyLoadedList || [];
  var slidesToLoad = getOnDemandLazySlides(_objectSpread$4(_objectSpread$4({}, spec), {}, {
    currentSlide,
    lazyLoadedList
  }));
  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
  var state = {
    slideCount,
    slideWidth,
    listWidth,
    trackWidth,
    currentSlide,
    slideHeight,
    listHeight,
    lazyLoadedList
  };
  if (spec.autoplaying === null && spec.autoplay) {
    state["autoplaying"] = "playing";
  }
  return state;
}, "initializedState");
innerSliderUtils.slideHandler = /* @__PURE__ */ __name(function slideHandler(spec) {
  var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index2 = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;
  var lazyLoadedList = spec.lazyLoadedList;
  if (waitForAnimate && animating)
    return {};
  var animationSlide = index2, finalSlide, animationLeft, finalLeft;
  var state = {}, nextState = {};
  var targetSlide = infinite ? index2 : clamp(index2, 0, slideCount - 1);
  if (fade) {
    if (!infinite && (index2 < 0 || index2 >= slideCount))
      return {};
    if (index2 < 0) {
      animationSlide = index2 + slideCount;
    } else if (index2 >= slideCount) {
      animationSlide = index2 - slideCount;
    }
    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {
      lazyLoadedList = lazyLoadedList.concat(animationSlide);
    }
    state = {
      animating: true,
      currentSlide: animationSlide,
      lazyLoadedList,
      targetSlide: animationSlide
    };
    nextState = {
      animating: false,
      targetSlide: animationSlide
    };
  } else {
    finalSlide = animationSlide;
    if (animationSlide < 0) {
      finalSlide = animationSlide + slideCount;
      if (!infinite)
        finalSlide = 0;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = slideCount - slideCount % slidesToScroll;
    } else if (!canGoNext(spec) && animationSlide > currentSlide) {
      animationSlide = finalSlide = currentSlide;
    } else if (centerMode && animationSlide >= slideCount) {
      animationSlide = infinite ? slideCount : slideCount - 1;
      finalSlide = infinite ? 0 : slideCount - 1;
    } else if (animationSlide >= slideCount) {
      finalSlide = animationSlide - slideCount;
      if (!infinite)
        finalSlide = slideCount - slidesToShow;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = 0;
    }
    if (!infinite && animationSlide + slidesToShow >= slideCount) {
      finalSlide = slideCount - slidesToShow;
    }
    animationLeft = getTrackLeft(_objectSpread$4(_objectSpread$4({}, spec), {}, {
      slideIndex: animationSlide
    }));
    finalLeft = getTrackLeft(_objectSpread$4(_objectSpread$4({}, spec), {}, {
      slideIndex: finalSlide
    }));
    if (!infinite) {
      if (animationLeft === finalLeft)
        animationSlide = finalSlide;
      animationLeft = finalLeft;
    }
    if (lazyLoad) {
      lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread$4(_objectSpread$4({}, spec), {}, {
        currentSlide: animationSlide
      })));
    }
    if (!useCSS) {
      state = {
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread$4(_objectSpread$4({}, spec), {}, {
          left: finalLeft
        })),
        lazyLoadedList,
        targetSlide
      };
    } else {
      state = {
        animating: true,
        currentSlide: finalSlide,
        trackStyle: getTrackAnimateCSS(_objectSpread$4(_objectSpread$4({}, spec), {}, {
          left: animationLeft
        })),
        lazyLoadedList,
        targetSlide
      };
      nextState = {
        animating: false,
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread$4(_objectSpread$4({}, spec), {}, {
          left: finalLeft
        })),
        swipeLeft: null,
        targetSlide
      };
    }
  }
  return {
    state,
    nextState
  };
}, "slideHandler");
innerSliderUtils.changeSlide = /* @__PURE__ */ __name(function changeSlide(spec, options) {
  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;
  var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;
  unevenOffset = slideCount % slidesToScroll !== 0;
  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
  if (options.message === "previous") {
    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
    targetSlide = currentSlide - slideOffset;
    if (lazyLoad && !infinite) {
      previousInt = currentSlide - slideOffset;
      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide - slidesToScroll;
    }
  } else if (options.message === "next") {
    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
    targetSlide = currentSlide + slideOffset;
    if (lazyLoad && !infinite) {
      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide + slidesToScroll;
    }
  } else if (options.message === "dots") {
    targetSlide = options.index * options.slidesToScroll;
  } else if (options.message === "children") {
    targetSlide = options.index;
    if (infinite) {
      var direction = siblingDirection(_objectSpread$4(_objectSpread$4({}, spec), {}, {
        targetSlide
      }));
      if (targetSlide > options.currentSlide && direction === "left") {
        targetSlide = targetSlide - slideCount;
      } else if (targetSlide < options.currentSlide && direction === "right") {
        targetSlide = targetSlide + slideCount;
      }
    }
  } else if (options.message === "index") {
    targetSlide = Number(options.index);
  }
  return targetSlide;
}, "changeSlide");
innerSliderUtils.keyHandler = /* @__PURE__ */ __name(function keyHandler(e2, accessibility, rtl) {
  if (e2.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility)
    return "";
  if (e2.keyCode === 37)
    return rtl ? "next" : "previous";
  if (e2.keyCode === 39)
    return rtl ? "previous" : "next";
  return "";
}, "keyHandler");
innerSliderUtils.swipeStart = /* @__PURE__ */ __name(function swipeStart(e2, swipe, draggable) {
  e2.target.tagName === "IMG" && safePreventDefault(e2);
  if (!swipe || !draggable && e2.type.indexOf("mouse") !== -1)
    return "";
  return {
    dragging: true,
    touchObject: {
      startX: e2.touches ? e2.touches[0].pageX : e2.clientX,
      startY: e2.touches ? e2.touches[0].pageY : e2.clientY,
      curX: e2.touches ? e2.touches[0].pageX : e2.clientX,
      curY: e2.touches ? e2.touches[0].pageY : e2.clientY
    }
  };
}, "swipeStart");
innerSliderUtils.swipeMove = /* @__PURE__ */ __name(function swipeMove(e2, spec) {
  var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;
  if (scrolling)
    return;
  if (animating)
    return safePreventDefault(e2);
  if (vertical && swipeToSlide && verticalSwiping)
    safePreventDefault(e2);
  var swipeLeft, state = {};
  var curLeft = getTrackLeft(spec);
  touchObject.curX = e2.touches ? e2.touches[0].pageX : e2.clientX;
  touchObject.curY = e2.touches ? e2.touches[0].pageY : e2.clientY;
  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {
    return {
      scrolling: true
    };
  }
  if (verticalSwiping)
    touchObject.swipeLength = verticalSwipeLength;
  var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
  if (verticalSwiping)
    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
  var dotCount = Math.ceil(slideCount / slidesToScroll);
  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
  var touchSwipeLength = touchObject.swipeLength;
  if (!infinite) {
    if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
      touchSwipeLength = touchObject.swipeLength * edgeFriction;
      if (edgeDragged === false && onEdge) {
        onEdge(swipeDirection);
        state["edgeDragged"] = true;
      }
    }
  }
  if (!swiped && swipeEvent) {
    swipeEvent(swipeDirection);
    state["swiped"] = true;
  }
  if (!vertical) {
    if (!rtl) {
      swipeLeft = curLeft + touchSwipeLength * positionOffset;
    } else {
      swipeLeft = curLeft - touchSwipeLength * positionOffset;
    }
  } else {
    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
  }
  if (verticalSwiping) {
    swipeLeft = curLeft + touchSwipeLength * positionOffset;
  }
  state = _objectSpread$4(_objectSpread$4({}, state), {}, {
    touchObject,
    swipeLeft,
    trackStyle: getTrackCSS(_objectSpread$4(_objectSpread$4({}, spec), {}, {
      left: swipeLeft
    }))
  });
  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {
    return state;
  }
  if (touchObject.swipeLength > 10) {
    state["swiping"] = true;
    safePreventDefault(e2);
  }
  return state;
}, "swipeMove");
innerSliderUtils.swipeEnd = /* @__PURE__ */ __name(function swipeEnd(e2, spec) {
  var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;
  if (!dragging) {
    if (swipe)
      safePreventDefault(e2);
    return {};
  }
  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
  var state = {
    dragging: false,
    edgeDragged: false,
    scrolling: false,
    swiping: false,
    swiped: false,
    swipeLeft: null,
    touchObject: {}
  };
  if (scrolling) {
    return state;
  }
  if (!touchObject.swipeLength) {
    return state;
  }
  if (touchObject.swipeLength > minSwipe) {
    safePreventDefault(e2);
    if (onSwipe) {
      onSwipe(swipeDirection);
    }
    var slideCount, newSlide;
    var activeSlide = infinite ? currentSlide : targetSlide;
    switch (swipeDirection) {
      case "left":
      case "up":
        newSlide = activeSlide + getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 0;
        break;
      case "right":
      case "down":
        newSlide = activeSlide - getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 1;
        break;
      default:
        slideCount = activeSlide;
    }
    state["triggerSlideHandler"] = slideCount;
  } else {
    var currentLeft = getTrackLeft(spec);
    state["trackStyle"] = getTrackAnimateCSS(_objectSpread$4(_objectSpread$4({}, spec), {}, {
      left: currentLeft
    }));
  }
  return state;
}, "swipeEnd");
var getNavigableIndexes = innerSliderUtils.getNavigableIndexes = /* @__PURE__ */ __name(function getNavigableIndexes2(spec) {
  var max2 = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
  var counter = spec.infinite ? spec.slidesToShow * -1 : 0;
  var indexes = [];
  while (breakpoint < max2) {
    indexes.push(breakpoint);
    breakpoint = counter + spec.slidesToScroll;
    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
  }
  return indexes;
}, "getNavigableIndexes");
var checkNavigable = innerSliderUtils.checkNavigable = /* @__PURE__ */ __name(function checkNavigable2(spec, index2) {
  var navigables = getNavigableIndexes(spec);
  var prevNavigable = 0;
  if (index2 > navigables[navigables.length - 1]) {
    index2 = navigables[navigables.length - 1];
  } else {
    for (var n2 in navigables) {
      if (index2 < navigables[n2]) {
        index2 = prevNavigable;
        break;
      }
      prevNavigable = navigables[n2];
    }
  }
  return index2;
}, "checkNavigable");
var getSlideCount = innerSliderUtils.getSlideCount = /* @__PURE__ */ __name(function getSlideCount2(spec) {
  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
  if (spec.swipeToSlide) {
    var swipedSlide;
    var slickList = spec.listRef;
    var slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
    Array.from(slides).every(function(slide) {
      if (!spec.vertical) {
        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      } else {
        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      }
      return true;
    });
    if (!swipedSlide) {
      return 0;
    }
    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
    return slidesTraversed;
  } else {
    return spec.slidesToScroll;
  }
}, "getSlideCount");
var checkSpecKeys = innerSliderUtils.checkSpecKeys = /* @__PURE__ */ __name(function checkSpecKeys2(spec, keysArray) {
  return keysArray.reduce(function(value, key) {
    return value && spec.hasOwnProperty(key);
  }, true) ? null : console.error("Keys Missing:", spec);
}, "checkSpecKeys");
var getTrackCSS = innerSliderUtils.getTrackCSS = /* @__PURE__ */ __name(function getTrackCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
  var trackWidth, trackHeight;
  var trackChildren = spec.slideCount + 2 * spec.slidesToShow;
  if (!spec.vertical) {
    trackWidth = getTotalSlides(spec) * spec.slideWidth;
  } else {
    trackHeight = trackChildren * spec.slideHeight;
  }
  var style2 = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (spec.useTransform) {
    var WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var transform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
    style2 = _objectSpread$4(_objectSpread$4({}, style2), {}, {
      WebkitTransform,
      transform,
      msTransform
    });
  } else {
    if (spec.vertical) {
      style2["top"] = spec.left;
    } else {
      style2["left"] = spec.left;
    }
  }
  if (spec.fade)
    style2 = {
      opacity: 1
    };
  if (trackWidth)
    style2.width = trackWidth;
  if (trackHeight)
    style2.height = trackHeight;
  if (window && !window.addEventListener && window.attachEvent) {
    if (!spec.vertical) {
      style2.marginLeft = spec.left + "px";
    } else {
      style2.marginTop = spec.left + "px";
    }
  }
  return style2;
}, "getTrackCSS");
var getTrackAnimateCSS = innerSliderUtils.getTrackAnimateCSS = /* @__PURE__ */ __name(function getTrackAnimateCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
  var style2 = getTrackCSS(spec);
  if (spec.useTransform) {
    style2.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
    style2.transition = "transform " + spec.speed + "ms " + spec.cssEase;
  } else {
    if (spec.vertical) {
      style2.transition = "top " + spec.speed + "ms " + spec.cssEase;
    } else {
      style2.transition = "left " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
}, "getTrackAnimateCSS");
var getTrackLeft = innerSliderUtils.getTrackLeft = /* @__PURE__ */ __name(function getTrackLeft2(spec) {
  if (spec.unslick) {
    return 0;
  }
  checkSpecKeys(spec, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow", "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
  var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;
  var slideOffset = 0;
  var targetLeft;
  var targetSlide;
  var verticalOffset = 0;
  if (fade || spec.slideCount === 1) {
    return 0;
  }
  var slidesToOffset = 0;
  if (infinite) {
    slidesToOffset = -getPreClones(spec);
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
    }
    if (centerMode) {
      slidesToOffset += parseInt(slidesToShow / 2);
    }
  } else {
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = slidesToShow - slideCount % slidesToScroll;
    }
    if (centerMode) {
      slidesToOffset = parseInt(slidesToShow / 2);
    }
  }
  slideOffset = slidesToOffset * slideWidth;
  verticalOffset = slidesToOffset * slideHeight;
  if (!vertical) {
    targetLeft = slideIndex * slideWidth * -1 + slideOffset;
  } else {
    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
  }
  if (variableWidth === true) {
    var targetSlideIndex;
    var trackElem = trackRef && trackRef.node;
    targetSlideIndex = slideIndex + getPreClones(spec);
    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
    if (centerMode === true) {
      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
      targetSlide = trackElem && trackElem.children[targetSlideIndex];
      targetLeft = 0;
      for (var slide = 0; slide < targetSlideIndex; slide++) {
        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
      }
      targetLeft -= parseInt(spec.centerPadding);
      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
    }
  }
  return targetLeft;
}, "getTrackLeft");
var getPreClones = innerSliderUtils.getPreClones = /* @__PURE__ */ __name(function getPreClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  if (spec.variableWidth) {
    return spec.slideCount;
  }
  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
}, "getPreClones");
var getPostClones = innerSliderUtils.getPostClones = /* @__PURE__ */ __name(function getPostClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  return spec.slideCount;
}, "getPostClones");
var getTotalSlides = innerSliderUtils.getTotalSlides = /* @__PURE__ */ __name(function getTotalSlides2(spec) {
  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
}, "getTotalSlides");
var siblingDirection = innerSliderUtils.siblingDirection = /* @__PURE__ */ __name(function siblingDirection2(spec) {
  if (spec.targetSlide > spec.currentSlide) {
    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {
      return "left";
    }
    return "right";
  } else {
    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {
      return "right";
    }
    return "left";
  }
}, "siblingDirection");
var slidesOnRight = innerSliderUtils.slidesOnRight = /* @__PURE__ */ __name(function slidesOnRight2(_ref) {
  var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;
  if (centerMode) {
    var right2 = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      right2 += 1;
    if (rtl && slidesToShow % 2 === 0)
      right2 += 1;
    return right2;
  }
  if (rtl) {
    return 0;
  }
  return slidesToShow - 1;
}, "slidesOnRight");
var slidesOnLeft = innerSliderUtils.slidesOnLeft = /* @__PURE__ */ __name(function slidesOnLeft2(_ref2) {
  var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;
  if (centerMode) {
    var left2 = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      left2 += 1;
    if (!rtl && slidesToShow % 2 === 0)
      left2 += 1;
    return left2;
  }
  if (rtl) {
    return slidesToShow - 1;
  }
  return 0;
}, "slidesOnLeft");
innerSliderUtils.canUseDOM = /* @__PURE__ */ __name(function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}, "canUseDOM");
var validSettings = innerSliderUtils.validSettings = Object.keys(_defaultProps["default"]);
function filterSettings(settings) {
  return validSettings.reduce(function(acc, settingName) {
    if (settings.hasOwnProperty(settingName)) {
      acc[settingName] = settings[settingName];
    }
    return acc;
  }, {});
}
__name(filterSettings, "filterSettings");
var track = {};
Object.defineProperty(track, "__esModule", {
  value: true
});
track.Track = void 0;
var _react$3 = _interopRequireDefault$9(reactExports);
var _classnames$3 = _interopRequireDefault$9(classnamesExports);
var _innerSliderUtils$3 = innerSliderUtils;
function _interopRequireDefault$9(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
__name(_interopRequireDefault$9, "_interopRequireDefault$9");
function _typeof$3(o) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3(o);
}
__name(_typeof$3, "_typeof$3");
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
__name(_extends$2, "_extends$2");
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
__name(_classCallCheck$3, "_classCallCheck$3");
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$3(descriptor.key), descriptor);
  }
}
__name(_defineProperties$3, "_defineProperties$3");
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
__name(_createClass$3, "_createClass$3");
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
__name(_inherits$3, "_inherits$3");
function _setPrototypeOf$3(o, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  }, "_setPrototypeOf");
  return _setPrototypeOf$3(o, p2);
}
__name(_setPrototypeOf$3, "_setPrototypeOf$3");
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return /* @__PURE__ */ __name(function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$3, "_createSuper$3");
function _possibleConstructorReturn$3(self2, call2) {
  if (call2 && (_typeof$3(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$3(self2);
}
__name(_possibleConstructorReturn$3, "_possibleConstructorReturn$3");
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
__name(_assertThisInitialized$3, "_assertThisInitialized$3");
function _isNativeReflectConstruct$3() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$3 = /* @__PURE__ */ __name(function _isNativeReflectConstruct2() {
    return !!t2;
  }, "_isNativeReflectConstruct"))();
}
__name(_isNativeReflectConstruct$3, "_isNativeReflectConstruct$3");
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, "_getPrototypeOf");
  return _getPrototypeOf$3(o);
}
__name(_getPrototypeOf$3, "_getPrototypeOf$3");
function ownKeys$3(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
__name(ownKeys$3, "ownKeys$3");
function _objectSpread$3(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$3(Object(t2), true).forEach(function(r3) {
      _defineProperty$3(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$3(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread$3, "_objectSpread$3");
function _defineProperty$3(obj, key, value) {
  key = _toPropertyKey$3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty$3, "_defineProperty$3");
function _toPropertyKey$3(t2) {
  var i = _toPrimitive$3(t2, "string");
  return "symbol" == _typeof$3(i) ? i : String(i);
}
__name(_toPropertyKey$3, "_toPropertyKey$3");
function _toPrimitive$3(t2, r2) {
  if ("object" != _typeof$3(t2) || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != _typeof$3(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
__name(_toPrimitive$3, "_toPrimitive$3");
var getSlideClasses = /* @__PURE__ */ __name(function getSlideClasses2(spec) {
  var slickActive, slickCenter, slickCloned;
  var centerOffset, index2;
  if (spec.rtl) {
    index2 = spec.slideCount - 1 - spec.index;
  } else {
    index2 = spec.index;
  }
  slickCloned = index2 < 0 || index2 >= spec.slideCount;
  if (spec.centerMode) {
    centerOffset = Math.floor(spec.slidesToShow / 2);
    slickCenter = (index2 - spec.currentSlide) % spec.slideCount === 0;
    if (index2 > spec.currentSlide - centerOffset - 1 && index2 <= spec.currentSlide + centerOffset) {
      slickActive = true;
    }
  } else {
    slickActive = spec.currentSlide <= index2 && index2 < spec.currentSlide + spec.slidesToShow;
  }
  var focusedSlide;
  if (spec.targetSlide < 0) {
    focusedSlide = spec.targetSlide + spec.slideCount;
  } else if (spec.targetSlide >= spec.slideCount) {
    focusedSlide = spec.targetSlide - spec.slideCount;
  } else {
    focusedSlide = spec.targetSlide;
  }
  var slickCurrent = index2 === focusedSlide;
  return {
    "slick-slide": true,
    "slick-active": slickActive,
    "slick-center": slickCenter,
    "slick-cloned": slickCloned,
    "slick-current": slickCurrent
    // dubious in case of RTL
  };
}, "getSlideClasses");
var getSlideStyle = /* @__PURE__ */ __name(function getSlideStyle2(spec) {
  var style2 = {};
  if (spec.variableWidth === void 0 || spec.variableWidth === false) {
    style2.width = spec.slideWidth;
  }
  if (spec.fade) {
    style2.position = "relative";
    if (spec.vertical) {
      style2.top = -spec.index * parseInt(spec.slideHeight);
    } else {
      style2.left = -spec.index * parseInt(spec.slideWidth);
    }
    style2.opacity = spec.currentSlide === spec.index ? 1 : 0;
    style2.zIndex = spec.currentSlide === spec.index ? 999 : 998;
    if (spec.useCSS) {
      style2.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
}, "getSlideStyle");
var getKey = /* @__PURE__ */ __name(function getKey2(child, fallbackKey) {
  return child.key || fallbackKey;
}, "getKey");
var renderSlides = /* @__PURE__ */ __name(function renderSlides2(spec) {
  var key;
  var slides = [];
  var preCloneSlides = [];
  var postCloneSlides = [];
  var childrenCount = _react$3["default"].Children.count(spec.children);
  var startIndex = (0, _innerSliderUtils$3.lazyStartIndex)(spec);
  var endIndex = (0, _innerSliderUtils$3.lazyEndIndex)(spec);
  _react$3["default"].Children.forEach(spec.children, function(elem, index2) {
    var child;
    var childOnClickOptions = {
      message: "children",
      index: index2,
      slidesToScroll: spec.slidesToScroll,
      currentSlide: spec.currentSlide
    };
    if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index2) >= 0) {
      child = elem;
    } else {
      child = /* @__PURE__ */ _react$3["default"].createElement("div", null);
    }
    var childStyle = getSlideStyle(_objectSpread$3(_objectSpread$3({}, spec), {}, {
      index: index2
    }));
    var slideClass = child.props.className || "";
    var slideClasses = getSlideClasses(_objectSpread$3(_objectSpread$3({}, spec), {}, {
      index: index2
    }));
    slides.push(/* @__PURE__ */ _react$3["default"].cloneElement(child, {
      key: "original" + getKey(child, index2),
      "data-index": index2,
      className: (0, _classnames$3["default"])(slideClasses, slideClass),
      tabIndex: "-1",
      "aria-hidden": !slideClasses["slick-active"],
      style: _objectSpread$3(_objectSpread$3({
        outline: "none"
      }, child.props.style || {}), childStyle),
      onClick: /* @__PURE__ */ __name(function onClick(e2) {
        child.props && child.props.onClick && child.props.onClick(e2);
        if (spec.focusOnSelect) {
          spec.focusOnSelect(childOnClickOptions);
        }
      }, "onClick")
    }));
    if (spec.infinite && spec.fade === false) {
      var preCloneNo = childrenCount - index2;
      if (preCloneNo <= (0, _innerSliderUtils$3.getPreClones)(spec)) {
        key = -preCloneNo;
        if (key >= startIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread$3(_objectSpread$3({}, spec), {}, {
          index: key
        }));
        preCloneSlides.push(/* @__PURE__ */ _react$3["default"].cloneElement(child, {
          key: "precloned" + getKey(child, key),
          "data-index": key,
          tabIndex: "-1",
          className: (0, _classnames$3["default"])(slideClasses, slideClass),
          "aria-hidden": !slideClasses["slick-active"],
          style: _objectSpread$3(_objectSpread$3({}, child.props.style || {}), childStyle),
          onClick: /* @__PURE__ */ __name(function onClick(e2) {
            child.props && child.props.onClick && child.props.onClick(e2);
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }, "onClick")
        }));
      }
      key = childrenCount + index2;
      if (key < endIndex) {
        child = elem;
      }
      slideClasses = getSlideClasses(_objectSpread$3(_objectSpread$3({}, spec), {}, {
        index: key
      }));
      postCloneSlides.push(/* @__PURE__ */ _react$3["default"].cloneElement(child, {
        key: "postcloned" + getKey(child, key),
        "data-index": key,
        tabIndex: "-1",
        className: (0, _classnames$3["default"])(slideClasses, slideClass),
        "aria-hidden": !slideClasses["slick-active"],
        style: _objectSpread$3(_objectSpread$3({}, child.props.style || {}), childStyle),
        onClick: /* @__PURE__ */ __name(function onClick(e2) {
          child.props && child.props.onClick && child.props.onClick(e2);
          if (spec.focusOnSelect) {
            spec.focusOnSelect(childOnClickOptions);
          }
        }, "onClick")
      }));
    }
  });
  if (spec.rtl) {
    return preCloneSlides.concat(slides, postCloneSlides).reverse();
  } else {
    return preCloneSlides.concat(slides, postCloneSlides);
  }
}, "renderSlides");
track.Track = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits$3(Track, _React$PureComponent);
  var _super = _createSuper$3(Track);
  function Track() {
    var _this;
    _classCallCheck$3(this, Track);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$3(_assertThisInitialized$3(_this), "node", null);
    _defineProperty$3(_assertThisInitialized$3(_this), "handleRef", function(ref) {
      _this.node = ref;
    });
    return _this;
  }
  __name(Track, "Track");
  _createClass$3(Track, [{
    key: "render",
    value: /* @__PURE__ */ __name(function render() {
      var slides = renderSlides(this.props);
      var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;
      var mouseEvents = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave
      };
      return /* @__PURE__ */ _react$3["default"].createElement("div", _extends$2({
        ref: this.handleRef,
        className: "slick-track",
        style: this.props.trackStyle
      }, mouseEvents), slides);
    }, "render")
  }]);
  return Track;
}(_react$3["default"].PureComponent);
var dots = {};
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
__name(_typeof$2, "_typeof$2");
Object.defineProperty(dots, "__esModule", {
  value: true
});
dots.Dots = void 0;
var _react$2 = _interopRequireDefault$8(reactExports);
var _classnames$2 = _interopRequireDefault$8(classnamesExports);
var _innerSliderUtils$2 = innerSliderUtils;
function _interopRequireDefault$8(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
__name(_interopRequireDefault$8, "_interopRequireDefault$8");
function ownKeys$2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
__name(ownKeys$2, "ownKeys$2");
function _objectSpread$2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
      _defineProperty$2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread$2, "_objectSpread$2");
function _defineProperty$2(obj, key, value) {
  key = _toPropertyKey$2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty$2, "_defineProperty$2");
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
__name(_classCallCheck$2, "_classCallCheck$2");
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
  }
}
__name(_defineProperties$2, "_defineProperties$2");
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
__name(_createClass$2, "_createClass$2");
function _toPropertyKey$2(t2) {
  var i = _toPrimitive$2(t2, "string");
  return "symbol" == _typeof$2(i) ? i : String(i);
}
__name(_toPropertyKey$2, "_toPropertyKey$2");
function _toPrimitive$2(t2, r2) {
  if ("object" != _typeof$2(t2) || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != _typeof$2(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
__name(_toPrimitive$2, "_toPrimitive$2");
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
__name(_inherits$2, "_inherits$2");
function _setPrototypeOf$2(o, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  }, "_setPrototypeOf");
  return _setPrototypeOf$2(o, p2);
}
__name(_setPrototypeOf$2, "_setPrototypeOf$2");
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return /* @__PURE__ */ __name(function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$2, "_createSuper$2");
function _possibleConstructorReturn$2(self2, call2) {
  if (call2 && (_typeof$2(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$2(self2);
}
__name(_possibleConstructorReturn$2, "_possibleConstructorReturn$2");
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
__name(_assertThisInitialized$2, "_assertThisInitialized$2");
function _isNativeReflectConstruct$2() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$2 = /* @__PURE__ */ __name(function _isNativeReflectConstruct2() {
    return !!t2;
  }, "_isNativeReflectConstruct"))();
}
__name(_isNativeReflectConstruct$2, "_isNativeReflectConstruct$2");
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, "_getPrototypeOf");
  return _getPrototypeOf$2(o);
}
__name(_getPrototypeOf$2, "_getPrototypeOf$2");
var getDotCount = /* @__PURE__ */ __name(function getDotCount2(spec) {
  var dots2;
  if (spec.infinite) {
    dots2 = Math.ceil(spec.slideCount / spec.slidesToScroll);
  } else {
    dots2 = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
  }
  return dots2;
}, "getDotCount");
dots.Dots = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits$2(Dots, _React$PureComponent);
  var _super = _createSuper$2(Dots);
  function Dots() {
    _classCallCheck$2(this, Dots);
    return _super.apply(this, arguments);
  }
  __name(Dots, "Dots");
  _createClass$2(Dots, [{
    key: "clickHandler",
    value: /* @__PURE__ */ __name(function clickHandler(options, e2) {
      e2.preventDefault();
      this.props.clickHandler(options);
    }, "clickHandler")
  }, {
    key: "render",
    value: /* @__PURE__ */ __name(function render() {
      var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;
      var dotCount = getDotCount({
        slideCount,
        slidesToScroll,
        slidesToShow,
        infinite
      });
      var mouseEvents = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave
      };
      var dots2 = [];
      for (var i = 0; i < dotCount; i++) {
        var _rightBound = (i + 1) * slidesToScroll - 1;
        var rightBound = infinite ? _rightBound : (0, _innerSliderUtils$2.clamp)(_rightBound, 0, slideCount - 1);
        var _leftBound = rightBound - (slidesToScroll - 1);
        var leftBound = infinite ? _leftBound : (0, _innerSliderUtils$2.clamp)(_leftBound, 0, slideCount - 1);
        var className = (0, _classnames$2["default"])({
          "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound
        });
        var dotOptions = {
          message: "dots",
          index: i,
          slidesToScroll,
          currentSlide
        };
        var onClick = this.clickHandler.bind(this, dotOptions);
        dots2 = dots2.concat(/* @__PURE__ */ _react$2["default"].createElement("li", {
          key: i,
          className
        }, /* @__PURE__ */ _react$2["default"].cloneElement(this.props.customPaging(i), {
          onClick
        })));
      }
      return /* @__PURE__ */ _react$2["default"].cloneElement(this.props.appendDots(dots2), _objectSpread$2({
        className: this.props.dotsClass
      }, mouseEvents));
    }, "render")
  }]);
  return Dots;
}(_react$2["default"].PureComponent);
var arrows = {};
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
__name(_typeof$1, "_typeof$1");
Object.defineProperty(arrows, "__esModule", {
  value: true
});
arrows.PrevArrow = arrows.NextArrow = void 0;
var _react$1 = _interopRequireDefault$7(reactExports);
var _classnames$1 = _interopRequireDefault$7(classnamesExports);
var _innerSliderUtils$1 = innerSliderUtils;
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
__name(_interopRequireDefault$7, "_interopRequireDefault$7");
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
__name(_extends$1, "_extends$1");
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
__name(ownKeys$1, "ownKeys$1");
function _objectSpread$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread$1, "_objectSpread$1");
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty$1, "_defineProperty$1");
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
__name(_classCallCheck$1, "_classCallCheck$1");
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
__name(_defineProperties$1, "_defineProperties$1");
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
__name(_createClass$1, "_createClass$1");
function _toPropertyKey$1(t2) {
  var i = _toPrimitive$1(t2, "string");
  return "symbol" == _typeof$1(i) ? i : String(i);
}
__name(_toPropertyKey$1, "_toPropertyKey$1");
function _toPrimitive$1(t2, r2) {
  if ("object" != _typeof$1(t2) || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != _typeof$1(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
__name(_toPrimitive$1, "_toPrimitive$1");
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
__name(_inherits$1, "_inherits$1");
function _setPrototypeOf$1(o, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  }, "_setPrototypeOf");
  return _setPrototypeOf$1(o, p2);
}
__name(_setPrototypeOf$1, "_setPrototypeOf$1");
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return /* @__PURE__ */ __name(function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$1, "_createSuper$1");
function _possibleConstructorReturn$1(self2, call2) {
  if (call2 && (_typeof$1(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
__name(_possibleConstructorReturn$1, "_possibleConstructorReturn$1");
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
__name(_assertThisInitialized$1, "_assertThisInitialized$1");
function _isNativeReflectConstruct$1() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$1 = /* @__PURE__ */ __name(function _isNativeReflectConstruct2() {
    return !!t2;
  }, "_isNativeReflectConstruct"))();
}
__name(_isNativeReflectConstruct$1, "_isNativeReflectConstruct$1");
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, "_getPrototypeOf");
  return _getPrototypeOf$1(o);
}
__name(_getPrototypeOf$1, "_getPrototypeOf$1");
arrows.PrevArrow = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits$1(PrevArrow, _React$PureComponent);
  var _super = _createSuper$1(PrevArrow);
  function PrevArrow() {
    _classCallCheck$1(this, PrevArrow);
    return _super.apply(this, arguments);
  }
  __name(PrevArrow, "PrevArrow");
  _createClass$1(PrevArrow, [{
    key: "clickHandler",
    value: /* @__PURE__ */ __name(function clickHandler(options, e2) {
      if (e2) {
        e2.preventDefault();
      }
      this.props.clickHandler(options, e2);
    }, "clickHandler")
  }, {
    key: "render",
    value: /* @__PURE__ */ __name(function render() {
      var prevClasses = {
        "slick-arrow": true,
        "slick-prev": true
      };
      var prevHandler = this.clickHandler.bind(this, {
        message: "previous"
      });
      if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {
        prevClasses["slick-disabled"] = true;
        prevHandler = null;
      }
      var prevArrowProps = {
        key: "0",
        "data-role": "none",
        className: (0, _classnames$1["default"])(prevClasses),
        style: {
          display: "block"
        },
        onClick: prevHandler
      };
      var customProps = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      };
      var prevArrow;
      if (this.props.prevArrow) {
        prevArrow = /* @__PURE__ */ _react$1["default"].cloneElement(this.props.prevArrow, _objectSpread$1(_objectSpread$1({}, prevArrowProps), customProps));
      } else {
        prevArrow = /* @__PURE__ */ _react$1["default"].createElement("button", _extends$1({
          key: "0",
          type: "button"
        }, prevArrowProps), " ", "Previous");
      }
      return prevArrow;
    }, "render")
  }]);
  return PrevArrow;
}(_react$1["default"].PureComponent);
arrows.NextArrow = /* @__PURE__ */ function(_React$PureComponent2) {
  _inherits$1(NextArrow, _React$PureComponent2);
  var _super2 = _createSuper$1(NextArrow);
  function NextArrow() {
    _classCallCheck$1(this, NextArrow);
    return _super2.apply(this, arguments);
  }
  __name(NextArrow, "NextArrow");
  _createClass$1(NextArrow, [{
    key: "clickHandler",
    value: /* @__PURE__ */ __name(function clickHandler(options, e2) {
      if (e2) {
        e2.preventDefault();
      }
      this.props.clickHandler(options, e2);
    }, "clickHandler")
  }, {
    key: "render",
    value: /* @__PURE__ */ __name(function render() {
      var nextClasses = {
        "slick-arrow": true,
        "slick-next": true
      };
      var nextHandler = this.clickHandler.bind(this, {
        message: "next"
      });
      if (!(0, _innerSliderUtils$1.canGoNext)(this.props)) {
        nextClasses["slick-disabled"] = true;
        nextHandler = null;
      }
      var nextArrowProps = {
        key: "1",
        "data-role": "none",
        className: (0, _classnames$1["default"])(nextClasses),
        style: {
          display: "block"
        },
        onClick: nextHandler
      };
      var customProps = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      };
      var nextArrow;
      if (this.props.nextArrow) {
        nextArrow = /* @__PURE__ */ _react$1["default"].cloneElement(this.props.nextArrow, _objectSpread$1(_objectSpread$1({}, nextArrowProps), customProps));
      } else {
        nextArrow = /* @__PURE__ */ _react$1["default"].createElement("button", _extends$1({
          key: "1",
          type: "button"
        }, nextArrowProps), " ", "Next");
      }
      return nextArrow;
    }, "render")
  }]);
  return NextArrow;
}(_react$1["default"].PureComponent);
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  __name(getIndex, "getIndex");
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      __name(class_1, "class_1");
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index2 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index2 = getIndex(this.__entries__, key);
        if (~index2) {
          this.__entries__[index2][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i2 = 0, _a2 = this.__entries__; _i2 < _a2.length; _i2++) {
          var entry = _a2[_i2];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay2) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  __name(resolvePending, "resolvePending");
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  __name(timeoutCallback, "timeoutCallback");
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay2);
    }
    lastCallTime = timeStamp;
  }
  __name(proxy, "proxy");
  return proxy;
}
__name(throttle, "throttle");
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    __name(ResizeObserverController2, "ResizeObserverController");
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
      var _b2 = _a2.propertyName, propertyName = _b2 === void 0 ? "" : _b2;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = /* @__PURE__ */ __name(function(target, props) {
  for (var _i2 = 0, _a2 = Object.keys(props); _i2 < _a2.length; _i2++) {
    var key = _a2[_i2];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
}, "defineConfigurable");
var getWindowOf = /* @__PURE__ */ __name(function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
}, "getWindowOf");
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
__name(toFloat, "toFloat");
function getBordersSize(styles2) {
  var positions = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    positions[_i2 - 1] = arguments[_i2];
  }
  return positions.reduce(function(size2, position2) {
    var value = styles2["border-" + position2 + "-width"];
    return size2 + toFloat(value);
  }, 0);
}
__name(getBordersSize, "getBordersSize");
function getPaddings(styles2) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i2 = 0, positions_1 = positions; _i2 < positions_1.length; _i2++) {
    var position2 = positions_1[_i2];
    var value = styles2["padding-" + position2];
    paddings[position2] = toFloat(value);
  }
  return paddings;
}
__name(getPaddings, "getPaddings");
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
__name(getSVGContentRect, "getSVGContentRect");
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles2 = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles2);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width2 = toFloat(styles2.width), height2 = toFloat(styles2.height);
  if (styles2.boxSizing === "border-box") {
    if (Math.round(width2 + horizPad) !== clientWidth) {
      width2 -= getBordersSize(styles2, "left", "right") + horizPad;
    }
    if (Math.round(height2 + vertPad) !== clientHeight) {
      height2 -= getBordersSize(styles2, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width2 + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height2 + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width2 -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height2 -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width2, height2);
}
__name(getHTMLElementContentRect, "getHTMLElementContentRect");
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
__name(isDocumentElement, "isDocumentElement");
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
__name(getContentRect, "getContentRect");
function createReadOnlyRect(_a2) {
  var x2 = _a2.x, y2 = _a2.y, width2 = _a2.width, height2 = _a2.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width: width2,
    height: height2,
    top: y2,
    right: x2 + width2,
    bottom: height2 + y2,
    left: x2
  });
  return rect;
}
__name(createReadOnlyRect, "createReadOnlyRect");
function createRectInit(x2, y2, width2, height2) {
  return { x: x2, y: y2, width: width2, height: height2 };
}
__name(createRectInit, "createRectInit");
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    __name(ResizeObservation2, "ResizeObservation");
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    __name(ResizeObserverEntry2, "ResizeObserverEntry");
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    __name(ResizeObserverSPI2, "ResizeObserverSPI");
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$1 = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    __name(ResizeObserver2, "ResizeObserver");
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver$1.prototype[method] = function() {
    var _a2;
    return (_a2 = observers.get(this))[method].apply(_a2, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$1;
}();
const ResizeObserver_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: index
}, Symbol.toStringTag, { value: "Module" }));
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(ResizeObserver_es);
Object.defineProperty(innerSlider, "__esModule", {
  value: true
});
innerSlider.InnerSlider = void 0;
var _react = _interopRequireDefault$6(reactExports);
var _initialState = _interopRequireDefault$6(initialState);
var _lodash = _interopRequireDefault$6(lodash_debounce);
var _classnames = _interopRequireDefault$6(classnamesExports);
var _innerSliderUtils = innerSliderUtils;
var _track = track;
var _dots = dots;
var _arrows = arrows;
var _resizeObserverPolyfill = _interopRequireDefault$6(require$$8);
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
__name(_interopRequireDefault$6, "_interopRequireDefault$6");
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
__name(_typeof, "_typeof");
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
__name(_extends, "_extends");
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
__name(_objectWithoutProperties, "_objectWithoutProperties");
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
__name(ownKeys, "ownKeys");
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread, "_objectSpread");
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
__name(_classCallCheck, "_classCallCheck");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
__name(_defineProperties, "_defineProperties");
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
__name(_createClass, "_createClass");
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
__name(_inherits, "_inherits");
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  }, "_setPrototypeOf");
  return _setPrototypeOf(o, p2);
}
__name(_setPrototypeOf, "_setPrototypeOf");
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return /* @__PURE__ */ __name(function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper, "_createSuper");
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
__name(_possibleConstructorReturn, "_possibleConstructorReturn");
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
__name(_assertThisInitialized, "_assertThisInitialized");
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = /* @__PURE__ */ __name(function _isNativeReflectConstruct2() {
    return !!t2;
  }, "_isNativeReflectConstruct"))();
}
__name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  }, "_getPrototypeOf");
  return _getPrototypeOf(o);
}
__name(_getPrototypeOf, "_getPrototypeOf");
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty, "_defineProperty");
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
__name(_toPropertyKey, "_toPropertyKey");
function _toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != _typeof(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
__name(_toPrimitive, "_toPrimitive");
innerSlider.InnerSlider = /* @__PURE__ */ function(_React$Component) {
  _inherits(InnerSlider, _React$Component);
  var _super = _createSuper(InnerSlider);
  function InnerSlider(props) {
    var _this;
    _classCallCheck(this, InnerSlider);
    _this = _super.call(this, props);
    _defineProperty(_assertThisInitialized(_this), "listRefHandler", function(ref) {
      return _this.list = ref;
    });
    _defineProperty(_assertThisInitialized(_this), "trackRefHandler", function(ref) {
      return _this.track = ref;
    });
    _defineProperty(_assertThisInitialized(_this), "adaptHeight", function() {
      if (_this.props.adaptiveHeight && _this.list) {
        var elem = _this.list.querySelector('[data-index="'.concat(_this.state.currentSlide, '"]'));
        _this.list.style.height = (0, _innerSliderUtils.getHeight)(elem) + "px";
      }
    });
    _defineProperty(_assertThisInitialized(_this), "componentDidMount", function() {
      _this.props.onInit && _this.props.onInit();
      if (_this.props.lazyLoad) {
        var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));
        if (slidesToLoad.length > 0) {
          _this.setState(function(prevState) {
            return {
              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
            };
          });
          if (_this.props.onLazyLoad) {
            _this.props.onLazyLoad(slidesToLoad);
          }
        }
      }
      var spec = _objectSpread({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props);
      _this.updateState(spec, true, function() {
        _this.adaptHeight();
        _this.props.autoplay && _this.autoPlay("update");
      });
      if (_this.props.lazyLoad === "progressive") {
        _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1e3);
      }
      _this.ro = new _resizeObserverPolyfill["default"](function() {
        if (_this.state.animating) {
          _this.onWindowResized(false);
          _this.callbackTimers.push(setTimeout(function() {
            return _this.onWindowResized();
          }, _this.props.speed));
        } else {
          _this.onWindowResized();
        }
      });
      _this.ro.observe(_this.list);
      document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(slide) {
        slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;
        slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;
      });
      if (window.addEventListener) {
        window.addEventListener("resize", _this.onWindowResized);
      } else {
        window.attachEvent("onresize", _this.onWindowResized);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "componentWillUnmount", function() {
      if (_this.animationEndCallback) {
        clearTimeout(_this.animationEndCallback);
      }
      if (_this.lazyLoadTimer) {
        clearInterval(_this.lazyLoadTimer);
      }
      if (_this.callbackTimers.length) {
        _this.callbackTimers.forEach(function(timer) {
          return clearTimeout(timer);
        });
        _this.callbackTimers = [];
      }
      if (window.addEventListener) {
        window.removeEventListener("resize", _this.onWindowResized);
      } else {
        window.detachEvent("onresize", _this.onWindowResized);
      }
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
      }
      _this.ro.disconnect();
    });
    _defineProperty(_assertThisInitialized(_this), "componentDidUpdate", function(prevProps) {
      _this.checkImagesLoad();
      _this.props.onReInit && _this.props.onReInit();
      if (_this.props.lazyLoad) {
        var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));
        if (slidesToLoad.length > 0) {
          _this.setState(function(prevState) {
            return {
              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
            };
          });
          if (_this.props.onLazyLoad) {
            _this.props.onLazyLoad(slidesToLoad);
          }
        }
      }
      _this.adaptHeight();
      var spec = _objectSpread(_objectSpread({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props), _this.state);
      var setTrackStyle = _this.didPropsChange(prevProps);
      setTrackStyle && _this.updateState(spec, setTrackStyle, function() {
        if (_this.state.currentSlide >= _react["default"].Children.count(_this.props.children)) {
          _this.changeSlide({
            message: "index",
            index: _react["default"].Children.count(_this.props.children) - _this.props.slidesToShow,
            currentSlide: _this.state.currentSlide
          });
        }
        if (_this.props.autoplay) {
          _this.autoPlay("update");
        } else {
          _this.pause("paused");
        }
      });
    });
    _defineProperty(_assertThisInitialized(_this), "onWindowResized", function(setTrackStyle) {
      if (_this.debouncedResize)
        _this.debouncedResize.cancel();
      _this.debouncedResize = (0, _lodash["default"])(function() {
        return _this.resizeWindow(setTrackStyle);
      }, 50);
      _this.debouncedResize();
    });
    _defineProperty(_assertThisInitialized(_this), "resizeWindow", function() {
      var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var isTrackMounted = Boolean(_this.track && _this.track.node);
      if (!isTrackMounted)
        return;
      var spec = _objectSpread(_objectSpread({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props), _this.state);
      _this.updateState(spec, setTrackStyle, function() {
        if (_this.props.autoplay)
          _this.autoPlay("update");
        else
          _this.pause("paused");
      });
      _this.setState({
        animating: false
      });
      clearTimeout(_this.animationEndCallback);
      delete _this.animationEndCallback;
    });
    _defineProperty(_assertThisInitialized(_this), "updateState", function(spec, setTrackStyle, callback) {
      var updatedState = (0, _innerSliderUtils.initializedState)(spec);
      spec = _objectSpread(_objectSpread(_objectSpread({}, spec), updatedState), {}, {
        slideIndex: updatedState.currentSlide
      });
      var targetLeft = (0, _innerSliderUtils.getTrackLeft)(spec);
      spec = _objectSpread(_objectSpread({}, spec), {}, {
        left: targetLeft
      });
      var trackStyle = (0, _innerSliderUtils.getTrackCSS)(spec);
      if (setTrackStyle || _react["default"].Children.count(_this.props.children) !== _react["default"].Children.count(spec.children)) {
        updatedState["trackStyle"] = trackStyle;
      }
      _this.setState(updatedState, callback);
    });
    _defineProperty(_assertThisInitialized(_this), "ssrInit", function() {
      if (_this.props.variableWidth) {
        var _trackWidth = 0, _trackLeft = 0;
        var childrenWidths = [];
        var preClones = (0, _innerSliderUtils.getPreClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {
          slideCount: _this.props.children.length
        }));
        var postClones = (0, _innerSliderUtils.getPostClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {
          slideCount: _this.props.children.length
        }));
        _this.props.children.forEach(function(child) {
          childrenWidths.push(child.props.style.width);
          _trackWidth += child.props.style.width;
        });
        for (var i = 0; i < preClones; i++) {
          _trackLeft += childrenWidths[childrenWidths.length - 1 - i];
          _trackWidth += childrenWidths[childrenWidths.length - 1 - i];
        }
        for (var _i2 = 0; _i2 < postClones; _i2++) {
          _trackWidth += childrenWidths[_i2];
        }
        for (var _i22 = 0; _i22 < _this.state.currentSlide; _i22++) {
          _trackLeft += childrenWidths[_i22];
        }
        var _trackStyle = {
          width: _trackWidth + "px",
          left: -_trackLeft + "px"
        };
        if (_this.props.centerMode) {
          var currentWidth = "".concat(childrenWidths[_this.state.currentSlide], "px");
          _trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
        }
        return {
          trackStyle: _trackStyle
        };
      }
      var childrenCount = _react["default"].Children.count(_this.props.children);
      var spec = _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {
        slideCount: childrenCount
      });
      var slideCount = (0, _innerSliderUtils.getPreClones)(spec) + (0, _innerSliderUtils.getPostClones)(spec) + childrenCount;
      var trackWidth = 100 / _this.props.slidesToShow * slideCount;
      var slideWidth = 100 / slideCount;
      var trackLeft = -slideWidth * ((0, _innerSliderUtils.getPreClones)(spec) + _this.state.currentSlide) * trackWidth / 100;
      if (_this.props.centerMode) {
        trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
      }
      var trackStyle = {
        width: trackWidth + "%",
        left: trackLeft + "%"
      };
      return {
        slideWidth: slideWidth + "%",
        trackStyle
      };
    });
    _defineProperty(_assertThisInitialized(_this), "checkImagesLoad", function() {
      var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(".slick-slide img") || [];
      var imagesCount = images.length, loadedCount = 0;
      Array.prototype.forEach.call(images, function(image) {
        var handler = /* @__PURE__ */ __name(function handler2() {
          return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();
        }, "handler");
        if (!image.onclick) {
          image.onclick = function() {
            return image.parentNode.focus();
          };
        } else {
          var prevClickHandler = image.onclick;
          image.onclick = function(e2) {
            prevClickHandler(e2);
            image.parentNode.focus();
          };
        }
        if (!image.onload) {
          if (_this.props.lazyLoad) {
            image.onload = function() {
              _this.adaptHeight();
              _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));
            };
          } else {
            image.onload = handler;
            image.onerror = function() {
              handler();
              _this.props.onLazyLoadError && _this.props.onLazyLoadError();
            };
          }
        }
      });
    });
    _defineProperty(_assertThisInitialized(_this), "progressiveLazyLoad", function() {
      var slidesToLoad = [];
      var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);
      for (var index2 = _this.state.currentSlide; index2 < _this.state.slideCount + (0, _innerSliderUtils.getPostClones)(spec); index2++) {
        if (_this.state.lazyLoadedList.indexOf(index2) < 0) {
          slidesToLoad.push(index2);
          break;
        }
      }
      for (var _index = _this.state.currentSlide - 1; _index >= -(0, _innerSliderUtils.getPreClones)(spec); _index--) {
        if (_this.state.lazyLoadedList.indexOf(_index) < 0) {
          slidesToLoad.push(_index);
          break;
        }
      }
      if (slidesToLoad.length > 0) {
        _this.setState(function(state) {
          return {
            lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)
          };
        });
        if (_this.props.onLazyLoad) {
          _this.props.onLazyLoad(slidesToLoad);
        }
      } else {
        if (_this.lazyLoadTimer) {
          clearInterval(_this.lazyLoadTimer);
          delete _this.lazyLoadTimer;
        }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "slideHandler", function(index2) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange;
      var currentSlide = _this.state.currentSlide;
      var _slideHandler = (0, _innerSliderUtils.slideHandler)(_objectSpread(_objectSpread(_objectSpread({
        index: index2
      }, _this.props), _this.state), {}, {
        trackRef: _this.track,
        useCSS: _this.props.useCSS && !dontAnimate
      })), state = _slideHandler.state, nextState = _slideHandler.nextState;
      if (!state)
        return;
      beforeChange && beforeChange(currentSlide, state.currentSlide);
      var slidesToLoad = state.lazyLoadedList.filter(function(value) {
        return _this.state.lazyLoadedList.indexOf(value) < 0;
      });
      onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);
      if (!_this.props.waitForAnimate && _this.animationEndCallback) {
        clearTimeout(_this.animationEndCallback);
        afterChange && afterChange(currentSlide);
        delete _this.animationEndCallback;
      }
      _this.setState(state, function() {
        if (asNavFor && _this.asNavForIndex !== index2) {
          _this.asNavForIndex = index2;
          asNavFor.innerSlider.slideHandler(index2);
        }
        if (!nextState)
          return;
        _this.animationEndCallback = setTimeout(function() {
          var animating = nextState.animating, firstBatch = _objectWithoutProperties(nextState, ["animating"]);
          _this.setState(firstBatch, function() {
            _this.callbackTimers.push(setTimeout(function() {
              return _this.setState({
                animating
              });
            }, 10));
            afterChange && afterChange(state.currentSlide);
            delete _this.animationEndCallback;
          });
        }, speed);
      });
    });
    _defineProperty(_assertThisInitialized(_this), "changeSlide", function(options) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);
      var targetSlide = (0, _innerSliderUtils.changeSlide)(spec, options);
      if (targetSlide !== 0 && !targetSlide)
        return;
      if (dontAnimate === true) {
        _this.slideHandler(targetSlide, dontAnimate);
      } else {
        _this.slideHandler(targetSlide);
      }
      _this.props.autoplay && _this.autoPlay("update");
      if (_this.props.focusOnSelect) {
        var nodes = _this.list.querySelectorAll(".slick-current");
        nodes[0] && nodes[0].focus();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "clickHandler", function(e2) {
      if (_this.clickable === false) {
        e2.stopPropagation();
        e2.preventDefault();
      }
      _this.clickable = true;
    });
    _defineProperty(_assertThisInitialized(_this), "keyHandler", function(e2) {
      var dir = (0, _innerSliderUtils.keyHandler)(e2, _this.props.accessibility, _this.props.rtl);
      dir !== "" && _this.changeSlide({
        message: dir
      });
    });
    _defineProperty(_assertThisInitialized(_this), "selectHandler", function(options) {
      _this.changeSlide(options);
    });
    _defineProperty(_assertThisInitialized(_this), "disableBodyScroll", function() {
      var preventDefault = /* @__PURE__ */ __name(function preventDefault2(e2) {
        e2 = e2 || window.event;
        if (e2.preventDefault)
          e2.preventDefault();
        e2.returnValue = false;
      }, "preventDefault");
      window.ontouchmove = preventDefault;
    });
    _defineProperty(_assertThisInitialized(_this), "enableBodyScroll", function() {
      window.ontouchmove = null;
    });
    _defineProperty(_assertThisInitialized(_this), "swipeStart", function(e2) {
      if (_this.props.verticalSwiping) {
        _this.disableBodyScroll();
      }
      var state = (0, _innerSliderUtils.swipeStart)(e2, _this.props.swipe, _this.props.draggable);
      state !== "" && _this.setState(state);
    });
    _defineProperty(_assertThisInitialized(_this), "swipeMove", function(e2) {
      var state = (0, _innerSliderUtils.swipeMove)(e2, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {
        trackRef: _this.track,
        listRef: _this.list,
        slideIndex: _this.state.currentSlide
      }));
      if (!state)
        return;
      if (state["swiping"]) {
        _this.clickable = false;
      }
      _this.setState(state);
    });
    _defineProperty(_assertThisInitialized(_this), "swipeEnd", function(e2) {
      var state = (0, _innerSliderUtils.swipeEnd)(e2, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {
        trackRef: _this.track,
        listRef: _this.list,
        slideIndex: _this.state.currentSlide
      }));
      if (!state)
        return;
      var triggerSlideHandler = state["triggerSlideHandler"];
      delete state["triggerSlideHandler"];
      _this.setState(state);
      if (triggerSlideHandler === void 0)
        return;
      _this.slideHandler(triggerSlideHandler);
      if (_this.props.verticalSwiping) {
        _this.enableBodyScroll();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "touchEnd", function(e2) {
      _this.swipeEnd(e2);
      _this.clickable = true;
    });
    _defineProperty(_assertThisInitialized(_this), "slickPrev", function() {
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "previous"
        });
      }, 0));
    });
    _defineProperty(_assertThisInitialized(_this), "slickNext", function() {
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "next"
        });
      }, 0));
    });
    _defineProperty(_assertThisInitialized(_this), "slickGoTo", function(slide) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      slide = Number(slide);
      if (isNaN(slide))
        return "";
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "index",
          index: slide,
          currentSlide: _this.state.currentSlide
        }, dontAnimate);
      }, 0));
    });
    _defineProperty(_assertThisInitialized(_this), "play", function() {
      var nextIndex;
      if (_this.props.rtl) {
        nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;
      } else {
        if ((0, _innerSliderUtils.canGoNext)(_objectSpread(_objectSpread({}, _this.props), _this.state))) {
          nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;
        } else {
          return false;
        }
      }
      _this.slideHandler(nextIndex);
    });
    _defineProperty(_assertThisInitialized(_this), "autoPlay", function(playType) {
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
      }
      var autoplaying = _this.state.autoplaying;
      if (playType === "update") {
        if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") {
          return;
        }
      } else if (playType === "leave") {
        if (autoplaying === "paused" || autoplaying === "focused") {
          return;
        }
      } else if (playType === "blur") {
        if (autoplaying === "paused" || autoplaying === "hovered") {
          return;
        }
      }
      _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);
      _this.setState({
        autoplaying: "playing"
      });
    });
    _defineProperty(_assertThisInitialized(_this), "pause", function(pauseType) {
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
        _this.autoplayTimer = null;
      }
      var autoplaying = _this.state.autoplaying;
      if (pauseType === "paused") {
        _this.setState({
          autoplaying: "paused"
        });
      } else if (pauseType === "focused") {
        if (autoplaying === "hovered" || autoplaying === "playing") {
          _this.setState({
            autoplaying: "focused"
          });
        }
      } else {
        if (autoplaying === "playing") {
          _this.setState({
            autoplaying: "hovered"
          });
        }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onDotsOver", function() {
      return _this.props.autoplay && _this.pause("hovered");
    });
    _defineProperty(_assertThisInitialized(_this), "onDotsLeave", function() {
      return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
    });
    _defineProperty(_assertThisInitialized(_this), "onTrackOver", function() {
      return _this.props.autoplay && _this.pause("hovered");
    });
    _defineProperty(_assertThisInitialized(_this), "onTrackLeave", function() {
      return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
    });
    _defineProperty(_assertThisInitialized(_this), "onSlideFocus", function() {
      return _this.props.autoplay && _this.pause("focused");
    });
    _defineProperty(_assertThisInitialized(_this), "onSlideBlur", function() {
      return _this.props.autoplay && _this.state.autoplaying === "focused" && _this.autoPlay("blur");
    });
    _defineProperty(_assertThisInitialized(_this), "render", function() {
      var className = (0, _classnames["default"])("slick-slider", _this.props.className, {
        "slick-vertical": _this.props.vertical,
        "slick-initialized": true
      });
      var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);
      var trackProps = (0, _innerSliderUtils.extractObject)(spec, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect", "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight", "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle", "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]);
      var pauseOnHover = _this.props.pauseOnHover;
      trackProps = _objectSpread(_objectSpread({}, trackProps), {}, {
        onMouseEnter: pauseOnHover ? _this.onTrackOver : null,
        onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,
        onMouseOver: pauseOnHover ? _this.onTrackOver : null,
        focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null
      });
      var dots2;
      if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {
        var dotProps = (0, _innerSliderUtils.extractObject)(spec, ["dotsClass", "slideCount", "slidesToShow", "currentSlide", "slidesToScroll", "clickHandler", "children", "customPaging", "infinite", "appendDots"]);
        var pauseOnDotsHover = _this.props.pauseOnDotsHover;
        dotProps = _objectSpread(_objectSpread({}, dotProps), {}, {
          clickHandler: _this.changeSlide,
          onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,
          onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,
          onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null
        });
        dots2 = /* @__PURE__ */ _react["default"].createElement(_dots.Dots, dotProps);
      }
      var prevArrow, nextArrow;
      var arrowProps = (0, _innerSliderUtils.extractObject)(spec, ["infinite", "centerMode", "currentSlide", "slideCount", "slidesToShow", "prevArrow", "nextArrow"]);
      arrowProps.clickHandler = _this.changeSlide;
      if (_this.props.arrows) {
        prevArrow = /* @__PURE__ */ _react["default"].createElement(_arrows.PrevArrow, arrowProps);
        nextArrow = /* @__PURE__ */ _react["default"].createElement(_arrows.NextArrow, arrowProps);
      }
      var verticalHeightStyle = null;
      if (_this.props.vertical) {
        verticalHeightStyle = {
          height: _this.state.listHeight
        };
      }
      var centerPaddingStyle = null;
      if (_this.props.vertical === false) {
        if (_this.props.centerMode === true) {
          centerPaddingStyle = {
            padding: "0px " + _this.props.centerPadding
          };
        }
      } else {
        if (_this.props.centerMode === true) {
          centerPaddingStyle = {
            padding: _this.props.centerPadding + " 0px"
          };
        }
      }
      var listStyle = _objectSpread(_objectSpread({}, verticalHeightStyle), centerPaddingStyle);
      var touchMove = _this.props.touchMove;
      var listProps = {
        className: "slick-list",
        style: listStyle,
        onClick: _this.clickHandler,
        onMouseDown: touchMove ? _this.swipeStart : null,
        onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
        onMouseUp: touchMove ? _this.swipeEnd : null,
        onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,
        onTouchStart: touchMove ? _this.swipeStart : null,
        onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
        onTouchEnd: touchMove ? _this.touchEnd : null,
        onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,
        onKeyDown: _this.props.accessibility ? _this.keyHandler : null
      };
      var innerSliderProps = {
        className,
        dir: "ltr",
        style: _this.props.style
      };
      if (_this.props.unslick) {
        listProps = {
          className: "slick-list"
        };
        innerSliderProps = {
          className
        };
      }
      return /* @__PURE__ */ _react["default"].createElement("div", innerSliderProps, !_this.props.unslick ? prevArrow : "", /* @__PURE__ */ _react["default"].createElement("div", _extends({
        ref: _this.listRefHandler
      }, listProps), /* @__PURE__ */ _react["default"].createElement(_track.Track, _extends({
        ref: _this.trackRefHandler
      }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : "", !_this.props.unslick ? dots2 : "");
    });
    _this.list = null;
    _this.track = null;
    _this.state = _objectSpread(_objectSpread({}, _initialState["default"]), {}, {
      currentSlide: _this.props.initialSlide,
      targetSlide: _this.props.initialSlide ? _this.props.initialSlide : 0,
      slideCount: _react["default"].Children.count(_this.props.children)
    });
    _this.callbackTimers = [];
    _this.clickable = true;
    _this.debouncedResize = null;
    var ssrState = _this.ssrInit();
    _this.state = _objectSpread(_objectSpread({}, _this.state), ssrState);
    return _this;
  }
  __name(InnerSlider, "InnerSlider");
  _createClass(InnerSlider, [{
    key: "didPropsChange",
    value: /* @__PURE__ */ __name(function didPropsChange(prevProps) {
      var setTrackStyle = false;
      for (var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++) {
        var key = _Object$keys[_i3];
        if (!prevProps.hasOwnProperty(key)) {
          setTrackStyle = true;
          break;
        }
        if (_typeof(prevProps[key]) === "object" || typeof prevProps[key] === "function" || isNaN(prevProps[key])) {
          continue;
        }
        if (prevProps[key] !== this.props[key]) {
          setTrackStyle = true;
          break;
        }
      }
      return setTrackStyle || _react["default"].Children.count(this.props.children) !== _react["default"].Children.count(prevProps.children);
    }, "didPropsChange")
  }]);
  return InnerSlider;
}(_react["default"].Component);
var camel2hyphen$1 = /* @__PURE__ */ __name(function(str) {
  return str.replace(/[A-Z]/g, function(match2) {
    return "-" + match2.toLowerCase();
  }).toLowerCase();
}, "camel2hyphen$1");
var camel2hyphen_1 = camel2hyphen$1;
var camel2hyphen = camel2hyphen_1;
var isDimension = /* @__PURE__ */ __name(function(feature) {
  var re2 = /[height|width]$/;
  return re2.test(feature);
}, "isDimension");
var obj2mq = /* @__PURE__ */ __name(function(obj) {
  var mq = "";
  var features = Object.keys(obj);
  features.forEach(function(feature, index2) {
    var value = obj[feature];
    feature = camel2hyphen(feature);
    if (isDimension(feature) && typeof value === "number") {
      value = value + "px";
    }
    if (value === true) {
      mq += feature;
    } else if (value === false) {
      mq += "not " + feature;
    } else {
      mq += "(" + feature + ": " + value + ")";
    }
    if (index2 < features.length - 1) {
      mq += " and ";
    }
  });
  return mq;
}, "obj2mq");
var json2mq = /* @__PURE__ */ __name(function(query) {
  var mq = "";
  if (typeof query === "string") {
    return query;
  }
  if (query instanceof Array) {
    query.forEach(function(q2, index2) {
      mq += obj2mq(q2);
      if (index2 < query.length - 1) {
        mq += ", ";
      }
    });
    return mq;
  }
  return obj2mq(query);
}, "json2mq");
var json2mq_1 = json2mq;
var QueryHandler_1;
var hasRequiredQueryHandler;
function requireQueryHandler() {
  if (hasRequiredQueryHandler)
    return QueryHandler_1;
  hasRequiredQueryHandler = 1;
  function QueryHandler(options) {
    this.options = options;
    !options.deferSetup && this.setup();
  }
  __name(QueryHandler, "QueryHandler");
  QueryHandler.prototype = {
    constructor: QueryHandler,
    /**
     * coordinates setup of the handler
     *
     * @function
     */
    setup: function() {
      if (this.options.setup) {
        this.options.setup();
      }
      this.initialised = true;
    },
    /**
     * coordinates setup and triggering of the handler
     *
     * @function
     */
    on: function() {
      !this.initialised && this.setup();
      this.options.match && this.options.match();
    },
    /**
     * coordinates the unmatch event for the handler
     *
     * @function
     */
    off: function() {
      this.options.unmatch && this.options.unmatch();
    },
    /**
     * called when a handler is to be destroyed.
     * delegates to the destroy or unmatch callbacks, depending on availability.
     *
     * @function
     */
    destroy: function() {
      this.options.destroy ? this.options.destroy() : this.off();
    },
    /**
     * determines equality by reference.
     * if object is supplied compare options, if function, compare match callback
     *
     * @function
     * @param {object || function} [target] the target for comparison
     */
    equals: function(target) {
      return this.options === target || this.options.match === target;
    }
  };
  QueryHandler_1 = QueryHandler;
  return QueryHandler_1;
}
__name(requireQueryHandler, "requireQueryHandler");
var Util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return Util;
  hasRequiredUtil = 1;
  function each(collection, fn2) {
    var i = 0, length2 = collection.length, cont;
    for (i; i < length2; i++) {
      cont = fn2(collection[i], i);
      if (cont === false) {
        break;
      }
    }
  }
  __name(each, "each");
  function isArray2(target) {
    return Object.prototype.toString.apply(target) === "[object Array]";
  }
  __name(isArray2, "isArray");
  function isFunction2(target) {
    return typeof target === "function";
  }
  __name(isFunction2, "isFunction");
  Util = {
    isFunction: isFunction2,
    isArray: isArray2,
    each
  };
  return Util;
}
__name(requireUtil, "requireUtil");
var MediaQuery_1;
var hasRequiredMediaQuery;
function requireMediaQuery() {
  if (hasRequiredMediaQuery)
    return MediaQuery_1;
  hasRequiredMediaQuery = 1;
  var QueryHandler = requireQueryHandler();
  var each = requireUtil().each;
  function MediaQuery(query, isUnconditional) {
    this.query = query;
    this.isUnconditional = isUnconditional;
    this.handlers = [];
    this.mql = window.matchMedia(query);
    var self2 = this;
    this.listener = function(mql) {
      self2.mql = mql.currentTarget || mql;
      self2.assess();
    };
    this.mql.addListener(this.listener);
  }
  __name(MediaQuery, "MediaQuery");
  MediaQuery.prototype = {
    constuctor: MediaQuery,
    /**
     * add a handler for this query, triggering if already active
     *
     * @param {object} handler
     * @param {function} handler.match callback for when query is activated
     * @param {function} [handler.unmatch] callback for when query is deactivated
     * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
     * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
     */
    addHandler: function(handler) {
      var qh2 = new QueryHandler(handler);
      this.handlers.push(qh2);
      this.matches() && qh2.on();
    },
    /**
     * removes the given handler from the collection, and calls it's destroy methods
     *
     * @param {object || function} handler the handler to remove
     */
    removeHandler: function(handler) {
      var handlers = this.handlers;
      each(handlers, function(h2, i) {
        if (h2.equals(handler)) {
          h2.destroy();
          return !handlers.splice(i, 1);
        }
      });
    },
    /**
     * Determine whether the media query should be considered a match
     *
     * @return {Boolean} true if media query can be considered a match, false otherwise
     */
    matches: function() {
      return this.mql.matches || this.isUnconditional;
    },
    /**
     * Clears all handlers and unbinds events
     */
    clear: function() {
      each(this.handlers, function(handler) {
        handler.destroy();
      });
      this.mql.removeListener(this.listener);
      this.handlers.length = 0;
    },
    /*
        * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
        */
    assess: function() {
      var action = this.matches() ? "on" : "off";
      each(this.handlers, function(handler) {
        handler[action]();
      });
    }
  };
  MediaQuery_1 = MediaQuery;
  return MediaQuery_1;
}
__name(requireMediaQuery, "requireMediaQuery");
var MediaQueryDispatch_1;
var hasRequiredMediaQueryDispatch;
function requireMediaQueryDispatch() {
  if (hasRequiredMediaQueryDispatch)
    return MediaQueryDispatch_1;
  hasRequiredMediaQueryDispatch = 1;
  var MediaQuery = requireMediaQuery();
  var Util2 = requireUtil();
  var each = Util2.each;
  var isFunction2 = Util2.isFunction;
  var isArray2 = Util2.isArray;
  function MediaQueryDispatch() {
    if (!window.matchMedia) {
      throw new Error("matchMedia not present, legacy browsers require a polyfill");
    }
    this.queries = {};
    this.browserIsIncapable = !window.matchMedia("only all").matches;
  }
  __name(MediaQueryDispatch, "MediaQueryDispatch");
  MediaQueryDispatch.prototype = {
    constructor: MediaQueryDispatch,
    /**
     * Registers a handler for the given media query
     *
     * @param {string} q the media query
     * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
     * @param {function} options.match fired when query matched
     * @param {function} [options.unmatch] fired when a query is no longer matched
     * @param {function} [options.setup] fired when handler first triggered
     * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
     * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
     */
    register: function(q2, options, shouldDegrade) {
      var queries = this.queries, isUnconditional = shouldDegrade && this.browserIsIncapable;
      if (!queries[q2]) {
        queries[q2] = new MediaQuery(q2, isUnconditional);
      }
      if (isFunction2(options)) {
        options = { match: options };
      }
      if (!isArray2(options)) {
        options = [options];
      }
      each(options, function(handler) {
        if (isFunction2(handler)) {
          handler = { match: handler };
        }
        queries[q2].addHandler(handler);
      });
      return this;
    },
    /**
     * unregisters a query and all it's handlers, or a specific handler for a query
     *
     * @param {string} q the media query to target
     * @param {object || function} [handler] specific handler to unregister
     */
    unregister: function(q2, handler) {
      var query = this.queries[q2];
      if (query) {
        if (handler) {
          query.removeHandler(handler);
        } else {
          query.clear();
          delete this.queries[q2];
        }
      }
      return this;
    }
  };
  MediaQueryDispatch_1 = MediaQueryDispatch;
  return MediaQueryDispatch_1;
}
__name(requireMediaQueryDispatch, "requireMediaQueryDispatch");
var src;
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc)
    return src;
  hasRequiredSrc = 1;
  var MediaQueryDispatch = requireMediaQueryDispatch();
  src = new MediaQueryDispatch();
  return src;
}
__name(requireSrc, "requireSrc");
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var _react2 = _interopRequireDefault2(reactExports);
  var _innerSlider = innerSlider;
  var _json2mq = _interopRequireDefault2(json2mq_1);
  var _defaultProps2 = _interopRequireDefault2(defaultProps);
  var _innerSliderUtils2 = innerSliderUtils;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  __name(_interopRequireDefault2, "_interopRequireDefault");
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }
  __name(_typeof2, "_typeof");
  function _extends3() {
    _extends3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }
  __name(_extends3, "_extends");
  function ownKeys2(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e2);
      r2 && (o = o.filter(function(r22) {
        return Object.getOwnPropertyDescriptor(e2, r22).enumerable;
      })), t2.push.apply(t2, o);
    }
    return t2;
  }
  __name(ownKeys2, "ownKeys");
  function _objectSpread2(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys2(Object(t2), true).forEach(function(r22) {
        _defineProperty2(e2, r22, t2[r22]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys2(Object(t2)).forEach(function(r22) {
        Object.defineProperty(e2, r22, Object.getOwnPropertyDescriptor(t2, r22));
      });
    }
    return e2;
  }
  __name(_objectSpread2, "_objectSpread");
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  __name(_classCallCheck2, "_classCallCheck");
  function _defineProperties2(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
    }
  }
  __name(_defineProperties2, "_defineProperties");
  function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties2(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  __name(_createClass2, "_createClass");
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass)
      _setPrototypeOf2(subClass, superClass);
  }
  __name(_inherits2, "_inherits");
  function _setPrototypeOf2(o, p2) {
    _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function _setPrototypeOf22(o2, p22) {
      o2.__proto__ = p22;
      return o2;
    }, "_setPrototypeOf2");
    return _setPrototypeOf2(o, p2);
  }
  __name(_setPrototypeOf2, "_setPrototypeOf");
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return /* @__PURE__ */ __name(function _createSuperInternal() {
      var Super = _getPrototypeOf2(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf2(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn2(this, result);
    }, "_createSuperInternal");
  }
  __name(_createSuper2, "_createSuper");
  function _possibleConstructorReturn2(self2, call2) {
    if (call2 && (_typeof2(call2) === "object" || typeof call2 === "function")) {
      return call2;
    } else if (call2 !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized2(self2);
  }
  __name(_possibleConstructorReturn2, "_possibleConstructorReturn");
  function _assertThisInitialized2(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  __name(_assertThisInitialized2, "_assertThisInitialized");
  function _isNativeReflectConstruct2() {
    try {
      var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t22) {
    }
    return (_isNativeReflectConstruct2 = /* @__PURE__ */ __name(function _isNativeReflectConstruct22() {
      return !!t2;
    }, "_isNativeReflectConstruct2"))();
  }
  __name(_isNativeReflectConstruct2, "_isNativeReflectConstruct");
  function _getPrototypeOf2(o) {
    _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function _getPrototypeOf22(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    }, "_getPrototypeOf2");
    return _getPrototypeOf2(o);
  }
  __name(_getPrototypeOf2, "_getPrototypeOf");
  function _defineProperty2(obj, key, value) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  __name(_defineProperty2, "_defineProperty");
  function _toPropertyKey2(t2) {
    var i = _toPrimitive2(t2, "string");
    return "symbol" == _typeof2(i) ? i : String(i);
  }
  __name(_toPropertyKey2, "_toPropertyKey");
  function _toPrimitive2(t2, r2) {
    if ("object" != _typeof2(t2) || !t2)
      return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i = e2.call(t2, r2 || "default");
      if ("object" != _typeof2(i))
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  __name(_toPrimitive2, "_toPrimitive");
  var enquire = (0, _innerSliderUtils2.canUseDOM)() && requireSrc();
  exports["default"] = /* @__PURE__ */ function(_React$Component) {
    _inherits2(Slider2, _React$Component);
    var _super = _createSuper2(Slider2);
    function Slider2(props) {
      var _this;
      _classCallCheck2(this, Slider2);
      _this = _super.call(this, props);
      _defineProperty2(_assertThisInitialized2(_this), "innerSliderRefHandler", function(ref) {
        return _this.innerSlider = ref;
      });
      _defineProperty2(_assertThisInitialized2(_this), "slickPrev", function() {
        return _this.innerSlider.slickPrev();
      });
      _defineProperty2(_assertThisInitialized2(_this), "slickNext", function() {
        return _this.innerSlider.slickNext();
      });
      _defineProperty2(_assertThisInitialized2(_this), "slickGoTo", function(slide) {
        var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return _this.innerSlider.slickGoTo(slide, dontAnimate);
      });
      _defineProperty2(_assertThisInitialized2(_this), "slickPause", function() {
        return _this.innerSlider.pause("paused");
      });
      _defineProperty2(_assertThisInitialized2(_this), "slickPlay", function() {
        return _this.innerSlider.autoPlay("play");
      });
      _this.state = {
        breakpoint: null
      };
      _this._responsiveMediaHandlers = [];
      return _this;
    }
    __name(Slider2, "Slider2");
    _createClass2(Slider2, [{
      key: "media",
      value: /* @__PURE__ */ __name(function media(query, handler) {
        enquire.register(query, handler);
        this._responsiveMediaHandlers.push({
          query,
          handler
        });
      }, "media")
      // handles responsive breakpoints
    }, {
      key: "componentDidMount",
      value: /* @__PURE__ */ __name(function componentDidMount() {
        var _this2 = this;
        if (this.props.responsive) {
          var breakpoints = this.props.responsive.map(function(breakpt) {
            return breakpt.breakpoint;
          });
          breakpoints.sort(function(x2, y2) {
            return x2 - y2;
          });
          breakpoints.forEach(function(breakpoint, index2) {
            var bQuery;
            if (index2 === 0) {
              bQuery = (0, _json2mq["default"])({
                minWidth: 0,
                maxWidth: breakpoint
              });
            } else {
              bQuery = (0, _json2mq["default"])({
                minWidth: breakpoints[index2 - 1] + 1,
                maxWidth: breakpoint
              });
            }
            (0, _innerSliderUtils2.canUseDOM)() && _this2.media(bQuery, function() {
              _this2.setState({
                breakpoint
              });
            });
          });
          var query = (0, _json2mq["default"])({
            minWidth: breakpoints.slice(-1)[0]
          });
          (0, _innerSliderUtils2.canUseDOM)() && this.media(query, function() {
            _this2.setState({
              breakpoint: null
            });
          });
        }
      }, "componentDidMount")
    }, {
      key: "componentWillUnmount",
      value: /* @__PURE__ */ __name(function componentWillUnmount() {
        this._responsiveMediaHandlers.forEach(function(obj) {
          enquire.unregister(obj.query, obj.handler);
        });
      }, "componentWillUnmount")
    }, {
      key: "render",
      value: /* @__PURE__ */ __name(function render() {
        var _this3 = this;
        var settings;
        var newProps;
        if (this.state.breakpoint) {
          newProps = this.props.responsive.filter(function(resp) {
            return resp.breakpoint === _this3.state.breakpoint;
          });
          settings = newProps[0].settings === "unslick" ? "unslick" : _objectSpread2(_objectSpread2(_objectSpread2({}, _defaultProps2["default"]), this.props), newProps[0].settings);
        } else {
          settings = _objectSpread2(_objectSpread2({}, _defaultProps2["default"]), this.props);
        }
        if (settings.centerMode) {
          if (settings.slidesToScroll > 1 && false) {
            console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
          }
          settings.slidesToScroll = 1;
        }
        if (settings.fade) {
          if (settings.slidesToShow > 1 && false) {
            console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
          }
          if (settings.slidesToScroll > 1 && false) {
            console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
          }
          settings.slidesToShow = 1;
          settings.slidesToScroll = 1;
        }
        var children = _react2["default"].Children.toArray(this.props.children);
        children = children.filter(function(child) {
          if (typeof child === "string") {
            return !!child.trim();
          }
          return !!child;
        });
        if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
          console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
          settings.variableWidth = false;
        }
        var newChildren = [];
        var currentWidth = null;
        for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {
          var newSlide = [];
          for (var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {
            var row = [];
            for (var k2 = j; k2 < j + settings.slidesPerRow; k2 += 1) {
              if (settings.variableWidth && children[k2].props.style) {
                currentWidth = children[k2].props.style.width;
              }
              if (k2 >= children.length)
                break;
              row.push(/* @__PURE__ */ _react2["default"].cloneElement(children[k2], {
                key: 100 * i + 10 * j + k2,
                tabIndex: -1,
                style: {
                  width: "".concat(100 / settings.slidesPerRow, "%"),
                  display: "inline-block"
                }
              }));
            }
            newSlide.push(/* @__PURE__ */ _react2["default"].createElement("div", {
              key: 10 * i + j
            }, row));
          }
          if (settings.variableWidth) {
            newChildren.push(/* @__PURE__ */ _react2["default"].createElement("div", {
              key: i,
              style: {
                width: currentWidth
              }
            }, newSlide));
          } else {
            newChildren.push(/* @__PURE__ */ _react2["default"].createElement("div", {
              key: i
            }, newSlide));
          }
        }
        if (settings === "unslick") {
          var className = "regular slider " + (this.props.className || "");
          return /* @__PURE__ */ _react2["default"].createElement("div", {
            className
          }, children);
        } else if (newChildren.length <= settings.slidesToShow && !settings.infinite) {
          settings.unslick = true;
        }
        return /* @__PURE__ */ _react2["default"].createElement(_innerSlider.InnerSlider, _extends3({
          style: this.props.style,
          ref: this.innerSliderRefHandler
        }, (0, _innerSliderUtils2.filterSettings)(settings)), newChildren);
      }, "render")
    }]);
    return Slider2;
  }(_react2["default"].Component);
})(slider);
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var _slider = _interopRequireDefault2(slider);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  __name(_interopRequireDefault2, "_interopRequireDefault");
  exports["default"] = _slider["default"];
})(lib);
const Slider = /* @__PURE__ */ getDefaultExportFromCjs(lib);
const CardChecklistItem = /* @__PURE__ */ __name(({
  checklistItem,
  onOpenItemImage,
  onChangeProblem,
  onChangeOkay,
  onChangeObservation,
  renderItemImage,
  renderErrorColor,
  renderOkayColor,
  renderObservation,
  isMovimentationResponsable,
  handleFileChange,
  toBeDone: toBeDone2,
  isIOS,
  shouldShowFinalizeButton,
  handleSendChecklistItems,
  key,
  isMobile
}) => {
  const shouldShowUploadFileButton = /* @__PURE__ */ __name(() => {
    return toBeDone2() && isMovimentationResponsable() && isMobile;
  }, "shouldShowUploadFileButton");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Card,
    {
      sx: {
        width: {
          xs: "100%"
        },
        boxShadow: "none",
        margin: "auto",
        minHeight: 320,
        borderRadius: "10px",
        cursor: "pointer"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CardMedia,
          {
            onClick: () => onOpenItemImage(checklistItem),
            sx: {
              height: 200
            },
            image: renderItemImage(checklistItem),
            title: "checklist image"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", children: checklistItem.nome_item_checklist }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => onChangeProblem(checklistItem),
              sx: { width: "fit-content" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", gap: 1, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  default_1$m,
                  {
                    sx: {
                      color: renderErrorColor(checklistItem)
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    sx: {
                      color: renderErrorColor(checklistItem)
                    },
                    variant: "body2",
                    fontSize: "small",
                    children: "Problema"
                  }
                )
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              id: "notProblem",
              onClick: () => onChangeOkay(checklistItem),
              sx: { width: "fit-content" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", gap: 1, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  default_1$l,
                  {
                    sx: {
                      color: renderOkayColor(checklistItem)
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    sx: {
                      color: renderOkayColor(checklistItem)
                    },
                    variant: "body2",
                    fontSize: "small",
                    children: "Okay"
                  }
                )
              ] })
            }
          ),
          shouldShowUploadFileButton() && /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "file",
                id: "fileUpload",
                accept: "image/*",
                capture: isIOS ? false : "environment",
                style: { display: "none" },
                onChange: (e2) => handleFileChange(e2, checklistItem)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                component: "span",
                variant: "outlined",
                sx: {
                  height: "20px",
                  width: "fit-content",
                  padding: 2,
                  borderRadius: 5
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", gap: 0.5, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", children: "Novo Arquivo" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$9, { sx: { fontSize: "16px" } })
                ] })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              onChange: (e2) => onChangeObservation(e2, checklistItem),
              placeholder: "Observao...",
              value: renderObservation(checklistItem)
            }
          ),
          shouldShowFinalizeButton && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleSendChecklistItems, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              fontSize: "medium",
              fontFamily: "revert-layer",
              textTransform: "capitalize",
              children: "Finalizar"
            }
          ) })
        ] }) })
      ]
    },
    key
  );
}, "CardChecklistItem");
var NavigateBefore = {};
var _interopRequireDefault$5 = interopRequireDefaultExports;
Object.defineProperty(NavigateBefore, "__esModule", {
  value: true
});
var default_1$5 = NavigateBefore.default = void 0;
var _createSvgIcon$5 = _interopRequireDefault$5(requireCreateSvgIcon());
var _jsxRuntime$5 = jsxRuntimeExports;
default_1$5 = NavigateBefore.default = (0, _createSvgIcon$5.default)(/* @__PURE__ */ (0, _jsxRuntime$5.jsx)("path", {
  d: "M15.41 7.41 14 6l-6 6 6 6 1.41-1.41L10.83 12z"
}), "NavigateBefore");
var NavigateNext = {};
var _interopRequireDefault$4 = interopRequireDefaultExports;
Object.defineProperty(NavigateNext, "__esModule", {
  value: true
});
var default_1$4 = NavigateNext.default = void 0;
var _createSvgIcon$4 = _interopRequireDefault$4(requireCreateSvgIcon());
var _jsxRuntime$4 = jsxRuntimeExports;
default_1$4 = NavigateNext.default = (0, _createSvgIcon$4.default)(/* @__PURE__ */ (0, _jsxRuntime$4.jsx)("path", {
  d: "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
}), "NavigateNext");
var Circle = {};
var _interopRequireDefault$3 = interopRequireDefaultExports;
Object.defineProperty(Circle, "__esModule", {
  value: true
});
var default_1$3 = Circle.default = void 0;
var _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon());
var _jsxRuntime$3 = jsxRuntimeExports;
default_1$3 = Circle.default = (0, _createSvgIcon$3.default)(/* @__PURE__ */ (0, _jsxRuntime$3.jsx)("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2"
}), "Circle");
const SliderPagination = /* @__PURE__ */ __name(({
  ChecklistItems,
  currentSlideIndex,
  previous,
  next: next2
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: "space-y-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: previous, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$5, { sx: { color: "blue" } }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: next2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$4, { sx: { color: "blue" } }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", justifyContent: "center", flexWrap: "wrap", gap: 1, children: ChecklistItems == null ? void 0 : ChecklistItems.map((_checklistItem, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      default_1$3,
      {
        sx: {
          width: "12px",
          height: "12px",
          borderRadius: "50%",
          backgroundColor: index2 === currentSlideIndex ? "#333" : "#bbb",
          // Cor ativa para o slide atual
          transition: "transform 0.3s ease, background-color 0.3s ease",
          cursor: "pointer",
          color: "#e3e3e3",
          transform: index2 === currentSlideIndex ? "scale(1.4)" : "scale(1)",
          // Aumento do ponto ativo
          "&:hover": {
            backgroundColor: "#888",
            // Cor ao passar o mouse
            transform: index2 === currentSlideIndex ? "scale(1.4)" : "scale(1.2)"
            // Efeito de zoom ao passar o mouse
          }
        }
      },
      index2
    )) })
  ] });
}, "SliderPagination");
dayjs.extend(utc);
dayjs.extend(timezone);
const ChecklistItemsModal = /* @__PURE__ */ __name(() => {
  var _a2, _b2;
  const {
    checklistOpen,
    toggleChecklistOpen,
    setChecklistOpen,
    refreshChecklist,
    toggleRefreshChecklist
  } = reactExports.useContext(checklistContext);
  const { user } = reactExports.useContext(userContext);
  const [ChecklistItems, setChecklistItems] = reactExports.useState([]);
  const [isMobile, setIsMobile] = reactExports.useState(false);
  const [currentSlideIndex, setCurrentSlideIndex] = reactExports.useState(0);
  const [isIOS, setIsIOS] = reactExports.useState(false);
  const sliderRef = reactExports.useRef(null);
  const [itemImageOpen, setItemImageOpen] = reactExports.useState();
  const [isLoadingItems, setIsLoadingItems] = reactExports.useState(true);
  function verifyIsIOS() {
    if (navigator.userAgent.toLowerCase().includes("iphone")) {
      setIsIOS(true);
      return;
    }
    setIsIOS(false);
  }
  __name(verifyIsIOS, "verifyIsIOS");
  const next2 = /* @__PURE__ */ __name(async () => {
    if (sliderRef.current) {
      sliderRef.current.slickNext();
    }
    return;
  }, "next");
  const previous = /* @__PURE__ */ __name(() => {
    if (sliderRef.current) {
      sliderRef.current.slickPrev();
    }
  }, "previous");
  const settings = {
    swipe: true,
    arrows: false,
    accessibility: false,
    dots: false,
    infinite: false,
    speed: 200,
    slidesToShow: 1,
    slidesToScroll: 1,
    draggable: false,
    beforeChange: (oldIndex) => {
      if (ChecklistItems && ChecklistItems[oldIndex]) {
        (async () => {
          await sendChecklistItems(ChecklistItems);
          console.log("saved it");
        })();
      } else {
        console.log("dont save it because there's no item");
      }
    },
    afterChange: (current) => setCurrentSlideIndex(current)
  };
  const handleClose = /* @__PURE__ */ __name(() => {
    toggleChecklistOpen();
  }, "handleClose");
  const handleUploadImage = /* @__PURE__ */ __name(async (checklistItem, file) => {
    if (checklistItem) {
      const updatedItems = updateChecklistItemToOkay(checklistItem);
      await sendChecklistItems(updatedItems);
      await uploadFileToChecklistItemFile(checklistItem.id_item_checklist_movimentacao, file);
      toggleRefreshChecklist();
      return;
    }
  }, "handleUploadImage");
  const updateChecklistItemToOkay = /* @__PURE__ */ __name((checklistItemReceived) => {
    return (ChecklistItems == null ? void 0 : ChecklistItems.map((checklistItem) => {
      if (checklistItem) {
        return checklistItem.id_item_checklist_movimentacao === checklistItemReceived.id_item_checklist_movimentacao ? {
          ...checklistItemReceived,
          problema: 0
        } : checklistItem;
      }
      return checklistItem;
    })) || [];
  }, "updateChecklistItemToOkay");
  const handleFileChange = /* @__PURE__ */ __name(async (e2, checklistItem) => {
    var _a3;
    const file = (_a3 = e2.target.files) == null ? void 0 : _a3[0];
    if (isMovimentationResponsable() && file && toBeDone2()) {
      const formData = new FormData();
      formData.append("file", file);
      await handleUploadImage(checklistItem, formData);
      return;
    }
    alert("Editar checklist no  permitido!");
  }, "handleFileChange");
  const handleChangeProblem = /* @__PURE__ */ __name((checklistItemReceived) => {
    if (checklistItemReceived) {
      const problem = checklistItemReceived.problema;
      if (!problem && isTypeResponsable2()) {
        const updatedItems = ChecklistItems == null ? void 0 : ChecklistItems.map(
          (checklistItem) => checklistItem.id_item_checklist_movimentacao === checklistItemReceived.id_item_checklist_movimentacao ? {
            ...checklistItem,
            problema: 1
          } : checklistItem
        );
        setChecklistItems(updatedItems);
      }
    }
  }, "handleChangeProblem");
  const handleChangeOkay = /* @__PURE__ */ __name((checklistItemReceived) => {
    if (checklistItemReceived) {
      const problem = checklistItemReceived.problema;
      if (problem && isTypeResponsable2()) {
        const updatedItems = ChecklistItems == null ? void 0 : ChecklistItems.map(
          (checklistItem) => checklistItem.id_item_checklist_movimentacao === checklistItemReceived.id_item_checklist_movimentacao ? {
            ...checklistItem,
            problema: 0
          } : checklistItem
        );
        setChecklistItems(updatedItems);
      }
    }
  }, "handleChangeOkay");
  const handleAproveChecklist = /* @__PURE__ */ __name(async () => {
    if (checklistOpen[1]) {
      const currentChecklist = {
        ...checklistOpen[1]
      };
      const problemItem = ChecklistItems == null ? void 0 : ChecklistItems.find((checklistItem) => checklistItem.problema);
      if (problemItem) {
        alert(
          "Existem itens com problemas, todos devem estar Okay para aprovar!"
        );
        return;
      }
      const response = ChecklistItems && await sendChecklistItems(ChecklistItems);
      if (response && response.status === 200) {
        currentChecklist.aprovado = 1;
        currentChecklist.data_aprovado = dayjs().tz("America/Sao_Paulo").format("YYYY-MM-DD HH:mm:ss");
        const response2 = await sendChecklist(currentChecklist);
        if (response2 && response2.status === 200) {
          setChecklistOpen([true, currentChecklist]);
          toggleRefreshChecklist();
          alert("Checklist Aprovado!");
        }
      }
    }
  }, "handleAproveChecklist");
  const handleReproveChecklist = /* @__PURE__ */ __name(async () => {
    if (checklistOpen[1]) {
      const currentChecklist = {
        ...checklistOpen[1]
      };
      const problemItem = ChecklistItems == null ? void 0 : ChecklistItems.find(
        (checklistItem) => checklistItem.problema === 1
      );
      if (!problemItem) {
        alert(
          "Por favor, marque o item com problema antes de reprovar o checklist"
        );
        return;
      }
      const response = ChecklistItems && await sendChecklistItems(ChecklistItems);
      if (response && response.status === 200) {
        currentChecklist.aprovado = 0;
        currentChecklist.realizado = 0;
        currentChecklist.reprovado = 1;
        const checklistResponse = await sendChecklist(currentChecklist);
        if (checklistResponse && checklistResponse.status === 200) {
          setChecklistOpen([true, currentChecklist]);
          toggleRefreshChecklist();
          alert("Checklist Reprovado!");
        }
      }
    }
  }, "handleReproveChecklist");
  const handleSendChecklistItems = /* @__PURE__ */ __name(async () => {
    const noFilteItem = ChecklistItems.find((item) => !item.arquivo);
    if (noFilteItem) {
      alert("Todos os itens da checklist devem ter uma imagem.");
      return;
    }
    if (ChecklistItems) {
      const response = await sendChecklistItems(ChecklistItems);
      if (response && response.status === 200 && checklistOpen[1]) {
        const currentChecklist = { ...checklistOpen[1] };
        currentChecklist.realizado = 1;
        currentChecklist.data_realizado = dayjs().tz("America/Sao_Paulo").format("YYYY-MM-DD HH:mm:ss");
        await sendCurrentChecklist(currentChecklist);
        toggleRefreshChecklist();
        toggleChecklistOpen();
      }
      return;
    }
  }, "handleSendChecklistItems");
  const sendCurrentChecklist = /* @__PURE__ */ __name(async (checklist) => {
    const response = await sendChecklist(checklist);
    if (response && response.status === 200) {
      setChecklistOpen([
        true,
        {
          ...checklist
        }
      ]);
    }
  }, "sendCurrentChecklist");
  const handleChangeItemObservation = /* @__PURE__ */ __name((e2, checklistItemReceived) => {
    const { value } = e2.target;
    const updatedChecklistItems = ChecklistItems == null ? void 0 : ChecklistItems.map(
      (checklistItem) => {
        if (checklistItemReceived.id_item_checklist_movimentacao === checklistItem.id_item_checklist_movimentacao) {
          const updatedChecklistMap = { ...checklistItemReceived };
          updatedChecklistMap.observacao = value;
          return { ...updatedChecklistMap };
        }
        return {
          ...checklistItem
        };
      }
    );
    setChecklistItems(updatedChecklistItems);
  }, "handleChangeItemObservation");
  const getChecklistItemsMap = reactExports.useCallback(async () => {
    if (checklistOpen[1]) {
      const { id_patrimonio, id_movimentacao, id_checklist_movimentacao } = checklistOpen[1];
      const checklistItems = await getChecklistItems(
        id_patrimonio,
        id_movimentacao,
        id_checklist_movimentacao
      );
      if (checklistItems) {
        console.log(checklistItems);
        setChecklistItems(checklistItems);
        return;
      }
    }
  }, [checklistOpen]);
  const renderItemImage = /* @__PURE__ */ __name((checklistItem) => {
    if (checklistItem.arquivo) {
      return `${checklistItem.arquivo}`;
    }
    return CameraFileLogo;
  }, "renderItemImage");
  const renderErrorColor = /* @__PURE__ */ __name((checklistItem) => {
    if (checklistItem) {
      return checklistItem.problema ? "red" : "gray";
    }
    return "gray";
  }, "renderErrorColor");
  const renderOkayColor = /* @__PURE__ */ __name((checklistItem) => {
    if (checklistItem) {
      return !checklistItem.problema ? "green" : "gray";
    }
    return "gray";
  }, "renderOkayColor");
  const toBeAproved2 = /* @__PURE__ */ __name(() => {
    var _a3, _b3;
    if (isTypeResponsable2()) {
      return ((_a3 = checklistOpen[1]) == null ? void 0 : _a3.aprovado) === 0 && ((_b3 = checklistOpen[1]) == null ? void 0 : _b3.realizado) === 1;
    }
    return false;
  }, "toBeAproved");
  const isTypeResponsable2 = /* @__PURE__ */ __name(() => {
    var _a3;
    return ((_a3 = checklistOpen[1]) == null ? void 0 : _a3.responsavel_tipo) === (user == null ? void 0 : user.responsavel_tipo);
  }, "isTypeResponsable");
  const isMovimentationResponsable = /* @__PURE__ */ __name(() => {
    var _a3, _b3, _c2;
    console.log(
      "isMoveRespnsable: ",
      ((_a3 = checklistOpen[1]) == null ? void 0 : _a3.responsavel_movimentacao) === (user == null ? void 0 : user.CODPESSOA)
    );
    console.log("user.CODPESSOA", user == null ? void 0 : user.CODPESSOA);
    console.log("responsable: ", (_b3 = checklistOpen[1]) == null ? void 0 : _b3.responsavel_movimentacao);
    return ((_c2 = checklistOpen[1]) == null ? void 0 : _c2.responsavel_movimentacao) === (user == null ? void 0 : user.CODPESSOA);
  }, "isMovimentationResponsable");
  const toBeDone2 = /* @__PURE__ */ __name(() => {
    var _a3, _b3, _c2, _d2;
    console.log(
      "tobeDone: ",
      ((_a3 = checklistOpen[1]) == null ? void 0 : _a3.realizado) === 0 && ((_b3 = checklistOpen[1]) == null ? void 0 : _b3.aprovado) === 0
    );
    return ((_c2 = checklistOpen[1]) == null ? void 0 : _c2.realizado) === 0 && ((_d2 = checklistOpen[1]) == null ? void 0 : _d2.aprovado) === 0;
  }, "toBeDone");
  const checkIfMobile = /* @__PURE__ */ __name(() => {
    const mobileBreakpoint = 768;
    if (window.innerWidth <= mobileBreakpoint) {
      setIsMobile(true);
    } else {
      setIsMobile(false);
    }
  }, "checkIfMobile");
  const lastItem = /* @__PURE__ */ __name(() => {
    if (ChecklistItems && currentSlideIndex === ChecklistItems.length - 1) {
      return true;
    }
    return false;
  }, "lastItem");
  const renderObservation = /* @__PURE__ */ __name((checklistItem) => {
    if (checklistItem) {
      return checklistItem.observacao ? checklistItem.observacao : "";
    }
    return "";
  }, "renderObservation");
  const handleCloseImageModal = /* @__PURE__ */ __name(() => {
    setItemImageOpen(void 0);
  }, "handleCloseImageModal");
  const handleOpenItemImage = /* @__PURE__ */ __name((checklistItem) => {
    if (checklistItem.arquivo) {
      setItemImageOpen(checklistItem);
      return;
    }
    alert("No h arquivo!");
  }, "handleOpenItemImage");
  const shouldShowFinalizeButton = toBeDone2() && isMovimentationResponsable() && (lastItem() || !isMobile) || isTypeResponsable2();
  const shouldShowApprovalButtons = toBeAproved2() && (lastItem() || !isMobile);
  reactExports.useEffect(() => {
    if ((ChecklistItems == null ? void 0 : ChecklistItems.length) > 0) {
      const timer = setTimeout(() => {
        setIsLoadingItems(false);
      }, (ChecklistItems == null ? void 0 : ChecklistItems.length) * 200);
      return () => clearTimeout(timer);
    }
  });
  reactExports.useEffect(() => {
    verifyIsIOS();
    checkIfMobile();
    getChecklistItemsMap();
  }, [checklistOpen, refreshChecklist, getChecklistItemsMap]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Modal$3, { open: checklistOpen[0], onClose: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        display: "flex",
        flexDirection: "column",
        gap: "4rem",
        justifyContent: "start",
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        height: "96%",
        width: {
          xs: "90%",
          md: "60%",
          lg: "40%",
          xl: "80%"
        },
        bgcolor: "background.paper",
        boxShadow: 24,
        p: {
          xs: 0.5,
          md: 3,
          lg: 4,
          xl: 5
        },
        overflowY: "scroll",
        borderRadius: "8px",
        // Bordas arredondadas para um visual mais clean
        outline: "none"
        // Remover as bordas do modal
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            onClick: handleClose,
            sx: {
              position: "absolute",
              top: 8,
              right: 8
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, { sx: { color: "red" } })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Stack,
          {
            direction: "column",
            alignItems: "center",
            spacing: 1,
            padding: 1,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Typography,
                {
                  variant: "h6",
                  component: "h2",
                  textAlign: "center",
                  marginBottom: 2,
                  children: "Checklist"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Typography,
                {
                  textAlign: "center",
                  fontSize: "small",
                  color: "blue",
                  sx: { textDecoration: "underline", cursor: "pointer" },
                  onClick: () => {
                    var _a3;
                    return window.open(
                      `/patrimony/details/${(_a3 = checklistOpen[1]) == null ? void 0 : _a3.id_patrimonio}`
                    );
                  },
                  children: [
                    "Patrimnio ",
                    (_a2 = checklistOpen[1]) == null ? void 0 : _a2.id_patrimonio,
                    " (",
                    (_b2 = checklistOpen[1]) == null ? void 0 : _b2.nome,
                    ")"
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              display: "flex",
              flexDirection: "column",
              alignItems: {
                md: "center"
              },
              justifyContent: "center",
              gap: "2rem"
            },
            children: isLoadingItems ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { sx: { margin: "auto" } }) : ChecklistItems && !isMobile ? (
              // Desktop
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  sx: {
                    display: "grid",
                    gridTemplateColumns: `repeat(${Math.min(
                      ChecklistItems.length,
                      4
                    )}, 1fr)`,
                    // Definindo o mximo de 4 colunas
                    justifyContent: "center",
                    gap: 2
                    // Espaamento entre os itens do grid
                  },
                  children: ChecklistItems.map((checklistItem) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    CardChecklistItem,
                    {
                      checklistItem,
                      onOpenItemImage: handleOpenItemImage,
                      onChangeProblem: handleChangeProblem,
                      onChangeOkay: handleChangeOkay,
                      onChangeObservation: handleChangeItemObservation,
                      renderItemImage,
                      renderErrorColor,
                      renderOkayColor,
                      renderObservation,
                      isMovimentationResponsable,
                      handleFileChange,
                      toBeDone: toBeDone2,
                      isMobile,
                      isIOS,
                      shouldShowFinalizeButton,
                      handleSendChecklistItems
                    },
                    checklistItem.id_item_checklist_movimentacao
                  ))
                }
              )
            ) : (
              // Mobile
              ChecklistItems && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: 1, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Slider, { ref: sliderRef, ...settings, children: ChecklistItems.map((checklistItem) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  CardChecklistItem,
                  {
                    checklistItem,
                    onOpenItemImage: handleOpenItemImage,
                    onChangeProblem: handleChangeProblem,
                    onChangeOkay: handleChangeOkay,
                    onChangeObservation: handleChangeItemObservation,
                    renderItemImage,
                    renderErrorColor,
                    renderOkayColor,
                    renderObservation,
                    toBeDone: toBeDone2,
                    handleFileChange,
                    isMovimentationResponsable,
                    isIOS,
                    isMobile,
                    shouldShowFinalizeButton,
                    handleSendChecklistItems
                  },
                  checklistItem.id_item_checklist_movimentacao
                )) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SliderPagination,
                  {
                    ChecklistItems,
                    currentSlideIndex,
                    previous,
                    next: next2
                  }
                )
              ] })
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            display: "flex",
            justifyContent: "center",
            gap: 2,
            marginTop: "1rem",
            sx: {
              transform: "translateY(-4rem)"
            },
            children: shouldShowApprovalButtons && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleAproveChecklist, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "medium", textTransform: "capitalize", children: "Aprovar" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleReproveChecklist, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "medium", textTransform: "capitalize", children: "Reprovar" }) })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FileViewer,
          {
            fileViewerOpen: itemImageOpen !== void 0,
            fileUrl: (itemImageOpen == null ? void 0 : itemImageOpen.arquivo) || "",
            fileName: (itemImageOpen == null ? void 0 : itemImageOpen.arquivo) || "",
            isPDF: isPDF$1,
            handleCloseFileViewer: handleCloseImageModal
          }
        )
      ]
    }
  ) });
}, "ChecklistItemsModal");
const ptBR$2 = {
  components: {
    MuiBreadcrumbs: {
      defaultProps: {
        expandText: "Mostrar caminho"
      }
    },
    MuiTablePagination: {
      defaultProps: {
        getItemAriaLabel: (type) => {
          if (type === "first") {
            return "Ir para a primeira pgina";
          }
          if (type === "last") {
            return "Ir para a ltima pgina";
          }
          if (type === "next") {
            return "Ir para a prxima pgina";
          }
          return "Ir para a pgina anterior";
        },
        labelRowsPerPage: "Linhas por pgina:",
        labelDisplayedRows: ({
          from: from2,
          to,
          count
        }) => `${from2}${to} de ${count !== -1 ? count : `mais de ${to}`}`
      }
    },
    MuiRating: {
      defaultProps: {
        getLabelText: (value) => `${value} Estrela${value !== 1 ? "s" : ""}`,
        emptyLabelText: "Vazio"
      }
    },
    MuiAutocomplete: {
      defaultProps: {
        clearText: "Limpar",
        closeText: "Fechar",
        loadingText: "Carregando",
        noOptionsText: "Sem opes",
        openText: "Abrir"
      }
    },
    MuiAlert: {
      defaultProps: {
        closeText: "Fechar"
      }
    },
    MuiPagination: {
      defaultProps: {
        "aria-label": "Navegar pela paginao",
        getItemAriaLabel: (type, page, selected) => {
          if (type === "page") {
            return `${selected ? "" : "Ir para a "}pgina ${page}`;
          }
          if (type === "first") {
            return "Ir para a primeira pgina";
          }
          if (type === "last") {
            return "Ir para a ltima pgina";
          }
          if (type === "next") {
            return "Ir para a prxima pgina";
          }
          return "Ir para a pgina anterior";
        }
      }
    }
  }
};
const getGridLocalization = /* @__PURE__ */ __name((gridTranslations, coreTranslations) => {
  var _a2, _b2;
  return {
    components: {
      MuiDataGrid: {
        defaultProps: {
          localeText: _extends$4({}, gridTranslations, {
            MuiTablePagination: ((_b2 = (_a2 = coreTranslations == null ? void 0 : coreTranslations.components) == null ? void 0 : _a2.MuiTablePagination) == null ? void 0 : _b2.defaultProps) || {}
          })
        }
      }
    }
  };
}, "getGridLocalization");
const ptBRGrid = {
  // Root
  noRowsLabel: "Nenhuma linha",
  noResultsOverlayLabel: "Nenhum resultado encontrado.",
  // Density selector toolbar button text
  toolbarDensity: "Densidade",
  toolbarDensityLabel: "Densidade",
  toolbarDensityCompact: "Compacto",
  toolbarDensityStandard: "Padro",
  toolbarDensityComfortable: "Confortvel",
  // Columns selector toolbar button text
  toolbarColumns: "Colunas",
  toolbarColumnsLabel: "Exibir seletor de colunas",
  // Filters toolbar button text
  toolbarFilters: "Filtros",
  toolbarFiltersLabel: "Exibir filtros",
  toolbarFiltersTooltipHide: "Ocultar filtros",
  toolbarFiltersTooltipShow: "Exibir filtros",
  toolbarFiltersTooltipActive: (count) => `${count} ${count !== 1 ? "filtros" : "filtro"} ${count !== 1 ? "ativos" : "ativo"}`,
  // Quick filter toolbar field
  toolbarQuickFilterPlaceholder: "Procurar",
  toolbarQuickFilterLabel: "Procurar",
  toolbarQuickFilterDeleteIconLabel: "Limpar",
  // Export selector toolbar button text
  toolbarExport: "Exportar",
  toolbarExportLabel: "Exportar",
  toolbarExportCSV: "Baixar como CSV",
  toolbarExportPrint: "Imprimir",
  toolbarExportExcel: "Baixar como Excel",
  // Columns management text
  columnsManagementSearchTitle: "Buscar",
  columnsManagementNoColumns: "Nenhuma coluna",
  columnsManagementShowHideAllText: "Mostrar/Ocultar Todas",
  columnsManagementReset: "Redefinir",
  // columnsManagementDeleteIconLabel: 'Clear',
  // Filter panel text
  filterPanelAddFilter: "Adicionar filtro",
  filterPanelRemoveAll: "Remover todos",
  filterPanelDeleteIconLabel: "Excluir",
  filterPanelLogicOperator: "Operador lgico",
  filterPanelOperator: "Operador",
  filterPanelOperatorAnd: "E",
  filterPanelOperatorOr: "Ou",
  filterPanelColumns: "Colunas",
  filterPanelInputLabel: "Valor",
  filterPanelInputPlaceholder: "Filtrar valor",
  // Filter operators text
  filterOperatorContains: "contm",
  filterOperatorDoesNotContain: "no contm",
  filterOperatorEquals: " igual a",
  filterOperatorDoesNotEqual: "no  igual a",
  filterOperatorStartsWith: "comea com",
  filterOperatorEndsWith: "termina com",
  filterOperatorIs: "",
  filterOperatorNot: "no ",
  filterOperatorAfter: "aps",
  filterOperatorOnOrAfter: "em ou aps",
  filterOperatorBefore: "antes de",
  filterOperatorOnOrBefore: "em ou antes de",
  filterOperatorIsEmpty: "est vazio",
  filterOperatorIsNotEmpty: "no est vazio",
  filterOperatorIsAnyOf: " qualquer um dos",
  "filterOperator=": "igual ",
  "filterOperator!=": "diferente de",
  "filterOperator>": "maior que",
  "filterOperator>=": "maior ou igual que",
  "filterOperator<": "menor que",
  "filterOperator<=": "menor ou igual que",
  // Header filter operators text
  headerFilterOperatorContains: "Contm",
  headerFilterOperatorDoesNotContain: "No contm",
  headerFilterOperatorEquals: "Igual",
  headerFilterOperatorDoesNotEqual: "No  igual a",
  headerFilterOperatorStartsWith: "Comea com",
  headerFilterOperatorEndsWith: "Termina com",
  headerFilterOperatorIs: "",
  headerFilterOperatorNot: "No ",
  headerFilterOperatorAfter: "Depois de",
  headerFilterOperatorOnOrAfter: "Est entre ou depois de",
  headerFilterOperatorBefore: "Antes de",
  headerFilterOperatorOnOrBefore: "Est entre ou antes de",
  headerFilterOperatorIsEmpty: " vazio",
  headerFilterOperatorIsNotEmpty: "No  vazio",
  headerFilterOperatorIsAnyOf: " algum",
  "headerFilterOperator=": "Igual",
  "headerFilterOperator!=": "No igual",
  "headerFilterOperator>": "Maior que",
  "headerFilterOperator>=": "Maior que ou igual a",
  "headerFilterOperator<": "Menor que",
  "headerFilterOperator<=": "Menor que ou igual a",
  // Filter values text
  filterValueAny: "qualquer",
  filterValueTrue: "verdadeiro",
  filterValueFalse: "falso",
  // Column menu text
  columnMenuLabel: "Menu",
  columnMenuShowColumns: "Exibir colunas",
  columnMenuManageColumns: "Gerir colunas",
  columnMenuFilter: "Filtrar",
  columnMenuHideColumn: "Ocultar",
  columnMenuUnsort: "Desfazer ordenao",
  columnMenuSortAsc: "Ordenar do menor para o maior",
  columnMenuSortDesc: "Ordenar do maior para o menor",
  // Column header text
  columnHeaderFiltersTooltipActive: (count) => `${count} ${count !== 1 ? "filtros" : "filtro"} ${count !== 1 ? "ativos" : "ativo"}`,
  columnHeaderFiltersLabel: "Exibir Filtros",
  columnHeaderSortIconLabel: "Ordenar",
  // Rows selected footer text
  footerRowSelected: (count) => count !== 1 ? `${count.toLocaleString()} linhas selecionadas` : `${count.toLocaleString()} linha selecionada`,
  // Total row amount footer text
  footerTotalRows: "Total de linhas:",
  // Total visible row amount footer text
  footerTotalVisibleRows: (visibleCount, totalCount) => `${visibleCount.toLocaleString()} de ${totalCount.toLocaleString()}`,
  // Checkbox selection text
  checkboxSelectionHeaderName: "Seleo",
  checkboxSelectionSelectAllRows: "Selecionar todas linhas",
  checkboxSelectionUnselectAllRows: "Deselecionar todas linhas",
  checkboxSelectionSelectRow: "Selecionar linha",
  checkboxSelectionUnselectRow: "Deselecionar linha",
  // Boolean cell text
  booleanCellTrueLabel: "sim",
  booleanCellFalseLabel: "no",
  // Actions cell more text
  actionsCellMore: "mais",
  // Column pinning text
  pinToLeft: "Fixar  esquerda",
  pinToRight: "Fixar  direita",
  unpin: "Desafixar",
  // Tree Data
  treeDataGroupingHeaderName: "Grupo",
  treeDataExpand: "mostrar filhos",
  treeDataCollapse: "esconder filhos",
  // Grouping columns
  groupingColumnHeaderName: "Grupo",
  groupColumn: (name) => `Agrupar por ${name}`,
  unGroupColumn: (name) => `Parar agrupamento por ${name}`,
  // Master/detail
  detailPanelToggle: "Painel de detalhes",
  expandDetailPanel: "Expandir",
  collapseDetailPanel: "Esconder",
  // Row reordering text
  rowReorderingHeaderName: "Reorganizar linhas",
  // Aggregation
  aggregationMenuItemHeader: "Agrupar",
  aggregationFunctionLabelSum: "soma",
  aggregationFunctionLabelAvg: "mdia",
  aggregationFunctionLabelMin: "mn",
  aggregationFunctionLabelMax: "mx",
  aggregationFunctionLabelSize: "tamanho"
};
const ptBR$1 = getGridLocalization(ptBRGrid, ptBR$2);
const timeViews = {
  hours: "horas",
  minutes: "minutos",
  seconds: "segundos",
  meridiem: "meridiano"
};
const ptBRPickers = {
  // Calendar navigation
  previousMonth: "Ms anterior",
  nextMonth: "Prximo ms",
  // View navigation
  openPreviousView: "Abrir prxima seleo",
  openNextView: "Abrir seleo anterior",
  calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "Seleo de ano est aberta, alternando para seleo de calendrio" : "Seleo de calendrios est aberta, alternando para seleo de ano",
  // DateRange labels
  start: "Incio",
  end: "Fim",
  startDate: "Data de incio",
  startTime: "Hora de incio",
  endDate: "Data de Trmino",
  endTime: "Hora de Trmino",
  // Action bar
  cancelButtonLabel: "Cancelar",
  clearButtonLabel: "Limpar",
  okButtonLabel: "OK",
  todayButtonLabel: "Hoje",
  // Toolbar titles
  datePickerToolbarTitle: "Selecione a data",
  dateTimePickerToolbarTitle: "Selecione data e hora",
  timePickerToolbarTitle: "Selecione a hora",
  dateRangePickerToolbarTitle: "Selecione o intervalo entre datas",
  // Clock labels
  clockLabelText: (view, time2, adapter) => `Selecione ${timeViews[view]}. ${time2 === null ? "Hora no selecionada" : `Selecionado a hora ${adapter.format(time2, "fullTime")}`}`,
  hoursClockNumberText: (hours) => `${hours} horas`,
  minutesClockNumberText: (minutes) => `${minutes} minutos`,
  secondsClockNumberText: (seconds) => `${seconds} segundos`,
  // Digital clock labels
  selectViewText: (view) => `Selecione ${timeViews[view]}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Nmero da semana",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (weekNumber) => `Semana ${weekNumber}`,
  calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
  // Open picker labels
  openDatePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Escolha uma data, data selecionada ${utils2.format(value, "fullDate")}` : "Escolha uma data",
  openTimePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Escolha uma hora, hora selecionada ${utils2.format(value, "fullTime")}` : "Escolha uma hora",
  // fieldClearLabel: 'Clear value',
  // Table labels
  timeTableLabel: "escolha uma hora",
  dateTableLabel: "escolha uma data",
  // Field section placeholders
  fieldYearPlaceholder: (params) => "A".repeat(params.digitAmount),
  fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "DD",
  fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "SSSS" : "SS",
  fieldHoursPlaceholder: () => "hh",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa",
  // View names
  year: "Ano",
  month: "Ms",
  day: "Dia",
  weekDay: "Dia da Semana",
  hours: "Horas",
  minutes: "Minutos",
  seconds: "Segundos",
  meridiem: "Meio dia",
  // Common
  empty: "Vazio"
};
const ptBR = getPickersLocalization(ptBRPickers);
const ChecklistCard = /* @__PURE__ */ __name(({
  cardData,
  columns: columns2,
  key,
  props,
  handleOpenChecklist,
  renderValue: renderValue2
}) => {
  const { style: style2 } = props;
  const { user } = reactExports.useContext(userContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { ...style2, ...basicCardStyles }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: basicCardContentStyles, className: "shadow-sm shadow-gray-600", children: [
    columns2.map((column2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { marginBottom: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", gap: 1, alignItems: "center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { fontSize: "small", fontWeight: "bold", color: "black", children: [
        column2.label,
        ":"
      ] }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", color: "textSecondary", children: renderValue2 && user && renderValue2(column2, cardData, user) })
    ] }) }, column2.dataKey)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: () => handleOpenChecklist(cardData),
        sx: { ...BaseButtonStyles },
        children: "Detalhes"
      }
    )
  ] }) }, key);
}, "ChecklistCard");
const theme$3 = createTheme(
  {
    palette: {
      primary: { main: "#1976d2" }
    }
  },
  ptBR$1,
  ptBR,
  ptBR$2
);
const PatrimonyChecklist = /* @__PURE__ */ __name(() => {
  const navigate = useNavigate();
  const { id_patrimonio } = useParams();
  const { toggleChecklistOpen, refreshChecklist } = reactExports.useContext(checklistContext);
  const [checklistData, setChecklistData] = reactExports.useState(
    []
  );
  const [isMobile, setIsMobile] = reactExports.useState(false);
  const [isCardViewActive, setIsCardViewActive] = reactExports.useState(false);
  const handleOpenChecklist = /* @__PURE__ */ __name((row) => {
    toggleChecklistOpen(row);
  }, "handleOpenChecklist");
  const handleBack = /* @__PURE__ */ __name(() => {
    navigate(`/patrimony`);
  }, "handleBack");
  const getChecklistData = reactExports.useCallback(async () => {
    const checkListData = await getChecklistDataByPatrimonyId(
      Number(id_patrimonio)
    );
    if (checkListData) {
      setChecklistData(checkListData);
    }
  }, [id_patrimonio]);
  reactExports.useEffect(() => {
    getChecklistData();
    setIsCardViewActive(window.innerWidth < 768);
    setIsMobile(window.innerWidth < 768);
  }, [getChecklistData, refreshChecklist]);
  const columns2 = [
    {
      field: "nome_patrimonio",
      headerName: "Patrimnio",
      width: 300
    },
    {
      field: "id_checklist_movimentacao",
      headerName: "Checklist",
      width: 100
    },
    {
      field: "id_movimentacao",
      headerName: "Movimentao",
      width: 120
    },
    {
      field: "data_criacao",
      headerName: "Data de Criao",
      width: 200,
      valueFormatter: (value) => value ? dateTimeRenderer(value) : ""
    },
    {
      field: "realizado",
      headerName: "Realizado",
      width: 100,
      valueFormatter: (value) => value === 1 ? "Sim" : "No"
    },
    {
      field: "data_realizado",
      headerName: "Data de Realizao",
      width: 150,
      valueFormatter: (value) => value ? dateTimeRenderer(value) : ""
    },
    {
      field: "aprovado",
      headerName: "Aprovado",
      width: 100,
      valueFormatter: (value) => value === 1 ? "Sim" : "No"
    },
    {
      field: "data_aprovado",
      headerName: "Data de Aprovao",
      width: 150,
      valueFormatter: (value) => value ? dateTimeRenderer(value) : ""
    },
    {
      field: "descricao_projeto",
      headerName: "Projeto",
      width: 400
    },
    {
      field: "nome_responsavel",
      headerName: "Responsvel",
      width: 200
    }
  ];
  const GridFooter3 = /* @__PURE__ */ __name(() => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridFooterContainer, { sx: { paddingX: 6 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { fontSize: "small", color: "blue", children: [
        "Total de checklists: ",
        checklistData.length
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(GridPagination, {})
    ] });
  }, "GridFooter");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      height: "100vh",
      display: "flex",
      width: "100%",
      flexDirection: "column",
      padding: 0.5,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AppBar, { position: "static", sx: { ...basicAppbarStyles }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { display: "flex", alignItems: "center", flexGrow: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              sx: {
                color: "#F7941E",
                cursor: "pointer",
                "&:hover": {
                  backgroundColor: "rgba(0, 0, 0, 0.05)"
                }
              },
              onClick: handleBack,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftIcon, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              textAlign: "left",
              fontSize: "medium",
              fontFamily: "Roboto",
              padding: 2,
              children: (checklistData == null ? void 0 : checklistData.length) ? `Histrico de Checklists do Patrimnio | ${checklistData[0].nome_patrimonio} | 000${checklistData[0].id_patrimonio}` : "No h checklists para este patrimnio"
            }
          ),
          isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
            TableViewToggleButton,
            {
              isCardViewActive,
              setIsCardViewActive
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Paper,
          {
            sx: {
              height: "calc(100% - 64px)",
              // Ajusta para ocupar a tela abaixo do AppBar
              marginTop: 2
            },
            children: [
              !isCardViewActive && /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider2, { theme: theme$3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                DataGrid,
                {
                  rows: checklistData,
                  columns: columns2,
                  getRowId: (row) => row.id_checklist_movimentacao,
                  initialState: {
                    pagination: {
                      paginationModel: {
                        pageSize: 30
                      }
                    }
                  },
                  columnHeaderHeight: 30,
                  pageSizeOptions: [10, 20, 30],
                  rowHeight: 30,
                  onRowClick: ({ row }) => handleOpenChecklist(row),
                  slots: {
                    footer: GridFooter3
                  },
                  sx: {
                    "& .MuiDataGrid-row:hover": {
                      backgroundColor: "#e7eaf6"
                    },
                    padding: 0.5,
                    width: "100%",
                    borderCollapse: "collapse",
                    fontFamily: "Arial, sans-serif",
                    fontSize: "12.5px",
                    "& .MuiDataGrid-columnHeaders": {
                      fontWeight: "bold"
                    },
                    "& .MuiDataGrid-columnHeaderTitle": {
                      fontWeight: "bold",
                      fontSize: 12
                    },
                    "& .MuiDataGrid-row": {
                      ":nth-child(even)": {
                        backgroundColor: "#e7eaf6"
                      }
                    },
                    "& .MuiDataGrid-cell": {
                      paddingLeft: 1.2
                    }
                  }
                }
              ) }),
              isCardViewActive && /* @__PURE__ */ jsxRuntimeExports.jsx(
                FixedSizeList,
                {
                  height: 600,
                  width: "100%",
                  itemSize: 320,
                  itemCount: checklistData.length,
                  overscanCount: 1,
                  children: ({ index: index2, style: style2, data }) => {
                    const cardStyle = { ...style2 };
                    const columns22 = [
                      { label: "Patrimnio", dataKey: "nome_patrimonio" },
                      { label: "Data de Criao", dataKey: "data_criacao" },
                      { label: "Projeto", dataKey: "descricao_projeto" },
                      { label: "Responsvel", dataKey: "nome_responsavel" },
                      { label: "Realizado", dataKey: "realizado" },
                      { label: "Aprovado", dataKey: "aprovado" }
                    ];
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ChecklistCard,
                      {
                        props: { index: index2, style: cardStyle, data },
                        cardData: checklistData[index2],
                        renderValue,
                        handleOpenChecklist,
                        columns: columns22
                      },
                      0
                    );
                  }
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistItemsModal, {})
      ]
    }
  );
}, "PatrimonyChecklist");
const CustomOpportunityRow = React$1.memo((props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MemoizedGridRow, { ...props }) });
});
const defaultColumnFilters = [
  { dataKey: "numero_projeto", filterValue: "" },
  { dataKey: "numero_adicional", filterValue: "" },
  { dataKey: "status", filterValue: "" },
  { dataKey: "descricao_projeto", filterValue: "" },
  { dataKey: "cliente", filterValue: "" },
  { dataKey: "data_cadastro", filterValue: "" },
  { dataKey: "data_solicitacao", filterValue: "" },
  { dataKey: "data_envio_proposta", filterValue: "" },
  { dataKey: "data_fechamento", filterValue: "" },
  { dataKey: "vendedor", filterValue: "" },
  { dataKey: "gerente", filterValue: "" },
  { dataKey: "coordenador", filterValue: "" }
];
const defaultDateFilters = [
  { dateFilterKey: "data_inicio", from: "", to: "", dbField: "DATAINICIO" },
  {
    dateFilterKey: "data_interacao",
    from: "",
    to: "",
    dbField: "DATAINTERACAO"
  },
  {
    dateFilterKey: "data_fechamento",
    from: "",
    to: "",
    dbField: "DATAENTREGA"
  }
];
const OpportunityInfoContext = reactExports.createContext({
  filteredRows: [],
  columnFilters: defaultColumnFilters,
  dateFilters: defaultDateFilters,
  finishedOppsEnabled: false,
  creatingOpportunity: false,
  refreshOpportunityInfo: false,
  currentOppIdSelected: 0,
  setCurrentOppIdSelected: () => {
  },
  setFinishedOppsEnabled: () => {
  },
  toggleCreatingOpportunity: () => {
  },
  toggleRefreshOpportunityInfo: () => {
  },
  changeFilteredRows: () => {
  },
  changeColumnFilters: () => {
  },
  setCreatingOpportunity: () => {
  },
  setDateFilters: () => {
  }
});
const OpportunityInfoProvider = /* @__PURE__ */ __name(({
  children
}) => {
  const [filteredRows, setFilteredRows] = reactExports.useState([]);
  const [columnFilters, setColumnFilters] = reactExports.useState(defaultColumnFilters);
  const [dateFilters, setDateFilters] = reactExports.useState(defaultDateFilters);
  const [creatingOpportunity, setCreatingOpportunity] = reactExports.useState(false);
  const [refreshOpportunityInfo, setRefreshOpportunityInfo] = reactExports.useState(false);
  const [finishedOppsEnabled, setFinishedOppsEnabled] = reactExports.useState(false);
  const [currentOppIdSelected, setCurrentOppIdSelected] = reactExports.useState(0);
  const toggleCreatingOpportunity = /* @__PURE__ */ __name(() => {
    console.log("toggleCreatingOpportunity: ", !creatingOpportunity);
    setCreatingOpportunity((prev2) => !prev2);
  }, "toggleCreatingOpportunity");
  const toggleRefreshOpportunityInfo = /* @__PURE__ */ __name(() => {
    setRefreshOpportunityInfo((prev2) => !prev2);
  }, "toggleRefreshOpportunityInfo");
  const changeFilteredRows = /* @__PURE__ */ __name((rows) => {
    setFilteredRows(rows);
  }, "changeFilteredRows");
  const changeColumnFilters = /* @__PURE__ */ __name((filters) => {
    setColumnFilters(filters);
  }, "changeColumnFilters");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    OpportunityInfoContext.Provider,
    {
      value: {
        filteredRows,
        columnFilters,
        dateFilters,
        setDateFilters,
        creatingOpportunity,
        refreshOpportunityInfo,
        toggleCreatingOpportunity,
        toggleRefreshOpportunityInfo,
        changeFilteredRows,
        changeColumnFilters,
        finishedOppsEnabled,
        currentOppIdSelected,
        setCurrentOppIdSelected,
        setCreatingOpportunity,
        setFinishedOppsEnabled
      },
      children
    }
  );
}, "OpportunityInfoProvider");
const styles$6 = {
  guideContainer: {
    width: "100%",
    display: "flex !important",
    flexDirection: "column",
    justifyContent: "center",
    alignItems: "center",
    padding: 0.5,
    gap: 2,
    overflowY: "hidden"
  },
  contentContainer: {
    display: "flex",
    alignItems: "flex-start",
    flexWrap: "wrap",
    gap: 2,
    width: "100%",
    minWidth: 0
  }
};
const styles$5 = {
  container: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: "100%"
  },
  formGrid: {
    display: "grid",
    gridTemplateColumns: {
      xs: "1fr",
      md: "1fr 1fr"
    },
    gap: 1,
    rowGap: 2,
    width: "100%",
    padding: 1
  }
};
const OpportunityRegistration = /* @__PURE__ */ __name(({ guide, guidesReference }) => {
  const { user } = reactExports.useContext(userContext);
  const [statusOptions, setStatusOptions] = reactExports.useState(
    []
  );
  const [clientOptions, setClientOptions] = reactExports.useState(
    []
  );
  const [projectOptions, setProjectOptions] = reactExports.useState([]);
  const [isEditing, setIseEditing] = reactExports.useState(false);
  const [opportunityRegistration, setOpportunityRegistration] = reactExports.useState({
    idProjeto: guide.fields[0].data,
    numeroAdicional: guide.fields[1].data,
    nome: guide.fields[2].data,
    codStatus: guide.fields[3].data,
    descricaoVenda: guide.fields[4].data,
    fkCodCliente: guide.fields[5].data,
    dataSolicitacao: guide.fields[6].data,
    dataInicio: guide.fields[7].data,
    dataEntrega: guide.fields[8].data
  });
  const renderOptions = /* @__PURE__ */ __name((column2) => {
    if (column2.dataKey === "idProjeto")
      return projectOptions;
    if (column2.dataKey === "codStatus")
      return statusOptions;
    if (column2.dataKey === "fkCodCliente")
      return clientOptions;
  }, "renderOptions");
  const changeReference = /* @__PURE__ */ __name((field) => {
    if (guidesReference.current) {
      const guideIndex = guidesReference.current.indexOf(guide);
      const fieldIndex = guidesReference.current[guideIndex].fields.findIndex((referenceField) => referenceField.dataKey === field.dataKey);
      guidesReference.current[guideIndex].fields[fieldIndex] = field;
    }
  }, "changeReference");
  const handleChangeTextField = /* @__PURE__ */ __name((e2, receivedField) => {
    const { value } = e2.target;
    if (receivedField.type === "text") {
      receivedField.data = value;
      setOpportunityRegistration({
        ...opportunityRegistration,
        [receivedField.dataKey]: value
      });
      changeReference(receivedField);
    }
    if (receivedField.type === "date") {
      receivedField.data = value;
      setOpportunityRegistration({
        ...opportunityRegistration,
        [receivedField.dataKey]: value
      });
      changeReference(receivedField);
    }
    return;
  }, "handleChangeTextField");
  const handleChangeAutoComplete = /* @__PURE__ */ __name((field, _event, value, _reason, _details) => {
    setOpportunityRegistration({
      ...opportunityRegistration,
      [field.dataKey]: value == null ? void 0 : value.id
    });
    field.data = value == null ? void 0 : value.id;
    changeReference(field);
  }, "handleChangeAutoComplete");
  const editableField = /* @__PURE__ */ __name((field) => {
    return field.dataKey !== "numeroAdicional";
  }, "editableField");
  const setDefaultClientWhenNotDefined = /* @__PURE__ */ __name(async () => {
    const clientNotDefined = opportunityRegistration.fkCodCliente == "-";
    console.log({
      clientNotDefined,
      idProjeto: opportunityRegistration.idProjeto
    });
    if (clientNotDefined && opportunityRegistration.idProjeto) {
      const clientFromFirstProject = await fetchClientFromFirstProjectOption(
        opportunityRegistration.idProjeto
      );
      console.log({ clientFromFirstProject });
      setOpportunityRegistration({
        ...opportunityRegistration,
        fkCodCliente: clientFromFirstProject.id
      });
      if (guidesReference.current) {
        guide.fields[5].data = clientFromFirstProject.id;
        guidesReference.current[0] = guide;
      }
      return;
    }
  }, "setDefaultClientWhenNotDefined");
  const fetchClientOps = reactExports.useCallback(async () => {
    const clients = await fetchAllClients(0);
    const options = clients.map((client2) => ({
      label: client2.NOMEFANTASIA,
      id: client2.CODCLIENTE,
      object: "client",
      key: client2.CODCLIENTE
    }));
    setClientOptions(options);
  }, [setClientOptions]);
  const fetchProjectsOps = reactExports.useCallback(async () => {
    const projects = await fetchProjectOptionsByUser((user == null ? void 0 : user.CODPESSOA) || 0);
    const options = projects && projects.map((project) => ({
      label: project.DESCRICAO,
      id: project.ID,
      object: "project",
      key: project.ID
    })) || [];
    setProjectOptions([...options]);
  }, [setProjectOptions]);
  const fetchStatusOps = reactExports.useCallback(async () => {
    const statusList = await fetchStatusList();
    const options = statusList.map((status) => ({
      label: status.NOME,
      id: status.CODSTATUS,
      object: "status",
      key: status.CODSTATUS
    })) || [];
    setStatusOptions(options);
  }, [setStatusOptions]);
  const renderAutoCompleteValue = /* @__PURE__ */ __name((field) => {
    if (field.dataKey === "idProjeto") {
      const optionValueSelected = projectOptions.find(
        (option) => option.id === field.data
      );
      if (optionValueSelected)
        return optionValueSelected;
    }
    if (field.dataKey === "codStatus") {
      const optionValueSelected = statusOptions.find(
        (option) => option.id === field.data
      );
      if (optionValueSelected)
        return optionValueSelected;
    }
    if (field.dataKey === "fkCodCliente") {
      const optionValueSelected = clientOptions.find(
        (option) => option.id === opportunityRegistration.fkCodCliente
      );
      if (optionValueSelected)
        return optionValueSelected;
    }
    return {
      label: "",
      id: 0,
      object: "",
      key: 0
    };
  }, "renderAutoCompleteValue");
  reactExports.useEffect(() => {
    fetchClientOps();
    fetchProjectsOps();
    fetchStatusOps();
  }, []);
  reactExports.useEffect(() => {
    if (!isEditing) {
      console.log("REGISTRATION");
      console.log({
        idProjeto: guide.fields[0].data,
        numeroAdicional: guide.fields[1].data,
        nome: guide.fields[2].data,
        codStatus: guide.fields[3].data,
        descricaoVenda: guide.fields[4].data,
        fkCodCliente: guide.fields[5].data,
        dataSolicitacao: guide.fields[6].data,
        dataInicio: guide.fields[7].data,
        dataEntrega: guide.fields[8].data
      });
      setOpportunityRegistration({
        idProjeto: guide.fields[0].data,
        numeroAdicional: guide.fields[1].data,
        nome: guide.fields[2].data,
        codStatus: guide.fields[3].data,
        descricaoVenda: guide.fields[4].data,
        fkCodCliente: guide.fields[5].data,
        dataSolicitacao: guide.fields[6].data,
        dataInicio: guide.fields[7].data,
        dataEntrega: guide.fields[8].data
      });
    }
  }, [guide]);
  reactExports.useEffect(() => {
    if (clientOptions && opportunityRegistration) {
      setDefaultClientWhenNotDefined();
    }
  }, [opportunityRegistration]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: styles$5.container, children: opportunityRegistration && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: styles$5.formGrid, children: guide.fields.map((field, index2) => {
    if (editableField(field) && !field.autoComplete && field.dataKey !== "codOs") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          sx: { gridColumn: "span 2" },
          type: field.type,
          label: field.label,
          onChange: (e2) => handleChangeTextField(e2, field),
          value: opportunityRegistration[field.dataKey],
          required: opportunityRegistration.codStatus === 11,
          InputLabelProps: {
            shrink: true
          },
          onFocus: () => setIseEditing(true)
        },
        index2
      );
    }
    if (editableField(field) && field.autoComplete) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Autocomplete,
        {
          sx: { gridColumn: "span 2" },
          value: renderAutoCompleteValue(field),
          disablePortal: true,
          getOptionKey: (option) => option.key,
          disabled: field.dataKey === "idProjeto",
          onChange: (_event, value, _reason, _details) => handleChangeAutoComplete(field, _event, value),
          options: renderOptions(field) || [],
          renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              ...params,
              label: field.label,
              InputLabelProps: { shrink: true }
            }
          )
        },
        field.dataKey
      );
    }
  }) }) });
}, "OpportunityRegistration");
const style$2 = {
  container: {
    width: "100%",
    display: "flex",
    flexDirection: "column",
    alignItems: "start",
    gap: 2,
    padding: 1
  },
  commentField: {
    borderRadius: 2,
    // Bordas arredondadas
    backgroundColor: "#f9f9f9",
    // Fundo claro para destacar
    boxShadow: "0px 4px 6px rgba(0, 0, 0, 0.1)",
    // Efeito de profundidade
    "& .MuiOutlinedInput-root": {
      "& fieldset": {
        borderColor: "#1976d2"
        // Cor da borda inicial
      },
      "&:hover fieldset": {
        borderColor: "#1565c0"
        // Cor da borda ao passar o mouse
      },
      "&.Mui-focused fieldset": {
        borderColor: "#0d47a1",
        // Cor da borda ao focar
        borderWidth: "2px"
        // Aumenta a espessura ao focar
      }
    },
    "& .MuiInputLabel-root": {
      color: "#757575"
      // Cor do label
    },
    "& .MuiInputLabel-root.Mui-focused": {
      color: "#0d47a1"
      // Cor do label ao focar
    }
  }
};
const CommentRow = /* @__PURE__ */ __name(({ index: index2, comment: comment2, style: style2, setCommentBeingEdit }) => {
  const { user } = reactExports.useContext(userContext);
  const [alert2, setAlert] = reactExports.useState();
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const commentBelongsToUser = /* @__PURE__ */ __name((comment22) => {
    return (user == null ? void 0 : user.NOME) === comment22.criadoPor;
  }, "commentBelongsToUser");
  const displayAlert = /* @__PURE__ */ __name(async (severity, message) => {
    setTimeout(() => {
      setAlert(void 0);
    }, 3e3);
    setAlert({ severity, message });
    return;
  }, "displayAlert");
  const handleStartEdition = /* @__PURE__ */ __name(() => {
    if (commentBelongsToUser(comment2)) {
      setCommentBeingEdit(comment2);
      return;
    }
    displayAlert("warning", "Voc no tem permisso para editar o comentrio");
  }, "handleStartEdition");
  const renderCommentPreview = /* @__PURE__ */ __name((commentValue) => {
    var _a2;
    if (commentValue.length > 50) {
      return ((_a2 = comment2.descricao) == null ? void 0 : _a2.substring(0, 40)) + "...";
    }
    return comment2.descricao;
  }, "renderCommentPreview");
  const handleCloseModal = /* @__PURE__ */ __name(() => {
    setIsModalOpen(false);
  }, "handleCloseModal");
  const handleOpenModal = /* @__PURE__ */ __name(() => {
    setIsModalOpen(true);
  }, "handleOpenModal");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { alignItems: "flex-start", style: { ...style2 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemAvatar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$j, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ListItemText,
        {
          primary: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: handleOpenModal, style: { cursor: "pointer" }, children: renderCommentPreview(comment2.descricao) || "Comentrio vazio" }),
          secondary: comment2.criadoPor ? `Por: ${comment2.criadoPor} | ${formatDateWithNoTime(
            comment2.criadoEm || ""
          )}` : "Autor desconhecido"
        }
      ),
      (user == null ? void 0 : user.CODPESSOA) === 2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          sx: { ...buttonStylesMobile, marginX: 2 },
          onClick: () => handleStartEdition(),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$8, {})
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: alert2 && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...alertAnimation, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: alert2 == null ? void 0 : alert2.severity, children: alert2 == null ? void 0 : alert2.message }) }) })
    ] }, index2),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Modal$3,
      {
        open: isModalOpen,
        onClose: handleCloseModal,
        "aria-labelledby": "modal-title",
        "aria-describedby": "modal-description",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              width: "80%",
              maxWidth: "600px",
              bgcolor: "background.paper",
              boxShadow: 24,
              p: 4,
              borderRadius: 2
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  onClick: handleCloseModal,
                  sx: { position: "absolute", right: 0, top: 0 },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, { sx: { color: "red" } })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { ...typographyStyles.bodyText, textAlign: "left" }, children: comment2.descricao })
            ]
          }
        )
      }
    )
  ] });
}, "CommentRow");
const OpportunityInteraction = /* @__PURE__ */ __name(({ guide, guidesReference }) => {
  const { user } = reactExports.useContext(userContext);
  const [interactionDate, setInteractionDate] = reactExports.useState();
  const [comments, setComments] = reactExports.useState();
  const [commentBeingEdited, setCommentBeingEdited] = reactExports.useState();
  const [commentBeingAdded, setCommentBeingAdded] = reactExports.useState();
  const handleChangeComment = /* @__PURE__ */ __name((e2, commentId) => {
    const { value } = e2.target;
    if (comments) {
      const updatedComments = comments.map(
        (comment2) => comment2.codigoComentario === commentId ? { ...comment2, descricao: value } : comment2
      );
      setComments(updatedComments);
    }
    if (commentBeingEdited) {
      setCommentBeingEdited({
        ...commentBeingEdited,
        descricao: value
      });
      return;
    }
    if (commentBeingAdded) {
      setCommentBeingEdited({
        ...commentBeingAdded,
        descricao: value
      });
      return;
    }
  }, "handleChangeComment");
  const handleChangeInteractonDate = /* @__PURE__ */ __name((e2, _dataKey) => {
    if (guidesReference.current) {
      const { value } = e2.target;
      setInteractionDate(value);
      guide.fields[0].data = value;
      guidesReference.current[1] = guide;
    }
  }, "handleChangeInteractonDate");
  const handleCancelAddorEditComment = /* @__PURE__ */ __name(() => {
    setComments(guide.fields[1].data);
    setCommentBeingEdited(void 0);
    setCommentBeingAdded(void 0);
  }, "handleCancelAddorEditComment");
  const handleFocus = /* @__PURE__ */ __name(() => {
    if (guidesReference.current && !commentBeingEdited) {
      const newComment = {
        email: "",
        codOs: guidesReference.current[0].fields[0].data,
        criadoEm: (/* @__PURE__ */ new Date()).toISOString(),
        criadoPor: (user == null ? void 0 : user.NOME) || "",
        descricao: "",
        codigoComentario: Math.random()
      };
      setCommentBeingAdded(newComment);
      setComments([...comments || [], newComment]);
    }
  }, "handleFocus");
  const handleConclude = /* @__PURE__ */ __name(() => {
    if (guidesReference.current && comments) {
      guide.fields[1].data = [...comments];
      guidesReference.current[1] = guide;
      handleCancelAddorEditComment();
    }
  }, "handleConclude");
  reactExports.useEffect(() => {
    setInteractionDate(guide.fields[0].data);
    setComments(guide.fields[1].data);
  }, [guide]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: style$2.container,
      children: [
        guide.fields.map((field, _index) => {
          if (field.dataKey === "dataInteracao") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                fullWidth: true,
                label: field.label,
                type: field.type,
                onChange: (e2) => handleChangeInteractonDate(e2, field.dataKey),
                InputLabelProps: { shrink: true },
                value: interactionDate
              },
              field.dataKey
            );
          }
          if (field.dataKey === "comentarios") {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { sx: { width: "100%", gap: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  onChange: (e2) => handleChangeComment(
                    e2,
                    (commentBeingEdited == null ? void 0 : commentBeingEdited.codigoComentario) || (commentBeingAdded == null ? void 0 : commentBeingAdded.codigoComentario) || 0
                  ),
                  label: "Comentrio",
                  InputLabelProps: { shrink: commentBeingEdited && true },
                  placeholder: "Digite seu comentrio aqui...",
                  type: "text",
                  multiline: true,
                  rows: 3,
                  onFocus: handleFocus,
                  onKeyDown: (e2) => {
                    e2.key === "Enter" && handleConclude();
                  },
                  value: (commentBeingEdited == null ? void 0 : commentBeingEdited.descricao) || (commentBeingAdded == null ? void 0 : commentBeingAdded.descricao) || "",
                  onBlur: handleCancelAddorEditComment,
                  variant: "outlined",
                  fullWidth: true,
                  sx: style$2.commentField
                },
                field.dataKey
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: (commentBeingEdited || commentBeingAdded) && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...alertAnimation, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", gap: 1, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    sx: BaseButtonStyles,
                    onClick: handleCancelAddorEditComment,
                    children: "Cancelar"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleConclude, sx: BaseButtonStyles, children: "Concluir" })
              ] }) }) })
            ] }, field.dataKey);
          }
        }),
        comments && /* @__PURE__ */ jsxRuntimeExports.jsx(
          FixedSizeList,
          {
            height: 400,
            itemCount: comments == null ? void 0 : comments.length,
            itemSize: 100,
            width: "100%",
            children: ({ index: index2, style: style2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              CommentRow,
              {
                setCommentBeingEdit: setCommentBeingEdited,
                style: style2,
                index: index2,
                comment: comments[index2]
              },
              index2
            )
          }
        )
      ]
    }
  );
}, "OpportunityInteraction");
const styles$4 = {
  container: {
    width: "100%",
    overflowY: "scroll",
    overflowX: "hidden",
    "::-webkit-scrollbar": {
      width: "4px"
    }
  },
  uploadButton: {
    ...BaseButtonStyles,
    width: "fit-content"
  },
  gallery: {
    display: "grid",
    gridTemplateColumns: "repeat(auto-fit, minmax(150px, 1fr))",
    gap: 2,
    mt: 2,
    maxHeight: 300
  },
  fileContainer: {
    position: "relative",
    height: "150px",
    objectFit: "cover",
    cursor: "pointer",
    padding: 0.5
  },
  deleteButton: {
    backgroundColor: "white",
    position: "absolute",
    right: -1,
    top: -2,
    zIndex: 20,
    "&:hover": { backgroundColor: "white" }
  },
  pdfPreview: {
    display: "block",
    height: "150px",
    width: "100%",
    textDecoration: "none"
  },
  iframe: {
    height: "100%",
    width: "100%",
    objectFit: "fill",
    pointerEvents: "none"
  },
  imagePreview: {
    cursor: "pointer",
    width: "100%",
    height: "100%",
    borderRadius: "5px"
  }
};
const OpportunityFiles = /* @__PURE__ */ __name(({
  handleDeleteFile,
  handleChangeFiles,
  files
}) => {
  const [selectedFile, setSelectedFile] = reactExports.useState();
  const handleCloseFileViewer = /* @__PURE__ */ __name(() => {
    setSelectedFile(void 0);
  }, "handleCloseFileViewer");
  const handleFileClick = /* @__PURE__ */ __name((file) => {
    if (isPDF$1(file.nome_arquivo)) {
      window.open(file.arquivo);
      return;
    }
    setSelectedFile(file);
  }, "handleFileClick");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: styles$4.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { component: "span", sx: styles$4.uploadButton, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "file",
          id: "fileUpload",
          accept: "image/*, application/pdf",
          style: { display: "none" },
          onChange: (e2) => handleChangeFiles(e2)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", gap: 0.5, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", children: "Enviar Arquivo" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$9, { sx: { fontSize: "16px" } })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: styles$4.gallery, children: files && files.map((file, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: styles$4.fileContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          sx: styles$4.deleteButton,
          onClick: () => handleDeleteFile(file),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$t, { sx: { color: "#2B3990" } })
        }
      ),
      isPDF$1(file.nome_arquivo) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          onClick: () => setSelectedFile(file),
          sx: styles$4.pdfPreview,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              component: "iframe",
              src: file.arquivo,
              sx: styles$4.iframe
            }
          )
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          onClick: () => handleFileClick(file),
          src: file.arquivo,
          alt: file.nome_arquivo,
          style: {
            ...styles$4.imagePreview,
            objectFit: "cover"
          }
        }
      )
    ] }, index2)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FileViewer,
      {
        fileViewerOpen: selectedFile !== void 0,
        fileUrl: (selectedFile == null ? void 0 : selectedFile.arquivo) || "",
        handleCloseFileViewer,
        isPDF: isPDF$1,
        fileName: (selectedFile == null ? void 0 : selectedFile.nome_arquivo) || ""
      }
    )
  ] });
}, "OpportunityFiles");
OpportunityFiles.displayName = "OpportunityFiles";
const style$1 = {
  observationField: {
    borderRadius: 2,
    // Bordas arredondadas
    backgroundColor: "#f9f9f9",
    // Fundo claro para destacar
    boxShadow: "0px 4px 6px rgba(0, 0, 0, 0.1)",
    // Efeito de profundidade
    "& .MuiOutlinedInput-root": {
      "& fieldset": {
        borderColor: "#1976d2"
        // Cor da borda inicial
      },
      "&:hover fieldset": {
        borderColor: "#1565c0"
        // Cor da borda ao passar o mouse
      },
      "&.Mui-focused fieldset": {
        borderColor: "#0d47a1",
        // Cor da borda ao focar
        borderWidth: "2px"
        // Aumenta a espessura ao focar
      }
    },
    "& .MuiInputLabel-root": {
      color: "#757575"
      // Cor do label
    },
    "& .MuiInputLabel-root.Mui-focused": {
      color: "#0d47a1"
      // Cor do label ao focar
    }
  }
};
const OpportunityScope = /* @__PURE__ */ __name(({
  guide,
  guidesReference,
  formDataFilesRef
}) => {
  const [files, setFiles] = reactExports.useState([]);
  const [oppId, setOppId] = reactExports.useState();
  const [isEditing, setIsEditing] = reactExports.useState(false);
  const [observation, setObservation] = reactExports.useState();
  const handleDeleteFile = /* @__PURE__ */ __name((file) => {
    if (files && guidesReference.current) {
      const newFiles = files.filter(
        (oppFile) => oppFile.nome_arquivo !== file.nome_arquivo
      );
      setFiles(newFiles);
      guide.fields[1].data = newFiles;
      guidesReference.current[2] = guide;
    }
  }, "handleDeleteFile");
  const handleChangeFiles = /* @__PURE__ */ __name(async (e2) => {
    var _a2;
    if (e2.target.files) {
      const file = e2.target.files[0];
      const newFile = {
        id_anexo_os: Math.random(),
        arquivo: URL.createObjectURL(file),
        nome_arquivo: file.name,
        codos: oppId || 0
      };
      setFiles([...files || [], newFile]);
      const newFormData = new FormData();
      (_a2 = formDataFilesRef.current) == null ? void 0 : _a2.forEach((value, key) => {
        newFormData.append(key, value);
      });
      newFormData.append("files", file);
      formDataFilesRef.current = newFormData;
      e2.target.value = "";
    }
  }, "handleChangeFiles");
  const cancelObsEdition = /* @__PURE__ */ __name(() => {
    setObservation("");
    setIsEditing(false);
  }, "cancelObsEdition");
  const handleChangeObservation = /* @__PURE__ */ __name((e2) => {
    const { value } = e2.target;
    setObservation(value);
  }, "handleChangeObservation");
  const concludeObservationEdition = /* @__PURE__ */ __name(() => {
    if (guidesReference.current) {
      guide.fields[0].data = observation;
      guidesReference.current[2] = guide;
    }
    setIsEditing(false);
  }, "concludeObservationEdition");
  reactExports.useEffect(() => {
    if (guidesReference.current) {
      const oppId2 = guidesReference.current[0].fields[0].data.codOs || 0;
      setOppId(oppId2);
      setFiles(guide.fields[1].data);
      setObservation(guide.fields[0].data);
    }
  }, [guide]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        width: "100%",
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
        justifyContent: "center",
        gap: 2,
        padding: 1
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Observao",
            InputLabelProps: { shrink: true },
            fullWidth: true,
            sx: style$1.observationField,
            multiline: true,
            type: "text",
            value: observation,
            onChange: handleChangeObservation,
            onFocus: () => setIsEditing(true)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isEditing && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...alertAnimation, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", gap: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              sx: BaseButtonStyles,
              onClick: concludeObservationEdition,
              children: "Concluir"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { sx: BaseButtonStyles, onClick: cancelObsEdition, children: "Cancelar" })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          OpportunityFiles,
          {
            files,
            handleDeleteFile,
            handleChangeFiles
          }
        )
      ]
    }
  );
}, "OpportunityScope");
const style = {
  formGrid: {
    display: "grid",
    gridTemplateColumns: {
      xs: "1fr",
      md: "1fr 1fr"
    },
    gap: 1,
    rowGap: 2,
    width: "100%",
    padding: 1
  }
};
const OpportunitySale = /* @__PURE__ */ __name(({ guide, guidesReference }) => {
  const [sale, setSale] = reactExports.useState();
  const [responsableOptions, setResponsableOptions] = reactExports.useState();
  const [currentResponsable, setCurrentResponsable] = reactExports.useState();
  const projectId = reactExports.useRef();
  const oppId = reactExports.useRef();
  const setDefaultResponsableWhenNotDefined = /* @__PURE__ */ __name(async () => {
    console.log("setDefaultResponsableWhen -- NotDefined");
    console.log(
      "condition: ",
      oppId.current
    );
    if (guidesReference.current && oppId.current && sale && responsableOptions && projectId.current) {
      const noResponsableDefined = sale.responsavel == 1;
      console.log({ noResponsableDefined });
      if (noResponsableDefined && projectId.current) {
        const responsableForFirstProject = await fetchResponsableForFirstProjectOption(projectId.current);
        console.log({ responsableForFirstProject });
        setCurrentResponsable(
          responsableOptions.find(
            (respOption) => respOption.id === responsableForFirstProject.id
          )
        );
        console.log({ responsableForFirstProject });
        guide.fields[0].data = responsableForFirstProject.id;
        guidesReference.current[3] = guide;
        return;
      }
    }
  }, "setDefaultResponsableWhenNotDefined");
  const setCurrentResponsableWhenDefined = /* @__PURE__ */ __name(() => {
    console.log("setCurrentResponsableWhen -- Defined");
    if ((sale == null ? void 0 : sale.responsavel) && responsableOptions) {
      const responsable = responsableOptions.find(
        (option) => option.id === sale.responsavel
      );
      console.log("defined responsable found: ", responsable);
      if (responsable) {
        setCurrentResponsable(
          responsableOptions.find(
            (option) => option.id === sale.responsavel
          )
        );
      }
    }
  }, "setCurrentResponsableWhenDefined");
  const fetchSalerOps = reactExports.useCallback(
    async () => {
      const salers = await fetchSalers(0);
      const options = salers.map((saler) => ({
        label: saler.NOME,
        id: saler.CODPESSOA,
        object: "saler",
        key: saler.CODPESSOA
      }));
      setResponsableOptions(options);
      setCurrentResponsable(options[0]);
    },
    [setResponsableOptions]
  );
  const handleChangeTextField = /* @__PURE__ */ __name((fieldReceived, e2) => {
    if (guidesReference.current && sale) {
      const { value } = e2.target;
      const updatedSale = {
        ...sale,
        [fieldReceived.dataKey]: value
      };
      const { valorFatDireto, valorFatDolphin } = updatedSale;
      const totalValue = Number(valorFatDireto) + Number(valorFatDolphin);
      setSale({ ...updatedSale, valorTotal: totalValue });
      const fieldIndex = guide.fields.indexOf(fieldReceived);
      fieldReceived.data = value;
      guide.fields[fieldIndex] = fieldReceived;
      guide.fields[4].data = totalValue;
      guidesReference.current[3] = guide;
    }
  }, "handleChangeTextField");
  const handleChangeAutoComplete = /* @__PURE__ */ __name((value) => {
    setCurrentResponsable(value);
    guide.fields[0].data = value.id;
  }, "handleChangeAutoComplete");
  reactExports.useEffect(() => {
    if (guidesReference.current) {
      projectId.current = guidesReference.current[0].fields[0].data;
      oppId.current = guidesReference.current[0].fields[9].data;
    }
    const firstsSaleState = {
      responsavel: guide.fields[0].data,
      valorFatDolphin: guide.fields[1].data,
      valorFatDireto: guide.fields[2].data,
      valorComissao: guide.fields[3].data,
      valorTotal: guide.fields[4].data
    };
    setSale(firstsSaleState);
    fetchSalerOps();
  }, [guide]);
  reactExports.useEffect(() => {
    if (responsableOptions) {
      setDefaultResponsableWhenNotDefined();
      setCurrentResponsableWhenDefined();
    }
  }, [responsableOptions]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: style.formGrid, children: guide.fields.map((field, _index) => {
    if (field.dataKey === "responsavel" && responsableOptions) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Autocomplete,
        {
          getOptionKey: (option) => option.id,
          options: responsableOptions,
          value: currentResponsable,
          renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              ...params,
              label: field.label,
              InputLabelProps: { shrink: true }
            }
          ),
          onChange: (_event, value, _reason, _details) => handleChangeAutoComplete(value)
        },
        field.dataKey
      );
    }
    if (sale) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          type: field.type,
          label: field.label,
          disabled: field.dataKey === "valorTotal",
          InputLabelProps: { shrink: true },
          onChange: (e2) => handleChangeTextField(field, e2),
          value: sale[field.dataKey]
        },
        field.dataKey
      );
    }
  }) });
}, "OpportunitySale");
const theme$2 = createTheme(
  {
    palette: {
      primary: { main: "#1976d2" }
    }
  },
  ptBR$1,
  ptBR,
  ptBR$2
);
const columns$1 = [
  {
    field: "NOME",
    headerName: "Nome",
    type: "string",
    align: "left",
    headerAlign: "center",
    filterable: true,
    width: 300
  }
];
const AddFollowersModal = /* @__PURE__ */ __name(({
  setFollowers,
  followers,
  guide,
  guidesReference
}) => {
  const [addingFollowrs, setAddingFollowers] = reactExports.useState(false);
  const [personList, setPersonList] = reactExports.useState([]);
  const [previousSelectedList, setPreviousSelectedList] = reactExports.useState(
    []
  );
  const [filteredPersonList, setFilteredPersonList] = reactExports.useState([]);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [newFollowers, setNewFollowers] = reactExports.useState();
  const GridFooter3 = /* @__PURE__ */ __name(() => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      GridFooterContainer,
      {
        sx: {
          color: "black",
          paddingX: 1,
          paddingY: 1,
          display: "flex",
          justifyContent: "end",
          flexGrow: 1,
          overFlowY: "scroll",
          zIndex: 20,
          backgroundColor: "white",
          borderRadius: 2,
          height: "30px"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { sx: BaseButtonStyles, onClick: () => handleConclude(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", textTransform: "capitalize", children: "Concluir" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(GridSelectedRowCount, { selectedRowCount: previousSelectedList.length }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            GridPagination,
            {
              sx: {
                padding: 0,
                display: "flex",
                alignItems: "center",
                justifyContent: "end",
                overflowY: "hidden",
                "& .MuiTablePagination-displayedRows": {
                  display: "none"
                },
                height: "30px"
              }
            }
          )
        ]
      }
    );
  }, "GridFooter");
  const fetchOptions = /* @__PURE__ */ __name(async () => {
    const peopleList = await fetchPersonList();
    setPersonList(peopleList || []);
    setFilteredPersonList(peopleList || []);
  }, "fetchOptions");
  const handleConclude = /* @__PURE__ */ __name(async () => {
    if (newFollowers && guidesReference.current) {
      const newOppFollowers = newFollowers.filter(
        (newFollower) => !followers.find(
          (follower) => follower.codpessoa === newFollower.codpessoa
        )
      );
      guide.fields[0].data = [...followers, ...newOppFollowers];
      guidesReference.current[4] = guide;
      setFollowers([...followers, ...newOppFollowers]);
    }
    setAddingFollowers(false);
  }, "handleConclude");
  const handleRowSelection = /* @__PURE__ */ __name((currentSelectionList, _details) => {
    setPreviousSelectedList(currentSelectionList);
    const selectedFollowers = currentSelectionList.map((id2) => {
      const selectedPerson = personList.find(
        (person) => person.CODPESSOA === id2
      );
      return {
        id_seguidor_projeto: 0,
        // ID fictcio, pode ser gerado ou obtido do backend
        id_projeto: 0,
        // ID do projeto (deve ser passado como prop ou contexto)
        codpessoa: (selectedPerson == null ? void 0 : selectedPerson.CODPESSOA) || 0,
        ativo: 1,
        // Define como ativo por padro
        nome: (selectedPerson == null ? void 0 : selectedPerson.NOME) || ""
      };
    });
    setNewFollowers(selectedFollowers);
  }, "handleRowSelection");
  reactExports.useEffect(() => {
    fetchOptions();
  }, [addingFollowrs]);
  reactExports.useEffect(() => {
    if (searchTerm) {
      const filtered = personList.filter(
        (person) => person.NOME.toLowerCase().includes(searchTerm.toLowerCase())
      );
      setFilteredPersonList(filtered);
    } else {
      setFilteredPersonList(personList);
    }
  }, [searchTerm, personList]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        sx: buttonStylesMobile,
        onClick: () => setAddingFollowers(!addingFollowrs),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "adicionar seguidores", children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$p, {}) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Modal$3, { open: addingFollowrs, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          position: "absolute",
          display: "flex",
          flexDirection: "column",
          gap: 1,
          top: "50%",
          justifyContent: "center",
          alignItems: "center",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: {
            xs: "90%",
            md: "80%",
            lg: "30%"
          },
          height: "90%",
          bgcolor: "background.paper",
          boxShadow: 24,
          p: 1
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              sx: {
                position: "absolute",
                right: 1,
                top: 1
              },
              onClick: () => setAddingFollowers(false),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {})
            }
          ),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontWeight: "bold", className: "text-gray-600", children: "Adicionar seguidores  proposta" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                variant: "outlined",
                value: searchTerm,
                onChange: (e2) => setSearchTerm(e2.target.value),
                margin: "normal",
                InputProps: {
                  sx: { borderRadius: 10, height: 40 },
                  placeholder: "busque por nome..."
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              sx: {
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                maxHeight: "80%",
                width: "100%"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider2, { theme: theme$2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                DataGrid,
                {
                  rows: filteredPersonList,
                  columns: columns$1,
                  getRowId: (row) => row.CODPESSOA,
                  sx: {
                    "& .MuiDataGrid-columnHeaders": {
                      backgroundColor: "blue",
                      display: "none"
                    },
                    maxWidth: {
                      xs: "100%",
                      md: "100%",
                      lg: "90%"
                    }
                  },
                  pageSizeOptions: [100],
                  initialState: {
                    pagination: {
                      paginationModel: {
                        pageSize: 100
                      }
                    }
                  },
                  slots: {
                    columnMenu: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Box,
                      {
                        sx: {
                          "& .MuiMenuItem-root": {
                            display: "flex",
                            flexWrap: "wrap"
                          },
                          maxWidth: {
                            xs: 260,
                            sm: 300
                          }
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnMenu, { ...props })
                      }
                    ),
                    footer: GridFooter3,
                    filterPanel: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      GridFilterPanel,
                      {
                        ...props,
                        disableAddFilterButton: true,
                        sx: {
                          "& .MuiDataGrid-filterFormColumnInput": {
                            display: "none"
                          },
                          "& .MuiDataGrid-filterFormOperatorInput": {
                            display: "none"
                          }
                        }
                      }
                    )
                  },
                  rowSelection: true,
                  disableMultipleRowSelection: false,
                  onRowSelectionModelChange: (newSelection, details) => handleRowSelection(newSelection),
                  disableColumnSelector: true,
                  checkboxSelection: true,
                  density: "compact"
                }
              ) })
            }
          )
        ]
      }
    ) })
  ] });
}, "AddFollowersModal");
AddFollowersModal.displayName = "AddFollowersModal";
const OpportunityFollowers = /* @__PURE__ */ __name(({ guide, guidesReference }) => {
  const [followers, setFollowers] = reactExports.useState([]);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [filteredFollowers, setFilteredFollowers] = reactExports.useState([]);
  const { user } = reactExports.useContext(userContext);
  reactExports.useEffect(() => {
    if (guide.fields[0].data && guidesReference.current && user) {
      const userInFollowersList = [...guide.fields[0].data].find((follower) => follower.codpessoa === user.CODPESSOA);
      if (!userInFollowersList) {
        const userFollower = {
          id_seguidor_projeto: 0,
          id_projeto: guidesReference.current[0].fields[0].data,
          codpessoa: user.CODPESSOA,
          ativo: 1,
          nome: user.NOME
        };
        guide.fields[0].data = [...guide.fields[0].data, userFollower];
        guidesReference.current[4] = guide;
      }
      setFollowers([...guide.fields[0].data]);
      setFilteredFollowers([...guide.fields[0].data]);
      console.log("followers: ", guide.fields[0].data);
    }
  }, [guide]);
  reactExports.useEffect(() => {
    const filtered = followers.filter(
      (follower) => follower.nome.toLowerCase().includes(searchTerm.toLowerCase())
    );
    setFilteredFollowers(filtered);
  }, [searchTerm, followers]);
  reactExports.useEffect(() => {
    setFilteredFollowers(followers);
  }, [followers]);
  const Row = /* @__PURE__ */ __name((props) => {
    const { index: index2, style: style2, data } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      ListItem,
      {
        style: {
          ...style2,
          borderRadius: 10
        },
        component: "div",
        disablePadding: true,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemAvatar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$j, {}) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemButton, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: `${data.nome}` }) })
        ]
      },
      index2
    );
  }, "Row");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { width: "100%", padding: 1 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AddFollowersModal,
      {
        setFollowers,
        followers,
        guide,
        guidesReference
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField,
      {
        variant: "outlined",
        value: searchTerm,
        onChange: (e2) => setSearchTerm(e2.target.value),
        margin: "normal",
        InputProps: {
          sx: { borderRadius: 10, height: 40 },
          placeholder: "busque por nome..."
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FixedSizeList,
      {
        height: 300,
        itemCount: filteredFollowers.length,
        itemSize: 50,
        width: "100%",
        children: ({ index: index2, style: style2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Row, { index: index2, style: style2, data: filteredFollowers[index2] })
      }
    )
  ] });
}, "OpportunityFollowers");
const OpportunityGuide = /* @__PURE__ */ __name(({
  guidesReference,
  guide,
  formDataFilesRef,
  isLoading
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { ...styles$6.guideContainer }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading2, children: guide.name }),
    !isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      guide.name === "Cadastro" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        OpportunityRegistration,
        {
          guidesReference,
          guide
        }
      ),
      guide.name === "Interao" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        OpportunityInteraction,
        {
          guide,
          guidesReference
        }
      ),
      guide.name === "Escopo" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        OpportunityScope,
        {
          guide,
          guidesReference,
          formDataFilesRef
        }
      ),
      guide.name === "Venda" && /* @__PURE__ */ jsxRuntimeExports.jsx(OpportunitySale, { guide, guidesReference }),
      guide.name === "Seguidores" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        OpportunityFollowers,
        {
          guide,
          guidesReference
        }
      )
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        sx: {
          height: 200,
          width: 200,
          display: "flex",
          padding: 2,
          justifyContent: "center"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {})
      }
    )
  ] });
}, "OpportunityGuide");
const AdicionalChoice = /* @__PURE__ */ __name(({
  isAdicionalChoiceOpen,
  handleClose,
  handleAdicionalChoice
}) => {
  const { currentOppIdSelected, creatingOpportunity } = reactExports.useContext(
    OpportunityInfoContext
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: isAdicionalChoiceOpen && creatingOpportunity && !(currentOppIdSelected > 0),
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: 300,
            bgcolor: "background.paper",
            boxShadow: 24,
            height: 150,
            overFlow: "hidden",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            gap: 2,
            p: 2
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                sx: {
                  position: "absolute",
                  right: 1,
                  top: 1
                },
                onClick: handleClose,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {})
              }
            ),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "A proposta  um adicional?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", gap: 1, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => handleAdicionalChoice(true),
                  sx: {
                    ...BaseButtonStyles,
                    backgroundColor: green[500],
                    "&:hover": { backgroundColor: green[800] }
                  },
                  children: "Sim"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => handleAdicionalChoice(false),
                  sx: {
                    ...BaseButtonStyles,
                    backgroundColor: red[500],
                    "&:hover": { backgroundColor: red[800] }
                  },
                  children: "No"
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, "AdicionalChoice");
AdicionalChoice.displayName = "AdicionalChoice";
const styles$3 = {
  modal: {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: {
      //responsive width
      xs: "95%",
      md: "40%",
      lg: "50%"
    },
    height: "95%",
    bgcolor: "background.paper",
    boxShadow: 24,
    overFlow: "hidden",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    p: 1,
    gap: 2
  },
  sliderContainer: {
    height: { xs: 450, md: "auto" },
    overflowY: "scroll",
    "&::-webkit-scrollbar": {
      width: "4px"
      // Largura da barra de scroll
    },
    "&::-webkit-scrollbar-track": {
      background: "#f1f1f1",
      // Cor de fundo da trilha da barra de scroll
      borderRadius: "4px"
    },
    "&::-webkit-scrollbar-thumb": {
      borderRadius: "4px"
    }
  },
  saveButtonContainer: {
    width: "100%",
    display: "flex",
    justifyContent: "center",
    backgroundColor: "white",
    position: "fixed",
    padding: 2,
    bottom: 2,
    zIndex: 20
  }
};
const styles$2 = {
  guideSelectorContainer: {
    display: "flex",
    width: "100%",
    gap: 1,
    alignItems: "center",
    overflowX: "scroll",
    padding: 2,
    backgroundColor: "white",
    // Cor de fundo
    zIndex: 20,
    border: "1px solid lightgray",
    borderRadius: 10,
    height: 50,
    "&::-webkit-scrollbar": {
      width: "4px",
      // Largura da barra de rolagem
      height: "2px"
    },
    "&::-webkit-scrollbar-thumb": {
      display: "none",
      height: "2px",
      backgroundColor: "#888",
      // Cor da barra de rolagem
      borderRadius: "4px"
      // Bordas arredondadas
    }
  }
};
const GuideSelector = /* @__PURE__ */ __name(({
  guides,
  currentSlideIndex,
  handleChangeGuide
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Stack,
    {
      direction: "row",
      sx: styles$2.guideSelectorContainer,
      children: guides.map((guide, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Chip,
        {
          onClick: () => handleChangeGuide(index2),
          sx: {
            cursor: "pointer"
          },
          label: guide.name,
          variant: currentSlideIndex === index2 ? "filled" : "outlined"
        },
        index2
      ))
    }
  );
}, "GuideSelector");
const ProjectChoiceModal = /* @__PURE__ */ __name(({
  handleSaveProjectChoiceAdicional,
  projectChoiceModalOpen,
  handleChangeAutoComplete,
  setProjectChoiceModalOpen
}) => {
  const [projectOptions, setProjectOptions] = reactExports.useState([]);
  const { user } = reactExports.useContext(userContext);
  const fetchProjectsOps = reactExports.useCallback(async () => {
    const projects = await fetchProjectOptionsByUser((user == null ? void 0 : user.CODPESSOA) || 0);
    const options = projects && projects.map((project) => ({
      label: project.DESCRICAO,
      id: project.ID,
      object: "project",
      key: project.ID
    })) || [];
    setProjectOptions([...options]);
  }, [setProjectOptions]);
  reactExports.useEffect(() => {
    fetchProjectsOps();
  }, []);
  const renderOptions = /* @__PURE__ */ __name((column2) => {
    if (column2.dataKey === "idProjeto")
      return projectOptions;
  }, "renderOptions");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: projectChoiceModalOpen,
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: {
              xs: "90%",
              md: "40%",
              lg: "25%"
            },
            bgcolor: "background.paper",
            boxShadow: 24,
            height: 300,
            overFlow: "hidden",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            gap: 2,
            p: 1
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                sx: {
                  position: "absolute",
                  right: 1,
                  top: 1
                },
                onClick: () => setProjectChoiceModalOpen(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {})
              }
            ),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading2, children: "Escolha o projeto" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Autocomplete,
              {
                disablePortal: true,
                onChange: handleChangeAutoComplete,
                fullWidth: true,
                options: renderOptions({
                  label: "N Projeto",
                  dataKey: "idProjeto",
                  autoComplete: true
                }) || [],
                getOptionKey: (option) => option.key,
                sx: { width: 300 },
                renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField,
                  {
                    ...params,
                    label: {
                      label: "N Projeto",
                      dataKey: "idProjeto",
                      autoComplete: true
                    }.label
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { sx: BaseButtonStyles, onClick: handleSaveProjectChoiceAdicional, children: "Salvar" })
          ]
        }
      )
    }
  );
}, "ProjectChoiceModal");
ProjectChoiceModal.displayName = "ProjectChoiceModal";
const useOpportunityModal = /* @__PURE__ */ __name((initialOpportunity, context) => {
  const {
    creatingOpportunity,
    currentOppIdSelected,
    setCurrentOppIdSelected,
    setCreatingOpportunity,
    toggleRefreshOpportunityInfo
  } = context;
  const [adicional, setAdicional] = reactExports.useState(false);
  const [opportunity, setCurrentOpportunity] = reactExports.useState(initialOpportunity);
  const sliderRef = reactExports.useRef(null);
  const [currentSlideIndex, setCurrentSlideIndex] = reactExports.useState(0);
  const [isAdicionalChoiceOpen, setIsAdicionalChoiceOpen] = reactExports.useState(true);
  const [refreshOpportunityFields, setRefreshOpportunityFields] = reactExports.useState(false);
  const [projectChoiceModalOpen, setProjectChoiceModalOpen] = reactExports.useState(false);
  const [renderFields, setRenderFields] = reactExports.useState(false);
  const [saveProgressModalOpen, setSaveProgressModalOpen] = reactExports.useState(false);
  const formDataFilesRef = reactExports.useRef(new FormData());
  const guidesReference = reactExports.useRef();
  const saveButtonContainerRef = reactExports.useRef(null);
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const { user } = reactExports.useContext(userContext);
  const settings = {
    swipe: true,
    arrows: false,
    accessibility: false,
    dots: false,
    infinite: false,
    speed: 200,
    slidesToShow: 1,
    slidesToScroll: 1,
    draggable: true,
    beforeChange: (_oldIndex, _newIndex) => {
    },
    afterChange: (current) => {
      setCurrentSlideIndex(current);
    }
  };
  const handleClose = /* @__PURE__ */ __name(() => {
    setCreatingOpportunity(false);
    setCurrentOppIdSelected(0);
    setCurrentSlideIndex(0);
    setSaveProgressModalOpen(false);
  }, "handleClose");
  const handleCloseAdicionalChoice = /* @__PURE__ */ __name(() => {
    setAdicional(false);
    setIsAdicionalChoiceOpen(false);
  }, "handleCloseAdicionalChoice");
  const setGuidesReference = /* @__PURE__ */ __name(() => {
    guidesReference.current = [
      {
        name: "Cadastro",
        fields: [
          { label: "N Projeto", dataKey: "idProjeto", autoComplete: true, type: "number", data: opportunity["idProjeto"] },
          { label: "N Adicional", dataKey: "numeroAdicional", type: "number", data: opportunity["numeroAdicional"] },
          { label: "Descrio da Proposta", dataKey: "nome", type: "text", data: opportunity["nome"] },
          { label: "Status", dataKey: "codStatus", autoComplete: true, type: "number", data: opportunity["codStatus"] },
          { label: "Descrio da Venda", dataKey: "descricaoVenda", autoComplete: false, type: "text", data: opportunity["descricaoVenda"] },
          { label: "Cliente", dataKey: "fkCodCliente", autoComplete: true, type: "number", data: opportunity["fkCodCliente"] },
          { label: "Data de Solicitao", dataKey: "dataSolicitacao", type: "date", data: opportunity["dataSolicitacao"] },
          { label: "Data de Incio", dataKey: "dataInicio", type: "date", data: opportunity["dataInicio"] },
          { label: "Data de Fechamento", dataKey: "dataEntrega", type: "date", data: opportunity["dataEntrega"] },
          { label: "N OS", dataKey: "codOs", autoComplete: false, type: "number", data: opportunity["codOs"] }
        ]
      },
      {
        name: "Interao",
        fields: [
          { label: "Data de Interao", dataKey: "dataInteracao", type: "date", data: opportunity["dataInteracao"] },
          { label: "Comentrios", dataKey: "comentarios", type: "text", data: opportunity["comentarios"] }
        ]
      },
      {
        name: "Escopo",
        fields: [
          { label: "Observaes", dataKey: "observacoes", type: "text", data: opportunity["observacoes"] },
          { label: "Anexos", dataKey: "files", type: "number", data: opportunity["files"] }
        ]
      },
      {
        name: "Venda",
        fields: [
          { label: "Vendedor", dataKey: "responsavel", autoComplete: true, type: "text", data: opportunity["responsavel"] },
          { label: "Valor Faturamento Dolphin", dataKey: "valorFatDolphin", type: "number", data: opportunity["valorFatDolphin"] },
          { label: "Valor Faturamento Direto", dataKey: "valorFatDireto", type: "number", data: opportunity["valorFatDireto"] },
          { label: "Valor Comisso", dataKey: "valorComissao", type: "number", data: opportunity["valorComissao"] },
          { label: "Valor Total", dataKey: "valorTotal", type: "number", data: opportunity["valorTotal"] }
        ]
      },
      {
        name: "Seguidores",
        fields: [
          { label: "Seguidores", dataKey: "seguidores", type: "Follower[]", data: opportunity["seguidores"] }
        ]
      }
    ];
  }, "setGuidesReference");
  const fetchOppData = reactExports.useCallback(async () => {
    const data = await getOpportunityById(currentOppIdSelected);
    const formattedOpp = {
      ...data,
      dataSolicitacao: data.dataSolicitacao ? new Date(data.dataSolicitacao).toISOString().split("T")[0] : null,
      dataNecessidade: data.dataNecessidade ? new Date(data.dataNecessidade).toISOString().split("T")[0] : null,
      dataInicio: data.dataInicio ? new Date(data.dataInicio).toISOString().split("T")[0] : null,
      dataPrevEntrega: data.dataPrevEntrega ? new Date(data.dataPrevEntrega).toISOString().split("T")[0] : null,
      dataEntrega: data.dataEntrega ? new Date(data.dataEntrega).toISOString().split("T")[0] : null,
      dataLiberacao: data.dataLiberacao ? new Date(data.dataLiberacao).toISOString().split("T")[0] : null,
      dataInteracao: data.dataInteracao ? new Date(data.dataInteracao).toISOString().split("T")[0] : null
    };
    console.log({ formattedOpp });
    setCurrentOpportunity(formattedOpp);
    setIsLoading(false);
  }, [currentOppIdSelected, setCurrentOpportunity]);
  const handleAdicionalChoice = /* @__PURE__ */ __name((isAdicional) => {
    if (isAdicional) {
      setAdicional(true);
      setProjectChoiceModalOpen(true);
      return;
    }
    setAdicional(false);
    setIsAdicionalChoiceOpen(false);
  }, "handleAdicionalChoice");
  const handleChangeGuide = /* @__PURE__ */ __name((index2) => {
    var _a2;
    (_a2 = sliderRef.current) == null ? void 0 : _a2.slickGoTo(index2);
    setCurrentSlideIndex(index2);
  }, "handleChangeGuide");
  const handleSaveProjectChoiceAdicional = /* @__PURE__ */ __name(async () => {
    const data = await createAdicional(opportunity);
    if (data) {
      setCurrentOpportunity({
        ...opportunity,
        idAdicional: data.adicional.ID,
        numeroAdicional: data.adicional.NUMERO,
        codOs: data.codOs
      });
      setCurrentOppIdSelected(data.codOs);
      setProjectChoiceModalOpen(false);
      setRefreshOpportunityFields(!refreshOpportunityFields);
      setAdicional(true);
      setCreatingOpportunity(false);
    }
  }, "handleSaveProjectChoiceAdicional");
  const getUpdatedOpportunity = /* @__PURE__ */ __name(() => {
    var _a2;
    let updatedOpportunity = { ...opportunity };
    (_a2 = guidesReference.current) == null ? void 0 : _a2.forEach((guide) => {
      guide.fields.forEach((field) => {
        console.log({ dataKey: field.dataKey, data: field.data });
        updatedOpportunity = {
          ...updatedOpportunity,
          [field.dataKey]: field.data
        };
      });
    });
    return updatedOpportunity;
  }, "getUpdatedOpportunity");
  const handlesaveProgressAction = /* @__PURE__ */ __name(async () => {
    await handleSaveOpportunity();
    handleClose();
  }, "handlesaveProgressAction");
  const handleChangeAutoComplete = /* @__PURE__ */ __name((_event, value, _reason, _details) => {
    if ((value == null ? void 0 : value.object) === "project") {
      setCurrentOpportunity({ ...opportunity, idProjeto: value == null ? void 0 : value.id });
      return;
    }
    if ((value == null ? void 0 : value.object) === "status") {
      setCurrentOpportunity({ ...opportunity, codStatus: value == null ? void 0 : value.id });
      return;
    }
    if ((value == null ? void 0 : value.object) === "saler") {
      setCurrentOpportunity({ ...opportunity, responsavel: value == null ? void 0 : value.id });
      return;
    }
    if ((value == null ? void 0 : value.object) === "client") {
      setCurrentOpportunity({ ...opportunity, fkCodCliente: value == null ? void 0 : value.id });
      return;
    }
  }, "handleChangeAutoComplete");
  const handleFileUpload = /* @__PURE__ */ __name(async (codOs) => {
    if (formDataFilesRef.current) {
      await createOpportunityFiles(codOs, formDataFilesRef.current);
    }
  }, "handleFileUpload");
  const resetFormData = /* @__PURE__ */ __name(() => {
    formDataFilesRef.current = new FormData();
  }, "resetFormData");
  const createNewOpportunity = /* @__PURE__ */ __name(async () => {
    setIsLoading(true);
    const updatedOpportunity = getUpdatedOpportunity();
    if (!updatedOpportunity)
      return;
    try {
      const createOppResponse = await createOpportunity(updatedOpportunity);
      if ((createOppResponse == null ? void 0 : createOppResponse.status) === 200) {
        setCurrentOpportunity(updatedOpportunity);
        await handleFileUpload(createOppResponse.data.codOs);
        setCurrentOppIdSelected(createOppResponse.data.codOs);
        setCreatingOpportunity(false);
      }
    } catch (e2) {
      console.log(e2);
    } finally {
      resetFormData();
      setRefreshOpportunityFields(!refreshOpportunityFields);
      setIsLoading(false);
      toggleRefreshOpportunityInfo();
    }
  }, "createNewOpportunity");
  const updateExistingOpportunity = /* @__PURE__ */ __name(async () => {
    setIsLoading(true);
    const updatedOpportunity = getUpdatedOpportunity();
    if (!updatedOpportunity)
      return;
    try {
      const response = await updateOpportunity(updatedOpportunity, user);
      if ((response == null ? void 0 : response.status) === 200) {
        setCurrentOpportunity(updatedOpportunity);
        await handleFileUpload(opportunity.codOs || 0);
      }
    } catch (e2) {
      console.log(e2);
    } finally {
      setIsLoading(false);
      resetFormData();
      setRefreshOpportunityFields(!refreshOpportunityFields);
      toggleRefreshOpportunityInfo();
    }
  }, "updateExistingOpportunity");
  const handleSaveOpportunity = reactExports.useCallback(async () => {
    if (opportunity.codOs) {
      await updateExistingOpportunity();
      return;
    }
    if (creatingOpportunity) {
      await createNewOpportunity();
      return;
    }
  }, [opportunity, refreshOpportunityFields, setCreatingOpportunity, setCurrentOppIdSelected, creatingOpportunity, currentSlideIndex]);
  reactExports.useEffect(() => {
  }, [currentSlideIndex]);
  reactExports.useEffect(() => {
    setGuidesReference();
    setRenderFields(!renderFields);
  }, [opportunity, refreshOpportunityFields]);
  reactExports.useEffect(() => {
    if (creatingOpportunity) {
      setIsAdicionalChoiceOpen(true);
      setIsLoading(false);
      return;
    }
    if (currentOppIdSelected > 0) {
      setIsAdicionalChoiceOpen(false);
      fetchOppData();
      return;
    }
    setCurrentOpportunity(initialOpportunity);
  }, [currentOppIdSelected, refreshOpportunityFields, creatingOpportunity, fetchOppData]);
  reactExports.useEffect(() => {
    var _a2;
    (_a2 = sliderRef.current) == null ? void 0 : _a2.slickGoTo(currentSlideIndex);
  }, [sliderRef]);
  return {
    adicional,
    opportunity,
    currentSlideIndex,
    creatingOpportunity,
    currentOppIdSelected,
    isAdicionalChoiceOpen,
    projectChoiceModalOpen,
    saveProgressModalOpen,
    sliderRef,
    saveButtonContainerRef,
    handleClose,
    handleCloseAdicionalChoice,
    handleAdicionalChoice,
    handleChangeGuide,
    handleSaveProjectChoiceAdicional,
    handlesaveProgressAction,
    handleChangeAutoComplete,
    handleFileUpload,
    handleSaveOpportunity,
    setProjectChoiceModalOpen,
    setSaveProgressModalOpen,
    guidesReference,
    formDataFilesRef,
    setCurrentSlideIndex,
    settings,
    isLoading,
    setIsLoading
  };
}, "useOpportunityModal");
const OpportunityModal = /* @__PURE__ */ __name(() => {
  const context = reactExports.useContext(OpportunityInfoContext);
  const {
    opportunity,
    currentSlideIndex,
    isAdicionalChoiceOpen,
    projectChoiceModalOpen,
    saveProgressModalOpen,
    sliderRef,
    saveButtonContainerRef,
    handleClose,
    handleCloseAdicionalChoice,
    handleAdicionalChoice,
    handleChangeGuide,
    handleSaveProjectChoiceAdicional,
    handlesaveProgressAction,
    handleChangeAutoComplete,
    handleSaveOpportunity,
    setProjectChoiceModalOpen,
    setSaveProgressModalOpen,
    creatingOpportunity,
    currentOppIdSelected,
    guidesReference,
    formDataFilesRef,
    settings,
    isLoading
  } = useOpportunityModal(opportunityDefault, context);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal$3,
    {
      open: creatingOpportunity || currentOppIdSelected > 0,
      onClose: handleClose,
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: styles$3.modal, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            sx: {
              position: "absolute",
              right: 1,
              top: 1
            },
            onClick: () => setSaveProgressModalOpen(true),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, {})
          }
        ),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading2, children: currentOppIdSelected > 0 ? `${opportunity.codOs} - ${opportunity.nome} ` : "Nova proposta" }) }),
        guidesReference.current && /* @__PURE__ */ jsxRuntimeExports.jsx(
          GuideSelector,
          {
            guides: guidesReference.current,
            currentSlideIndex,
            handleChangeGuide
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Stack,
          {
            sx: {
              ...styles$3.sliderContainer,
              paddingBottom: 10
            },
            direction: "column",
            width: "100%",
            position: "relative",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Slider, { ref: sliderRef, ...settings, children: guidesReference.current && guidesReference.current.map((guide) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              OpportunityGuide,
              {
                formDataFilesRef,
                guidesReference,
                guide,
                isLoading
              }
            )) })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ref: saveButtonContainerRef, sx: styles$3.saveButtonContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { sx: BaseButtonStyles, onClick: handleSaveOpportunity, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Salvar" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdicionalChoice,
          {
            isAdicionalChoiceOpen,
            handleClose: handleCloseAdicionalChoice,
            handleAdicionalChoice
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ProjectChoiceModal,
          {
            handleSaveProjectChoiceAdicional,
            projectChoiceModalOpen,
            setProjectChoiceModalOpen,
            handleChangeAutoComplete
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Dialog,
          {
            open: saveProgressModalOpen,
            onClose: handleClose,
            "aria-labelledby": "save-progress-title",
            "aria-describedby": "save-progress-description",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { id: "save-progress-title", children: "Salvar progresso?" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentText, { id: "save-progress-description", children: "Deseja salvar seu progresso antes de sair?" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { sx: { display: "flex", justifyContent: "center" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: handlesaveProgressAction,
                    sx: {
                      ...BaseButtonStyles,
                      backgroundColor: "darkgreen",
                      "&:hover": { backgroundColor: "green" }
                    },
                    autoFocus: true,
                    children: "Sim"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    sx: {
                      ...BaseButtonStyles,
                      backgroundColor: "darkred",
                      "&:hover": { backgroundColor: "red" }
                    },
                    onClick: handleClose,
                    color: "secondary",
                    children: "No"
                  }
                )
              ] })
            ]
          }
        )
      ] })
    }
  );
}, "OpportunityModal");
OpportunityModal.displayName = "OpportunityModal";
const OpportunityCard = reactExports.memo(
  ({ row, gridCardColumns: gridCardColumns2, style: style2 }) => {
    const { setCurrentOppIdSelected } = reactExports.useContext(OpportunityInfoContext);
    const handleSelectOpportunty = /* @__PURE__ */ __name((row2) => {
      console.log("handleSelectOpportunty");
      setCurrentOppIdSelected(row2.numeroOs);
    }, "handleSelectOpportunty");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { ...style2, ...basicCardStyles }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          ...basicCardContentStyles,
          width: "100%",
          height: "90%"
        },
        className: "border border-slate-200",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              textAlign: "center",
              sx: { fontWeight: "bold", marginBottom: 1 },
              children: row.nomeDescricaoProposta
            }
          ),
          gridCardColumns2.map((column2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: 1, direction: "row", alignItems: "start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                color: "textPrimary",
                sx: { fontSize: "small", fontWeight: "bold" },
                children: [
                  column2.headerName,
                  ":"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography,
              {
                color: column2.field === "valorTotal" ? "green" : "textPrimary",
                sx: { fontSize: "small" },
                children: row[column2.field]
              }
            )
          ] }, index2)),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => handleSelectOpportunty(row),
              sx: BaseButtonStyles,
              children: "Detalhes"
            }
          )
        ]
      }
    ) });
  }
);
OpportunityCard.displayName = "OpportunityCard";
var CheckBox = {};
var _interopRequireDefault$2 = interopRequireDefaultExports;
Object.defineProperty(CheckBox, "__esModule", {
  value: true
});
var default_1$2 = CheckBox.default = void 0;
var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
var _jsxRuntime$2 = jsxRuntimeExports;
default_1$2 = CheckBox.default = (0, _createSvgIcon$2.default)(/* @__PURE__ */ (0, _jsxRuntime$2.jsx)("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"
}), "CheckBox");
var DateRange = {};
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(DateRange, "__esModule", {
  value: true
});
var default_1$1 = DateRange.default = void 0;
var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
var _jsxRuntime$1 = jsxRuntimeExports;
default_1$1 = DateRange.default = (0, _createSvgIcon$1.default)(/* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
  d: "M9 11H7v2h2zm4 0h-2v2h2zm4 0h-2v2h2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2m0 16H5V9h14z"
}), "DateRange");
const styles$1 = {
  appBar: {
    display: "flex",
    flexDirection: "row",
    flexWrap: "noWrap",
    position: "static",
    backgroundColor: "#2B3990",
    alignItems: "start",
    justifyContent: "start",
    zIndex: 10,
    minHeight: "180px",
    gap: 0.4,
    padding: 1,
    boxShadow: "none"
  },
  stack: {
    flexDirection: "row",
    alignItems: "center",
    padding: 0
  },
  toolbar: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    height: "fit-content",
    justifyContent: "start",
    flexWrap: "wrap",
    width: "fit-content",
    gap: {
      xs: 4,
      sm: 3,
      md: 2,
      lg: 1
    },
    overflowX: "auto",
    "&::-webkit-scrollbar": {
      padding: "10px",
      width: "4px",
      height: "2px"
    },
    "&::-webkit-scrollbar-thumb": {
      height: "2px",
      backgroundColor: "white",
      borderRadius: "4px"
    },
    overflowY: "hidden",
    padding: 1
  },
  search: {
    maxWidth: {
      xs: 200,
      sm: 200,
      md: 250
    },
    padding: 0.1,
    border: "0.5px solid #e3e3e3"
  },
  stackButtons: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 1,
    alignItems: "center"
  },
  textField: {
    borderRadius: 1,
    height: 30,
    backgroundColor: "white",
    color: "black",
    "& .MuiOutlinedInput-notchedOutline": {
      border: "none",
      borderColor: "white"
    },
    "&:hover .MuiOutlinedInput-notchedOutline": {
      border: "2px solid",
      borderColor: "#8dc6ff"
    },
    maxWidth: 150
  },
  checkbox: {
    color: "white",
    "& .Mui-checked": {
      color: "white"
    }
  }
};
const styles = {
  mainContainer: {
    display: {
      xs: "none",
      md: "flex"
    },
    backgroundColor: "white",
    flexDirection: "column",
    borderRadius: "5px",
    height: "fit-content",
    gap: 1,
    padding: 0.5
  },
  container: {
    flexGrow: 1,
    flexShrink: 1,
    display: {
      xs: "none",
      md: "grid"
    },
    height: "fit-content",
    padding: 1,
    borderRadius: "5px",
    gridTemplateRows: "repeat(3, 1fr)",
    // 3 linhas com tamanho igual
    gridTemplateColumns: "repeat(5, 1fr)",
    // 5 colunas com tamanho igual
    gap: 1.2,
    alignItems: "center"
  },
  input: {
    height: 36,
    borderRadius: 0,
    lineHeight: "normal",
    padding: 0
  },
  formControl: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    gap: 1.5,
    borderRadius: 0.5,
    zIndex: 20
  }
};
const createFilters = /* @__PURE__ */ __name((columns2) => {
  return columns2.reduce((acc, column2) => {
    acc[column2.field] = {
      label: column2.headerName,
      dataKey: column2.field,
      values: []
      // Inicialmente vazio
    };
    return acc;
  }, {});
}, "createFilters");
const OpportunityFilters = /* @__PURE__ */ __name(({
  columns: columns2,
  allRows,
  setRows,
  dateFiltersActive,
  handleChangeDateFilters,
  dateParams,
  dateFilters,
  setDateFiltersActive
}) => {
  const filteredColumns = columns2.filter((column2) => {
    if (column2.field !== "dataSolicitacao" && column2.field !== "dataFechamento" && column2.field !== "dataInteracao" && column2.field !== "dataInicio" && column2.field !== "valorFaturamentoDolphin" && column2.field !== "valorFaturamentoDireto" && column2.field !== "valorTotal") {
      return true;
    }
    return false;
  });
  const [filters, setFilters] = React$1.useState(
    createFilters(filteredColumns)
  );
  const [clientOptions, setClientOptions] = reactExports.useState(
    []
  );
  const [responsableOptions, setResponsableOptions] = reactExports.useState();
  const [managerOptions, setManagerOptions] = reactExports.useState();
  const fetchManagerOptions = /* @__PURE__ */ __name(async () => {
    const managers = await fetchManagers();
    if (managers) {
      const options = managers.map((manager) => ({
        label: manager.NOME,
        id: manager.CODPESSOA,
        object: "manager",
        key: manager.CODPESSOA
      }));
      setManagerOptions(options);
    }
  }, "fetchManagerOptions");
  const fetchSalerOps = reactExports.useCallback(async () => {
    const salers = await fetchSalers(0);
    const options = salers.map((saler) => ({
      label: saler.NOME,
      id: saler.CODPESSOA,
      object: "saler",
      key: saler.CODPESSOA
    }));
    setResponsableOptions(options);
  }, []);
  const fetchClientOps = reactExports.useCallback(async () => {
    const clients = await fetchAllClients(0);
    const options = clients.map((client2) => ({
      label: client2.NOMEFANTASIA,
      id: client2.CODCLIENTE,
      object: "client",
      key: client2.CODCLIENTE
    }));
    console.log({ clientOptions: options });
    setClientOptions(options);
  }, [setClientOptions]);
  const [statusOptions, setStatusOptions] = reactExports.useState(
    []
  );
  const fetchStatusOps = reactExports.useCallback(async () => {
    const statusList = await fetchStatusList();
    const options = statusList.map((status) => ({
      label: status.NOME,
      id: status.CODSTATUS,
      object: "status",
      key: status.CODSTATUS
    })) || [];
    setStatusOptions(options);
  }, [setStatusOptions]);
  const updateFilterValues = /* @__PURE__ */ __name((dataKey, values2) => {
    setFilters((prevFilters) => ({
      ...prevFilters,
      [dataKey]: {
        ...prevFilters[dataKey],
        values: values2
      }
    }));
    console.log({
      ...filters,
      [dataKey]: {
        ...filters[dataKey],
        values: values2
      }
    });
    filterRows({
      ...filters,
      [dataKey]: {
        ...filters[dataKey],
        values: values2
      }
    });
  }, "updateFilterValues");
  const filterRows = /* @__PURE__ */ __name((currentFilters) => {
    console.log({ currentFilters });
    const filteredRows = [];
    const filterKeys = Object.keys(currentFilters);
    allRows.forEach((opportunity) => {
      let shouldInclude = true;
      for (let dataKey of filterKeys) {
        const filterValues = currentFilters[dataKey].values;
        if (filterValues.length > 0) {
          const oppIncludesValue = filterValues.some((filterValue) => {
            var _a2;
            const searchTerm = String(filterValue).toUpperCase();
            return (_a2 = opportunity[dataKey]) == null ? void 0 : _a2.toString().toUpperCase().includes(searchTerm);
          });
          if (!oppIncludesValue) {
            shouldInclude = false;
            break;
          }
        }
      }
      if (shouldInclude) {
        filteredRows.push(opportunity);
      }
    });
    console.log({ filteredRows });
    setRows(filteredRows);
  }, "filterRows");
  const renderFilterField = /* @__PURE__ */ __name((filter3) => {
    const { dataKey, label } = filter3;
    if (dataKey === "nomeCliente" || dataKey === "nomeVendedor" || dataKey === "nomeStatus" || dataKey === "nomeGerente") {
      const options = dataKey === "nomeCliente" ? clientOptions : dataKey === "nomeVendedor" ? responsableOptions : dataKey === "nomeStatus" ? statusOptions : managerOptions;
      console.log({ managerOptions });
      if (options) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Autocomplete,
          {
            multiple: true,
            options,
            disableCloseOnSelect: true,
            getOptionKey: (option) => option.id,
            getOptionLabel: (option) => option.label,
            renderTags: (optionArray, getTagProps) => optionArray.map((option, index2) => {
              const { key, ...tagProps } = getTagProps({ index: index2 });
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  variant: "outlined",
                  label: option.label,
                  ...tagProps,
                  sx: { display: "none" }
                },
                key
              );
            }),
            renderOption: (props, option, { selected }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { ...props, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { style: { marginRight: 8 }, checked: selected }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.smallText, children: option.label })
            ] }) }),
            value: options.filter(
              (option) => filters[dataKey].values.includes(option.label)
            ),
            onChange: (_2, newValue) => {
              updateFilterValues(
                dataKey,
                newValue.map((option) => option.label)
              );
            },
            renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                ...params,
                InputLabelProps: { shrink: true, sx: { color: "black" } },
                sx: {
                  "& .MuiOutlinedInput-root": {
                    padding: 0.5
                  }
                },
                InputProps: {
                  ...params.InputProps,
                  sx: styles.input
                },
                label
              }
            )
          },
          dataKey
        );
      }
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField,
      {
        label,
        value: filters[dataKey].values.join(", "),
        onChange: (e2) => updateFilterValues(dataKey, e2.target.value.split(", ")),
        fullWidth: true,
        InputLabelProps: {
          shrink: true,
          sx: {
            color: "black"
          }
        },
        InputProps: { sx: styles.input }
      },
      dataKey
    );
  }, "renderFilterField");
  reactExports.useEffect(() => {
    fetchStatusOps();
    fetchClientOps();
    fetchSalerOps();
    fetchManagerOptions();
    filterRows(filters);
  }, [allRows]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: styles.mainContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: styles.container, children: statusOptions && responsableOptions && clientOptions && Object.values(filters).map((filter3) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: renderFilterField(filter3) }, filter3.dataKey)) }),
    dateFiltersActive && /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        initial: { opacity: 0, y: 0 },
        animate: { opacity: 1, y: 0 },
        exit: { opacity: 0, y: -20 },
        transition: { duration: 0.3 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { sx: styles.formControl, children: [
          dateParams.map((dateFilter, index2) => {
            var _a2, _b2;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                type: "date",
                size: "small",
                onChange: (e2) => handleChangeDateFilters(e2, dateFilter),
                InputProps: { sx: typographyStyles.smallText },
                label: dateFilter.label,
                InputLabelProps: {
                  shrink: true
                },
                value: dateFilter.isFromParam ? (_a2 = dateFilters.find(
                  (filter3) => filter3.dateFilterKey === dateFilter.dataKey
                )) == null ? void 0 : _a2.from : (_b2 = dateFilters.find(
                  (filter3) => filter3.dateFilterKey === dateFilter.dataKey
                )) == null ? void 0 : _b2.to
              },
              index2
            ) }, index2);
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Fechar filtros", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              onClick: () => setDateFiltersActive(!dateFiltersActive),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, { sx: { color: "red" } })
            }
          ) })
        ] })
      },
      "filters"
    ) })
  ] });
}, "OpportunityFilters");
const OpportunityTableSearchBar = reactExports.memo(
  ({
    columns: columns2,
    allRows,
    setRows,
    isCardViewActive,
    setIsCardViewActive
  }) => {
    const navigate = useNavigate();
    const {
      setFinishedOppsEnabled,
      dateFilters,
      setDateFilters,
      toggleRefreshOpportunityInfo,
      toggleCreatingOpportunity
    } = reactExports.useContext(OpportunityInfoContext);
    const [dateFiltersActive, setDateFiltersActive] = reactExports.useState(false);
    const setRowsMemo = reactExports.useCallback(
      (newRows) => setRows(newRows),
      [setRows]
    );
    const columnsMemo = reactExports.useMemo(() => columns2, [columns2]);
    const allRowsMemo = reactExports.useMemo(() => allRows, [allRows]);
    const Search2 = styled("div")(({ theme: theme2 }) => ({
      position: "relative",
      borderRadius: theme2.shape.borderRadius,
      backgroundColor: alpha$2(theme2.palette.common.white, 0.15),
      "&:hover": {
        backgroundColor: alpha$2(theme2.palette.common.white, 0.25)
      },
      marginLeft: 0,
      width: "100%",
      [theme2.breakpoints.up("sm")]: {
        marginLeft: theme2.spacing(1),
        width: "auto"
      }
    }));
    const SearchIconWrapper2 = styled("div")(({ theme: theme2 }) => ({
      padding: theme2.spacing(0, 2),
      height: "100%",
      position: "absolute",
      pointerEvents: "none",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }));
    const StyledInputBase2 = styled(InputBase)(({ theme: theme2 }) => ({
      color: "inherit",
      width: "100%",
      "& .MuiInputBase-input": {
        height: 20,
        padding: theme2.spacing(0.5, 0.5, 0.5, 0),
        paddingLeft: `calc(1em + ${theme2.spacing(4)})`
      }
    }));
    const dateParams = [
      {
        dataKey: "data_inicio",
        label: "De Incio",
        isFromParam: true
      },
      {
        dataKey: "data_inicio",
        label: "At Incio",
        isFromParam: false
      },
      {
        dataKey: "data_interacao",
        label: "De Interao",
        isFromParam: true
      },
      {
        dataKey: "data_interacao",
        label: "At Interao",
        isFromParam: false
      },
      {
        dataKey: "data_fechamento",
        label: "De Fechamento",
        isFromParam: true
      },
      {
        dataKey: "data_fechamento",
        label: "At Fechamento",
        isFromParam: false
      }
    ];
    const handleChangeShowFinishedOpps = /* @__PURE__ */ __name((e2) => {
      const { checked } = e2.target;
      setFinishedOppsEnabled(checked);
    }, "handleChangeShowFinishedOpps");
    const handleSearchWithDateParams = /* @__PURE__ */ __name((_e2) => {
      toggleRefreshOpportunityInfo();
    }, "handleSearchWithDateParams");
    const handleChangeDateFilters = /* @__PURE__ */ __name((e2, dateFilterReceived) => {
      const { value } = e2.target;
      let changedDateFitlers = [];
      if (dateFilterReceived.isFromParam) {
        changedDateFitlers = dateFilters.map(
          (currentDateFilter) => currentDateFilter.dateFilterKey === dateFilterReceived.dataKey ? { ...currentDateFilter, from: value } : currentDateFilter
        );
      } else {
        changedDateFitlers = dateFilters.map(
          (currentDateFilter) => currentDateFilter.dateFilterKey === dateFilterReceived.dataKey ? { ...currentDateFilter, to: value } : currentDateFilter
        );
      }
      setDateFilters(changedDateFitlers);
    }, "handleChangeDateFilters");
    const handleCleanDateFilters = /* @__PURE__ */ __name(() => {
      setDateFilters(defaultDateFilters);
      toggleRefreshOpportunityInfo();
    }, "handleCleanDateFilters");
    const handleGeneralSearch = /* @__PURE__ */ __name((e2) => {
      const value = e2.target.value.toLowerCase();
      const newFilteredRows = allRowsMemo.filter(
        (row) => columnsMemo.some((column2) => {
          const cellValue = row[column2.field];
          return cellValue && String(cellValue).toLowerCase().includes(value);
        })
      );
      setRowsMemo(newFilteredRows);
    }, "handleGeneralSearch");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(AppBar, { sx: styles$1.appBar, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { sx: styles$1.stack, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => navigate("/home"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftIcon, { sx: { color: "white" } }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "white", fontSize: "medium", fontFamily: "Roboto", children: "Controle de Propostas e Oportunidades" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Toolbar, { sx: styles$1.toolbar, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Search2, { sx: styles$1.search, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIconWrapper2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$s, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              StyledInputBase2,
              {
                onChange: handleGeneralSearch,
                placeholder: "Buscar...",
                inputProps: {
                  "aria-label": "search",
                  height: 20,
                  width: 100
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { sx: styles$1.stackButtons, children: [
            dateFiltersActive && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: handleSearchWithDateParams,
                  sx: BaseButtonStyles,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Typography,
                    {
                      fontSize: "small",
                      fontFamily: "Roboto",
                      fontWeight: "semibold",
                      children: "Pesquisar"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: handleCleanDateFilters,
                  sx: BaseButtonStyles,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Typography,
                    {
                      fontSize: "small",
                      fontFamily: "Roboto",
                      fontWeight: "semibold",
                      children: "Limpar Filtros"
                    }
                  )
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                onClick: toggleCreatingOpportunity,
                sx: buttonStylesMobile,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$p, { sx: { color: "#2B3990" } })
              }
            ),
            !dateFiltersActive && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Mostrar filtros", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                sx: buttonStylesMobile,
                onClick: () => setDateFiltersActive(!dateFiltersActive),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$1, { sx: { color: "white" } })
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TableViewToggleButton,
              {
                isCardViewActive,
                setIsCardViewActive
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              FormControlLabel,
              {
                control: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Checkbox,
                  {
                    onChange: handleChangeShowFinishedOpps,
                    checkedIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$2, { sx: { color: "white" } }),
                    sx: styles$1.checkbox
                  }
                ),
                label: "Listar Finalizados"
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        OpportunityFilters,
        {
          columns: columns2,
          allRows,
          setRows,
          dateFiltersActive,
          dateFilters,
          handleChangeDateFilters,
          dateParams,
          setDateFiltersActive
        }
      )
    ] });
  }
);
OpportunityTableSearchBar.displayName = "OpportunityTableSearchBar";
const UseOpportunityInfoTable = /* @__PURE__ */ __name(() => {
  const windowWith = window.innerWidth;
  const { user } = reactExports.useContext(userContext);
  const [rows, setRows] = reactExports.useState([]);
  const [allRows, setAllRows] = reactExports.useState([]);
  const [isMobile, setIsMobile] = reactExports.useState(false);
  const [gridRowCount, setGridRowCount] = reactExports.useState(0);
  const [cardWidth, setCardWidth] = reactExports.useState(0);
  const [isCardViewActive, setIsCardViewActive] = reactExports.useState(false);
  const [gridOuterContainerHeight, setgridOuterContainerHeight] = reactExports.useState(0);
  const GridOuterContainerRef = reactExports.useRef(null);
  const [gridColumnsCount, setGridColumnsCount] = reactExports.useState(0);
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const {
    finishedOppsEnabled,
    refreshOpportunityInfo,
    dateFilters,
    setCurrentOppIdSelected
  } = reactExports.useContext(OpportunityInfoContext);
  const columns2 = reactExports.useMemo(
    () => [
      { field: "numeroProjeto", headerName: "N Projeto" },
      // os.ID_PROJETO
      { field: "numeroAdicional", headerName: "N Adicional" },
      // os.ID_ADICIONAL
      { field: "nomeStatus", headerName: "Status" },
      // s.NOME
      {
        field: "nomeDescricaoProposta",
        headerName: "Descrio",
        editable: false,
        cellClassName: "description-cell"
      },
      { field: "nomeCliente", headerName: "Cliente" },
      // c.NOME
      { field: "nomeVendedor", headerName: "Vendedor" },
      // vendedor.NOME
      { field: "nomeGerente", headerName: "Gerente" },
      // gerente.NOME
      {
        field: "valorFaturamentoDolphin",
        headerName: "Faturamento Dolphin"
      },
      {
        field: "valorFaturamentoDireto",
        headerName: "Faturamento Direto"
      },
      {
        field: "valorTotal",
        headerName: "Valor Total"
      },
      {
        field: "dataSolicitacao",
        headerName: "Solicitao",
        valueFormatter: (value) => {
          if (value)
            return formatDate(value);
          return "-";
        }
      },
      {
        field: "dataFechamento",
        headerName: "Fechamento",
        valueFormatter: (value) => {
          if (value)
            return formatDate(value);
          return "-";
        }
      },
      {
        field: "dataInteracao",
        headerName: "Data de Interao",
        valueFormatter: (value) => {
          if (value)
            return formatDate(value);
          return "-";
        }
      },
      {
        field: "dataInicio",
        headerName: "Data de Incio",
        valueFormatter: (value) => {
          if (value)
            return new Date(value).toLocaleDateString("pt-BR");
          return "-";
        }
      },
      {
        field: "numeroOs",
        headerName: "N OS"
      }
    ],
    []
  );
  const calculateIsMobile = /* @__PURE__ */ __name(() => {
    setIsMobile(window.innerWidth < 768);
  }, "calculateIsMobile");
  const calculateInitialCardViewActive = /* @__PURE__ */ __name(() => {
    setIsCardViewActive(windowWith <= 768);
  }, "calculateInitialCardViewActive");
  const fetchOpportunities = reactExports.useCallback(async () => {
    setIsLoading(true);
    if (user) {
      const opps = await getOpportunities(
        finishedOppsEnabled,
        dateFilters,
        user.CODPESSOA
      );
      if (opps) {
        setAllRows(opps);
        setRows(opps);
        calculateLayoutProps(opps.length);
      }
    }
    setIsLoading(false);
  }, [refreshOpportunityInfo, finishedOppsEnabled]);
  const shouldShowGrid = /* @__PURE__ */ __name(() => {
    return gridRowCount > 0 && cardWidth > 0 && gridColumnsCount > 0 && isCardViewActive;
  }, "shouldShowGrid");
  const calculateGridHeight = /* @__PURE__ */ __name(() => {
    if (GridOuterContainerRef.current) {
      const height2 = GridOuterContainerRef.current.clientHeight;
      setgridOuterContainerHeight(height2);
      return height2;
    }
  }, "calculateGridHeight");
  const calculateCardWidth = reactExports.useCallback(() => {
    const minCardWidth = 300;
    const maxCardWidth = 600;
    const minWindowWidth = 320;
    const maxWindowWidth = 1200;
    const clampedWindowWidth = Math.min(
      Math.max(windowWith, minWindowWidth),
      maxWindowWidth
    );
    const cardWidth2 = minCardWidth + (clampedWindowWidth - minWindowWidth) / (maxWindowWidth - minWindowWidth) * (maxCardWidth - minCardWidth);
    const roundedCardWidth = Math.round(cardWidth2);
    setCardWidth(roundedCardWidth);
    return roundedCardWidth;
  }, [windowWith]);
  const calculateGridColumnsCount = reactExports.useCallback(
    (cardWidth2) => {
      const gridColumnsCount2 = Math.floor(windowWith / cardWidth2);
      setGridColumnsCount(gridColumnsCount2);
      return gridColumnsCount2;
    },
    [windowWith]
  );
  const calculateGridRowCount = /* @__PURE__ */ __name((registerCount, gridColumnsCount2) => {
    const gridRowCount2 = registerCount / gridColumnsCount2;
    setGridRowCount(gridRowCount2);
    return gridRowCount2;
  }, "calculateGridRowCount");
  const calculateLayoutProps = reactExports.useCallback(
    (registerCount) => {
      const cardWidth2 = calculateCardWidth();
      const gridColumnsCount2 = calculateGridColumnsCount(cardWidth2);
      const gridRowCount2 = calculateGridRowCount(
        registerCount,
        gridColumnsCount2
      );
      const gridHeight = calculateGridHeight();
      console.log(gridRowCount2, gridHeight);
      calculateInitialCardViewActive();
    },
    [calculateCardWidth, calculateGridColumnsCount, rows.length]
  );
  const selectOpportunity = /* @__PURE__ */ __name((row) => {
    setCurrentOppIdSelected(row.row.numeroOs);
  }, "selectOpportunity");
  const GridFooter3 = /* @__PURE__ */ __name(() => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      GridFooterContainer,
      {
        sx: {
          color: "black",
          paddingX: 1,
          paddingY: 0,
          display: "flex",
          justifyContent: "space-between",
          // Alinha os itens nas extremidades
          alignItems: "center",
          // Centraliza verticalmente
          flexWrap: "nowrap",
          // Permite que o contedo quebre em vrias linhas
          overflowX: "auto",
          // Permite rolagem horizontal se necessrio
          overflowY: "hidden",
          zIndex: 20,
          backgroundColor: "#2B3990",
          borderRadius: 0,
          height: "auto",
          // Altura automtica para acomodar o contedo
          minHeight: "52px",
          // Altura mnima
          gap: 1
          // Espaamento entre os itens
        },
        className: "shadow-2xl",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              sx: {
                paddingTop: 1,
                display: isMobile ? "none" : "flex",
                justifyContent: "center",
                alignItems: "center",
                gap: 2,
                flexGrow: 1,
                // Ocupa o espao disponvel
                overflowX: "auto"
                // Permite rolagem horizontal se necessrio
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { fontSize: "small", color: "white", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold tracking-wide", children: [
                    " ",
                    "N de Registros",
                    " "
                  ] }),
                  " ",
                  rows.length
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { fontSize: "small", color: "white", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold tracking-wide", children: [
                    " ",
                    "Faturamento Dolphin:",
                    " "
                  ] }),
                  " ",
                  new Intl.NumberFormat("pt-BR", {
                    style: "currency",
                    currency: "BRL"
                  }).format(
                    rows.reduce((acumulador, opp) => {
                      const valorLimpo = String(opp.valorFaturamentoDireto).replace("R$", "").replace(/\./g, "").replace(",", ".");
                      return acumulador + Number(valorLimpo);
                    }, 0)
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { fontSize: "small", color: "white", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold tracking-wide", children: [
                    " ",
                    "Valor Total:",
                    " "
                  ] }),
                  " ",
                  new Intl.NumberFormat("pt-BR", {
                    style: "currency",
                    currency: "BRL"
                  }).format(
                    rows.reduce((acumulador, opp) => {
                      const valorLimpo = String(opp.valorTotal ? opp.valorTotal : 0).replace("R$", "").replace(/\./g, "").replace(",", ".");
                      return acumulador + Number(valorLimpo);
                    }, 0)
                  )
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            GridPagination,
            {
              sx: {
                padding: 0,
                width: "fit-content",
                display: "flex",
                alignItems: "center",
                justifyContent: "start",
                overflowY: "hidden",
                height: "30px",
                color: "white",
                "& .MuiToolbar-gutters": {
                  padding: 0,
                  "& .MuiTablePagination-selectLabel": {
                    display: "none"
                    // Oculta o rtulo "Rows per page"
                  }
                }
              }
            }
          )
        ]
      }
    );
  }, "GridFooter");
  reactExports.useEffect(() => {
    calculateIsMobile();
    fetchOpportunities();
  }, [fetchOpportunities, refreshOpportunityInfo]);
  return {
    // State Variables
    rows,
    allRows,
    isCardViewActive,
    gridOuterContainerHeight,
    gridColumnsCount,
    cardWidth,
    gridRowCount,
    isLoading,
    // Refs
    GridOuterContainerRef,
    // Functions
    setRows,
    setIsCardViewActive,
    shouldShowGrid,
    selectOpportunity,
    // Components
    columns: columns2,
    GridFooter: GridFooter3
  };
}, "UseOpportunityInfoTable");
const theme$1 = createTheme(
  {
    palette: {
      primary: { main: "#1976d2" }
    }
  },
  ptBR$1,
  ptBR,
  ptBR$2
);
const gridCardColumns = [
  {
    field: "numeroOs",
    headerName: "N OS"
  },
  { field: "numeroProjeto", headerName: "N Projeto" },
  { field: "numeroAdicional", headerName: "N Adicional" },
  // os.ID_ADICIONAL
  { field: "nomeDescricaoProposta", headerName: "Descrio" },
  { field: "nomeCliente", headerName: "Cliente" },
  {
    field: "valorTotal",
    headerName: "Valor Total"
  },
  { field: "nomeStatus", headerName: "Status" }
  // s.NOME
];
const OpportunityInfoTable = /* @__PURE__ */ __name(() => {
  const {
    rows,
    allRows,
    isCardViewActive,
    gridOuterContainerHeight,
    gridColumnsCount,
    cardWidth,
    gridRowCount,
    isLoading,
    GridOuterContainerRef,
    setRows,
    setIsCardViewActive,
    shouldShowGrid,
    selectOpportunity,
    columns: columns2,
    GridFooter: GridFooter3
  } = UseOpportunityInfoTable();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        width: "100%",
        height: "100%",
        backgroundColor: "#fff",
        display: "flex",
        boxSizing: "border-box",
        flexDirection: "column",
        gap: 0,
        flex: 1
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          OpportunityTableSearchBar,
          {
            columns: columns2,
            allRows,
            setRows,
            isCardViewActive,
            setIsCardViewActive
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            ref: GridOuterContainerRef,
            sx: {
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              boxSizing: "border-box",
              width: "100%",
              flexGrow: 1
            },
            children: [
              !isCardViewActive && !isLoading && gridOuterContainerHeight > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$3, { theme: theme$1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                DataGrid,
                {
                  rows,
                  columns: columns2,
                  getRowId: (row) => row.numeroOs,
                  rowHeight: 36,
                  density: "compact",
                  columnHeaderHeight: 40,
                  autosizeOnMount: true,
                  autosizeOptions: {
                    expand: true
                  },
                  sx: { ...OpportunityGridStyles, maxHeight: gridOuterContainerHeight },
                  onRowClick: selectOpportunity,
                  disableRowSelectionOnClick: true,
                  slots: {
                    footer: GridFooter3,
                    row: CustomOpportunityRow
                  }
                }
              ) }),
              !isLoading && shouldShowGrid() && /* @__PURE__ */ jsxRuntimeExports.jsx(
                FixedSizeGrid,
                {
                  columnCount: gridColumnsCount,
                  columnWidth: cardWidth,
                  height: gridOuterContainerHeight,
                  rowCount: gridRowCount,
                  rowHeight: 320,
                  width: gridColumnsCount * cardWidth + 20,
                  children: ({ columnIndex, rowIndex, style: style2 }) => {
                    console.log(columnIndex);
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(
                      OpportunityCard,
                      {
                        row: rows[rowIndex],
                        gridCardColumns,
                        style: style2
                      },
                      rows[rowIndex].numeroOs
                    );
                  }
                }
              ),
              isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Loader$1, {})
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(OpportunityModal, {})
      ]
    }
  );
}, "OpportunityInfoTable");
OpportunityInfoTable.displayName = "OpportunityInfoTable";
const CrmHome = /* @__PURE__ */ __name(() => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { height: "100vh", children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpportunityInfoTable, {}) });
}, "CrmHome");
var ArrowLeft = {};
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(ArrowLeft, "__esModule", {
  value: true
});
var default_1 = ArrowLeft.default = void 0;
var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
var _jsxRuntime = jsxRuntimeExports;
default_1 = ArrowLeft.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
  d: "m14 7-5 5 5 5z"
}), "ArrowLeft");
function ChecklistFiltersMobileMenu({ filterByStatus }) {
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const open2 = Boolean(anchorEl);
  const handleClick = /* @__PURE__ */ __name((event) => {
    setAnchorEl(event.currentTarget);
  }, "handleClick");
  const handleFilterByStatus = /* @__PURE__ */ __name((filterName) => {
    filterByStatus(filterName);
    setAnchorEl(null);
  }, "handleFilterByStatus");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        "aria-controls": open2 ? "basic-menu" : void 0,
        "aria-haspopup": "true",
        "aria-expanded": open2 ? "true" : void 0,
        onClick: handleClick,
        sx: { ...buttonStylesMobile },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, { sx: { color: "white" } })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Menu$1,
      {
        id: "basic-menu",
        anchorEl,
        open: open2,
        onClose: handleFilterByStatus,
        MenuListProps: {
          "aria-labelledby": "basic-button"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { onClick: () => handleFilterByStatus("problemas"), children: "problemas" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { onClick: () => handleFilterByStatus("atrasados"), children: "atrasados" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { onClick: () => handleFilterByStatus("aprovar"), children: "para aprovar" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { onClick: () => handleFilterByStatus("todos"), children: "todos" })
        ]
      }
    )
  ] });
}
__name(ChecklistFiltersMobileMenu, "ChecklistFiltersMobileMenu");
const ChecklistAppBar = /* @__PURE__ */ __name(({
  handleBack,
  filterByStatus,
  currentStatusFilterSelected,
  isMobile,
  user,
  handleSearch,
  isCardViewActive,
  setIsCardViewActive
}) => {
  console.log(!isMobile && (user == null ? void 0 : user.responsavel_tipo));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AppBar,
    {
      position: "static",
      sx: {
        ...basicAppbarStyles,
        alignItems: {
          xs: "center",
          md: "start"
        }
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          display: "flex",
          alignItems: "center",
          flexWrap: "wrap",
          left: 2,
          gap: 1,
          width: { xs: "90%", sm: "80%", md: "70%", lg: "60%" },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                onClick: handleBack,
                sx: {
                  color: "#F7941E",
                  cursor: "pointer",
                  "&:hover": {
                    backgroundColor: "rgba(0, 0, 0, 0.05)"
                  },
                  zIndex: 1e3
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1, {})
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography,
              {
                textAlign: "center",
                fontSize: "medium",
                fontFamily: "Roboto",
                padding: 2,
                children: "Checklists Pendentes"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Search, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIconWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$s, {}) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                StyledInputBase,
                {
                  placeholder: "Buscar...",
                  inputProps: { "aria-label": "search" },
                  onChange: handleSearch
                }
              )
            ] }),
            isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
              TableViewToggleButton,
              {
                isCardViewActive,
                setIsCardViewActive
              }
            ),
            !isMobile && (user == null ? void 0 : user.responsavel_tipo) && /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 2, alignItems: "center", children: ["atrasados", "aprovar", "problemas", "todos"].map((status) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                id: status,
                onClick: () => filterByStatus(status),
                sx: {
                  color: "white",
                  backgroundColor: currentStatusFilterSelected === status || status === "todos" && currentStatusFilterSelected === "" ? "#f1b963" : "#F7941E",
                  "&:hover": {
                    backgroundColor: "#f1b963"
                  },
                  height: "1.4rem",
                  fontSize: "12px"
                },
                children: status.charAt(0).toUpperCase() + status.slice(1)
              },
              status
            )) }),
            isMobile && (user == null ? void 0 : user.responsavel_tipo) && /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistFiltersMobileMenu, { filterByStatus })
          ]
        }
      )
    }
  ) });
}, "ChecklistAppBar");
const columns = [
  {
    width: 80,
    label: "Checklist",
    dataKey: "id_checklist_movimentacao",
    numeric: true
  },
  {
    width: 80,
    label: "Patrimnio",
    dataKey: "id_patrimonio",
    numeric: true
  },
  {
    width: 180,
    label: "Data de Criao",
    dataKey: "data_criacao"
  },
  {
    width: 70,
    label: "Realizado",
    dataKey: "realizado",
    numeric: true
  },
  {
    width: 70,
    label: "Aprovado",
    dataKey: "aprovado",
    numeric: true
  },
  {
    width: 180,
    label: "Data de Realizao",
    dataKey: "data_realizado"
  },
  {
    label: "Patrimnio",
    dataKey: "nome_patrimonio",
    width: 300,
    numeric: false
  },
  {
    width: 500,
    label: "Projeto",
    dataKey: "descricao_projeto",
    numeric: false
  },
  {
    width: 200,
    label: "Responsvel",
    dataKey: "nome_responsavel",
    numeric: true
  }
];
const VirtuosoTableComponents = {
  Scroller: React$1.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { component: Paper, ...props, ref })),
  Table: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Table$1,
    {
      ...props,
      sx: { borderCollapse: "separate", tableLayout: "fixed" }
    }
  ),
  TableHead: React$1.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { ...props, ref })),
  TableRow,
  TableBody: React$1.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { ...props, ref }))
};
const ChecklistTasks = /* @__PURE__ */ __name(() => {
  const { user } = reactExports.useContext(userContext);
  const {
    toggleChecklistOpen,
    refreshChecklist,
    currentColumnFilters,
    setCurrentColumnFilters,
    filteredNotificationsByUser,
    currentStatusFilterSelected,
    setCurrentStatusFilterSelected,
    currentFilteredByStatus,
    setCurrentFilteredByStatus,
    setFilteredNotificationsByUser
  } = reactExports.useContext(checklistContext);
  const [isMobile, setIsMobile] = reactExports.useState(false);
  const [isCardViewActive, setIsCardViewActive] = reactExports.useState(false);
  const navigate = useNavigate();
  const filterByActiveColumnFilters = reactExports.useCallback(
    (columnFilters, notifications) => {
      const activeFilters = columnFilters.filter(
        (filter3) => filter3.filterValue.trim() !== ""
      );
      if (activeFilters.length > 0) {
        const filteredNotifications = notifications == null ? void 0 : notifications.filter((notification) => {
          return activeFilters.every((filter3) => {
            const { dataKey, filterValue } = filter3;
            if (dataKey === "id_checklist_movimentacao" || dataKey === "id_movimentacao") {
              console.log("coluna numrica");
              return String(
                notification[dataKey]
              ) === String(filterValue);
            }
            if (dataKey === "data_realizado" || dataKey === "data_criacao") {
              const renderedDate = renderDateValue(dataKey, notification);
              return renderedDate == null ? void 0 : renderedDate.includes(filterValue);
            }
            return String(notification[dataKey]).toLowerCase().includes(filterValue.toLowerCase());
          });
        });
        return filteredNotifications;
      }
      return notifications;
    },
    []
  );
  const getNotifications = reactExports.useCallback(async () => {
    console.log("currentColumn filters: ", currentColumnFilters);
    if (user) {
      const notifications = await getPatrimonyNotifications(
        user,
        currentStatusFilterSelected
      );
      setCurrentFilteredByStatus(notifications);
      const filteredByUser = filterByActiveColumnFilters(
        currentColumnFilters,
        notifications
      );
      setFilteredNotificationsByUser(filteredByUser);
    }
  }, [
    currentColumnFilters,
    currentStatusFilterSelected,
    filterByActiveColumnFilters,
    setCurrentFilteredByStatus,
    setFilteredNotificationsByUser,
    user
  ]);
  const handleChangeColumnFilter = /* @__PURE__ */ __name((e2, column2) => {
    const { value } = e2.target;
    const changedColumnFilters = currentColumnFilters.map(
      (columnfilter) => columnfilter.dataKey === column2.dataKey ? {
        ...columnfilter,
        filterValue: value
      } : columnfilter
    );
    setCurrentColumnFilters(changedColumnFilters);
    const filteredByColumnsNotifications = filterByActiveColumnFilters(
      changedColumnFilters,
      currentFilteredByStatus
    );
    console.log(
      "filteredByColumnsNotifications",
      filteredByColumnsNotifications
    );
    setFilteredNotificationsByUser(filteredByColumnsNotifications || []);
  }, "handleChangeColumnFilter");
  function fixedHeaderContent2() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { sx: { backgroundColor: "#2B3990", borderRadius: "none" }, children: columns.map((column2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      TableCell,
      {
        variant: "head",
        align: column2.numeric || false ? "left" : "left",
        sx: { width: column2.width, paddingY: 0.4 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", fontFamily: "Roboto", color: "white", children: column2.label }),
          column2.dataKey !== "realizado" && column2.dataKey !== "aprovado" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              id: "standard-basic",
              label: "",
              variant: "standard",
              onChange: (e2) => handleChangeColumnFilter(e2, column2),
              sx: {
                fontSize: "10px",
                // Tamanho da fonte do texto digitado
                "& .MuiInput-underline:before": {
                  borderBottom: "1px solid white"
                  // Linha padro
                },
                "& .MuiInput-underline:hover:not(.Mui-disabled):before": {
                  borderBottom: "2px solid white"
                  // Linha ao passar o mouse
                },
                "& .MuiInput-underline:after": {
                  borderBottom: "2px solid white"
                  // Linha ao focar no campo
                }
              },
              InputProps: {
                sx: {
                  color: "white",
                  "&:hover:not(.Mui-disabled):before": {
                    borderBottom: "2px solid white"
                    // Linha ao passar o mouse
                  },
                  "&:after": {
                    borderBottom: "2px solid white"
                    // Linha ao focar no campo
                  },
                  height: "1rem"
                }
              }
            }
          )
        ]
      },
      column2.dataKey
    )) });
  }
  __name(fixedHeaderContent2, "fixedHeaderContent");
  const handleBack = /* @__PURE__ */ __name(() => {
    navigate("/patrimony");
  }, "handleBack");
  const renderDateValue = /* @__PURE__ */ __name((dataKey, row) => {
    const date = dateTimeRenderer(
      row[dataKey] || ""
    );
    return date === "Invalid Date, Invalid Date" ? "" : date;
  }, "renderDateValue");
  const handleOpenChecklist = /* @__PURE__ */ __name((row) => {
    toggleChecklistOpen(row);
  }, "handleOpenChecklist");
  function rowContent(_index, row) {
    const isDateValue = /* @__PURE__ */ __name((column2) => {
      return column2.dataKey === "data_aprovado" || column2.dataKey === "data_realizado" || column2.dataKey === "data_criacao";
    }, "isDateValue");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(React$1.Fragment, { children: columns.map((column2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      TableCell,
      {
        sx: {
          cursor: "pointer",
          paddingY: "0.5rem"
        },
        onClick: () => handleOpenChecklist(row),
        align: column2.numeric || false ? "left" : "left",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: "small", children: isDateValue(column2) ? renderDateValue(column2.dataKey, row) : user && renderValue(column2, row, user) })
      },
      column2.dataKey
    )) });
  }
  __name(rowContent, "rowContent");
  const filterByStatus = /* @__PURE__ */ __name((checklistStatus) => {
    if (checklistStatus === "atrasados") {
      console.log("atrasados");
      setCurrentStatusFilterSelected("atrasados");
      return;
    }
    if (checklistStatus === "aprovar") {
      console.log("aprovar");
      setCurrentStatusFilterSelected("aprovar");
      return;
    }
    if (checklistStatus === "problemas") {
      console.log("problemas");
      setCurrentStatusFilterSelected("problemas");
      return;
    }
    if (checklistStatus === "todos") {
      console.log("todos");
      setCurrentStatusFilterSelected("todos");
      return;
    }
  }, "filterByStatus");
  const handleSearch = /* @__PURE__ */ __name((e2) => {
    const { value } = e2.target;
    console.log("searching for: ", value);
    const filteredNotifications = currentFilteredByStatus.filter(
      (notification) => {
        var _a2, _b2;
        return notification.nome.toLowerCase().includes(value.toLowerCase()) || ((_a2 = notification.descricao_projeto) == null ? void 0 : _a2.toLowerCase().includes(value.toLowerCase())) || ((_b2 = notification.nome_responsavel) == null ? void 0 : _b2.toLowerCase().includes(value.toLowerCase()));
      }
    );
    setFilteredNotificationsByUser(filteredNotifications);
  }, "handleSearch");
  reactExports.useEffect(() => {
    const checkIsMobile = /* @__PURE__ */ __name(() => {
      setIsMobile(window.matchMedia("(max-width: 768px)").matches);
      setIsCardViewActive(window.innerWidth <= 768);
    }, "checkIsMobile");
    checkIsMobile();
    window.addEventListener("resize", checkIsMobile);
    return () => {
      window.removeEventListener("resize", checkIsMobile);
    };
  }, []);
  reactExports.useEffect(() => {
    getNotifications();
  }, [refreshChecklist, currentStatusFilterSelected]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        height: "85vh",
        width: "100%",
        padding: {
          xs: 0.2,
          sm: 2,
          md: 3,
          lg: 2,
          xl: 1
        }
      },
      children: [
        user && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ChecklistAppBar,
          {
            setIsCardViewActive,
            isCardViewActive,
            handleSearch,
            handleBack,
            filterByStatus,
            user,
            currentStatusFilterSelected,
            isMobile
          }
        ),
        filteredNotificationsByUser && !isCardViewActive && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableVirtuoso,
          {
            data: filteredNotificationsByUser,
            style: { borderRadius: 0 },
            components: {
              ...VirtuosoTableComponents,
              TableRow: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                TableRow,
                {
                  ...props,
                  sx: {
                    cursor: "pointer",
                    "&:hover": { backgroundColor: "#e7eaf6" }
                  }
                }
              )
            },
            fixedHeaderContent: fixedHeaderContent2,
            itemContent: rowContent
          }
        ),
        filteredNotificationsByUser && isCardViewActive && /* @__PURE__ */ jsxRuntimeExports.jsx(
          FixedSizeList,
          {
            height: 640,
            width: "100%",
            itemSize: 320,
            itemCount: filteredNotificationsByUser.length,
            overscanCount: 1,
            children: ({ index: index2, style: style2, data }) => {
              const columns2 = [
                { label: "Patrimnio", dataKey: "nome_patrimonio" },
                { label: "Data de Criao", dataKey: "data_criacao" },
                { label: "Projeto", dataKey: "descricao_projeto" },
                { label: "Responsvel", dataKey: "nome_responsavel" },
                { label: "Realizado", dataKey: "realizado" },
                { label: "Aprovado", dataKey: "aprovado" }
              ];
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                ChecklistCard,
                {
                  handleOpenChecklist,
                  renderValue,
                  props: { index: index2, style: style2, data },
                  columns: columns2,
                  cardData: filteredNotificationsByUser[index2]
                },
                index2
              );
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            display: "flex",
            justifyContent: "flex-end",
            paddingY: "0.4rem",
            paddingX: "2rem",
            children: filteredNotificationsByUser && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                color: "blue",
                fontWeight: "semibold",
                fontFamily: "Roboto",
                children: [
                  "Total de Checklists: ",
                  filteredNotificationsByUser.length
                ]
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistItemsModal, {})
      ]
    }
  );
}, "ChecklistTasks");
const QuoteItemsTable = /* @__PURE__ */ __name(({ items, isSupplier }) => {
  const [currentItems, setCurrentItems] = reactExports.useState([...items]);
  const [isSelecting, setIsSelecting] = reactExports.useState(false);
  const [selectionModel, setSelectionModel] = reactExports.useState();
  console.log({
    currentItems,
    isSelecting,
    selectionModel,
    setCurrentItems
  });
  const handleGenerateSupplierUrl = /* @__PURE__ */ __name(() => {
    const url = new URL(window.location.href);
    url.searchParams.set("supplier", "1");
    navigator.clipboard.writeText(url.toString()).then(() => {
      console.log("URL copiada para a rea de transferncia:", url);
    }).catch((err) => {
      console.error("Erro ao copiar a URL:", err);
    });
    alert("Link copiado para rea de transferncia");
  }, "handleGenerateSupplierUrl");
  const handleSelection = /* @__PURE__ */ __name((newSelectionModel) => {
    setIsSelecting(true);
    if (newSelectionModel.length) {
      setIsSelecting(true);
      setSelectionModel(newSelectionModel);
      return;
    }
    setIsSelecting(false);
  }, "handleSelection");
  const columns2 = [
    { field: "id_item_cotacao", headerName: "ID Item", width: 100, editable: true },
    { field: "descricao_item", headerName: "Descrio", width: 300, editable: true },
    {
      field: "preco_unitario",
      headerName: "Preo Unitrio (R$)",
      width: 150,
      editable: true,
      valueFormatter: (value) => value.toLocaleString("pt-BR", {
        style: "currency",
        currency: "BRL"
      })
    },
    { field: "quantidade", headerName: "Quantidade", width: 120, editable: true },
    {
      field: "subtotal",
      headerName: "Subtotal (R$)",
      width: 150,
      editable: true,
      valueFormatter: (value) => value.toLocaleString("pt-BR", {
        style: "currency",
        currency: "BRL"
      })
    }
  ];
  const CustomColumnHeaders = /* @__PURE__ */ __name((props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MemoizedGridColumnHeaders, { ...props });
  }, "CustomColumnHeaders");
  console.log(CustomColumnHeaders);
  reactExports.useEffect(() => {
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { height: "100%", display: "flex", flexDirection: "column", gap: 1, padding: 1 }, children: [
    !isSupplier && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { sx: { ...BaseButtonStyles, width: 200 }, onClick: handleGenerateSupplierUrl, children: "Gerar Link de fornecedor" }),
    isSupplier && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { sx: { ...BaseButtonStyles, width: 200 }, onClick: handleGenerateSupplierUrl, children: "Enviar cotao" }),
    isSupplier && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", gap: 2, alignItems: "center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading1, children: "Por favor, preencha a coluna preo unitrio com seus valores!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading2, children: '(aps preencher todos os itens, clique em "Enviar Cotao"!)' })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DataGrid,
      {
        rows: items.map((item) => ({
          ...item,
          id: item.id_item_cotacao
          // O DataGrid exige um campo "id"
        })),
        columns: columns2,
        initialState: {
          pagination: {
            paginationModel: {
              pageSize: 100
            }
          }
        },
        onRowSelectionModelChange: handleSelection,
        density: "compact",
        autosizeOnMount: true,
        pageSizeOptions: [50, 100],
        disableRowSelectionOnClick: true
      }
    )
  ] });
}, "QuoteItemsTable");
const QuoteDetail = /* @__PURE__ */ __name(() => {
  const [isEditing, setIsEditing] = reactExports.useState();
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const [currentQuoteData, setCurrentQuoteData] = reactExports.useState(defaultQuote);
  const [isSupplier, setIsSupplier] = reactExports.useState(false);
  console.log({ currentQuoteData });
  const handleChange = /* @__PURE__ */ __name((e2, dataKey) => {
    const { value } = e2.target;
    console.log({
      ...quoteData,
      [dataKey]: value
    });
    setCurrentQuoteData({
      ...quoteData,
      [dataKey]: value
    });
  }, "handleChange");
  const handleSave = /* @__PURE__ */ __name(() => {
    console.log("saving");
  }, "handleSave");
  const formatToBRL = /* @__PURE__ */ __name((value) => {
    return new Intl.NumberFormat("pt-BR", {
      style: "currency",
      currency: "BRL"
    }).format(value);
  }, "formatToBRL");
  const verifySupplier = /* @__PURE__ */ __name(() => {
    setIsLoading(true);
    const url = new URL(window.location.href);
    if (Number(url.searchParams.get("supplier")) === 1) {
      setIsSupplier(true);
    }
    setIsLoading(false);
  }, "verifySupplier");
  const quoteData = dummyQuotes[0];
  const selectedFields = quoteFields.filter(
    (field) => field.dataKey === "observacao" || field.dataKey === "data_validade" || field.dataKey === "condicoes_pagamento" || field.dataKey === "data_cotacao" || field.dataKey === "fornecedor"
  );
  reactExports.useEffect(() => {
    verifySupplier();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { ...quoteDetailPageStyles }, children: [
    !isLoading && !isSupplier && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { ...boxDefaultStyles, height: "50%", display: "flex", gap: 2 }, className: "shadow-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { height: "100%", width: "40%", padding: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: typographyStyles.heading1, children: quoteData.descricao }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "grid", gridTemplateColumns: `1fr 1fr`, gap: 1, alignContent: "start" }, children: selectedFields.map((field) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: field.label,
            name: field.label,
            onFocus: () => setIsEditing(true),
            onBlur: () => setIsEditing(false),
            sx: { display: "flex", flexShrink: 1 },
            type: field.type === "number" ? "number" : "text",
            value: quoteData[field.dataKey] || "",
            onChange: (e2) => handleChange(e2, field.dataKey),
            fullWidth: true,
            margin: "normal"
          },
          field.dataKey
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isEditing && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.5 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { sx: BaseButtonStyles, onClick: handleSave, className: "shadow-lg", children: "Salvar alteraes" }) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { height: "100%", width: "30%", padding: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { sx: typographyStyles.heading1, children: [
        "Total: ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-700", children: `${formatToBRL(1500)}` })
      ] }) })
    ] }),
    !isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { ...boxDefaultStyles, height: "50%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QuoteItemsTable, { items: quoteData.itens, isSupplier }) }),
    isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Loader$1, {})
  ] });
}, "QuoteDetail");
const router = createBrowserRouter([
  { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SignIn, {}) },
  { path: "/home", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Home, {}) },
  { path: "/requisitions", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RequisitionHome, {}) },
  { path: "/patrimony", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PatrimonyHome, {}) },
  {
    path: "patrimony/checklist/:id_patrimonio",
    element: /* @__PURE__ */ jsxRuntimeExports.jsx(PatrimonyChecklist, {})
  },
  { path: "/patrimony/details/:id_patrimonio", element: /* @__PURE__ */ jsxRuntimeExports.jsx(MovimentationContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MovementationFileContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PatrimonyFileContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PatrimonyDetails, {}) }) }) }) },
  {
    path: "requisitions/requisitionDetail/:id",
    element: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemsContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RequisitionDetail, {}) })
  },
  {
    path: "requisitions/quote/:quoteId",
    element: /* @__PURE__ */ jsxRuntimeExports.jsx(QuoteDetail, {})
  },
  {
    path: "tasks",
    element: /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistTasks, {})
  },
  {
    path: "/crm",
    element: /* @__PURE__ */ jsxRuntimeExports.jsx(CrmHome, {})
  }
]);
var client = {};
var m = reactDomExports;
{
  client.createRoot = m.createRoot;
  client.hydrateRoot = m.hydrateRoot;
}
var Subscribable = (_d = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, __name(_d, "Subscribable"), _d);
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop() {
  return void 0;
}
__name(noop, "noop");
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
__name(functionalUpdate, "functionalUpdate");
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
__name(isValidTimeout, "isValidTimeout");
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
__name(timeUntilStale, "timeUntilStale");
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
__name(matchQuery, "matchQuery");
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
__name(matchMutation, "matchMutation");
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn(queryKey);
}
__name(hashQueryKeyByOptions, "hashQueryKeyByOptions");
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_2, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
__name(hashKey, "hashKey");
function partialMatchKey(a, b2) {
  if (a === b2) {
    return true;
  }
  if (typeof a !== typeof b2) {
    return false;
  }
  if (a && b2 && typeof a === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key) => !partialMatchKey(a[key], b2[key]));
  }
  return false;
}
__name(partialMatchKey, "partialMatchKey");
function replaceEqualDeep(a, b2) {
  if (a === b2) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b2);
  if (array || isPlainObject(a) && isPlainObject(b2)) {
    const aItems = array ? a : Object.keys(a);
    const aSize = aItems.length;
    const bItems = array ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array ? i : bItems[i];
      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b2[key] === void 0) {
        copy2[key] = void 0;
        equalItems++;
      } else {
        copy2[key] = replaceEqualDeep(a[key], b2[key]);
        if (copy2[key] === a[key] && a[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy2;
  }
  return b2;
}
__name(replaceEqualDeep, "replaceEqualDeep");
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
__name(isPlainArray, "isPlainArray");
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
__name(isPlainObject, "isPlainObject");
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
__name(hasObjectPrototype, "hasObjectPrototype");
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
__name(sleep, "sleep");
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
__name(replaceData, "replaceData");
function addToEnd(items, item, max2 = 0) {
  const newItems = [...items, item];
  return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
}
__name(addToEnd, "addToEnd");
function addToStart(items, item, max2 = 0) {
  const newItems = [item, ...items];
  return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
}
__name(addToStart, "addToStart");
var skipToken = Symbol();
var FocusManager = (_e = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused, void 0);
    __privateAdd(this, _cleanup, void 0);
    __privateAdd(this, _setup, void 0);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = /* @__PURE__ */ __name(() => onFocus(), "listener");
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup, setup);
    (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a2;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a2 = globalThis.document) == null ? void 0 : _a2.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), __name(_e, "FocusManager"), _e);
var focusManager = new FocusManager();
var OnlineManager = (_f = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2, void 0);
    __privateAdd(this, _setup2, void 0);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = /* @__PURE__ */ __name(() => onOnline(true), "onlineListener");
        const offlineListener = /* @__PURE__ */ __name(() => onOnline(false), "offlineListener");
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup2, setup);
    (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), __name(_f, "OnlineManager"), _f);
var onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
__name(defaultRetryDelay, "defaultRetryDelay");
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
__name(canFetch, "canFetch");
var CancelledError = (_g = class {
  constructor(options) {
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
}, __name(_g, "CancelledError"), _g);
function isCancelledError(value) {
  return value instanceof CancelledError;
}
__name(isCancelledError, "isCancelledError");
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = /* @__PURE__ */ __name((cancelOptions) => {
    var _a2;
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      (_a2 = config2.abort) == null ? void 0 : _a2.call(config2);
    }
  }, "cancel");
  const cancelRetry = /* @__PURE__ */ __name(() => {
    isRetryCancelled = true;
  }, "cancelRetry");
  const continueRetry = /* @__PURE__ */ __name(() => {
    isRetryCancelled = false;
  }, "continueRetry");
  const canContinue = /* @__PURE__ */ __name(() => focusManager.isFocused() && (config2.networkMode === "always" || onlineManager.isOnline()) && config2.canRun(), "canContinue");
  const canStart = /* @__PURE__ */ __name(() => canFetch(config2.networkMode) && config2.canRun(), "canStart");
  const resolve = /* @__PURE__ */ __name((value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config2.onSuccess) == null ? void 0 : _a2.call(config2, value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  }, "resolve");
  const reject = /* @__PURE__ */ __name((value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config2.onError) == null ? void 0 : _a2.call(config2, value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  }, "reject");
  const pause = /* @__PURE__ */ __name(() => {
    return new Promise((continueResolve) => {
      var _a2;
      continueFn = /* @__PURE__ */ __name((value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      }, "continueFn");
      (_a2 = config2.onPause) == null ? void 0 : _a2.call(config2);
    }).then(() => {
      var _a2;
      continueFn = void 0;
      if (!isResolved) {
        (_a2 = config2.onContinue) == null ? void 0 : _a2.call(config2);
      }
    });
  }, "pause");
  const run = /* @__PURE__ */ __name(() => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    try {
      promiseOrValue = config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _a2;
      if (isResolved) {
        return;
      }
      const retry = config2.retry ?? (isServer ? 0 : 3);
      const retryDelay = config2.retryDelay ?? defaultRetryDelay;
      const delay2 = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      (_a2 = config2.onFail) == null ? void 0 : _a2.call(config2, failureCount, error);
      sleep(delay2).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  }, "run");
  return {
    promise,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return promise;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return promise;
    }
  };
}
__name(createRetryer, "createRetryer");
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = /* @__PURE__ */ __name((callback) => {
    callback();
  }, "notifyFn");
  let batchNotifyFn = /* @__PURE__ */ __name((callback) => {
    callback();
  }, "batchNotifyFn");
  let scheduleFn = /* @__PURE__ */ __name((cb2) => setTimeout(cb2, 0), "scheduleFn");
  const setScheduler = /* @__PURE__ */ __name((fn2) => {
    scheduleFn = fn2;
  }, "setScheduler");
  const batch = /* @__PURE__ */ __name((callback) => {
    let result;
    transactions++;
    try {
      result = callback();
    } finally {
      transactions--;
      if (!transactions) {
        flush();
      }
    }
    return result;
  }, "batch");
  const schedule = /* @__PURE__ */ __name((callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  }, "schedule");
  const batchCalls = /* @__PURE__ */ __name((callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  }, "batchCalls");
  const flush = /* @__PURE__ */ __name(() => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  }, "flush");
  const setNotifyFunction = /* @__PURE__ */ __name((fn2) => {
    notifyFn = fn2;
  }, "setNotifyFunction");
  const setBatchNotifyFunction = /* @__PURE__ */ __name((fn2) => {
    batchNotifyFn = fn2;
  }, "setBatchNotifyFunction");
  return {
    batch,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction,
    setScheduler
  };
}
__name(createNotifyManager, "createNotifyManager");
var notifyManager = createNotifyManager();
var Removable = (_h = class {
  constructor() {
    __privateAdd(this, _gcTimeout, void 0);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), __name(_h, "Removable"), _h);
var Query = (_i = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _dispatch);
    __privateAdd(this, _initialState2, void 0);
    __privateAdd(this, _revertState, void 0);
    __privateAdd(this, _cache, void 0);
    __privateAdd(this, _retryer, void 0);
    __privateAdd(this, _defaultOptions, void 0);
    __privateAdd(this, _abortSignalConsumed, void 0);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config2.defaultOptions);
    this.setOptions(config2.options);
    this.observers = [];
    __privateSet(this, _cache, config2.cache);
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    __privateSet(this, _initialState2, config2.state || getDefaultState$1(this.options));
    this.state = __privateGet(this, _initialState2);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _dispatch, dispatch_fn).call(this, {
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
  }
  cancel(options) {
    var _a2, _b2;
    const promise = (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
    (_b2 = __privateGet(this, _retryer)) == null ? void 0 : _b2.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState2));
  }
  isActive() {
    return this.observers.some((observer) => observer.options.enabled !== false);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _a2;
    const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  onOnline() {
    var _a2;
    const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x2) => x2 !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    var _a2, _b2, _c2;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x2) => x2.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const queryFnContext = {
      queryKey: this.queryKey,
      meta: this.meta
    };
    const addSignalProperty = /* @__PURE__ */ __name((object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    }, "addSignalProperty");
    addSignalProperty(queryFnContext);
    const fetchFn = /* @__PURE__ */ __name(() => {
      if (!this.options.queryFn || this.options.queryFn === skipToken) {
        return Promise.reject(
          new Error(`Missing queryFn: '${this.options.queryHash}'`)
        );
      }
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          this.options.queryFn,
          queryFnContext,
          this
        );
      }
      return this.options.queryFn(
        queryFnContext
      );
    }, "fetchFn");
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_a2 = this.options.behavior) == null ? void 0 : _a2.onFetch(
      context,
      this
    );
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b2 = context.fetchOptions) == null ? void 0 : _b2.meta)) {
      __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "fetch", meta: (_c2 = context.fetchOptions) == null ? void 0 : _c2.meta });
    }
    const onError = /* @__PURE__ */ __name((error) => {
      var _a3, _b3, _c3, _d2;
      if (!(isCancelledError(error) && error.silent)) {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, {
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        (_b3 = (_a3 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b3.call(
          _a3,
          error,
          this
        );
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          this.state.data,
          error,
          this
        );
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    }, "onError");
    __privateSet(this, _retryer, createRetryer({
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _a3, _b3, _c3, _d2;
        if (data === void 0) {
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        this.setData(data);
        (_b3 = (_a3 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b3.call(_a3, data, this);
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          data,
          this.state.error,
          this
        );
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: (failureCount, error) => {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    }));
    return __privateGet(this, _retryer).start();
  }
}, _initialState2 = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _dispatch = new WeakSet(), dispatch_fn = /* @__PURE__ */ __name(function(action) {
  const reducer = /* @__PURE__ */ __name((state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state,
          ...fetchState(state.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        return {
          ...state,
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const error = action.error;
        if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
          return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
        }
        return {
          ...state,
          error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state,
          ...action.state
        };
    }
  }, "reducer");
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, "#dispatch"), __name(_i, "Query"), _i);
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
__name(fetchState, "fetchState");
function getDefaultState$1(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
__name(getDefaultState$1, "getDefaultState$1");
var QueryCache = (_j = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _queries, void 0);
    this.config = config2;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client2, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        queryKey,
        queryHash,
        options: client2.defaultQueryOptions(options),
        state,
        defaultOptions: client2.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), __name(_j, "QueryCache"), _j);
var Mutation = (_k = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _dispatch2);
    __privateAdd(this, _observers, void 0);
    __privateAdd(this, _mutationCache, void 0);
    __privateAdd(this, _retryer2, void 0);
    this.mutationId = config2.mutationId;
    __privateSet(this, _mutationCache, config2.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x2) => x2 !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    var _a2;
    return ((_a2 = __privateGet(this, _retryer2)) == null ? void 0 : _a2.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n, _o, _p, _q, _r, _s, _t7;
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (!restored) {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await ((_b2 = (_a2 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b2.call(
          _a2,
          variables,
          this
        ));
        const context = await ((_d2 = (_c2 = this.options).onMutate) == null ? void 0 : _d2.call(_c2, variables));
        if (context !== this.state.context) {
          __privateMethod(this, _dispatch2, dispatch_fn2).call(this, {
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await __privateGet(this, _retryer2).start();
      await ((_f2 = (_e2 = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f2.call(
        _e2,
        data,
        variables,
        this.state.context,
        this
      ));
      await ((_h2 = (_g2 = this.options).onSuccess) == null ? void 0 : _h2.call(_g2, data, variables, this.state.context));
      await ((_j2 = (_i2 = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j2.call(
        _i2,
        data,
        null,
        this.state.variables,
        this.state.context,
        this
      ));
      await ((_l2 = (_k2 = this.options).onSettled) == null ? void 0 : _l2.call(_k2, data, null, variables, this.state.context));
      __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "success", data });
      return data;
    } catch (error) {
      try {
        await ((_n = (_m2 = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n.call(
          _m2,
          error,
          variables,
          this.state.context,
          this
        ));
        await ((_p = (_o = this.options).onError) == null ? void 0 : _p.call(
          _o,
          error,
          variables,
          this.state.context
        ));
        await ((_r = (_q = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r.call(
          _q,
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_t7 = (_s = this.options).onSettled) == null ? void 0 : _t7.call(
          _s,
          void 0,
          error,
          variables,
          this.state.context
        ));
        throw error;
      } finally {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _dispatch2 = new WeakSet(), dispatch_fn2 = /* @__PURE__ */ __name(function(action) {
  const reducer = /* @__PURE__ */ __name((state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state,
          isPaused: true
        };
      case "continue":
        return {
          ...state,
          isPaused: false
        };
      case "pending":
        return {
          ...state,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state,
          data: void 0,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  }, "reducer");
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, "#dispatch"), __name(_k, "Mutation"), _k);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
__name(getDefaultState, "getDefaultState");
var MutationCache = (_l = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _mutations, void 0);
    __privateAdd(this, _mutationId, void 0);
    this.config = config2;
    __privateSet(this, _mutations, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, Date.now());
  }
  build(client2, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client2.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    const scope = scopeFor(mutation);
    const mutations = __privateGet(this, _mutations).get(scope) ?? [];
    mutations.push(mutation);
    __privateGet(this, _mutations).set(scope, mutations);
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    var _a2;
    const scope = scopeFor(mutation);
    if (__privateGet(this, _mutations).has(scope)) {
      const mutations = (_a2 = __privateGet(this, _mutations).get(scope)) == null ? void 0 : _a2.filter((x2) => x2 !== mutation);
      if (mutations) {
        if (mutations.length === 0) {
          __privateGet(this, _mutations).delete(scope);
        } else {
          __privateGet(this, _mutations).set(scope, mutations);
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    var _a2;
    const firstPendingMutation = (_a2 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a2.find((m2) => m2.state.status === "pending");
    return !firstPendingMutation || firstPendingMutation === mutation;
  }
  runNext(mutation) {
    var _a2;
    const foundMutation = (_a2 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a2.find((m2) => m2 !== mutation && m2.state.isPaused);
    return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return [...__privateGet(this, _mutations).values()].flat();
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x2) => x2.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop))
      )
    );
  }
}, _mutations = new WeakMap(), _mutationId = new WeakMap(), __name(_l, "MutationCache"), _l);
function scopeFor(mutation) {
  var _a2;
  return ((_a2 = mutation.options.scope) == null ? void 0 : _a2.id) ?? String(mutation.mutationId);
}
__name(scopeFor, "scopeFor");
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const fetchFn = /* @__PURE__ */ __name(async () => {
        var _a2, _b2, _c2, _d2, _e2;
        const options = context.options;
        const direction = (_c2 = (_b2 = (_a2 = context.fetchOptions) == null ? void 0 : _a2.meta) == null ? void 0 : _b2.fetchMore) == null ? void 0 : _c2.direction;
        const oldPages = ((_d2 = context.state.data) == null ? void 0 : _d2.pages) || [];
        const oldPageParams = ((_e2 = context.state.data) == null ? void 0 : _e2.pageParams) || [];
        const empty2 = { pages: [], pageParams: [] };
        let cancelled = false;
        const addSignalProperty = /* @__PURE__ */ __name((object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        }, "addSignalProperty");
        const queryFn = context.options.queryFn && context.options.queryFn !== skipToken ? context.options.queryFn : () => {
          return Promise.reject(
            new Error(`Missing queryFn: '${context.options.queryHash}'`)
          );
        };
        const fetchPage = /* @__PURE__ */ __name(async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        }, "fetchPage");
        let result;
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          result = await fetchPage(
            empty2,
            oldPageParams[0] ?? options.initialPageParam
          );
          const remainingPages = pages ?? oldPages.length;
          for (let i = 1; i < remainingPages; i++) {
            const param = getNextPageParam(options, result);
            result = await fetchPage(result, param);
          }
        }
        return result;
      }, "fetchFn");
      if (context.options.persister) {
        context.fetchFn = () => {
          var _a2, _b2;
          return (_b2 = (_a2 = context.options).persister) == null ? void 0 : _b2.call(
            _a2,
            fetchFn,
            {
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
__name(infiniteQueryBehavior, "infiniteQueryBehavior");
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  );
}
__name(getNextPageParam, "getNextPageParam");
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a2;
  return (_a2 = options.getPreviousPageParam) == null ? void 0 : _a2.call(
    options,
    pages[0],
    pages,
    pageParams[0],
    pageParams
  );
}
__name(getPreviousPageParam, "getPreviousPageParam");
var QueryClient = (_m = class {
  constructor(config2 = {}) {
    __privateAdd(this, _queryCache, void 0);
    __privateAdd(this, _mutationCache2, void 0);
    __privateAdd(this, _defaultOptions2, void 0);
    __privateAdd(this, _queryDefaults, void 0);
    __privateAdd(this, _mutationDefaults, void 0);
    __privateAdd(this, _mountCount, void 0);
    __privateAdd(this, _unsubscribeFocus, void 0);
    __privateAdd(this, _unsubscribeOnline, void 0);
    __privateSet(this, _queryCache, config2.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config2.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config2.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1)
      return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a2, _b2;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0)
      return;
    (_a2 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state.data;
  }
  ensureQueryData(options) {
    const cachedData = this.getQueryData(options.queryKey);
    if (cachedData === void 0)
      return this.fetchQuery(options);
    else {
      const defaultedOptions = this.defaultQueryOptions(options);
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      if (options.revalidateIfStale && query.isStaleByTime(defaultedOptions.staleTime)) {
        void this.prefetchQuery(defaultedOptions);
      }
      return Promise.resolve(cachedData);
    }
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters = {}, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(filters = {}, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: filters.refetchType ?? filters.type ?? "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters = {}, options) {
    const fetchOptions = {
      ...options,
      cancelRefetch: (options == null ? void 0 : options.cancelRefetch) ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop).catch(noop);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop).catch(noop);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults2 = [...__privateGet(this, _queryDefaults).values()];
    let result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults2 = [...__privateGet(this, _mutationDefaults).values()];
    let result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...(options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), __name(_m, "QueryClient"), _m);
var QueryClientContext = reactExports.createContext(
  void 0
);
var QueryClientProvider = /* @__PURE__ */ __name(({
  client: client2,
  children
}) => {
  reactExports.useEffect(() => {
    client2.mount();
    return () => {
      client2.unmount();
    };
  }, [client2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientContext.Provider, { value: client2, children });
}, "QueryClientProvider");
const theme = createTheme(
  {
    palette: {
      primary: { main: "#1976d2" }
    }
  },
  ptBR$2
);
const queryClient = new QueryClient();
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React$1.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider2, { theme, children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RequisitionContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpportunityInfoProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PatrimonyInfoContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router }) }) }) }) }) }) }) }) })
);
